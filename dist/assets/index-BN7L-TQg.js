(function () {
  const e = document.createElement("link").relList;
  if (e && e.supports && e.supports("modulepreload")) return;
  for (const r of document.querySelectorAll('link[rel="modulepreload"]')) i(r);
  new MutationObserver((r) => {
    for (const s of r)
      if (s.type === "childList")
        for (const o of s.addedNodes)
          o.tagName === "LINK" && o.rel === "modulepreload" && i(o);
  }).observe(document, { childList: !0, subtree: !0 });
  function t(r) {
    const s = {};
    return (
      r.integrity && (s.integrity = r.integrity),
      r.referrerPolicy && (s.referrerPolicy = r.referrerPolicy),
      r.crossOrigin === "use-credentials"
        ? (s.credentials = "include")
        : r.crossOrigin === "anonymous"
        ? (s.credentials = "omit")
        : (s.credentials = "same-origin"),
      s
    );
  }
  function i(r) {
    if (r.ep) return;
    r.ep = !0;
    const s = t(r);
    fetch(r.href, s);
  }
})();
var Ed =
  typeof globalThis < "u"
    ? globalThis
    : typeof window < "u"
    ? window
    : typeof global < "u"
    ? global
    : typeof self < "u"
    ? self
    : {};
function gb(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default")
    ? n.default
    : n;
}
var vb = { exports: {} },
  sg = {},
  yb = { exports: {} },
  Pt = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var Jf = Symbol.for("react.element"),
  GN = Symbol.for("react.portal"),
  WN = Symbol.for("react.fragment"),
  jN = Symbol.for("react.strict_mode"),
  XN = Symbol.for("react.profiler"),
  YN = Symbol.for("react.provider"),
  qN = Symbol.for("react.context"),
  ZN = Symbol.for("react.forward_ref"),
  KN = Symbol.for("react.suspense"),
  QN = Symbol.for("react.memo"),
  $N = Symbol.for("react.lazy"),
  Gw = Symbol.iterator;
function JN(n) {
  return n === null || typeof n != "object"
    ? null
    : ((n = (Gw && n[Gw]) || n["@@iterator"]),
      typeof n == "function" ? n : null);
}
var xb = {
    isMounted: function () {
      return !1;
    },
    enqueueForceUpdate: function () {},
    enqueueReplaceState: function () {},
    enqueueSetState: function () {},
  },
  _b = Object.assign,
  Sb = {};
function Vu(n, e, t) {
  (this.props = n),
    (this.context = e),
    (this.refs = Sb),
    (this.updater = t || xb);
}
Vu.prototype.isReactComponent = {};
Vu.prototype.setState = function (n, e) {
  if (typeof n != "object" && typeof n != "function" && n != null)
    throw Error(
      "setState(...): takes an object of state variables to update or a function which returns an object of state variables."
    );
  this.updater.enqueueSetState(this, n, e, "setState");
};
Vu.prototype.forceUpdate = function (n) {
  this.updater.enqueueForceUpdate(this, n, "forceUpdate");
};
function Mb() {}
Mb.prototype = Vu.prototype;
function Z_(n, e, t) {
  (this.props = n),
    (this.context = e),
    (this.refs = Sb),
    (this.updater = t || xb);
}
var K_ = (Z_.prototype = new Mb());
K_.constructor = Z_;
_b(K_, Vu.prototype);
K_.isPureReactComponent = !0;
var Ww = Array.isArray,
  wb = Object.prototype.hasOwnProperty,
  Q_ = { current: null },
  Eb = { key: !0, ref: !0, __self: !0, __source: !0 };
function Tb(n, e, t) {
  var i,
    r = {},
    s = null,
    o = null;
  if (e != null)
    for (i in (e.ref !== void 0 && (o = e.ref),
    e.key !== void 0 && (s = "" + e.key),
    e))
      wb.call(e, i) && !Eb.hasOwnProperty(i) && (r[i] = e[i]);
  var a = arguments.length - 2;
  if (a === 1) r.children = t;
  else if (1 < a) {
    for (var u = Array(a), f = 0; f < a; f++) u[f] = arguments[f + 2];
    r.children = u;
  }
  if (n && n.defaultProps)
    for (i in ((a = n.defaultProps), a)) r[i] === void 0 && (r[i] = a[i]);
  return {
    $$typeof: Jf,
    type: n,
    key: s,
    ref: o,
    props: r,
    _owner: Q_.current,
  };
}
function eD(n, e) {
  return {
    $$typeof: Jf,
    type: n.type,
    key: e,
    ref: n.ref,
    props: n.props,
    _owner: n._owner,
  };
}
function $_(n) {
  return typeof n == "object" && n !== null && n.$$typeof === Jf;
}
function tD(n) {
  var e = { "=": "=0", ":": "=2" };
  return (
    "$" +
    n.replace(/[=:]/g, function (t) {
      return e[t];
    })
  );
}
var jw = /\/+/g;
function g0(n, e) {
  return typeof n == "object" && n !== null && n.key != null
    ? tD("" + n.key)
    : e.toString(36);
}
function Xp(n, e, t, i, r) {
  var s = typeof n;
  (s === "undefined" || s === "boolean") && (n = null);
  var o = !1;
  if (n === null) o = !0;
  else
    switch (s) {
      case "string":
      case "number":
        o = !0;
        break;
      case "object":
        switch (n.$$typeof) {
          case Jf:
          case GN:
            o = !0;
        }
    }
  if (o)
    return (
      (o = n),
      (r = r(o)),
      (n = i === "" ? "." + g0(o, 0) : i),
      Ww(r)
        ? ((t = ""),
          n != null && (t = n.replace(jw, "$&/") + "/"),
          Xp(r, e, t, "", function (f) {
            return f;
          }))
        : r != null &&
          ($_(r) &&
            (r = eD(
              r,
              t +
                (!r.key || (o && o.key === r.key)
                  ? ""
                  : ("" + r.key).replace(jw, "$&/") + "/") +
                n
            )),
          e.push(r)),
      1
    );
  if (((o = 0), (i = i === "" ? "." : i + ":"), Ww(n)))
    for (var a = 0; a < n.length; a++) {
      s = n[a];
      var u = i + g0(s, a);
      o += Xp(s, e, t, u, r);
    }
  else if (((u = JN(n)), typeof u == "function"))
    for (n = u.call(n), a = 0; !(s = n.next()).done; )
      (s = s.value), (u = i + g0(s, a++)), (o += Xp(s, e, t, u, r));
  else if (s === "object")
    throw (
      ((e = String(n)),
      Error(
        "Objects are not valid as a React child (found: " +
          (e === "[object Object]"
            ? "object with keys {" + Object.keys(n).join(", ") + "}"
            : e) +
          "). If you meant to render a collection of children, use an array instead."
      ))
    );
  return o;
}
function Td(n, e, t) {
  if (n == null) return n;
  var i = [],
    r = 0;
  return (
    Xp(n, i, "", "", function (s) {
      return e.call(t, s, r++);
    }),
    i
  );
}
function nD(n) {
  if (n._status === -1) {
    var e = n._result;
    (e = e()),
      e.then(
        function (t) {
          (n._status === 0 || n._status === -1) &&
            ((n._status = 1), (n._result = t));
        },
        function (t) {
          (n._status === 0 || n._status === -1) &&
            ((n._status = 2), (n._result = t));
        }
      ),
      n._status === -1 && ((n._status = 0), (n._result = e));
  }
  if (n._status === 1) return n._result.default;
  throw n._result;
}
var bi = { current: null },
  Yp = { transition: null },
  iD = {
    ReactCurrentDispatcher: bi,
    ReactCurrentBatchConfig: Yp,
    ReactCurrentOwner: Q_,
  };
function Ab() {
  throw Error("act(...) is not supported in production builds of React.");
}
Pt.Children = {
  map: Td,
  forEach: function (n, e, t) {
    Td(
      n,
      function () {
        e.apply(this, arguments);
      },
      t
    );
  },
  count: function (n) {
    var e = 0;
    return (
      Td(n, function () {
        e++;
      }),
      e
    );
  },
  toArray: function (n) {
    return (
      Td(n, function (e) {
        return e;
      }) || []
    );
  },
  only: function (n) {
    if (!$_(n))
      throw Error(
        "React.Children.only expected to receive a single React element child."
      );
    return n;
  },
};
Pt.Component = Vu;
Pt.Fragment = WN;
Pt.Profiler = XN;
Pt.PureComponent = Z_;
Pt.StrictMode = jN;
Pt.Suspense = KN;
Pt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = iD;
Pt.act = Ab;
Pt.cloneElement = function (n, e, t) {
  if (n == null)
    throw Error(
      "React.cloneElement(...): The argument must be a React element, but you passed " +
        n +
        "."
    );
  var i = _b({}, n.props),
    r = n.key,
    s = n.ref,
    o = n._owner;
  if (e != null) {
    if (
      (e.ref !== void 0 && ((s = e.ref), (o = Q_.current)),
      e.key !== void 0 && (r = "" + e.key),
      n.type && n.type.defaultProps)
    )
      var a = n.type.defaultProps;
    for (u in e)
      wb.call(e, u) &&
        !Eb.hasOwnProperty(u) &&
        (i[u] = e[u] === void 0 && a !== void 0 ? a[u] : e[u]);
  }
  var u = arguments.length - 2;
  if (u === 1) i.children = t;
  else if (1 < u) {
    a = Array(u);
    for (var f = 0; f < u; f++) a[f] = arguments[f + 2];
    i.children = a;
  }
  return { $$typeof: Jf, type: n.type, key: r, ref: s, props: i, _owner: o };
};
Pt.createContext = function (n) {
  return (
    (n = {
      $$typeof: qN,
      _currentValue: n,
      _currentValue2: n,
      _threadCount: 0,
      Provider: null,
      Consumer: null,
      _defaultValue: null,
      _globalName: null,
    }),
    (n.Provider = { $$typeof: YN, _context: n }),
    (n.Consumer = n)
  );
};
Pt.createElement = Tb;
Pt.createFactory = function (n) {
  var e = Tb.bind(null, n);
  return (e.type = n), e;
};
Pt.createRef = function () {
  return { current: null };
};
Pt.forwardRef = function (n) {
  return { $$typeof: ZN, render: n };
};
Pt.isValidElement = $_;
Pt.lazy = function (n) {
  return { $$typeof: $N, _payload: { _status: -1, _result: n }, _init: nD };
};
Pt.memo = function (n, e) {
  return { $$typeof: QN, type: n, compare: e === void 0 ? null : e };
};
Pt.startTransition = function (n) {
  var e = Yp.transition;
  Yp.transition = {};
  try {
    n();
  } finally {
    Yp.transition = e;
  }
};
Pt.unstable_act = Ab;
Pt.useCallback = function (n, e) {
  return bi.current.useCallback(n, e);
};
Pt.useContext = function (n) {
  return bi.current.useContext(n);
};
Pt.useDebugValue = function () {};
Pt.useDeferredValue = function (n) {
  return bi.current.useDeferredValue(n);
};
Pt.useEffect = function (n, e) {
  return bi.current.useEffect(n, e);
};
Pt.useId = function () {
  return bi.current.useId();
};
Pt.useImperativeHandle = function (n, e, t) {
  return bi.current.useImperativeHandle(n, e, t);
};
Pt.useInsertionEffect = function (n, e) {
  return bi.current.useInsertionEffect(n, e);
};
Pt.useLayoutEffect = function (n, e) {
  return bi.current.useLayoutEffect(n, e);
};
Pt.useMemo = function (n, e) {
  return bi.current.useMemo(n, e);
};
Pt.useReducer = function (n, e, t) {
  return bi.current.useReducer(n, e, t);
};
Pt.useRef = function (n) {
  return bi.current.useRef(n);
};
Pt.useState = function (n) {
  return bi.current.useState(n);
};
Pt.useSyncExternalStore = function (n, e, t) {
  return bi.current.useSyncExternalStore(n, e, t);
};
Pt.useTransition = function () {
  return bi.current.useTransition();
};
Pt.version = "18.3.1";
yb.exports = Pt;
var se = yb.exports;
const ss = gb(se);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var rD = se,
  sD = Symbol.for("react.element"),
  oD = Symbol.for("react.fragment"),
  aD = Object.prototype.hasOwnProperty,
  lD = rD.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
  uD = { key: !0, ref: !0, __self: !0, __source: !0 };
function bb(n, e, t) {
  var i,
    r = {},
    s = null,
    o = null;
  t !== void 0 && (s = "" + t),
    e.key !== void 0 && (s = "" + e.key),
    e.ref !== void 0 && (o = e.ref);
  for (i in e) aD.call(e, i) && !uD.hasOwnProperty(i) && (r[i] = e[i]);
  if (n && n.defaultProps)
    for (i in ((e = n.defaultProps), e)) r[i] === void 0 && (r[i] = e[i]);
  return {
    $$typeof: sD,
    type: n,
    key: s,
    ref: o,
    props: r,
    _owner: lD.current,
  };
}
sg.Fragment = oD;
sg.jsx = bb;
sg.jsxs = bb;
vb.exports = sg;
var z = vb.exports,
  Ky = {},
  Cb = { exports: {} },
  ir = {},
  Pb = { exports: {} },
  Rb = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ (function (n) {
  function e(k, G) {
    var W = k.length;
    k.push(G);
    e: for (; 0 < W; ) {
      var Y = (W - 1) >>> 1,
        ie = k[Y];
      if (0 < r(ie, G)) (k[Y] = G), (k[W] = ie), (W = Y);
      else break e;
    }
  }
  function t(k) {
    return k.length === 0 ? null : k[0];
  }
  function i(k) {
    if (k.length === 0) return null;
    var G = k[0],
      W = k.pop();
    if (W !== G) {
      k[0] = W;
      e: for (var Y = 0, ie = k.length, J = ie >>> 1; Y < J; ) {
        var he = 2 * (Y + 1) - 1,
          Ee = k[he],
          be = he + 1,
          Pe = k[be];
        if (0 > r(Ee, W))
          be < ie && 0 > r(Pe, Ee)
            ? ((k[Y] = Pe), (k[be] = W), (Y = be))
            : ((k[Y] = Ee), (k[he] = W), (Y = he));
        else if (be < ie && 0 > r(Pe, W)) (k[Y] = Pe), (k[be] = W), (Y = be);
        else break e;
      }
    }
    return G;
  }
  function r(k, G) {
    var W = k.sortIndex - G.sortIndex;
    return W !== 0 ? W : k.id - G.id;
  }
  if (typeof performance == "object" && typeof performance.now == "function") {
    var s = performance;
    n.unstable_now = function () {
      return s.now();
    };
  } else {
    var o = Date,
      a = o.now();
    n.unstable_now = function () {
      return o.now() - a;
    };
  }
  var u = [],
    f = [],
    h = 1,
    d = null,
    p = 3,
    m = !1,
    y = !1,
    w = !1,
    S = typeof setTimeout == "function" ? setTimeout : null,
    v = typeof clearTimeout == "function" ? clearTimeout : null,
    M = typeof setImmediate < "u" ? setImmediate : null;
  typeof navigator < "u" &&
    navigator.scheduling !== void 0 &&
    navigator.scheduling.isInputPending !== void 0 &&
    navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function _(k) {
    for (var G = t(f); G !== null; ) {
      if (G.callback === null) i(f);
      else if (G.startTime <= k)
        i(f), (G.sortIndex = G.expirationTime), e(u, G);
      else break;
      G = t(f);
    }
  }
  function T(k) {
    if (((w = !1), _(k), !y))
      if (t(u) !== null) (y = !0), $(P);
      else {
        var G = t(f);
        G !== null && ce(T, G.startTime - k);
      }
  }
  function P(k, G) {
    (y = !1), w && ((w = !1), v(N), (N = -1)), (m = !0);
    var W = p;
    try {
      for (
        _(G), d = t(u);
        d !== null && (!(d.expirationTime > G) || (k && !B()));

      ) {
        var Y = d.callback;
        if (typeof Y == "function") {
          (d.callback = null), (p = d.priorityLevel);
          var ie = Y(d.expirationTime <= G);
          (G = n.unstable_now()),
            typeof ie == "function" ? (d.callback = ie) : d === t(u) && i(u),
            _(G);
        } else i(u);
        d = t(u);
      }
      if (d !== null) var J = !0;
      else {
        var he = t(f);
        he !== null && ce(T, he.startTime - G), (J = !1);
      }
      return J;
    } finally {
      (d = null), (p = W), (m = !1);
    }
  }
  var b = !1,
    L = null,
    N = -1,
    C = 5,
    R = -1;
  function B() {
    return !(n.unstable_now() - R < C);
  }
  function Z() {
    if (L !== null) {
      var k = n.unstable_now();
      R = k;
      var G = !0;
      try {
        G = L(!0, k);
      } finally {
        G ? ae() : ((b = !1), (L = null));
      }
    } else b = !1;
  }
  var ae;
  if (typeof M == "function")
    ae = function () {
      M(Z);
    };
  else if (typeof MessageChannel < "u") {
    var V = new MessageChannel(),
      Q = V.port2;
    (V.port1.onmessage = Z),
      (ae = function () {
        Q.postMessage(null);
      });
  } else
    ae = function () {
      S(Z, 0);
    };
  function $(k) {
    (L = k), b || ((b = !0), ae());
  }
  function ce(k, G) {
    N = S(function () {
      k(n.unstable_now());
    }, G);
  }
  (n.unstable_IdlePriority = 5),
    (n.unstable_ImmediatePriority = 1),
    (n.unstable_LowPriority = 4),
    (n.unstable_NormalPriority = 3),
    (n.unstable_Profiling = null),
    (n.unstable_UserBlockingPriority = 2),
    (n.unstable_cancelCallback = function (k) {
      k.callback = null;
    }),
    (n.unstable_continueExecution = function () {
      y || m || ((y = !0), $(P));
    }),
    (n.unstable_forceFrameRate = function (k) {
      0 > k || 125 < k
        ? console.error(
            "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
          )
        : (C = 0 < k ? Math.floor(1e3 / k) : 5);
    }),
    (n.unstable_getCurrentPriorityLevel = function () {
      return p;
    }),
    (n.unstable_getFirstCallbackNode = function () {
      return t(u);
    }),
    (n.unstable_next = function (k) {
      switch (p) {
        case 1:
        case 2:
        case 3:
          var G = 3;
          break;
        default:
          G = p;
      }
      var W = p;
      p = G;
      try {
        return k();
      } finally {
        p = W;
      }
    }),
    (n.unstable_pauseExecution = function () {}),
    (n.unstable_requestPaint = function () {}),
    (n.unstable_runWithPriority = function (k, G) {
      switch (k) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          k = 3;
      }
      var W = p;
      p = k;
      try {
        return G();
      } finally {
        p = W;
      }
    }),
    (n.unstable_scheduleCallback = function (k, G, W) {
      var Y = n.unstable_now();
      switch (
        (typeof W == "object" && W !== null
          ? ((W = W.delay), (W = typeof W == "number" && 0 < W ? Y + W : Y))
          : (W = Y),
        k)
      ) {
        case 1:
          var ie = -1;
          break;
        case 2:
          ie = 250;
          break;
        case 5:
          ie = 1073741823;
          break;
        case 4:
          ie = 1e4;
          break;
        default:
          ie = 5e3;
      }
      return (
        (ie = W + ie),
        (k = {
          id: h++,
          callback: G,
          priorityLevel: k,
          startTime: W,
          expirationTime: ie,
          sortIndex: -1,
        }),
        W > Y
          ? ((k.sortIndex = W),
            e(f, k),
            t(u) === null &&
              k === t(f) &&
              (w ? (v(N), (N = -1)) : (w = !0), ce(T, W - Y)))
          : ((k.sortIndex = ie), e(u, k), y || m || ((y = !0), $(P))),
        k
      );
    }),
    (n.unstable_shouldYield = B),
    (n.unstable_wrapCallback = function (k) {
      var G = p;
      return function () {
        var W = p;
        p = G;
        try {
          return k.apply(this, arguments);
        } finally {
          p = W;
        }
      };
    });
})(Rb);
Pb.exports = Rb;
var cD = Pb.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var fD = se,
  tr = cD;
function we(n) {
  for (
    var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + n, t = 1;
    t < arguments.length;
    t++
  )
    e += "&args[]=" + encodeURIComponent(arguments[t]);
  return (
    "Minified React error #" +
    n +
    "; visit " +
    e +
    " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
  );
}
var Lb = new Set(),
  ff = {};
function el(n, e) {
  Au(n, e), Au(n + "Capture", e);
}
function Au(n, e) {
  for (ff[n] = e, n = 0; n < e.length; n++) Lb.add(e[n]);
}
var Bs = !(
    typeof window > "u" ||
    typeof window.document > "u" ||
    typeof window.document.createElement > "u"
  ),
  Qy = Object.prototype.hasOwnProperty,
  hD =
    /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
  Xw = {},
  Yw = {};
function dD(n) {
  return Qy.call(Yw, n)
    ? !0
    : Qy.call(Xw, n)
    ? !1
    : hD.test(n)
    ? (Yw[n] = !0)
    : ((Xw[n] = !0), !1);
}
function pD(n, e, t, i) {
  if (t !== null && t.type === 0) return !1;
  switch (typeof e) {
    case "function":
    case "symbol":
      return !0;
    case "boolean":
      return i
        ? !1
        : t !== null
        ? !t.acceptsBooleans
        : ((n = n.toLowerCase().slice(0, 5)), n !== "data-" && n !== "aria-");
    default:
      return !1;
  }
}
function mD(n, e, t, i) {
  if (e === null || typeof e > "u" || pD(n, e, t, i)) return !0;
  if (i) return !1;
  if (t !== null)
    switch (t.type) {
      case 3:
        return !e;
      case 4:
        return e === !1;
      case 5:
        return isNaN(e);
      case 6:
        return isNaN(e) || 1 > e;
    }
  return !1;
}
function Ci(n, e, t, i, r, s, o) {
  (this.acceptsBooleans = e === 2 || e === 3 || e === 4),
    (this.attributeName = i),
    (this.attributeNamespace = r),
    (this.mustUseProperty = t),
    (this.propertyName = n),
    (this.type = e),
    (this.sanitizeURL = s),
    (this.removeEmptyString = o);
}
var Jn = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style"
  .split(" ")
  .forEach(function (n) {
    Jn[n] = new Ci(n, 0, !1, n, null, !1, !1);
  });
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"],
].forEach(function (n) {
  var e = n[0];
  Jn[e] = new Ci(e, 1, !1, n[1], null, !1, !1);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function (n) {
  Jn[n] = new Ci(n, 2, !1, n.toLowerCase(), null, !1, !1);
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha",
].forEach(function (n) {
  Jn[n] = new Ci(n, 2, !1, n, null, !1, !1);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope"
  .split(" ")
  .forEach(function (n) {
    Jn[n] = new Ci(n, 3, !1, n.toLowerCase(), null, !1, !1);
  });
["checked", "multiple", "muted", "selected"].forEach(function (n) {
  Jn[n] = new Ci(n, 3, !0, n, null, !1, !1);
});
["capture", "download"].forEach(function (n) {
  Jn[n] = new Ci(n, 4, !1, n, null, !1, !1);
});
["cols", "rows", "size", "span"].forEach(function (n) {
  Jn[n] = new Ci(n, 6, !1, n, null, !1, !1);
});
["rowSpan", "start"].forEach(function (n) {
  Jn[n] = new Ci(n, 5, !1, n.toLowerCase(), null, !1, !1);
});
var J_ = /[\-:]([a-z])/g;
function e1(n) {
  return n[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height"
  .split(" ")
  .forEach(function (n) {
    var e = n.replace(J_, e1);
    Jn[e] = new Ci(e, 1, !1, n, null, !1, !1);
  });
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type"
  .split(" ")
  .forEach(function (n) {
    var e = n.replace(J_, e1);
    Jn[e] = new Ci(e, 1, !1, n, "http://www.w3.org/1999/xlink", !1, !1);
  });
["xml:base", "xml:lang", "xml:space"].forEach(function (n) {
  var e = n.replace(J_, e1);
  Jn[e] = new Ci(e, 1, !1, n, "http://www.w3.org/XML/1998/namespace", !1, !1);
});
["tabIndex", "crossOrigin"].forEach(function (n) {
  Jn[n] = new Ci(n, 1, !1, n.toLowerCase(), null, !1, !1);
});
Jn.xlinkHref = new Ci(
  "xlinkHref",
  1,
  !1,
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  !1
);
["src", "href", "action", "formAction"].forEach(function (n) {
  Jn[n] = new Ci(n, 1, !1, n.toLowerCase(), null, !0, !0);
});
function t1(n, e, t, i) {
  var r = Jn.hasOwnProperty(e) ? Jn[e] : null;
  (r !== null
    ? r.type !== 0
    : i ||
      !(2 < e.length) ||
      (e[0] !== "o" && e[0] !== "O") ||
      (e[1] !== "n" && e[1] !== "N")) &&
    (mD(e, t, r, i) && (t = null),
    i || r === null
      ? dD(e) && (t === null ? n.removeAttribute(e) : n.setAttribute(e, "" + t))
      : r.mustUseProperty
      ? (n[r.propertyName] = t === null ? (r.type === 3 ? !1 : "") : t)
      : ((e = r.attributeName),
        (i = r.attributeNamespace),
        t === null
          ? n.removeAttribute(e)
          : ((r = r.type),
            (t = r === 3 || (r === 4 && t === !0) ? "" : "" + t),
            i ? n.setAttributeNS(i, e, t) : n.setAttribute(e, t))));
}
var qs = fD.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
  Ad = Symbol.for("react.element"),
  Ql = Symbol.for("react.portal"),
  $l = Symbol.for("react.fragment"),
  n1 = Symbol.for("react.strict_mode"),
  $y = Symbol.for("react.profiler"),
  Ib = Symbol.for("react.provider"),
  Nb = Symbol.for("react.context"),
  i1 = Symbol.for("react.forward_ref"),
  Jy = Symbol.for("react.suspense"),
  ex = Symbol.for("react.suspense_list"),
  r1 = Symbol.for("react.memo"),
  yo = Symbol.for("react.lazy"),
  Db = Symbol.for("react.offscreen"),
  qw = Symbol.iterator;
function gc(n) {
  return n === null || typeof n != "object"
    ? null
    : ((n = (qw && n[qw]) || n["@@iterator"]),
      typeof n == "function" ? n : null);
}
var hn = Object.assign,
  v0;
function zc(n) {
  if (v0 === void 0)
    try {
      throw Error();
    } catch (t) {
      var e = t.stack.trim().match(/\n( *(at )?)/);
      v0 = (e && e[1]) || "";
    }
  return (
    `
` +
    v0 +
    n
  );
}
var y0 = !1;
function x0(n, e) {
  if (!n || y0) return "";
  y0 = !0;
  var t = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (e)
      if (
        ((e = function () {
          throw Error();
        }),
        Object.defineProperty(e.prototype, "props", {
          set: function () {
            throw Error();
          },
        }),
        typeof Reflect == "object" && Reflect.construct)
      ) {
        try {
          Reflect.construct(e, []);
        } catch (f) {
          var i = f;
        }
        Reflect.construct(n, [], e);
      } else {
        try {
          e.call();
        } catch (f) {
          i = f;
        }
        n.call(e.prototype);
      }
    else {
      try {
        throw Error();
      } catch (f) {
        i = f;
      }
      n();
    }
  } catch (f) {
    if (f && i && typeof f.stack == "string") {
      for (
        var r = f.stack.split(`
`),
          s = i.stack.split(`
`),
          o = r.length - 1,
          a = s.length - 1;
        1 <= o && 0 <= a && r[o] !== s[a];

      )
        a--;
      for (; 1 <= o && 0 <= a; o--, a--)
        if (r[o] !== s[a]) {
          if (o !== 1 || a !== 1)
            do
              if ((o--, a--, 0 > a || r[o] !== s[a])) {
                var u =
                  `
` + r[o].replace(" at new ", " at ");
                return (
                  n.displayName &&
                    u.includes("<anonymous>") &&
                    (u = u.replace("<anonymous>", n.displayName)),
                  u
                );
              }
            while (1 <= o && 0 <= a);
          break;
        }
    }
  } finally {
    (y0 = !1), (Error.prepareStackTrace = t);
  }
  return (n = n ? n.displayName || n.name : "") ? zc(n) : "";
}
function gD(n) {
  switch (n.tag) {
    case 5:
      return zc(n.type);
    case 16:
      return zc("Lazy");
    case 13:
      return zc("Suspense");
    case 19:
      return zc("SuspenseList");
    case 0:
    case 2:
    case 15:
      return (n = x0(n.type, !1)), n;
    case 11:
      return (n = x0(n.type.render, !1)), n;
    case 1:
      return (n = x0(n.type, !0)), n;
    default:
      return "";
  }
}
function tx(n) {
  if (n == null) return null;
  if (typeof n == "function") return n.displayName || n.name || null;
  if (typeof n == "string") return n;
  switch (n) {
    case $l:
      return "Fragment";
    case Ql:
      return "Portal";
    case $y:
      return "Profiler";
    case n1:
      return "StrictMode";
    case Jy:
      return "Suspense";
    case ex:
      return "SuspenseList";
  }
  if (typeof n == "object")
    switch (n.$$typeof) {
      case Nb:
        return (n.displayName || "Context") + ".Consumer";
      case Ib:
        return (n._context.displayName || "Context") + ".Provider";
      case i1:
        var e = n.render;
        return (
          (n = n.displayName),
          n ||
            ((n = e.displayName || e.name || ""),
            (n = n !== "" ? "ForwardRef(" + n + ")" : "ForwardRef")),
          n
        );
      case r1:
        return (
          (e = n.displayName || null), e !== null ? e : tx(n.type) || "Memo"
        );
      case yo:
        (e = n._payload), (n = n._init);
        try {
          return tx(n(e));
        } catch {}
    }
  return null;
}
function vD(n) {
  var e = n.type;
  switch (n.tag) {
    case 24:
      return "Cache";
    case 9:
      return (e.displayName || "Context") + ".Consumer";
    case 10:
      return (e._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return (
        (n = e.render),
        (n = n.displayName || n.name || ""),
        e.displayName || (n !== "" ? "ForwardRef(" + n + ")" : "ForwardRef")
      );
    case 7:
      return "Fragment";
    case 5:
      return e;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return tx(e);
    case 8:
      return e === n1 ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if (typeof e == "function") return e.displayName || e.name || null;
      if (typeof e == "string") return e;
  }
  return null;
}
function zo(n) {
  switch (typeof n) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return n;
    case "object":
      return n;
    default:
      return "";
  }
}
function Ob(n) {
  var e = n.type;
  return (
    (n = n.nodeName) &&
    n.toLowerCase() === "input" &&
    (e === "checkbox" || e === "radio")
  );
}
function yD(n) {
  var e = Ob(n) ? "checked" : "value",
    t = Object.getOwnPropertyDescriptor(n.constructor.prototype, e),
    i = "" + n[e];
  if (
    !n.hasOwnProperty(e) &&
    typeof t < "u" &&
    typeof t.get == "function" &&
    typeof t.set == "function"
  ) {
    var r = t.get,
      s = t.set;
    return (
      Object.defineProperty(n, e, {
        configurable: !0,
        get: function () {
          return r.call(this);
        },
        set: function (o) {
          (i = "" + o), s.call(this, o);
        },
      }),
      Object.defineProperty(n, e, { enumerable: t.enumerable }),
      {
        getValue: function () {
          return i;
        },
        setValue: function (o) {
          i = "" + o;
        },
        stopTracking: function () {
          (n._valueTracker = null), delete n[e];
        },
      }
    );
  }
}
function bd(n) {
  n._valueTracker || (n._valueTracker = yD(n));
}
function Ub(n) {
  if (!n) return !1;
  var e = n._valueTracker;
  if (!e) return !0;
  var t = e.getValue(),
    i = "";
  return (
    n && (i = Ob(n) ? (n.checked ? "true" : "false") : n.value),
    (n = i),
    n !== t ? (e.setValue(n), !0) : !1
  );
}
function mm(n) {
  if (((n = n || (typeof document < "u" ? document : void 0)), typeof n > "u"))
    return null;
  try {
    return n.activeElement || n.body;
  } catch {
    return n.body;
  }
}
function nx(n, e) {
  var t = e.checked;
  return hn({}, e, {
    defaultChecked: void 0,
    defaultValue: void 0,
    value: void 0,
    checked: t ?? n._wrapperState.initialChecked,
  });
}
function Zw(n, e) {
  var t = e.defaultValue == null ? "" : e.defaultValue,
    i = e.checked != null ? e.checked : e.defaultChecked;
  (t = zo(e.value != null ? e.value : t)),
    (n._wrapperState = {
      initialChecked: i,
      initialValue: t,
      controlled:
        e.type === "checkbox" || e.type === "radio"
          ? e.checked != null
          : e.value != null,
    });
}
function kb(n, e) {
  (e = e.checked), e != null && t1(n, "checked", e, !1);
}
function ix(n, e) {
  kb(n, e);
  var t = zo(e.value),
    i = e.type;
  if (t != null)
    i === "number"
      ? ((t === 0 && n.value === "") || n.value != t) && (n.value = "" + t)
      : n.value !== "" + t && (n.value = "" + t);
  else if (i === "submit" || i === "reset") {
    n.removeAttribute("value");
    return;
  }
  e.hasOwnProperty("value")
    ? rx(n, e.type, t)
    : e.hasOwnProperty("defaultValue") && rx(n, e.type, zo(e.defaultValue)),
    e.checked == null &&
      e.defaultChecked != null &&
      (n.defaultChecked = !!e.defaultChecked);
}
function Kw(n, e, t) {
  if (e.hasOwnProperty("value") || e.hasOwnProperty("defaultValue")) {
    var i = e.type;
    if (
      !(
        (i !== "submit" && i !== "reset") ||
        (e.value !== void 0 && e.value !== null)
      )
    )
      return;
    (e = "" + n._wrapperState.initialValue),
      t || e === n.value || (n.value = e),
      (n.defaultValue = e);
  }
  (t = n.name),
    t !== "" && (n.name = ""),
    (n.defaultChecked = !!n._wrapperState.initialChecked),
    t !== "" && (n.name = t);
}
function rx(n, e, t) {
  (e !== "number" || mm(n.ownerDocument) !== n) &&
    (t == null
      ? (n.defaultValue = "" + n._wrapperState.initialValue)
      : n.defaultValue !== "" + t && (n.defaultValue = "" + t));
}
var Bc = Array.isArray;
function xu(n, e, t, i) {
  if (((n = n.options), e)) {
    e = {};
    for (var r = 0; r < t.length; r++) e["$" + t[r]] = !0;
    for (t = 0; t < n.length; t++)
      (r = e.hasOwnProperty("$" + n[t].value)),
        n[t].selected !== r && (n[t].selected = r),
        r && i && (n[t].defaultSelected = !0);
  } else {
    for (t = "" + zo(t), e = null, r = 0; r < n.length; r++) {
      if (n[r].value === t) {
        (n[r].selected = !0), i && (n[r].defaultSelected = !0);
        return;
      }
      e !== null || n[r].disabled || (e = n[r]);
    }
    e !== null && (e.selected = !0);
  }
}
function sx(n, e) {
  if (e.dangerouslySetInnerHTML != null) throw Error(we(91));
  return hn({}, e, {
    value: void 0,
    defaultValue: void 0,
    children: "" + n._wrapperState.initialValue,
  });
}
function Qw(n, e) {
  var t = e.value;
  if (t == null) {
    if (((t = e.children), (e = e.defaultValue), t != null)) {
      if (e != null) throw Error(we(92));
      if (Bc(t)) {
        if (1 < t.length) throw Error(we(93));
        t = t[0];
      }
      e = t;
    }
    e == null && (e = ""), (t = e);
  }
  n._wrapperState = { initialValue: zo(t) };
}
function Fb(n, e) {
  var t = zo(e.value),
    i = zo(e.defaultValue);
  t != null &&
    ((t = "" + t),
    t !== n.value && (n.value = t),
    e.defaultValue == null && n.defaultValue !== t && (n.defaultValue = t)),
    i != null && (n.defaultValue = "" + i);
}
function $w(n) {
  var e = n.textContent;
  e === n._wrapperState.initialValue && e !== "" && e !== null && (n.value = e);
}
function zb(n) {
  switch (n) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function ox(n, e) {
  return n == null || n === "http://www.w3.org/1999/xhtml"
    ? zb(e)
    : n === "http://www.w3.org/2000/svg" && e === "foreignObject"
    ? "http://www.w3.org/1999/xhtml"
    : n;
}
var Cd,
  Bb = (function (n) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction
      ? function (e, t, i, r) {
          MSApp.execUnsafeLocalFunction(function () {
            return n(e, t, i, r);
          });
        }
      : n;
  })(function (n, e) {
    if (n.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in n)
      n.innerHTML = e;
    else {
      for (
        Cd = Cd || document.createElement("div"),
          Cd.innerHTML = "<svg>" + e.valueOf().toString() + "</svg>",
          e = Cd.firstChild;
        n.firstChild;

      )
        n.removeChild(n.firstChild);
      for (; e.firstChild; ) n.appendChild(e.firstChild);
    }
  });
function hf(n, e) {
  if (e) {
    var t = n.firstChild;
    if (t && t === n.lastChild && t.nodeType === 3) {
      t.nodeValue = e;
      return;
    }
  }
  n.textContent = e;
}
var jc = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0,
  },
  xD = ["Webkit", "ms", "Moz", "O"];
Object.keys(jc).forEach(function (n) {
  xD.forEach(function (e) {
    (e = e + n.charAt(0).toUpperCase() + n.substring(1)), (jc[e] = jc[n]);
  });
});
function Vb(n, e, t) {
  return e == null || typeof e == "boolean" || e === ""
    ? ""
    : t || typeof e != "number" || e === 0 || (jc.hasOwnProperty(n) && jc[n])
    ? ("" + e).trim()
    : e + "px";
}
function Hb(n, e) {
  n = n.style;
  for (var t in e)
    if (e.hasOwnProperty(t)) {
      var i = t.indexOf("--") === 0,
        r = Vb(t, e[t], i);
      t === "float" && (t = "cssFloat"), i ? n.setProperty(t, r) : (n[t] = r);
    }
}
var _D = hn(
  { menuitem: !0 },
  {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0,
  }
);
function ax(n, e) {
  if (e) {
    if (_D[n] && (e.children != null || e.dangerouslySetInnerHTML != null))
      throw Error(we(137, n));
    if (e.dangerouslySetInnerHTML != null) {
      if (e.children != null) throw Error(we(60));
      if (
        typeof e.dangerouslySetInnerHTML != "object" ||
        !("__html" in e.dangerouslySetInnerHTML)
      )
        throw Error(we(61));
    }
    if (e.style != null && typeof e.style != "object") throw Error(we(62));
  }
}
function lx(n, e) {
  if (n.indexOf("-") === -1) return typeof e.is == "string";
  switch (n) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return !1;
    default:
      return !0;
  }
}
var ux = null;
function s1(n) {
  return (
    (n = n.target || n.srcElement || window),
    n.correspondingUseElement && (n = n.correspondingUseElement),
    n.nodeType === 3 ? n.parentNode : n
  );
}
var cx = null,
  _u = null,
  Su = null;
function Jw(n) {
  if ((n = nh(n))) {
    if (typeof cx != "function") throw Error(we(280));
    var e = n.stateNode;
    e && ((e = cg(e)), cx(n.stateNode, n.type, e));
  }
}
function Gb(n) {
  _u ? (Su ? Su.push(n) : (Su = [n])) : (_u = n);
}
function Wb() {
  if (_u) {
    var n = _u,
      e = Su;
    if (((Su = _u = null), Jw(n), e)) for (n = 0; n < e.length; n++) Jw(e[n]);
  }
}
function jb(n, e) {
  return n(e);
}
function Xb() {}
var _0 = !1;
function Yb(n, e, t) {
  if (_0) return n(e, t);
  _0 = !0;
  try {
    return jb(n, e, t);
  } finally {
    (_0 = !1), (_u !== null || Su !== null) && (Xb(), Wb());
  }
}
function df(n, e) {
  var t = n.stateNode;
  if (t === null) return null;
  var i = cg(t);
  if (i === null) return null;
  t = i[e];
  e: switch (e) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
      (i = !i.disabled) ||
        ((n = n.type),
        (i = !(
          n === "button" ||
          n === "input" ||
          n === "select" ||
          n === "textarea"
        ))),
        (n = !i);
      break e;
    default:
      n = !1;
  }
  if (n) return null;
  if (t && typeof t != "function") throw Error(we(231, e, typeof t));
  return t;
}
var fx = !1;
if (Bs)
  try {
    var vc = {};
    Object.defineProperty(vc, "passive", {
      get: function () {
        fx = !0;
      },
    }),
      window.addEventListener("test", vc, vc),
      window.removeEventListener("test", vc, vc);
  } catch {
    fx = !1;
  }
function SD(n, e, t, i, r, s, o, a, u) {
  var f = Array.prototype.slice.call(arguments, 3);
  try {
    e.apply(t, f);
  } catch (h) {
    this.onError(h);
  }
}
var Xc = !1,
  gm = null,
  vm = !1,
  hx = null,
  MD = {
    onError: function (n) {
      (Xc = !0), (gm = n);
    },
  };
function wD(n, e, t, i, r, s, o, a, u) {
  (Xc = !1), (gm = null), SD.apply(MD, arguments);
}
function ED(n, e, t, i, r, s, o, a, u) {
  if ((wD.apply(this, arguments), Xc)) {
    if (Xc) {
      var f = gm;
      (Xc = !1), (gm = null);
    } else throw Error(we(198));
    vm || ((vm = !0), (hx = f));
  }
}
function tl(n) {
  var e = n,
    t = n;
  if (n.alternate) for (; e.return; ) e = e.return;
  else {
    n = e;
    do (e = n), e.flags & 4098 && (t = e.return), (n = e.return);
    while (n);
  }
  return e.tag === 3 ? t : null;
}
function qb(n) {
  if (n.tag === 13) {
    var e = n.memoizedState;
    if (
      (e === null && ((n = n.alternate), n !== null && (e = n.memoizedState)),
      e !== null)
    )
      return e.dehydrated;
  }
  return null;
}
function eE(n) {
  if (tl(n) !== n) throw Error(we(188));
}
function TD(n) {
  var e = n.alternate;
  if (!e) {
    if (((e = tl(n)), e === null)) throw Error(we(188));
    return e !== n ? null : n;
  }
  for (var t = n, i = e; ; ) {
    var r = t.return;
    if (r === null) break;
    var s = r.alternate;
    if (s === null) {
      if (((i = r.return), i !== null)) {
        t = i;
        continue;
      }
      break;
    }
    if (r.child === s.child) {
      for (s = r.child; s; ) {
        if (s === t) return eE(r), n;
        if (s === i) return eE(r), e;
        s = s.sibling;
      }
      throw Error(we(188));
    }
    if (t.return !== i.return) (t = r), (i = s);
    else {
      for (var o = !1, a = r.child; a; ) {
        if (a === t) {
          (o = !0), (t = r), (i = s);
          break;
        }
        if (a === i) {
          (o = !0), (i = r), (t = s);
          break;
        }
        a = a.sibling;
      }
      if (!o) {
        for (a = s.child; a; ) {
          if (a === t) {
            (o = !0), (t = s), (i = r);
            break;
          }
          if (a === i) {
            (o = !0), (i = s), (t = r);
            break;
          }
          a = a.sibling;
        }
        if (!o) throw Error(we(189));
      }
    }
    if (t.alternate !== i) throw Error(we(190));
  }
  if (t.tag !== 3) throw Error(we(188));
  return t.stateNode.current === t ? n : e;
}
function Zb(n) {
  return (n = TD(n)), n !== null ? Kb(n) : null;
}
function Kb(n) {
  if (n.tag === 5 || n.tag === 6) return n;
  for (n = n.child; n !== null; ) {
    var e = Kb(n);
    if (e !== null) return e;
    n = n.sibling;
  }
  return null;
}
var Qb = tr.unstable_scheduleCallback,
  tE = tr.unstable_cancelCallback,
  AD = tr.unstable_shouldYield,
  bD = tr.unstable_requestPaint,
  Mn = tr.unstable_now,
  CD = tr.unstable_getCurrentPriorityLevel,
  o1 = tr.unstable_ImmediatePriority,
  $b = tr.unstable_UserBlockingPriority,
  ym = tr.unstable_NormalPriority,
  PD = tr.unstable_LowPriority,
  Jb = tr.unstable_IdlePriority,
  og = null,
  os = null;
function RD(n) {
  if (os && typeof os.onCommitFiberRoot == "function")
    try {
      os.onCommitFiberRoot(og, n, void 0, (n.current.flags & 128) === 128);
    } catch {}
}
var Fr = Math.clz32 ? Math.clz32 : ND,
  LD = Math.log,
  ID = Math.LN2;
function ND(n) {
  return (n >>>= 0), n === 0 ? 32 : (31 - ((LD(n) / ID) | 0)) | 0;
}
var Pd = 64,
  Rd = 4194304;
function Vc(n) {
  switch (n & -n) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return n & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return n & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return n;
  }
}
function xm(n, e) {
  var t = n.pendingLanes;
  if (t === 0) return 0;
  var i = 0,
    r = n.suspendedLanes,
    s = n.pingedLanes,
    o = t & 268435455;
  if (o !== 0) {
    var a = o & ~r;
    a !== 0 ? (i = Vc(a)) : ((s &= o), s !== 0 && (i = Vc(s)));
  } else (o = t & ~r), o !== 0 ? (i = Vc(o)) : s !== 0 && (i = Vc(s));
  if (i === 0) return 0;
  if (
    e !== 0 &&
    e !== i &&
    !(e & r) &&
    ((r = i & -i), (s = e & -e), r >= s || (r === 16 && (s & 4194240) !== 0))
  )
    return e;
  if ((i & 4 && (i |= t & 16), (e = n.entangledLanes), e !== 0))
    for (n = n.entanglements, e &= i; 0 < e; )
      (t = 31 - Fr(e)), (r = 1 << t), (i |= n[t]), (e &= ~r);
  return i;
}
function DD(n, e) {
  switch (n) {
    case 1:
    case 2:
    case 4:
      return e + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return e + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function OD(n, e) {
  for (
    var t = n.suspendedLanes,
      i = n.pingedLanes,
      r = n.expirationTimes,
      s = n.pendingLanes;
    0 < s;

  ) {
    var o = 31 - Fr(s),
      a = 1 << o,
      u = r[o];
    u === -1
      ? (!(a & t) || a & i) && (r[o] = DD(a, e))
      : u <= e && (n.expiredLanes |= a),
      (s &= ~a);
  }
}
function dx(n) {
  return (
    (n = n.pendingLanes & -1073741825),
    n !== 0 ? n : n & 1073741824 ? 1073741824 : 0
  );
}
function eC() {
  var n = Pd;
  return (Pd <<= 1), !(Pd & 4194240) && (Pd = 64), n;
}
function S0(n) {
  for (var e = [], t = 0; 31 > t; t++) e.push(n);
  return e;
}
function eh(n, e, t) {
  (n.pendingLanes |= e),
    e !== 536870912 && ((n.suspendedLanes = 0), (n.pingedLanes = 0)),
    (n = n.eventTimes),
    (e = 31 - Fr(e)),
    (n[e] = t);
}
function UD(n, e) {
  var t = n.pendingLanes & ~e;
  (n.pendingLanes = e),
    (n.suspendedLanes = 0),
    (n.pingedLanes = 0),
    (n.expiredLanes &= e),
    (n.mutableReadLanes &= e),
    (n.entangledLanes &= e),
    (e = n.entanglements);
  var i = n.eventTimes;
  for (n = n.expirationTimes; 0 < t; ) {
    var r = 31 - Fr(t),
      s = 1 << r;
    (e[r] = 0), (i[r] = -1), (n[r] = -1), (t &= ~s);
  }
}
function a1(n, e) {
  var t = (n.entangledLanes |= e);
  for (n = n.entanglements; t; ) {
    var i = 31 - Fr(t),
      r = 1 << i;
    (r & e) | (n[i] & e) && (n[i] |= e), (t &= ~r);
  }
}
var Vt = 0;
function tC(n) {
  return (n &= -n), 1 < n ? (4 < n ? (n & 268435455 ? 16 : 536870912) : 4) : 1;
}
var nC,
  l1,
  iC,
  rC,
  sC,
  px = !1,
  Ld = [],
  Ao = null,
  bo = null,
  Co = null,
  pf = new Map(),
  mf = new Map(),
  So = [],
  kD =
    "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(
      " "
    );
function nE(n, e) {
  switch (n) {
    case "focusin":
    case "focusout":
      Ao = null;
      break;
    case "dragenter":
    case "dragleave":
      bo = null;
      break;
    case "mouseover":
    case "mouseout":
      Co = null;
      break;
    case "pointerover":
    case "pointerout":
      pf.delete(e.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      mf.delete(e.pointerId);
  }
}
function yc(n, e, t, i, r, s) {
  return n === null || n.nativeEvent !== s
    ? ((n = {
        blockedOn: e,
        domEventName: t,
        eventSystemFlags: i,
        nativeEvent: s,
        targetContainers: [r],
      }),
      e !== null && ((e = nh(e)), e !== null && l1(e)),
      n)
    : ((n.eventSystemFlags |= i),
      (e = n.targetContainers),
      r !== null && e.indexOf(r) === -1 && e.push(r),
      n);
}
function FD(n, e, t, i, r) {
  switch (e) {
    case "focusin":
      return (Ao = yc(Ao, n, e, t, i, r)), !0;
    case "dragenter":
      return (bo = yc(bo, n, e, t, i, r)), !0;
    case "mouseover":
      return (Co = yc(Co, n, e, t, i, r)), !0;
    case "pointerover":
      var s = r.pointerId;
      return pf.set(s, yc(pf.get(s) || null, n, e, t, i, r)), !0;
    case "gotpointercapture":
      return (
        (s = r.pointerId), mf.set(s, yc(mf.get(s) || null, n, e, t, i, r)), !0
      );
  }
  return !1;
}
function oC(n) {
  var e = Ra(n.target);
  if (e !== null) {
    var t = tl(e);
    if (t !== null) {
      if (((e = t.tag), e === 13)) {
        if (((e = qb(t)), e !== null)) {
          (n.blockedOn = e),
            sC(n.priority, function () {
              iC(t);
            });
          return;
        }
      } else if (e === 3 && t.stateNode.current.memoizedState.isDehydrated) {
        n.blockedOn = t.tag === 3 ? t.stateNode.containerInfo : null;
        return;
      }
    }
  }
  n.blockedOn = null;
}
function qp(n) {
  if (n.blockedOn !== null) return !1;
  for (var e = n.targetContainers; 0 < e.length; ) {
    var t = mx(n.domEventName, n.eventSystemFlags, e[0], n.nativeEvent);
    if (t === null) {
      t = n.nativeEvent;
      var i = new t.constructor(t.type, t);
      (ux = i), t.target.dispatchEvent(i), (ux = null);
    } else return (e = nh(t)), e !== null && l1(e), (n.blockedOn = t), !1;
    e.shift();
  }
  return !0;
}
function iE(n, e, t) {
  qp(n) && t.delete(e);
}
function zD() {
  (px = !1),
    Ao !== null && qp(Ao) && (Ao = null),
    bo !== null && qp(bo) && (bo = null),
    Co !== null && qp(Co) && (Co = null),
    pf.forEach(iE),
    mf.forEach(iE);
}
function xc(n, e) {
  n.blockedOn === e &&
    ((n.blockedOn = null),
    px ||
      ((px = !0),
      tr.unstable_scheduleCallback(tr.unstable_NormalPriority, zD)));
}
function gf(n) {
  function e(r) {
    return xc(r, n);
  }
  if (0 < Ld.length) {
    xc(Ld[0], n);
    for (var t = 1; t < Ld.length; t++) {
      var i = Ld[t];
      i.blockedOn === n && (i.blockedOn = null);
    }
  }
  for (
    Ao !== null && xc(Ao, n),
      bo !== null && xc(bo, n),
      Co !== null && xc(Co, n),
      pf.forEach(e),
      mf.forEach(e),
      t = 0;
    t < So.length;
    t++
  )
    (i = So[t]), i.blockedOn === n && (i.blockedOn = null);
  for (; 0 < So.length && ((t = So[0]), t.blockedOn === null); )
    oC(t), t.blockedOn === null && So.shift();
}
var Mu = qs.ReactCurrentBatchConfig,
  _m = !0;
function BD(n, e, t, i) {
  var r = Vt,
    s = Mu.transition;
  Mu.transition = null;
  try {
    (Vt = 1), u1(n, e, t, i);
  } finally {
    (Vt = r), (Mu.transition = s);
  }
}
function VD(n, e, t, i) {
  var r = Vt,
    s = Mu.transition;
  Mu.transition = null;
  try {
    (Vt = 4), u1(n, e, t, i);
  } finally {
    (Vt = r), (Mu.transition = s);
  }
}
function u1(n, e, t, i) {
  if (_m) {
    var r = mx(n, e, t, i);
    if (r === null) L0(n, e, i, Sm, t), nE(n, i);
    else if (FD(r, n, e, t, i)) i.stopPropagation();
    else if ((nE(n, i), e & 4 && -1 < kD.indexOf(n))) {
      for (; r !== null; ) {
        var s = nh(r);
        if (
          (s !== null && nC(s),
          (s = mx(n, e, t, i)),
          s === null && L0(n, e, i, Sm, t),
          s === r)
        )
          break;
        r = s;
      }
      r !== null && i.stopPropagation();
    } else L0(n, e, i, null, t);
  }
}
var Sm = null;
function mx(n, e, t, i) {
  if (((Sm = null), (n = s1(i)), (n = Ra(n)), n !== null))
    if (((e = tl(n)), e === null)) n = null;
    else if (((t = e.tag), t === 13)) {
      if (((n = qb(e)), n !== null)) return n;
      n = null;
    } else if (t === 3) {
      if (e.stateNode.current.memoizedState.isDehydrated)
        return e.tag === 3 ? e.stateNode.containerInfo : null;
      n = null;
    } else e !== n && (n = null);
  return (Sm = n), null;
}
function aC(n) {
  switch (n) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (CD()) {
        case o1:
          return 1;
        case $b:
          return 4;
        case ym:
        case PD:
          return 16;
        case Jb:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var Eo = null,
  c1 = null,
  Zp = null;
function lC() {
  if (Zp) return Zp;
  var n,
    e = c1,
    t = e.length,
    i,
    r = "value" in Eo ? Eo.value : Eo.textContent,
    s = r.length;
  for (n = 0; n < t && e[n] === r[n]; n++);
  var o = t - n;
  for (i = 1; i <= o && e[t - i] === r[s - i]; i++);
  return (Zp = r.slice(n, 1 < i ? 1 - i : void 0));
}
function Kp(n) {
  var e = n.keyCode;
  return (
    "charCode" in n
      ? ((n = n.charCode), n === 0 && e === 13 && (n = 13))
      : (n = e),
    n === 10 && (n = 13),
    32 <= n || n === 13 ? n : 0
  );
}
function Id() {
  return !0;
}
function rE() {
  return !1;
}
function rr(n) {
  function e(t, i, r, s, o) {
    (this._reactName = t),
      (this._targetInst = r),
      (this.type = i),
      (this.nativeEvent = s),
      (this.target = o),
      (this.currentTarget = null);
    for (var a in n)
      n.hasOwnProperty(a) && ((t = n[a]), (this[a] = t ? t(s) : s[a]));
    return (
      (this.isDefaultPrevented = (
        s.defaultPrevented != null ? s.defaultPrevented : s.returnValue === !1
      )
        ? Id
        : rE),
      (this.isPropagationStopped = rE),
      this
    );
  }
  return (
    hn(e.prototype, {
      preventDefault: function () {
        this.defaultPrevented = !0;
        var t = this.nativeEvent;
        t &&
          (t.preventDefault
            ? t.preventDefault()
            : typeof t.returnValue != "unknown" && (t.returnValue = !1),
          (this.isDefaultPrevented = Id));
      },
      stopPropagation: function () {
        var t = this.nativeEvent;
        t &&
          (t.stopPropagation
            ? t.stopPropagation()
            : typeof t.cancelBubble != "unknown" && (t.cancelBubble = !0),
          (this.isPropagationStopped = Id));
      },
      persist: function () {},
      isPersistent: Id,
    }),
    e
  );
}
var Hu = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function (n) {
      return n.timeStamp || Date.now();
    },
    defaultPrevented: 0,
    isTrusted: 0,
  },
  f1 = rr(Hu),
  th = hn({}, Hu, { view: 0, detail: 0 }),
  HD = rr(th),
  M0,
  w0,
  _c,
  ag = hn({}, th, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: h1,
    button: 0,
    buttons: 0,
    relatedTarget: function (n) {
      return n.relatedTarget === void 0
        ? n.fromElement === n.srcElement
          ? n.toElement
          : n.fromElement
        : n.relatedTarget;
    },
    movementX: function (n) {
      return "movementX" in n
        ? n.movementX
        : (n !== _c &&
            (_c && n.type === "mousemove"
              ? ((M0 = n.screenX - _c.screenX), (w0 = n.screenY - _c.screenY))
              : (w0 = M0 = 0),
            (_c = n)),
          M0);
    },
    movementY: function (n) {
      return "movementY" in n ? n.movementY : w0;
    },
  }),
  sE = rr(ag),
  GD = hn({}, ag, { dataTransfer: 0 }),
  WD = rr(GD),
  jD = hn({}, th, { relatedTarget: 0 }),
  E0 = rr(jD),
  XD = hn({}, Hu, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }),
  YD = rr(XD),
  qD = hn({}, Hu, {
    clipboardData: function (n) {
      return "clipboardData" in n ? n.clipboardData : window.clipboardData;
    },
  }),
  ZD = rr(qD),
  KD = hn({}, Hu, { data: 0 }),
  oE = rr(KD),
  QD = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified",
  },
  $D = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta",
  },
  JD = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey",
  };
function e4(n) {
  var e = this.nativeEvent;
  return e.getModifierState ? e.getModifierState(n) : (n = JD[n]) ? !!e[n] : !1;
}
function h1() {
  return e4;
}
var t4 = hn({}, th, {
    key: function (n) {
      if (n.key) {
        var e = QD[n.key] || n.key;
        if (e !== "Unidentified") return e;
      }
      return n.type === "keypress"
        ? ((n = Kp(n)), n === 13 ? "Enter" : String.fromCharCode(n))
        : n.type === "keydown" || n.type === "keyup"
        ? $D[n.keyCode] || "Unidentified"
        : "";
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: h1,
    charCode: function (n) {
      return n.type === "keypress" ? Kp(n) : 0;
    },
    keyCode: function (n) {
      return n.type === "keydown" || n.type === "keyup" ? n.keyCode : 0;
    },
    which: function (n) {
      return n.type === "keypress"
        ? Kp(n)
        : n.type === "keydown" || n.type === "keyup"
        ? n.keyCode
        : 0;
    },
  }),
  n4 = rr(t4),
  i4 = hn({}, ag, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0,
  }),
  aE = rr(i4),
  r4 = hn({}, th, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: h1,
  }),
  s4 = rr(r4),
  o4 = hn({}, Hu, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }),
  a4 = rr(o4),
  l4 = hn({}, ag, {
    deltaX: function (n) {
      return "deltaX" in n ? n.deltaX : "wheelDeltaX" in n ? -n.wheelDeltaX : 0;
    },
    deltaY: function (n) {
      return "deltaY" in n
        ? n.deltaY
        : "wheelDeltaY" in n
        ? -n.wheelDeltaY
        : "wheelDelta" in n
        ? -n.wheelDelta
        : 0;
    },
    deltaZ: 0,
    deltaMode: 0,
  }),
  u4 = rr(l4),
  c4 = [9, 13, 27, 32],
  d1 = Bs && "CompositionEvent" in window,
  Yc = null;
Bs && "documentMode" in document && (Yc = document.documentMode);
var f4 = Bs && "TextEvent" in window && !Yc,
  uC = Bs && (!d1 || (Yc && 8 < Yc && 11 >= Yc)),
  lE = " ",
  uE = !1;
function cC(n, e) {
  switch (n) {
    case "keyup":
      return c4.indexOf(e.keyCode) !== -1;
    case "keydown":
      return e.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
      return !0;
    default:
      return !1;
  }
}
function fC(n) {
  return (n = n.detail), typeof n == "object" && "data" in n ? n.data : null;
}
var Jl = !1;
function h4(n, e) {
  switch (n) {
    case "compositionend":
      return fC(e);
    case "keypress":
      return e.which !== 32 ? null : ((uE = !0), lE);
    case "textInput":
      return (n = e.data), n === lE && uE ? null : n;
    default:
      return null;
  }
}
function d4(n, e) {
  if (Jl)
    return n === "compositionend" || (!d1 && cC(n, e))
      ? ((n = lC()), (Zp = c1 = Eo = null), (Jl = !1), n)
      : null;
  switch (n) {
    case "paste":
      return null;
    case "keypress":
      if (!(e.ctrlKey || e.altKey || e.metaKey) || (e.ctrlKey && e.altKey)) {
        if (e.char && 1 < e.char.length) return e.char;
        if (e.which) return String.fromCharCode(e.which);
      }
      return null;
    case "compositionend":
      return uC && e.locale !== "ko" ? null : e.data;
    default:
      return null;
  }
}
var p4 = {
  color: !0,
  date: !0,
  datetime: !0,
  "datetime-local": !0,
  email: !0,
  month: !0,
  number: !0,
  password: !0,
  range: !0,
  search: !0,
  tel: !0,
  text: !0,
  time: !0,
  url: !0,
  week: !0,
};
function cE(n) {
  var e = n && n.nodeName && n.nodeName.toLowerCase();
  return e === "input" ? !!p4[n.type] : e === "textarea";
}
function hC(n, e, t, i) {
  Gb(i),
    (e = Mm(e, "onChange")),
    0 < e.length &&
      ((t = new f1("onChange", "change", null, t, i)),
      n.push({ event: t, listeners: e }));
}
var qc = null,
  vf = null;
function m4(n) {
  wC(n, 0);
}
function lg(n) {
  var e = nu(n);
  if (Ub(e)) return n;
}
function g4(n, e) {
  if (n === "change") return e;
}
var dC = !1;
if (Bs) {
  var T0;
  if (Bs) {
    var A0 = "oninput" in document;
    if (!A0) {
      var fE = document.createElement("div");
      fE.setAttribute("oninput", "return;"),
        (A0 = typeof fE.oninput == "function");
    }
    T0 = A0;
  } else T0 = !1;
  dC = T0 && (!document.documentMode || 9 < document.documentMode);
}
function hE() {
  qc && (qc.detachEvent("onpropertychange", pC), (vf = qc = null));
}
function pC(n) {
  if (n.propertyName === "value" && lg(vf)) {
    var e = [];
    hC(e, vf, n, s1(n)), Yb(m4, e);
  }
}
function v4(n, e, t) {
  n === "focusin"
    ? (hE(), (qc = e), (vf = t), qc.attachEvent("onpropertychange", pC))
    : n === "focusout" && hE();
}
function y4(n) {
  if (n === "selectionchange" || n === "keyup" || n === "keydown")
    return lg(vf);
}
function x4(n, e) {
  if (n === "click") return lg(e);
}
function _4(n, e) {
  if (n === "input" || n === "change") return lg(e);
}
function S4(n, e) {
  return (n === e && (n !== 0 || 1 / n === 1 / e)) || (n !== n && e !== e);
}
var Br = typeof Object.is == "function" ? Object.is : S4;
function yf(n, e) {
  if (Br(n, e)) return !0;
  if (typeof n != "object" || n === null || typeof e != "object" || e === null)
    return !1;
  var t = Object.keys(n),
    i = Object.keys(e);
  if (t.length !== i.length) return !1;
  for (i = 0; i < t.length; i++) {
    var r = t[i];
    if (!Qy.call(e, r) || !Br(n[r], e[r])) return !1;
  }
  return !0;
}
function dE(n) {
  for (; n && n.firstChild; ) n = n.firstChild;
  return n;
}
function pE(n, e) {
  var t = dE(n);
  n = 0;
  for (var i; t; ) {
    if (t.nodeType === 3) {
      if (((i = n + t.textContent.length), n <= e && i >= e))
        return { node: t, offset: e - n };
      n = i;
    }
    e: {
      for (; t; ) {
        if (t.nextSibling) {
          t = t.nextSibling;
          break e;
        }
        t = t.parentNode;
      }
      t = void 0;
    }
    t = dE(t);
  }
}
function mC(n, e) {
  return n && e
    ? n === e
      ? !0
      : n && n.nodeType === 3
      ? !1
      : e && e.nodeType === 3
      ? mC(n, e.parentNode)
      : "contains" in n
      ? n.contains(e)
      : n.compareDocumentPosition
      ? !!(n.compareDocumentPosition(e) & 16)
      : !1
    : !1;
}
function gC() {
  for (var n = window, e = mm(); e instanceof n.HTMLIFrameElement; ) {
    try {
      var t = typeof e.contentWindow.location.href == "string";
    } catch {
      t = !1;
    }
    if (t) n = e.contentWindow;
    else break;
    e = mm(n.document);
  }
  return e;
}
function p1(n) {
  var e = n && n.nodeName && n.nodeName.toLowerCase();
  return (
    e &&
    ((e === "input" &&
      (n.type === "text" ||
        n.type === "search" ||
        n.type === "tel" ||
        n.type === "url" ||
        n.type === "password")) ||
      e === "textarea" ||
      n.contentEditable === "true")
  );
}
function M4(n) {
  var e = gC(),
    t = n.focusedElem,
    i = n.selectionRange;
  if (
    e !== t &&
    t &&
    t.ownerDocument &&
    mC(t.ownerDocument.documentElement, t)
  ) {
    if (i !== null && p1(t)) {
      if (
        ((e = i.start),
        (n = i.end),
        n === void 0 && (n = e),
        "selectionStart" in t)
      )
        (t.selectionStart = e), (t.selectionEnd = Math.min(n, t.value.length));
      else if (
        ((n = ((e = t.ownerDocument || document) && e.defaultView) || window),
        n.getSelection)
      ) {
        n = n.getSelection();
        var r = t.textContent.length,
          s = Math.min(i.start, r);
        (i = i.end === void 0 ? s : Math.min(i.end, r)),
          !n.extend && s > i && ((r = i), (i = s), (s = r)),
          (r = pE(t, s));
        var o = pE(t, i);
        r &&
          o &&
          (n.rangeCount !== 1 ||
            n.anchorNode !== r.node ||
            n.anchorOffset !== r.offset ||
            n.focusNode !== o.node ||
            n.focusOffset !== o.offset) &&
          ((e = e.createRange()),
          e.setStart(r.node, r.offset),
          n.removeAllRanges(),
          s > i
            ? (n.addRange(e), n.extend(o.node, o.offset))
            : (e.setEnd(o.node, o.offset), n.addRange(e)));
      }
    }
    for (e = [], n = t; (n = n.parentNode); )
      n.nodeType === 1 &&
        e.push({ element: n, left: n.scrollLeft, top: n.scrollTop });
    for (typeof t.focus == "function" && t.focus(), t = 0; t < e.length; t++)
      (n = e[t]),
        (n.element.scrollLeft = n.left),
        (n.element.scrollTop = n.top);
  }
}
var w4 = Bs && "documentMode" in document && 11 >= document.documentMode,
  eu = null,
  gx = null,
  Zc = null,
  vx = !1;
function mE(n, e, t) {
  var i = t.window === t ? t.document : t.nodeType === 9 ? t : t.ownerDocument;
  vx ||
    eu == null ||
    eu !== mm(i) ||
    ((i = eu),
    "selectionStart" in i && p1(i)
      ? (i = { start: i.selectionStart, end: i.selectionEnd })
      : ((i = (
          (i.ownerDocument && i.ownerDocument.defaultView) ||
          window
        ).getSelection()),
        (i = {
          anchorNode: i.anchorNode,
          anchorOffset: i.anchorOffset,
          focusNode: i.focusNode,
          focusOffset: i.focusOffset,
        })),
    (Zc && yf(Zc, i)) ||
      ((Zc = i),
      (i = Mm(gx, "onSelect")),
      0 < i.length &&
        ((e = new f1("onSelect", "select", null, e, t)),
        n.push({ event: e, listeners: i }),
        (e.target = eu))));
}
function Nd(n, e) {
  var t = {};
  return (
    (t[n.toLowerCase()] = e.toLowerCase()),
    (t["Webkit" + n] = "webkit" + e),
    (t["Moz" + n] = "moz" + e),
    t
  );
}
var tu = {
    animationend: Nd("Animation", "AnimationEnd"),
    animationiteration: Nd("Animation", "AnimationIteration"),
    animationstart: Nd("Animation", "AnimationStart"),
    transitionend: Nd("Transition", "TransitionEnd"),
  },
  b0 = {},
  vC = {};
Bs &&
  ((vC = document.createElement("div").style),
  "AnimationEvent" in window ||
    (delete tu.animationend.animation,
    delete tu.animationiteration.animation,
    delete tu.animationstart.animation),
  "TransitionEvent" in window || delete tu.transitionend.transition);
function ug(n) {
  if (b0[n]) return b0[n];
  if (!tu[n]) return n;
  var e = tu[n],
    t;
  for (t in e) if (e.hasOwnProperty(t) && t in vC) return (b0[n] = e[t]);
  return n;
}
var yC = ug("animationend"),
  xC = ug("animationiteration"),
  _C = ug("animationstart"),
  SC = ug("transitionend"),
  MC = new Map(),
  gE =
    "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
      " "
    );
function Xo(n, e) {
  MC.set(n, e), el(e, [n]);
}
for (var C0 = 0; C0 < gE.length; C0++) {
  var P0 = gE[C0],
    E4 = P0.toLowerCase(),
    T4 = P0[0].toUpperCase() + P0.slice(1);
  Xo(E4, "on" + T4);
}
Xo(yC, "onAnimationEnd");
Xo(xC, "onAnimationIteration");
Xo(_C, "onAnimationStart");
Xo("dblclick", "onDoubleClick");
Xo("focusin", "onFocus");
Xo("focusout", "onBlur");
Xo(SC, "onTransitionEnd");
Au("onMouseEnter", ["mouseout", "mouseover"]);
Au("onMouseLeave", ["mouseout", "mouseover"]);
Au("onPointerEnter", ["pointerout", "pointerover"]);
Au("onPointerLeave", ["pointerout", "pointerover"]);
el(
  "onChange",
  "change click focusin focusout input keydown keyup selectionchange".split(" ")
);
el(
  "onSelect",
  "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
    " "
  )
);
el("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
el(
  "onCompositionEnd",
  "compositionend focusout keydown keypress keyup mousedown".split(" ")
);
el(
  "onCompositionStart",
  "compositionstart focusout keydown keypress keyup mousedown".split(" ")
);
el(
  "onCompositionUpdate",
  "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
);
var Hc =
    "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
      " "
    ),
  A4 = new Set("cancel close invalid load scroll toggle".split(" ").concat(Hc));
function vE(n, e, t) {
  var i = n.type || "unknown-event";
  (n.currentTarget = t), ED(i, e, void 0, n), (n.currentTarget = null);
}
function wC(n, e) {
  e = (e & 4) !== 0;
  for (var t = 0; t < n.length; t++) {
    var i = n[t],
      r = i.event;
    i = i.listeners;
    e: {
      var s = void 0;
      if (e)
        for (var o = i.length - 1; 0 <= o; o--) {
          var a = i[o],
            u = a.instance,
            f = a.currentTarget;
          if (((a = a.listener), u !== s && r.isPropagationStopped())) break e;
          vE(r, a, f), (s = u);
        }
      else
        for (o = 0; o < i.length; o++) {
          if (
            ((a = i[o]),
            (u = a.instance),
            (f = a.currentTarget),
            (a = a.listener),
            u !== s && r.isPropagationStopped())
          )
            break e;
          vE(r, a, f), (s = u);
        }
    }
  }
  if (vm) throw ((n = hx), (vm = !1), (hx = null), n);
}
function qt(n, e) {
  var t = e[Mx];
  t === void 0 && (t = e[Mx] = new Set());
  var i = n + "__bubble";
  t.has(i) || (EC(e, n, 2, !1), t.add(i));
}
function R0(n, e, t) {
  var i = 0;
  e && (i |= 4), EC(t, n, i, e);
}
var Dd = "_reactListening" + Math.random().toString(36).slice(2);
function xf(n) {
  if (!n[Dd]) {
    (n[Dd] = !0),
      Lb.forEach(function (t) {
        t !== "selectionchange" && (A4.has(t) || R0(t, !1, n), R0(t, !0, n));
      });
    var e = n.nodeType === 9 ? n : n.ownerDocument;
    e === null || e[Dd] || ((e[Dd] = !0), R0("selectionchange", !1, e));
  }
}
function EC(n, e, t, i) {
  switch (aC(e)) {
    case 1:
      var r = BD;
      break;
    case 4:
      r = VD;
      break;
    default:
      r = u1;
  }
  (t = r.bind(null, e, t, n)),
    (r = void 0),
    !fx ||
      (e !== "touchstart" && e !== "touchmove" && e !== "wheel") ||
      (r = !0),
    i
      ? r !== void 0
        ? n.addEventListener(e, t, { capture: !0, passive: r })
        : n.addEventListener(e, t, !0)
      : r !== void 0
      ? n.addEventListener(e, t, { passive: r })
      : n.addEventListener(e, t, !1);
}
function L0(n, e, t, i, r) {
  var s = i;
  if (!(e & 1) && !(e & 2) && i !== null)
    e: for (;;) {
      if (i === null) return;
      var o = i.tag;
      if (o === 3 || o === 4) {
        var a = i.stateNode.containerInfo;
        if (a === r || (a.nodeType === 8 && a.parentNode === r)) break;
        if (o === 4)
          for (o = i.return; o !== null; ) {
            var u = o.tag;
            if (
              (u === 3 || u === 4) &&
              ((u = o.stateNode.containerInfo),
              u === r || (u.nodeType === 8 && u.parentNode === r))
            )
              return;
            o = o.return;
          }
        for (; a !== null; ) {
          if (((o = Ra(a)), o === null)) return;
          if (((u = o.tag), u === 5 || u === 6)) {
            i = s = o;
            continue e;
          }
          a = a.parentNode;
        }
      }
      i = i.return;
    }
  Yb(function () {
    var f = s,
      h = s1(t),
      d = [];
    e: {
      var p = MC.get(n);
      if (p !== void 0) {
        var m = f1,
          y = n;
        switch (n) {
          case "keypress":
            if (Kp(t) === 0) break e;
          case "keydown":
          case "keyup":
            m = n4;
            break;
          case "focusin":
            (y = "focus"), (m = E0);
            break;
          case "focusout":
            (y = "blur"), (m = E0);
            break;
          case "beforeblur":
          case "afterblur":
            m = E0;
            break;
          case "click":
            if (t.button === 2) break e;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            m = sE;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            m = WD;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            m = s4;
            break;
          case yC:
          case xC:
          case _C:
            m = YD;
            break;
          case SC:
            m = a4;
            break;
          case "scroll":
            m = HD;
            break;
          case "wheel":
            m = u4;
            break;
          case "copy":
          case "cut":
          case "paste":
            m = ZD;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            m = aE;
        }
        var w = (e & 4) !== 0,
          S = !w && n === "scroll",
          v = w ? (p !== null ? p + "Capture" : null) : p;
        w = [];
        for (var M = f, _; M !== null; ) {
          _ = M;
          var T = _.stateNode;
          if (
            (_.tag === 5 &&
              T !== null &&
              ((_ = T),
              v !== null && ((T = df(M, v)), T != null && w.push(_f(M, T, _)))),
            S)
          )
            break;
          M = M.return;
        }
        0 < w.length &&
          ((p = new m(p, y, null, t, h)), d.push({ event: p, listeners: w }));
      }
    }
    if (!(e & 7)) {
      e: {
        if (
          ((p = n === "mouseover" || n === "pointerover"),
          (m = n === "mouseout" || n === "pointerout"),
          p &&
            t !== ux &&
            (y = t.relatedTarget || t.fromElement) &&
            (Ra(y) || y[Vs]))
        )
          break e;
        if (
          (m || p) &&
          ((p =
            h.window === h
              ? h
              : (p = h.ownerDocument)
              ? p.defaultView || p.parentWindow
              : window),
          m
            ? ((y = t.relatedTarget || t.toElement),
              (m = f),
              (y = y ? Ra(y) : null),
              y !== null &&
                ((S = tl(y)), y !== S || (y.tag !== 5 && y.tag !== 6)) &&
                (y = null))
            : ((m = null), (y = f)),
          m !== y)
        ) {
          if (
            ((w = sE),
            (T = "onMouseLeave"),
            (v = "onMouseEnter"),
            (M = "mouse"),
            (n === "pointerout" || n === "pointerover") &&
              ((w = aE),
              (T = "onPointerLeave"),
              (v = "onPointerEnter"),
              (M = "pointer")),
            (S = m == null ? p : nu(m)),
            (_ = y == null ? p : nu(y)),
            (p = new w(T, M + "leave", m, t, h)),
            (p.target = S),
            (p.relatedTarget = _),
            (T = null),
            Ra(h) === f &&
              ((w = new w(v, M + "enter", y, t, h)),
              (w.target = _),
              (w.relatedTarget = S),
              (T = w)),
            (S = T),
            m && y)
          )
            t: {
              for (w = m, v = y, M = 0, _ = w; _; _ = Tl(_)) M++;
              for (_ = 0, T = v; T; T = Tl(T)) _++;
              for (; 0 < M - _; ) (w = Tl(w)), M--;
              for (; 0 < _ - M; ) (v = Tl(v)), _--;
              for (; M--; ) {
                if (w === v || (v !== null && w === v.alternate)) break t;
                (w = Tl(w)), (v = Tl(v));
              }
              w = null;
            }
          else w = null;
          m !== null && yE(d, p, m, w, !1),
            y !== null && S !== null && yE(d, S, y, w, !0);
        }
      }
      e: {
        if (
          ((p = f ? nu(f) : window),
          (m = p.nodeName && p.nodeName.toLowerCase()),
          m === "select" || (m === "input" && p.type === "file"))
        )
          var P = g4;
        else if (cE(p))
          if (dC) P = _4;
          else {
            P = y4;
            var b = v4;
          }
        else
          (m = p.nodeName) &&
            m.toLowerCase() === "input" &&
            (p.type === "checkbox" || p.type === "radio") &&
            (P = x4);
        if (P && (P = P(n, f))) {
          hC(d, P, t, h);
          break e;
        }
        b && b(n, p, f),
          n === "focusout" &&
            (b = p._wrapperState) &&
            b.controlled &&
            p.type === "number" &&
            rx(p, "number", p.value);
      }
      switch (((b = f ? nu(f) : window), n)) {
        case "focusin":
          (cE(b) || b.contentEditable === "true") &&
            ((eu = b), (gx = f), (Zc = null));
          break;
        case "focusout":
          Zc = gx = eu = null;
          break;
        case "mousedown":
          vx = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          (vx = !1), mE(d, t, h);
          break;
        case "selectionchange":
          if (w4) break;
        case "keydown":
        case "keyup":
          mE(d, t, h);
      }
      var L;
      if (d1)
        e: {
          switch (n) {
            case "compositionstart":
              var N = "onCompositionStart";
              break e;
            case "compositionend":
              N = "onCompositionEnd";
              break e;
            case "compositionupdate":
              N = "onCompositionUpdate";
              break e;
          }
          N = void 0;
        }
      else
        Jl
          ? cC(n, t) && (N = "onCompositionEnd")
          : n === "keydown" && t.keyCode === 229 && (N = "onCompositionStart");
      N &&
        (uC &&
          t.locale !== "ko" &&
          (Jl || N !== "onCompositionStart"
            ? N === "onCompositionEnd" && Jl && (L = lC())
            : ((Eo = h),
              (c1 = "value" in Eo ? Eo.value : Eo.textContent),
              (Jl = !0))),
        (b = Mm(f, N)),
        0 < b.length &&
          ((N = new oE(N, n, null, t, h)),
          d.push({ event: N, listeners: b }),
          L ? (N.data = L) : ((L = fC(t)), L !== null && (N.data = L)))),
        (L = f4 ? h4(n, t) : d4(n, t)) &&
          ((f = Mm(f, "onBeforeInput")),
          0 < f.length &&
            ((h = new oE("onBeforeInput", "beforeinput", null, t, h)),
            d.push({ event: h, listeners: f }),
            (h.data = L)));
    }
    wC(d, e);
  });
}
function _f(n, e, t) {
  return { instance: n, listener: e, currentTarget: t };
}
function Mm(n, e) {
  for (var t = e + "Capture", i = []; n !== null; ) {
    var r = n,
      s = r.stateNode;
    r.tag === 5 &&
      s !== null &&
      ((r = s),
      (s = df(n, t)),
      s != null && i.unshift(_f(n, s, r)),
      (s = df(n, e)),
      s != null && i.push(_f(n, s, r))),
      (n = n.return);
  }
  return i;
}
function Tl(n) {
  if (n === null) return null;
  do n = n.return;
  while (n && n.tag !== 5);
  return n || null;
}
function yE(n, e, t, i, r) {
  for (var s = e._reactName, o = []; t !== null && t !== i; ) {
    var a = t,
      u = a.alternate,
      f = a.stateNode;
    if (u !== null && u === i) break;
    a.tag === 5 &&
      f !== null &&
      ((a = f),
      r
        ? ((u = df(t, s)), u != null && o.unshift(_f(t, u, a)))
        : r || ((u = df(t, s)), u != null && o.push(_f(t, u, a)))),
      (t = t.return);
  }
  o.length !== 0 && n.push({ event: e, listeners: o });
}
var b4 = /\r\n?/g,
  C4 = /\u0000|\uFFFD/g;
function xE(n) {
  return (typeof n == "string" ? n : "" + n)
    .replace(
      b4,
      `
`
    )
    .replace(C4, "");
}
function Od(n, e, t) {
  if (((e = xE(e)), xE(n) !== e && t)) throw Error(we(425));
}
function wm() {}
var yx = null,
  xx = null;
function _x(n, e) {
  return (
    n === "textarea" ||
    n === "noscript" ||
    typeof e.children == "string" ||
    typeof e.children == "number" ||
    (typeof e.dangerouslySetInnerHTML == "object" &&
      e.dangerouslySetInnerHTML !== null &&
      e.dangerouslySetInnerHTML.__html != null)
  );
}
var Sx = typeof setTimeout == "function" ? setTimeout : void 0,
  P4 = typeof clearTimeout == "function" ? clearTimeout : void 0,
  _E = typeof Promise == "function" ? Promise : void 0,
  R4 =
    typeof queueMicrotask == "function"
      ? queueMicrotask
      : typeof _E < "u"
      ? function (n) {
          return _E.resolve(null).then(n).catch(L4);
        }
      : Sx;
function L4(n) {
  setTimeout(function () {
    throw n;
  });
}
function I0(n, e) {
  var t = e,
    i = 0;
  do {
    var r = t.nextSibling;
    if ((n.removeChild(t), r && r.nodeType === 8))
      if (((t = r.data), t === "/$")) {
        if (i === 0) {
          n.removeChild(r), gf(e);
          return;
        }
        i--;
      } else (t !== "$" && t !== "$?" && t !== "$!") || i++;
    t = r;
  } while (t);
  gf(e);
}
function Po(n) {
  for (; n != null; n = n.nextSibling) {
    var e = n.nodeType;
    if (e === 1 || e === 3) break;
    if (e === 8) {
      if (((e = n.data), e === "$" || e === "$!" || e === "$?")) break;
      if (e === "/$") return null;
    }
  }
  return n;
}
function SE(n) {
  n = n.previousSibling;
  for (var e = 0; n; ) {
    if (n.nodeType === 8) {
      var t = n.data;
      if (t === "$" || t === "$!" || t === "$?") {
        if (e === 0) return n;
        e--;
      } else t === "/$" && e++;
    }
    n = n.previousSibling;
  }
  return null;
}
var Gu = Math.random().toString(36).slice(2),
  is = "__reactFiber$" + Gu,
  Sf = "__reactProps$" + Gu,
  Vs = "__reactContainer$" + Gu,
  Mx = "__reactEvents$" + Gu,
  I4 = "__reactListeners$" + Gu,
  N4 = "__reactHandles$" + Gu;
function Ra(n) {
  var e = n[is];
  if (e) return e;
  for (var t = n.parentNode; t; ) {
    if ((e = t[Vs] || t[is])) {
      if (
        ((t = e.alternate),
        e.child !== null || (t !== null && t.child !== null))
      )
        for (n = SE(n); n !== null; ) {
          if ((t = n[is])) return t;
          n = SE(n);
        }
      return e;
    }
    (n = t), (t = n.parentNode);
  }
  return null;
}
function nh(n) {
  return (
    (n = n[is] || n[Vs]),
    !n || (n.tag !== 5 && n.tag !== 6 && n.tag !== 13 && n.tag !== 3) ? null : n
  );
}
function nu(n) {
  if (n.tag === 5 || n.tag === 6) return n.stateNode;
  throw Error(we(33));
}
function cg(n) {
  return n[Sf] || null;
}
var wx = [],
  iu = -1;
function Yo(n) {
  return { current: n };
}
function Qt(n) {
  0 > iu || ((n.current = wx[iu]), (wx[iu] = null), iu--);
}
function Xt(n, e) {
  iu++, (wx[iu] = n.current), (n.current = e);
}
var Bo = {},
  pi = Yo(Bo),
  Fi = Yo(!1),
  Xa = Bo;
function bu(n, e) {
  var t = n.type.contextTypes;
  if (!t) return Bo;
  var i = n.stateNode;
  if (i && i.__reactInternalMemoizedUnmaskedChildContext === e)
    return i.__reactInternalMemoizedMaskedChildContext;
  var r = {},
    s;
  for (s in t) r[s] = e[s];
  return (
    i &&
      ((n = n.stateNode),
      (n.__reactInternalMemoizedUnmaskedChildContext = e),
      (n.__reactInternalMemoizedMaskedChildContext = r)),
    r
  );
}
function zi(n) {
  return (n = n.childContextTypes), n != null;
}
function Em() {
  Qt(Fi), Qt(pi);
}
function ME(n, e, t) {
  if (pi.current !== Bo) throw Error(we(168));
  Xt(pi, e), Xt(Fi, t);
}
function TC(n, e, t) {
  var i = n.stateNode;
  if (((e = e.childContextTypes), typeof i.getChildContext != "function"))
    return t;
  i = i.getChildContext();
  for (var r in i) if (!(r in e)) throw Error(we(108, vD(n) || "Unknown", r));
  return hn({}, t, i);
}
function Tm(n) {
  return (
    (n =
      ((n = n.stateNode) && n.__reactInternalMemoizedMergedChildContext) || Bo),
    (Xa = pi.current),
    Xt(pi, n),
    Xt(Fi, Fi.current),
    !0
  );
}
function wE(n, e, t) {
  var i = n.stateNode;
  if (!i) throw Error(we(169));
  t
    ? ((n = TC(n, e, Xa)),
      (i.__reactInternalMemoizedMergedChildContext = n),
      Qt(Fi),
      Qt(pi),
      Xt(pi, n))
    : Qt(Fi),
    Xt(Fi, t);
}
var Cs = null,
  fg = !1,
  N0 = !1;
function AC(n) {
  Cs === null ? (Cs = [n]) : Cs.push(n);
}
function D4(n) {
  (fg = !0), AC(n);
}
function qo() {
  if (!N0 && Cs !== null) {
    N0 = !0;
    var n = 0,
      e = Vt;
    try {
      var t = Cs;
      for (Vt = 1; n < t.length; n++) {
        var i = t[n];
        do i = i(!0);
        while (i !== null);
      }
      (Cs = null), (fg = !1);
    } catch (r) {
      throw (Cs !== null && (Cs = Cs.slice(n + 1)), Qb(o1, qo), r);
    } finally {
      (Vt = e), (N0 = !1);
    }
  }
  return null;
}
var ru = [],
  su = 0,
  Am = null,
  bm = 0,
  xr = [],
  _r = 0,
  Ya = null,
  Ls = 1,
  Is = "";
function Sa(n, e) {
  (ru[su++] = bm), (ru[su++] = Am), (Am = n), (bm = e);
}
function bC(n, e, t) {
  (xr[_r++] = Ls), (xr[_r++] = Is), (xr[_r++] = Ya), (Ya = n);
  var i = Ls;
  n = Is;
  var r = 32 - Fr(i) - 1;
  (i &= ~(1 << r)), (t += 1);
  var s = 32 - Fr(e) + r;
  if (30 < s) {
    var o = r - (r % 5);
    (s = (i & ((1 << o) - 1)).toString(32)),
      (i >>= o),
      (r -= o),
      (Ls = (1 << (32 - Fr(e) + r)) | (t << r) | i),
      (Is = s + n);
  } else (Ls = (1 << s) | (t << r) | i), (Is = n);
}
function m1(n) {
  n.return !== null && (Sa(n, 1), bC(n, 1, 0));
}
function g1(n) {
  for (; n === Am; )
    (Am = ru[--su]), (ru[su] = null), (bm = ru[--su]), (ru[su] = null);
  for (; n === Ya; )
    (Ya = xr[--_r]),
      (xr[_r] = null),
      (Is = xr[--_r]),
      (xr[_r] = null),
      (Ls = xr[--_r]),
      (xr[_r] = null);
}
var Ji = null,
  $i = null,
  nn = !1,
  Dr = null;
function CC(n, e) {
  var t = Sr(5, null, null, 0);
  (t.elementType = "DELETED"),
    (t.stateNode = e),
    (t.return = n),
    (e = n.deletions),
    e === null ? ((n.deletions = [t]), (n.flags |= 16)) : e.push(t);
}
function EE(n, e) {
  switch (n.tag) {
    case 5:
      var t = n.type;
      return (
        (e =
          e.nodeType !== 1 || t.toLowerCase() !== e.nodeName.toLowerCase()
            ? null
            : e),
        e !== null
          ? ((n.stateNode = e), (Ji = n), ($i = Po(e.firstChild)), !0)
          : !1
      );
    case 6:
      return (
        (e = n.pendingProps === "" || e.nodeType !== 3 ? null : e),
        e !== null ? ((n.stateNode = e), (Ji = n), ($i = null), !0) : !1
      );
    case 13:
      return (
        (e = e.nodeType !== 8 ? null : e),
        e !== null
          ? ((t = Ya !== null ? { id: Ls, overflow: Is } : null),
            (n.memoizedState = {
              dehydrated: e,
              treeContext: t,
              retryLane: 1073741824,
            }),
            (t = Sr(18, null, null, 0)),
            (t.stateNode = e),
            (t.return = n),
            (n.child = t),
            (Ji = n),
            ($i = null),
            !0)
          : !1
      );
    default:
      return !1;
  }
}
function Ex(n) {
  return (n.mode & 1) !== 0 && (n.flags & 128) === 0;
}
function Tx(n) {
  if (nn) {
    var e = $i;
    if (e) {
      var t = e;
      if (!EE(n, e)) {
        if (Ex(n)) throw Error(we(418));
        e = Po(t.nextSibling);
        var i = Ji;
        e && EE(n, e)
          ? CC(i, t)
          : ((n.flags = (n.flags & -4097) | 2), (nn = !1), (Ji = n));
      }
    } else {
      if (Ex(n)) throw Error(we(418));
      (n.flags = (n.flags & -4097) | 2), (nn = !1), (Ji = n);
    }
  }
}
function TE(n) {
  for (n = n.return; n !== null && n.tag !== 5 && n.tag !== 3 && n.tag !== 13; )
    n = n.return;
  Ji = n;
}
function Ud(n) {
  if (n !== Ji) return !1;
  if (!nn) return TE(n), (nn = !0), !1;
  var e;
  if (
    ((e = n.tag !== 3) &&
      !(e = n.tag !== 5) &&
      ((e = n.type),
      (e = e !== "head" && e !== "body" && !_x(n.type, n.memoizedProps))),
    e && (e = $i))
  ) {
    if (Ex(n)) throw (PC(), Error(we(418)));
    for (; e; ) CC(n, e), (e = Po(e.nextSibling));
  }
  if ((TE(n), n.tag === 13)) {
    if (((n = n.memoizedState), (n = n !== null ? n.dehydrated : null), !n))
      throw Error(we(317));
    e: {
      for (n = n.nextSibling, e = 0; n; ) {
        if (n.nodeType === 8) {
          var t = n.data;
          if (t === "/$") {
            if (e === 0) {
              $i = Po(n.nextSibling);
              break e;
            }
            e--;
          } else (t !== "$" && t !== "$!" && t !== "$?") || e++;
        }
        n = n.nextSibling;
      }
      $i = null;
    }
  } else $i = Ji ? Po(n.stateNode.nextSibling) : null;
  return !0;
}
function PC() {
  for (var n = $i; n; ) n = Po(n.nextSibling);
}
function Cu() {
  ($i = Ji = null), (nn = !1);
}
function v1(n) {
  Dr === null ? (Dr = [n]) : Dr.push(n);
}
var O4 = qs.ReactCurrentBatchConfig;
function Sc(n, e, t) {
  if (
    ((n = t.ref), n !== null && typeof n != "function" && typeof n != "object")
  ) {
    if (t._owner) {
      if (((t = t._owner), t)) {
        if (t.tag !== 1) throw Error(we(309));
        var i = t.stateNode;
      }
      if (!i) throw Error(we(147, n));
      var r = i,
        s = "" + n;
      return e !== null &&
        e.ref !== null &&
        typeof e.ref == "function" &&
        e.ref._stringRef === s
        ? e.ref
        : ((e = function (o) {
            var a = r.refs;
            o === null ? delete a[s] : (a[s] = o);
          }),
          (e._stringRef = s),
          e);
    }
    if (typeof n != "string") throw Error(we(284));
    if (!t._owner) throw Error(we(290, n));
  }
  return n;
}
function kd(n, e) {
  throw (
    ((n = Object.prototype.toString.call(e)),
    Error(
      we(
        31,
        n === "[object Object]"
          ? "object with keys {" + Object.keys(e).join(", ") + "}"
          : n
      )
    ))
  );
}
function AE(n) {
  var e = n._init;
  return e(n._payload);
}
function RC(n) {
  function e(v, M) {
    if (n) {
      var _ = v.deletions;
      _ === null ? ((v.deletions = [M]), (v.flags |= 16)) : _.push(M);
    }
  }
  function t(v, M) {
    if (!n) return null;
    for (; M !== null; ) e(v, M), (M = M.sibling);
    return null;
  }
  function i(v, M) {
    for (v = new Map(); M !== null; )
      M.key !== null ? v.set(M.key, M) : v.set(M.index, M), (M = M.sibling);
    return v;
  }
  function r(v, M) {
    return (v = No(v, M)), (v.index = 0), (v.sibling = null), v;
  }
  function s(v, M, _) {
    return (
      (v.index = _),
      n
        ? ((_ = v.alternate),
          _ !== null
            ? ((_ = _.index), _ < M ? ((v.flags |= 2), M) : _)
            : ((v.flags |= 2), M))
        : ((v.flags |= 1048576), M)
    );
  }
  function o(v) {
    return n && v.alternate === null && (v.flags |= 2), v;
  }
  function a(v, M, _, T) {
    return M === null || M.tag !== 6
      ? ((M = B0(_, v.mode, T)), (M.return = v), M)
      : ((M = r(M, _)), (M.return = v), M);
  }
  function u(v, M, _, T) {
    var P = _.type;
    return P === $l
      ? h(v, M, _.props.children, T, _.key)
      : M !== null &&
        (M.elementType === P ||
          (typeof P == "object" &&
            P !== null &&
            P.$$typeof === yo &&
            AE(P) === M.type))
      ? ((T = r(M, _.props)), (T.ref = Sc(v, M, _)), (T.return = v), T)
      : ((T = im(_.type, _.key, _.props, null, v.mode, T)),
        (T.ref = Sc(v, M, _)),
        (T.return = v),
        T);
  }
  function f(v, M, _, T) {
    return M === null ||
      M.tag !== 4 ||
      M.stateNode.containerInfo !== _.containerInfo ||
      M.stateNode.implementation !== _.implementation
      ? ((M = V0(_, v.mode, T)), (M.return = v), M)
      : ((M = r(M, _.children || [])), (M.return = v), M);
  }
  function h(v, M, _, T, P) {
    return M === null || M.tag !== 7
      ? ((M = za(_, v.mode, T, P)), (M.return = v), M)
      : ((M = r(M, _)), (M.return = v), M);
  }
  function d(v, M, _) {
    if ((typeof M == "string" && M !== "") || typeof M == "number")
      return (M = B0("" + M, v.mode, _)), (M.return = v), M;
    if (typeof M == "object" && M !== null) {
      switch (M.$$typeof) {
        case Ad:
          return (
            (_ = im(M.type, M.key, M.props, null, v.mode, _)),
            (_.ref = Sc(v, null, M)),
            (_.return = v),
            _
          );
        case Ql:
          return (M = V0(M, v.mode, _)), (M.return = v), M;
        case yo:
          var T = M._init;
          return d(v, T(M._payload), _);
      }
      if (Bc(M) || gc(M))
        return (M = za(M, v.mode, _, null)), (M.return = v), M;
      kd(v, M);
    }
    return null;
  }
  function p(v, M, _, T) {
    var P = M !== null ? M.key : null;
    if ((typeof _ == "string" && _ !== "") || typeof _ == "number")
      return P !== null ? null : a(v, M, "" + _, T);
    if (typeof _ == "object" && _ !== null) {
      switch (_.$$typeof) {
        case Ad:
          return _.key === P ? u(v, M, _, T) : null;
        case Ql:
          return _.key === P ? f(v, M, _, T) : null;
        case yo:
          return (P = _._init), p(v, M, P(_._payload), T);
      }
      if (Bc(_) || gc(_)) return P !== null ? null : h(v, M, _, T, null);
      kd(v, _);
    }
    return null;
  }
  function m(v, M, _, T, P) {
    if ((typeof T == "string" && T !== "") || typeof T == "number")
      return (v = v.get(_) || null), a(M, v, "" + T, P);
    if (typeof T == "object" && T !== null) {
      switch (T.$$typeof) {
        case Ad:
          return (v = v.get(T.key === null ? _ : T.key) || null), u(M, v, T, P);
        case Ql:
          return (v = v.get(T.key === null ? _ : T.key) || null), f(M, v, T, P);
        case yo:
          var b = T._init;
          return m(v, M, _, b(T._payload), P);
      }
      if (Bc(T) || gc(T)) return (v = v.get(_) || null), h(M, v, T, P, null);
      kd(M, T);
    }
    return null;
  }
  function y(v, M, _, T) {
    for (
      var P = null, b = null, L = M, N = (M = 0), C = null;
      L !== null && N < _.length;
      N++
    ) {
      L.index > N ? ((C = L), (L = null)) : (C = L.sibling);
      var R = p(v, L, _[N], T);
      if (R === null) {
        L === null && (L = C);
        break;
      }
      n && L && R.alternate === null && e(v, L),
        (M = s(R, M, N)),
        b === null ? (P = R) : (b.sibling = R),
        (b = R),
        (L = C);
    }
    if (N === _.length) return t(v, L), nn && Sa(v, N), P;
    if (L === null) {
      for (; N < _.length; N++)
        (L = d(v, _[N], T)),
          L !== null &&
            ((M = s(L, M, N)), b === null ? (P = L) : (b.sibling = L), (b = L));
      return nn && Sa(v, N), P;
    }
    for (L = i(v, L); N < _.length; N++)
      (C = m(L, v, N, _[N], T)),
        C !== null &&
          (n && C.alternate !== null && L.delete(C.key === null ? N : C.key),
          (M = s(C, M, N)),
          b === null ? (P = C) : (b.sibling = C),
          (b = C));
    return (
      n &&
        L.forEach(function (B) {
          return e(v, B);
        }),
      nn && Sa(v, N),
      P
    );
  }
  function w(v, M, _, T) {
    var P = gc(_);
    if (typeof P != "function") throw Error(we(150));
    if (((_ = P.call(_)), _ == null)) throw Error(we(151));
    for (
      var b = (P = null), L = M, N = (M = 0), C = null, R = _.next();
      L !== null && !R.done;
      N++, R = _.next()
    ) {
      L.index > N ? ((C = L), (L = null)) : (C = L.sibling);
      var B = p(v, L, R.value, T);
      if (B === null) {
        L === null && (L = C);
        break;
      }
      n && L && B.alternate === null && e(v, L),
        (M = s(B, M, N)),
        b === null ? (P = B) : (b.sibling = B),
        (b = B),
        (L = C);
    }
    if (R.done) return t(v, L), nn && Sa(v, N), P;
    if (L === null) {
      for (; !R.done; N++, R = _.next())
        (R = d(v, R.value, T)),
          R !== null &&
            ((M = s(R, M, N)), b === null ? (P = R) : (b.sibling = R), (b = R));
      return nn && Sa(v, N), P;
    }
    for (L = i(v, L); !R.done; N++, R = _.next())
      (R = m(L, v, N, R.value, T)),
        R !== null &&
          (n && R.alternate !== null && L.delete(R.key === null ? N : R.key),
          (M = s(R, M, N)),
          b === null ? (P = R) : (b.sibling = R),
          (b = R));
    return (
      n &&
        L.forEach(function (Z) {
          return e(v, Z);
        }),
      nn && Sa(v, N),
      P
    );
  }
  function S(v, M, _, T) {
    if (
      (typeof _ == "object" &&
        _ !== null &&
        _.type === $l &&
        _.key === null &&
        (_ = _.props.children),
      typeof _ == "object" && _ !== null)
    ) {
      switch (_.$$typeof) {
        case Ad:
          e: {
            for (var P = _.key, b = M; b !== null; ) {
              if (b.key === P) {
                if (((P = _.type), P === $l)) {
                  if (b.tag === 7) {
                    t(v, b.sibling),
                      (M = r(b, _.props.children)),
                      (M.return = v),
                      (v = M);
                    break e;
                  }
                } else if (
                  b.elementType === P ||
                  (typeof P == "object" &&
                    P !== null &&
                    P.$$typeof === yo &&
                    AE(P) === b.type)
                ) {
                  t(v, b.sibling),
                    (M = r(b, _.props)),
                    (M.ref = Sc(v, b, _)),
                    (M.return = v),
                    (v = M);
                  break e;
                }
                t(v, b);
                break;
              } else e(v, b);
              b = b.sibling;
            }
            _.type === $l
              ? ((M = za(_.props.children, v.mode, T, _.key)),
                (M.return = v),
                (v = M))
              : ((T = im(_.type, _.key, _.props, null, v.mode, T)),
                (T.ref = Sc(v, M, _)),
                (T.return = v),
                (v = T));
          }
          return o(v);
        case Ql:
          e: {
            for (b = _.key; M !== null; ) {
              if (M.key === b)
                if (
                  M.tag === 4 &&
                  M.stateNode.containerInfo === _.containerInfo &&
                  M.stateNode.implementation === _.implementation
                ) {
                  t(v, M.sibling),
                    (M = r(M, _.children || [])),
                    (M.return = v),
                    (v = M);
                  break e;
                } else {
                  t(v, M);
                  break;
                }
              else e(v, M);
              M = M.sibling;
            }
            (M = V0(_, v.mode, T)), (M.return = v), (v = M);
          }
          return o(v);
        case yo:
          return (b = _._init), S(v, M, b(_._payload), T);
      }
      if (Bc(_)) return y(v, M, _, T);
      if (gc(_)) return w(v, M, _, T);
      kd(v, _);
    }
    return (typeof _ == "string" && _ !== "") || typeof _ == "number"
      ? ((_ = "" + _),
        M !== null && M.tag === 6
          ? (t(v, M.sibling), (M = r(M, _)), (M.return = v), (v = M))
          : (t(v, M), (M = B0(_, v.mode, T)), (M.return = v), (v = M)),
        o(v))
      : t(v, M);
  }
  return S;
}
var Pu = RC(!0),
  LC = RC(!1),
  Cm = Yo(null),
  Pm = null,
  ou = null,
  y1 = null;
function x1() {
  y1 = ou = Pm = null;
}
function _1(n) {
  var e = Cm.current;
  Qt(Cm), (n._currentValue = e);
}
function Ax(n, e, t) {
  for (; n !== null; ) {
    var i = n.alternate;
    if (
      ((n.childLanes & e) !== e
        ? ((n.childLanes |= e), i !== null && (i.childLanes |= e))
        : i !== null && (i.childLanes & e) !== e && (i.childLanes |= e),
      n === t)
    )
      break;
    n = n.return;
  }
}
function wu(n, e) {
  (Pm = n),
    (y1 = ou = null),
    (n = n.dependencies),
    n !== null &&
      n.firstContext !== null &&
      (n.lanes & e && (ki = !0), (n.firstContext = null));
}
function wr(n) {
  var e = n._currentValue;
  if (y1 !== n)
    if (((n = { context: n, memoizedValue: e, next: null }), ou === null)) {
      if (Pm === null) throw Error(we(308));
      (ou = n), (Pm.dependencies = { lanes: 0, firstContext: n });
    } else ou = ou.next = n;
  return e;
}
var La = null;
function S1(n) {
  La === null ? (La = [n]) : La.push(n);
}
function IC(n, e, t, i) {
  var r = e.interleaved;
  return (
    r === null ? ((t.next = t), S1(e)) : ((t.next = r.next), (r.next = t)),
    (e.interleaved = t),
    Hs(n, i)
  );
}
function Hs(n, e) {
  n.lanes |= e;
  var t = n.alternate;
  for (t !== null && (t.lanes |= e), t = n, n = n.return; n !== null; )
    (n.childLanes |= e),
      (t = n.alternate),
      t !== null && (t.childLanes |= e),
      (t = n),
      (n = n.return);
  return t.tag === 3 ? t.stateNode : null;
}
var xo = !1;
function M1(n) {
  n.updateQueue = {
    baseState: n.memoizedState,
    firstBaseUpdate: null,
    lastBaseUpdate: null,
    shared: { pending: null, interleaved: null, lanes: 0 },
    effects: null,
  };
}
function NC(n, e) {
  (n = n.updateQueue),
    e.updateQueue === n &&
      (e.updateQueue = {
        baseState: n.baseState,
        firstBaseUpdate: n.firstBaseUpdate,
        lastBaseUpdate: n.lastBaseUpdate,
        shared: n.shared,
        effects: n.effects,
      });
}
function Us(n, e) {
  return {
    eventTime: n,
    lane: e,
    tag: 0,
    payload: null,
    callback: null,
    next: null,
  };
}
function Ro(n, e, t) {
  var i = n.updateQueue;
  if (i === null) return null;
  if (((i = i.shared), Dt & 2)) {
    var r = i.pending;
    return (
      r === null ? (e.next = e) : ((e.next = r.next), (r.next = e)),
      (i.pending = e),
      Hs(n, t)
    );
  }
  return (
    (r = i.interleaved),
    r === null ? ((e.next = e), S1(i)) : ((e.next = r.next), (r.next = e)),
    (i.interleaved = e),
    Hs(n, t)
  );
}
function Qp(n, e, t) {
  if (
    ((e = e.updateQueue), e !== null && ((e = e.shared), (t & 4194240) !== 0))
  ) {
    var i = e.lanes;
    (i &= n.pendingLanes), (t |= i), (e.lanes = t), a1(n, t);
  }
}
function bE(n, e) {
  var t = n.updateQueue,
    i = n.alternate;
  if (i !== null && ((i = i.updateQueue), t === i)) {
    var r = null,
      s = null;
    if (((t = t.firstBaseUpdate), t !== null)) {
      do {
        var o = {
          eventTime: t.eventTime,
          lane: t.lane,
          tag: t.tag,
          payload: t.payload,
          callback: t.callback,
          next: null,
        };
        s === null ? (r = s = o) : (s = s.next = o), (t = t.next);
      } while (t !== null);
      s === null ? (r = s = e) : (s = s.next = e);
    } else r = s = e;
    (t = {
      baseState: i.baseState,
      firstBaseUpdate: r,
      lastBaseUpdate: s,
      shared: i.shared,
      effects: i.effects,
    }),
      (n.updateQueue = t);
    return;
  }
  (n = t.lastBaseUpdate),
    n === null ? (t.firstBaseUpdate = e) : (n.next = e),
    (t.lastBaseUpdate = e);
}
function Rm(n, e, t, i) {
  var r = n.updateQueue;
  xo = !1;
  var s = r.firstBaseUpdate,
    o = r.lastBaseUpdate,
    a = r.shared.pending;
  if (a !== null) {
    r.shared.pending = null;
    var u = a,
      f = u.next;
    (u.next = null), o === null ? (s = f) : (o.next = f), (o = u);
    var h = n.alternate;
    h !== null &&
      ((h = h.updateQueue),
      (a = h.lastBaseUpdate),
      a !== o &&
        (a === null ? (h.firstBaseUpdate = f) : (a.next = f),
        (h.lastBaseUpdate = u)));
  }
  if (s !== null) {
    var d = r.baseState;
    (o = 0), (h = f = u = null), (a = s);
    do {
      var p = a.lane,
        m = a.eventTime;
      if ((i & p) === p) {
        h !== null &&
          (h = h.next =
            {
              eventTime: m,
              lane: 0,
              tag: a.tag,
              payload: a.payload,
              callback: a.callback,
              next: null,
            });
        e: {
          var y = n,
            w = a;
          switch (((p = e), (m = t), w.tag)) {
            case 1:
              if (((y = w.payload), typeof y == "function")) {
                d = y.call(m, d, p);
                break e;
              }
              d = y;
              break e;
            case 3:
              y.flags = (y.flags & -65537) | 128;
            case 0:
              if (
                ((y = w.payload),
                (p = typeof y == "function" ? y.call(m, d, p) : y),
                p == null)
              )
                break e;
              d = hn({}, d, p);
              break e;
            case 2:
              xo = !0;
          }
        }
        a.callback !== null &&
          a.lane !== 0 &&
          ((n.flags |= 64),
          (p = r.effects),
          p === null ? (r.effects = [a]) : p.push(a));
      } else
        (m = {
          eventTime: m,
          lane: p,
          tag: a.tag,
          payload: a.payload,
          callback: a.callback,
          next: null,
        }),
          h === null ? ((f = h = m), (u = d)) : (h = h.next = m),
          (o |= p);
      if (((a = a.next), a === null)) {
        if (((a = r.shared.pending), a === null)) break;
        (p = a),
          (a = p.next),
          (p.next = null),
          (r.lastBaseUpdate = p),
          (r.shared.pending = null);
      }
    } while (!0);
    if (
      (h === null && (u = d),
      (r.baseState = u),
      (r.firstBaseUpdate = f),
      (r.lastBaseUpdate = h),
      (e = r.shared.interleaved),
      e !== null)
    ) {
      r = e;
      do (o |= r.lane), (r = r.next);
      while (r !== e);
    } else s === null && (r.shared.lanes = 0);
    (Za |= o), (n.lanes = o), (n.memoizedState = d);
  }
}
function CE(n, e, t) {
  if (((n = e.effects), (e.effects = null), n !== null))
    for (e = 0; e < n.length; e++) {
      var i = n[e],
        r = i.callback;
      if (r !== null) {
        if (((i.callback = null), (i = t), typeof r != "function"))
          throw Error(we(191, r));
        r.call(i);
      }
    }
}
var ih = {},
  as = Yo(ih),
  Mf = Yo(ih),
  wf = Yo(ih);
function Ia(n) {
  if (n === ih) throw Error(we(174));
  return n;
}
function w1(n, e) {
  switch ((Xt(wf, e), Xt(Mf, n), Xt(as, ih), (n = e.nodeType), n)) {
    case 9:
    case 11:
      e = (e = e.documentElement) ? e.namespaceURI : ox(null, "");
      break;
    default:
      (n = n === 8 ? e.parentNode : e),
        (e = n.namespaceURI || null),
        (n = n.tagName),
        (e = ox(e, n));
  }
  Qt(as), Xt(as, e);
}
function Ru() {
  Qt(as), Qt(Mf), Qt(wf);
}
function DC(n) {
  Ia(wf.current);
  var e = Ia(as.current),
    t = ox(e, n.type);
  e !== t && (Xt(Mf, n), Xt(as, t));
}
function E1(n) {
  Mf.current === n && (Qt(as), Qt(Mf));
}
var ln = Yo(0);
function Lm(n) {
  for (var e = n; e !== null; ) {
    if (e.tag === 13) {
      var t = e.memoizedState;
      if (
        t !== null &&
        ((t = t.dehydrated), t === null || t.data === "$?" || t.data === "$!")
      )
        return e;
    } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) {
      if (e.flags & 128) return e;
    } else if (e.child !== null) {
      (e.child.return = e), (e = e.child);
      continue;
    }
    if (e === n) break;
    for (; e.sibling === null; ) {
      if (e.return === null || e.return === n) return null;
      e = e.return;
    }
    (e.sibling.return = e.return), (e = e.sibling);
  }
  return null;
}
var D0 = [];
function T1() {
  for (var n = 0; n < D0.length; n++)
    D0[n]._workInProgressVersionPrimary = null;
  D0.length = 0;
}
var $p = qs.ReactCurrentDispatcher,
  O0 = qs.ReactCurrentBatchConfig,
  qa = 0,
  fn = null,
  Nn = null,
  jn = null,
  Im = !1,
  Kc = !1,
  Ef = 0,
  U4 = 0;
function ri() {
  throw Error(we(321));
}
function A1(n, e) {
  if (e === null) return !1;
  for (var t = 0; t < e.length && t < n.length; t++)
    if (!Br(n[t], e[t])) return !1;
  return !0;
}
function b1(n, e, t, i, r, s) {
  if (
    ((qa = s),
    (fn = e),
    (e.memoizedState = null),
    (e.updateQueue = null),
    (e.lanes = 0),
    ($p.current = n === null || n.memoizedState === null ? B4 : V4),
    (n = t(i, r)),
    Kc)
  ) {
    s = 0;
    do {
      if (((Kc = !1), (Ef = 0), 25 <= s)) throw Error(we(301));
      (s += 1),
        (jn = Nn = null),
        (e.updateQueue = null),
        ($p.current = H4),
        (n = t(i, r));
    } while (Kc);
  }
  if (
    (($p.current = Nm),
    (e = Nn !== null && Nn.next !== null),
    (qa = 0),
    (jn = Nn = fn = null),
    (Im = !1),
    e)
  )
    throw Error(we(300));
  return n;
}
function C1() {
  var n = Ef !== 0;
  return (Ef = 0), n;
}
function ts() {
  var n = {
    memoizedState: null,
    baseState: null,
    baseQueue: null,
    queue: null,
    next: null,
  };
  return jn === null ? (fn.memoizedState = jn = n) : (jn = jn.next = n), jn;
}
function Er() {
  if (Nn === null) {
    var n = fn.alternate;
    n = n !== null ? n.memoizedState : null;
  } else n = Nn.next;
  var e = jn === null ? fn.memoizedState : jn.next;
  if (e !== null) (jn = e), (Nn = n);
  else {
    if (n === null) throw Error(we(310));
    (Nn = n),
      (n = {
        memoizedState: Nn.memoizedState,
        baseState: Nn.baseState,
        baseQueue: Nn.baseQueue,
        queue: Nn.queue,
        next: null,
      }),
      jn === null ? (fn.memoizedState = jn = n) : (jn = jn.next = n);
  }
  return jn;
}
function Tf(n, e) {
  return typeof e == "function" ? e(n) : e;
}
function U0(n) {
  var e = Er(),
    t = e.queue;
  if (t === null) throw Error(we(311));
  t.lastRenderedReducer = n;
  var i = Nn,
    r = i.baseQueue,
    s = t.pending;
  if (s !== null) {
    if (r !== null) {
      var o = r.next;
      (r.next = s.next), (s.next = o);
    }
    (i.baseQueue = r = s), (t.pending = null);
  }
  if (r !== null) {
    (s = r.next), (i = i.baseState);
    var a = (o = null),
      u = null,
      f = s;
    do {
      var h = f.lane;
      if ((qa & h) === h)
        u !== null &&
          (u = u.next =
            {
              lane: 0,
              action: f.action,
              hasEagerState: f.hasEagerState,
              eagerState: f.eagerState,
              next: null,
            }),
          (i = f.hasEagerState ? f.eagerState : n(i, f.action));
      else {
        var d = {
          lane: h,
          action: f.action,
          hasEagerState: f.hasEagerState,
          eagerState: f.eagerState,
          next: null,
        };
        u === null ? ((a = u = d), (o = i)) : (u = u.next = d),
          (fn.lanes |= h),
          (Za |= h);
      }
      f = f.next;
    } while (f !== null && f !== s);
    u === null ? (o = i) : (u.next = a),
      Br(i, e.memoizedState) || (ki = !0),
      (e.memoizedState = i),
      (e.baseState = o),
      (e.baseQueue = u),
      (t.lastRenderedState = i);
  }
  if (((n = t.interleaved), n !== null)) {
    r = n;
    do (s = r.lane), (fn.lanes |= s), (Za |= s), (r = r.next);
    while (r !== n);
  } else r === null && (t.lanes = 0);
  return [e.memoizedState, t.dispatch];
}
function k0(n) {
  var e = Er(),
    t = e.queue;
  if (t === null) throw Error(we(311));
  t.lastRenderedReducer = n;
  var i = t.dispatch,
    r = t.pending,
    s = e.memoizedState;
  if (r !== null) {
    t.pending = null;
    var o = (r = r.next);
    do (s = n(s, o.action)), (o = o.next);
    while (o !== r);
    Br(s, e.memoizedState) || (ki = !0),
      (e.memoizedState = s),
      e.baseQueue === null && (e.baseState = s),
      (t.lastRenderedState = s);
  }
  return [s, i];
}
function OC() {}
function UC(n, e) {
  var t = fn,
    i = Er(),
    r = e(),
    s = !Br(i.memoizedState, r);
  if (
    (s && ((i.memoizedState = r), (ki = !0)),
    (i = i.queue),
    P1(zC.bind(null, t, i, n), [n]),
    i.getSnapshot !== e || s || (jn !== null && jn.memoizedState.tag & 1))
  ) {
    if (
      ((t.flags |= 2048),
      Af(9, FC.bind(null, t, i, r, e), void 0, null),
      Xn === null)
    )
      throw Error(we(349));
    qa & 30 || kC(t, e, r);
  }
  return r;
}
function kC(n, e, t) {
  (n.flags |= 16384),
    (n = { getSnapshot: e, value: t }),
    (e = fn.updateQueue),
    e === null
      ? ((e = { lastEffect: null, stores: null }),
        (fn.updateQueue = e),
        (e.stores = [n]))
      : ((t = e.stores), t === null ? (e.stores = [n]) : t.push(n));
}
function FC(n, e, t, i) {
  (e.value = t), (e.getSnapshot = i), BC(e) && VC(n);
}
function zC(n, e, t) {
  return t(function () {
    BC(e) && VC(n);
  });
}
function BC(n) {
  var e = n.getSnapshot;
  n = n.value;
  try {
    var t = e();
    return !Br(n, t);
  } catch {
    return !0;
  }
}
function VC(n) {
  var e = Hs(n, 1);
  e !== null && zr(e, n, 1, -1);
}
function PE(n) {
  var e = ts();
  return (
    typeof n == "function" && (n = n()),
    (e.memoizedState = e.baseState = n),
    (n = {
      pending: null,
      interleaved: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: Tf,
      lastRenderedState: n,
    }),
    (e.queue = n),
    (n = n.dispatch = z4.bind(null, fn, n)),
    [e.memoizedState, n]
  );
}
function Af(n, e, t, i) {
  return (
    (n = { tag: n, create: e, destroy: t, deps: i, next: null }),
    (e = fn.updateQueue),
    e === null
      ? ((e = { lastEffect: null, stores: null }),
        (fn.updateQueue = e),
        (e.lastEffect = n.next = n))
      : ((t = e.lastEffect),
        t === null
          ? (e.lastEffect = n.next = n)
          : ((i = t.next), (t.next = n), (n.next = i), (e.lastEffect = n))),
    n
  );
}
function HC() {
  return Er().memoizedState;
}
function Jp(n, e, t, i) {
  var r = ts();
  (fn.flags |= n),
    (r.memoizedState = Af(1 | e, t, void 0, i === void 0 ? null : i));
}
function hg(n, e, t, i) {
  var r = Er();
  i = i === void 0 ? null : i;
  var s = void 0;
  if (Nn !== null) {
    var o = Nn.memoizedState;
    if (((s = o.destroy), i !== null && A1(i, o.deps))) {
      r.memoizedState = Af(e, t, s, i);
      return;
    }
  }
  (fn.flags |= n), (r.memoizedState = Af(1 | e, t, s, i));
}
function RE(n, e) {
  return Jp(8390656, 8, n, e);
}
function P1(n, e) {
  return hg(2048, 8, n, e);
}
function GC(n, e) {
  return hg(4, 2, n, e);
}
function WC(n, e) {
  return hg(4, 4, n, e);
}
function jC(n, e) {
  if (typeof e == "function")
    return (
      (n = n()),
      e(n),
      function () {
        e(null);
      }
    );
  if (e != null)
    return (
      (n = n()),
      (e.current = n),
      function () {
        e.current = null;
      }
    );
}
function XC(n, e, t) {
  return (
    (t = t != null ? t.concat([n]) : null), hg(4, 4, jC.bind(null, e, n), t)
  );
}
function R1() {}
function YC(n, e) {
  var t = Er();
  e = e === void 0 ? null : e;
  var i = t.memoizedState;
  return i !== null && e !== null && A1(e, i[1])
    ? i[0]
    : ((t.memoizedState = [n, e]), n);
}
function qC(n, e) {
  var t = Er();
  e = e === void 0 ? null : e;
  var i = t.memoizedState;
  return i !== null && e !== null && A1(e, i[1])
    ? i[0]
    : ((n = n()), (t.memoizedState = [n, e]), n);
}
function ZC(n, e, t) {
  return qa & 21
    ? (Br(t, e) || ((t = eC()), (fn.lanes |= t), (Za |= t), (n.baseState = !0)),
      e)
    : (n.baseState && ((n.baseState = !1), (ki = !0)), (n.memoizedState = t));
}
function k4(n, e) {
  var t = Vt;
  (Vt = t !== 0 && 4 > t ? t : 4), n(!0);
  var i = O0.transition;
  O0.transition = {};
  try {
    n(!1), e();
  } finally {
    (Vt = t), (O0.transition = i);
  }
}
function KC() {
  return Er().memoizedState;
}
function F4(n, e, t) {
  var i = Io(n);
  if (
    ((t = {
      lane: i,
      action: t,
      hasEagerState: !1,
      eagerState: null,
      next: null,
    }),
    QC(n))
  )
    $C(e, t);
  else if (((t = IC(n, e, t, i)), t !== null)) {
    var r = Ei();
    zr(t, n, i, r), JC(t, e, i);
  }
}
function z4(n, e, t) {
  var i = Io(n),
    r = { lane: i, action: t, hasEagerState: !1, eagerState: null, next: null };
  if (QC(n)) $C(e, r);
  else {
    var s = n.alternate;
    if (
      n.lanes === 0 &&
      (s === null || s.lanes === 0) &&
      ((s = e.lastRenderedReducer), s !== null)
    )
      try {
        var o = e.lastRenderedState,
          a = s(o, t);
        if (((r.hasEagerState = !0), (r.eagerState = a), Br(a, o))) {
          var u = e.interleaved;
          u === null
            ? ((r.next = r), S1(e))
            : ((r.next = u.next), (u.next = r)),
            (e.interleaved = r);
          return;
        }
      } catch {
      } finally {
      }
    (t = IC(n, e, r, i)),
      t !== null && ((r = Ei()), zr(t, n, i, r), JC(t, e, i));
  }
}
function QC(n) {
  var e = n.alternate;
  return n === fn || (e !== null && e === fn);
}
function $C(n, e) {
  Kc = Im = !0;
  var t = n.pending;
  t === null ? (e.next = e) : ((e.next = t.next), (t.next = e)),
    (n.pending = e);
}
function JC(n, e, t) {
  if (t & 4194240) {
    var i = e.lanes;
    (i &= n.pendingLanes), (t |= i), (e.lanes = t), a1(n, t);
  }
}
var Nm = {
    readContext: wr,
    useCallback: ri,
    useContext: ri,
    useEffect: ri,
    useImperativeHandle: ri,
    useInsertionEffect: ri,
    useLayoutEffect: ri,
    useMemo: ri,
    useReducer: ri,
    useRef: ri,
    useState: ri,
    useDebugValue: ri,
    useDeferredValue: ri,
    useTransition: ri,
    useMutableSource: ri,
    useSyncExternalStore: ri,
    useId: ri,
    unstable_isNewReconciler: !1,
  },
  B4 = {
    readContext: wr,
    useCallback: function (n, e) {
      return (ts().memoizedState = [n, e === void 0 ? null : e]), n;
    },
    useContext: wr,
    useEffect: RE,
    useImperativeHandle: function (n, e, t) {
      return (
        (t = t != null ? t.concat([n]) : null),
        Jp(4194308, 4, jC.bind(null, e, n), t)
      );
    },
    useLayoutEffect: function (n, e) {
      return Jp(4194308, 4, n, e);
    },
    useInsertionEffect: function (n, e) {
      return Jp(4, 2, n, e);
    },
    useMemo: function (n, e) {
      var t = ts();
      return (
        (e = e === void 0 ? null : e), (n = n()), (t.memoizedState = [n, e]), n
      );
    },
    useReducer: function (n, e, t) {
      var i = ts();
      return (
        (e = t !== void 0 ? t(e) : e),
        (i.memoizedState = i.baseState = e),
        (n = {
          pending: null,
          interleaved: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: n,
          lastRenderedState: e,
        }),
        (i.queue = n),
        (n = n.dispatch = F4.bind(null, fn, n)),
        [i.memoizedState, n]
      );
    },
    useRef: function (n) {
      var e = ts();
      return (n = { current: n }), (e.memoizedState = n);
    },
    useState: PE,
    useDebugValue: R1,
    useDeferredValue: function (n) {
      return (ts().memoizedState = n);
    },
    useTransition: function () {
      var n = PE(!1),
        e = n[0];
      return (n = k4.bind(null, n[1])), (ts().memoizedState = n), [e, n];
    },
    useMutableSource: function () {},
    useSyncExternalStore: function (n, e, t) {
      var i = fn,
        r = ts();
      if (nn) {
        if (t === void 0) throw Error(we(407));
        t = t();
      } else {
        if (((t = e()), Xn === null)) throw Error(we(349));
        qa & 30 || kC(i, e, t);
      }
      r.memoizedState = t;
      var s = { value: t, getSnapshot: e };
      return (
        (r.queue = s),
        RE(zC.bind(null, i, s, n), [n]),
        (i.flags |= 2048),
        Af(9, FC.bind(null, i, s, t, e), void 0, null),
        t
      );
    },
    useId: function () {
      var n = ts(),
        e = Xn.identifierPrefix;
      if (nn) {
        var t = Is,
          i = Ls;
        (t = (i & ~(1 << (32 - Fr(i) - 1))).toString(32) + t),
          (e = ":" + e + "R" + t),
          (t = Ef++),
          0 < t && (e += "H" + t.toString(32)),
          (e += ":");
      } else (t = U4++), (e = ":" + e + "r" + t.toString(32) + ":");
      return (n.memoizedState = e);
    },
    unstable_isNewReconciler: !1,
  },
  V4 = {
    readContext: wr,
    useCallback: YC,
    useContext: wr,
    useEffect: P1,
    useImperativeHandle: XC,
    useInsertionEffect: GC,
    useLayoutEffect: WC,
    useMemo: qC,
    useReducer: U0,
    useRef: HC,
    useState: function () {
      return U0(Tf);
    },
    useDebugValue: R1,
    useDeferredValue: function (n) {
      var e = Er();
      return ZC(e, Nn.memoizedState, n);
    },
    useTransition: function () {
      var n = U0(Tf)[0],
        e = Er().memoizedState;
      return [n, e];
    },
    useMutableSource: OC,
    useSyncExternalStore: UC,
    useId: KC,
    unstable_isNewReconciler: !1,
  },
  H4 = {
    readContext: wr,
    useCallback: YC,
    useContext: wr,
    useEffect: P1,
    useImperativeHandle: XC,
    useInsertionEffect: GC,
    useLayoutEffect: WC,
    useMemo: qC,
    useReducer: k0,
    useRef: HC,
    useState: function () {
      return k0(Tf);
    },
    useDebugValue: R1,
    useDeferredValue: function (n) {
      var e = Er();
      return Nn === null ? (e.memoizedState = n) : ZC(e, Nn.memoizedState, n);
    },
    useTransition: function () {
      var n = k0(Tf)[0],
        e = Er().memoizedState;
      return [n, e];
    },
    useMutableSource: OC,
    useSyncExternalStore: UC,
    useId: KC,
    unstable_isNewReconciler: !1,
  };
function Lr(n, e) {
  if (n && n.defaultProps) {
    (e = hn({}, e)), (n = n.defaultProps);
    for (var t in n) e[t] === void 0 && (e[t] = n[t]);
    return e;
  }
  return e;
}
function bx(n, e, t, i) {
  (e = n.memoizedState),
    (t = t(i, e)),
    (t = t == null ? e : hn({}, e, t)),
    (n.memoizedState = t),
    n.lanes === 0 && (n.updateQueue.baseState = t);
}
var dg = {
  isMounted: function (n) {
    return (n = n._reactInternals) ? tl(n) === n : !1;
  },
  enqueueSetState: function (n, e, t) {
    n = n._reactInternals;
    var i = Ei(),
      r = Io(n),
      s = Us(i, r);
    (s.payload = e),
      t != null && (s.callback = t),
      (e = Ro(n, s, r)),
      e !== null && (zr(e, n, r, i), Qp(e, n, r));
  },
  enqueueReplaceState: function (n, e, t) {
    n = n._reactInternals;
    var i = Ei(),
      r = Io(n),
      s = Us(i, r);
    (s.tag = 1),
      (s.payload = e),
      t != null && (s.callback = t),
      (e = Ro(n, s, r)),
      e !== null && (zr(e, n, r, i), Qp(e, n, r));
  },
  enqueueForceUpdate: function (n, e) {
    n = n._reactInternals;
    var t = Ei(),
      i = Io(n),
      r = Us(t, i);
    (r.tag = 2),
      e != null && (r.callback = e),
      (e = Ro(n, r, i)),
      e !== null && (zr(e, n, i, t), Qp(e, n, i));
  },
};
function LE(n, e, t, i, r, s, o) {
  return (
    (n = n.stateNode),
    typeof n.shouldComponentUpdate == "function"
      ? n.shouldComponentUpdate(i, s, o)
      : e.prototype && e.prototype.isPureReactComponent
      ? !yf(t, i) || !yf(r, s)
      : !0
  );
}
function eP(n, e, t) {
  var i = !1,
    r = Bo,
    s = e.contextType;
  return (
    typeof s == "object" && s !== null
      ? (s = wr(s))
      : ((r = zi(e) ? Xa : pi.current),
        (i = e.contextTypes),
        (s = (i = i != null) ? bu(n, r) : Bo)),
    (e = new e(t, s)),
    (n.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null),
    (e.updater = dg),
    (n.stateNode = e),
    (e._reactInternals = n),
    i &&
      ((n = n.stateNode),
      (n.__reactInternalMemoizedUnmaskedChildContext = r),
      (n.__reactInternalMemoizedMaskedChildContext = s)),
    e
  );
}
function IE(n, e, t, i) {
  (n = e.state),
    typeof e.componentWillReceiveProps == "function" &&
      e.componentWillReceiveProps(t, i),
    typeof e.UNSAFE_componentWillReceiveProps == "function" &&
      e.UNSAFE_componentWillReceiveProps(t, i),
    e.state !== n && dg.enqueueReplaceState(e, e.state, null);
}
function Cx(n, e, t, i) {
  var r = n.stateNode;
  (r.props = t), (r.state = n.memoizedState), (r.refs = {}), M1(n);
  var s = e.contextType;
  typeof s == "object" && s !== null
    ? (r.context = wr(s))
    : ((s = zi(e) ? Xa : pi.current), (r.context = bu(n, s))),
    (r.state = n.memoizedState),
    (s = e.getDerivedStateFromProps),
    typeof s == "function" && (bx(n, e, s, t), (r.state = n.memoizedState)),
    typeof e.getDerivedStateFromProps == "function" ||
      typeof r.getSnapshotBeforeUpdate == "function" ||
      (typeof r.UNSAFE_componentWillMount != "function" &&
        typeof r.componentWillMount != "function") ||
      ((e = r.state),
      typeof r.componentWillMount == "function" && r.componentWillMount(),
      typeof r.UNSAFE_componentWillMount == "function" &&
        r.UNSAFE_componentWillMount(),
      e !== r.state && dg.enqueueReplaceState(r, r.state, null),
      Rm(n, t, r, i),
      (r.state = n.memoizedState)),
    typeof r.componentDidMount == "function" && (n.flags |= 4194308);
}
function Lu(n, e) {
  try {
    var t = "",
      i = e;
    do (t += gD(i)), (i = i.return);
    while (i);
    var r = t;
  } catch (s) {
    r =
      `
Error generating stack: ` +
      s.message +
      `
` +
      s.stack;
  }
  return { value: n, source: e, stack: r, digest: null };
}
function F0(n, e, t) {
  return { value: n, source: null, stack: t ?? null, digest: e ?? null };
}
function Px(n, e) {
  try {
    console.error(e.value);
  } catch (t) {
    setTimeout(function () {
      throw t;
    });
  }
}
var G4 = typeof WeakMap == "function" ? WeakMap : Map;
function tP(n, e, t) {
  (t = Us(-1, t)), (t.tag = 3), (t.payload = { element: null });
  var i = e.value;
  return (
    (t.callback = function () {
      Om || ((Om = !0), (zx = i)), Px(n, e);
    }),
    t
  );
}
function nP(n, e, t) {
  (t = Us(-1, t)), (t.tag = 3);
  var i = n.type.getDerivedStateFromError;
  if (typeof i == "function") {
    var r = e.value;
    (t.payload = function () {
      return i(r);
    }),
      (t.callback = function () {
        Px(n, e);
      });
  }
  var s = n.stateNode;
  return (
    s !== null &&
      typeof s.componentDidCatch == "function" &&
      (t.callback = function () {
        Px(n, e),
          typeof i != "function" &&
            (Lo === null ? (Lo = new Set([this])) : Lo.add(this));
        var o = e.stack;
        this.componentDidCatch(e.value, {
          componentStack: o !== null ? o : "",
        });
      }),
    t
  );
}
function NE(n, e, t) {
  var i = n.pingCache;
  if (i === null) {
    i = n.pingCache = new G4();
    var r = new Set();
    i.set(e, r);
  } else (r = i.get(e)), r === void 0 && ((r = new Set()), i.set(e, r));
  r.has(t) || (r.add(t), (n = iO.bind(null, n, e, t)), e.then(n, n));
}
function DE(n) {
  do {
    var e;
    if (
      ((e = n.tag === 13) &&
        ((e = n.memoizedState), (e = e !== null ? e.dehydrated !== null : !0)),
      e)
    )
      return n;
    n = n.return;
  } while (n !== null);
  return null;
}
function OE(n, e, t, i, r) {
  return n.mode & 1
    ? ((n.flags |= 65536), (n.lanes = r), n)
    : (n === e
        ? (n.flags |= 65536)
        : ((n.flags |= 128),
          (t.flags |= 131072),
          (t.flags &= -52805),
          t.tag === 1 &&
            (t.alternate === null
              ? (t.tag = 17)
              : ((e = Us(-1, 1)), (e.tag = 2), Ro(t, e, 1))),
          (t.lanes |= 1)),
      n);
}
var W4 = qs.ReactCurrentOwner,
  ki = !1;
function Mi(n, e, t, i) {
  e.child = n === null ? LC(e, null, t, i) : Pu(e, n.child, t, i);
}
function UE(n, e, t, i, r) {
  t = t.render;
  var s = e.ref;
  return (
    wu(e, r),
    (i = b1(n, e, t, i, s, r)),
    (t = C1()),
    n !== null && !ki
      ? ((e.updateQueue = n.updateQueue),
        (e.flags &= -2053),
        (n.lanes &= ~r),
        Gs(n, e, r))
      : (nn && t && m1(e), (e.flags |= 1), Mi(n, e, i, r), e.child)
  );
}
function kE(n, e, t, i, r) {
  if (n === null) {
    var s = t.type;
    return typeof s == "function" &&
      !F1(s) &&
      s.defaultProps === void 0 &&
      t.compare === null &&
      t.defaultProps === void 0
      ? ((e.tag = 15), (e.type = s), iP(n, e, s, i, r))
      : ((n = im(t.type, null, i, e, e.mode, r)),
        (n.ref = e.ref),
        (n.return = e),
        (e.child = n));
  }
  if (((s = n.child), !(n.lanes & r))) {
    var o = s.memoizedProps;
    if (
      ((t = t.compare), (t = t !== null ? t : yf), t(o, i) && n.ref === e.ref)
    )
      return Gs(n, e, r);
  }
  return (
    (e.flags |= 1),
    (n = No(s, i)),
    (n.ref = e.ref),
    (n.return = e),
    (e.child = n)
  );
}
function iP(n, e, t, i, r) {
  if (n !== null) {
    var s = n.memoizedProps;
    if (yf(s, i) && n.ref === e.ref)
      if (((ki = !1), (e.pendingProps = i = s), (n.lanes & r) !== 0))
        n.flags & 131072 && (ki = !0);
      else return (e.lanes = n.lanes), Gs(n, e, r);
  }
  return Rx(n, e, t, i, r);
}
function rP(n, e, t) {
  var i = e.pendingProps,
    r = i.children,
    s = n !== null ? n.memoizedState : null;
  if (i.mode === "hidden")
    if (!(e.mode & 1))
      (e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }),
        Xt(lu, Ki),
        (Ki |= t);
    else {
      if (!(t & 1073741824))
        return (
          (n = s !== null ? s.baseLanes | t : t),
          (e.lanes = e.childLanes = 1073741824),
          (e.memoizedState = {
            baseLanes: n,
            cachePool: null,
            transitions: null,
          }),
          (e.updateQueue = null),
          Xt(lu, Ki),
          (Ki |= n),
          null
        );
      (e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }),
        (i = s !== null ? s.baseLanes : t),
        Xt(lu, Ki),
        (Ki |= i);
    }
  else
    s !== null ? ((i = s.baseLanes | t), (e.memoizedState = null)) : (i = t),
      Xt(lu, Ki),
      (Ki |= i);
  return Mi(n, e, r, t), e.child;
}
function sP(n, e) {
  var t = e.ref;
  ((n === null && t !== null) || (n !== null && n.ref !== t)) &&
    ((e.flags |= 512), (e.flags |= 2097152));
}
function Rx(n, e, t, i, r) {
  var s = zi(t) ? Xa : pi.current;
  return (
    (s = bu(e, s)),
    wu(e, r),
    (t = b1(n, e, t, i, s, r)),
    (i = C1()),
    n !== null && !ki
      ? ((e.updateQueue = n.updateQueue),
        (e.flags &= -2053),
        (n.lanes &= ~r),
        Gs(n, e, r))
      : (nn && i && m1(e), (e.flags |= 1), Mi(n, e, t, r), e.child)
  );
}
function FE(n, e, t, i, r) {
  if (zi(t)) {
    var s = !0;
    Tm(e);
  } else s = !1;
  if ((wu(e, r), e.stateNode === null))
    em(n, e), eP(e, t, i), Cx(e, t, i, r), (i = !0);
  else if (n === null) {
    var o = e.stateNode,
      a = e.memoizedProps;
    o.props = a;
    var u = o.context,
      f = t.contextType;
    typeof f == "object" && f !== null
      ? (f = wr(f))
      : ((f = zi(t) ? Xa : pi.current), (f = bu(e, f)));
    var h = t.getDerivedStateFromProps,
      d =
        typeof h == "function" ||
        typeof o.getSnapshotBeforeUpdate == "function";
    d ||
      (typeof o.UNSAFE_componentWillReceiveProps != "function" &&
        typeof o.componentWillReceiveProps != "function") ||
      ((a !== i || u !== f) && IE(e, o, i, f)),
      (xo = !1);
    var p = e.memoizedState;
    (o.state = p),
      Rm(e, i, o, r),
      (u = e.memoizedState),
      a !== i || p !== u || Fi.current || xo
        ? (typeof h == "function" && (bx(e, t, h, i), (u = e.memoizedState)),
          (a = xo || LE(e, t, a, i, p, u, f))
            ? (d ||
                (typeof o.UNSAFE_componentWillMount != "function" &&
                  typeof o.componentWillMount != "function") ||
                (typeof o.componentWillMount == "function" &&
                  o.componentWillMount(),
                typeof o.UNSAFE_componentWillMount == "function" &&
                  o.UNSAFE_componentWillMount()),
              typeof o.componentDidMount == "function" && (e.flags |= 4194308))
            : (typeof o.componentDidMount == "function" && (e.flags |= 4194308),
              (e.memoizedProps = i),
              (e.memoizedState = u)),
          (o.props = i),
          (o.state = u),
          (o.context = f),
          (i = a))
        : (typeof o.componentDidMount == "function" && (e.flags |= 4194308),
          (i = !1));
  } else {
    (o = e.stateNode),
      NC(n, e),
      (a = e.memoizedProps),
      (f = e.type === e.elementType ? a : Lr(e.type, a)),
      (o.props = f),
      (d = e.pendingProps),
      (p = o.context),
      (u = t.contextType),
      typeof u == "object" && u !== null
        ? (u = wr(u))
        : ((u = zi(t) ? Xa : pi.current), (u = bu(e, u)));
    var m = t.getDerivedStateFromProps;
    (h =
      typeof m == "function" ||
      typeof o.getSnapshotBeforeUpdate == "function") ||
      (typeof o.UNSAFE_componentWillReceiveProps != "function" &&
        typeof o.componentWillReceiveProps != "function") ||
      ((a !== d || p !== u) && IE(e, o, i, u)),
      (xo = !1),
      (p = e.memoizedState),
      (o.state = p),
      Rm(e, i, o, r);
    var y = e.memoizedState;
    a !== d || p !== y || Fi.current || xo
      ? (typeof m == "function" && (bx(e, t, m, i), (y = e.memoizedState)),
        (f = xo || LE(e, t, f, i, p, y, u) || !1)
          ? (h ||
              (typeof o.UNSAFE_componentWillUpdate != "function" &&
                typeof o.componentWillUpdate != "function") ||
              (typeof o.componentWillUpdate == "function" &&
                o.componentWillUpdate(i, y, u),
              typeof o.UNSAFE_componentWillUpdate == "function" &&
                o.UNSAFE_componentWillUpdate(i, y, u)),
            typeof o.componentDidUpdate == "function" && (e.flags |= 4),
            typeof o.getSnapshotBeforeUpdate == "function" && (e.flags |= 1024))
          : (typeof o.componentDidUpdate != "function" ||
              (a === n.memoizedProps && p === n.memoizedState) ||
              (e.flags |= 4),
            typeof o.getSnapshotBeforeUpdate != "function" ||
              (a === n.memoizedProps && p === n.memoizedState) ||
              (e.flags |= 1024),
            (e.memoizedProps = i),
            (e.memoizedState = y)),
        (o.props = i),
        (o.state = y),
        (o.context = u),
        (i = f))
      : (typeof o.componentDidUpdate != "function" ||
          (a === n.memoizedProps && p === n.memoizedState) ||
          (e.flags |= 4),
        typeof o.getSnapshotBeforeUpdate != "function" ||
          (a === n.memoizedProps && p === n.memoizedState) ||
          (e.flags |= 1024),
        (i = !1));
  }
  return Lx(n, e, t, i, s, r);
}
function Lx(n, e, t, i, r, s) {
  sP(n, e);
  var o = (e.flags & 128) !== 0;
  if (!i && !o) return r && wE(e, t, !1), Gs(n, e, s);
  (i = e.stateNode), (W4.current = e);
  var a =
    o && typeof t.getDerivedStateFromError != "function" ? null : i.render();
  return (
    (e.flags |= 1),
    n !== null && o
      ? ((e.child = Pu(e, n.child, null, s)), (e.child = Pu(e, null, a, s)))
      : Mi(n, e, a, s),
    (e.memoizedState = i.state),
    r && wE(e, t, !0),
    e.child
  );
}
function oP(n) {
  var e = n.stateNode;
  e.pendingContext
    ? ME(n, e.pendingContext, e.pendingContext !== e.context)
    : e.context && ME(n, e.context, !1),
    w1(n, e.containerInfo);
}
function zE(n, e, t, i, r) {
  return Cu(), v1(r), (e.flags |= 256), Mi(n, e, t, i), e.child;
}
var Ix = { dehydrated: null, treeContext: null, retryLane: 0 };
function Nx(n) {
  return { baseLanes: n, cachePool: null, transitions: null };
}
function aP(n, e, t) {
  var i = e.pendingProps,
    r = ln.current,
    s = !1,
    o = (e.flags & 128) !== 0,
    a;
  if (
    ((a = o) ||
      (a = n !== null && n.memoizedState === null ? !1 : (r & 2) !== 0),
    a
      ? ((s = !0), (e.flags &= -129))
      : (n === null || n.memoizedState !== null) && (r |= 1),
    Xt(ln, r & 1),
    n === null)
  )
    return (
      Tx(e),
      (n = e.memoizedState),
      n !== null && ((n = n.dehydrated), n !== null)
        ? (e.mode & 1
            ? n.data === "$!"
              ? (e.lanes = 8)
              : (e.lanes = 1073741824)
            : (e.lanes = 1),
          null)
        : ((o = i.children),
          (n = i.fallback),
          s
            ? ((i = e.mode),
              (s = e.child),
              (o = { mode: "hidden", children: o }),
              !(i & 1) && s !== null
                ? ((s.childLanes = 0), (s.pendingProps = o))
                : (s = gg(o, i, 0, null)),
              (n = za(n, i, t, null)),
              (s.return = e),
              (n.return = e),
              (s.sibling = n),
              (e.child = s),
              (e.child.memoizedState = Nx(t)),
              (e.memoizedState = Ix),
              n)
            : L1(e, o))
    );
  if (((r = n.memoizedState), r !== null && ((a = r.dehydrated), a !== null)))
    return j4(n, e, o, i, a, r, t);
  if (s) {
    (s = i.fallback), (o = e.mode), (r = n.child), (a = r.sibling);
    var u = { mode: "hidden", children: i.children };
    return (
      !(o & 1) && e.child !== r
        ? ((i = e.child),
          (i.childLanes = 0),
          (i.pendingProps = u),
          (e.deletions = null))
        : ((i = No(r, u)), (i.subtreeFlags = r.subtreeFlags & 14680064)),
      a !== null ? (s = No(a, s)) : ((s = za(s, o, t, null)), (s.flags |= 2)),
      (s.return = e),
      (i.return = e),
      (i.sibling = s),
      (e.child = i),
      (i = s),
      (s = e.child),
      (o = n.child.memoizedState),
      (o =
        o === null
          ? Nx(t)
          : {
              baseLanes: o.baseLanes | t,
              cachePool: null,
              transitions: o.transitions,
            }),
      (s.memoizedState = o),
      (s.childLanes = n.childLanes & ~t),
      (e.memoizedState = Ix),
      i
    );
  }
  return (
    (s = n.child),
    (n = s.sibling),
    (i = No(s, { mode: "visible", children: i.children })),
    !(e.mode & 1) && (i.lanes = t),
    (i.return = e),
    (i.sibling = null),
    n !== null &&
      ((t = e.deletions),
      t === null ? ((e.deletions = [n]), (e.flags |= 16)) : t.push(n)),
    (e.child = i),
    (e.memoizedState = null),
    i
  );
}
function L1(n, e) {
  return (
    (e = gg({ mode: "visible", children: e }, n.mode, 0, null)),
    (e.return = n),
    (n.child = e)
  );
}
function Fd(n, e, t, i) {
  return (
    i !== null && v1(i),
    Pu(e, n.child, null, t),
    (n = L1(e, e.pendingProps.children)),
    (n.flags |= 2),
    (e.memoizedState = null),
    n
  );
}
function j4(n, e, t, i, r, s, o) {
  if (t)
    return e.flags & 256
      ? ((e.flags &= -257), (i = F0(Error(we(422)))), Fd(n, e, o, i))
      : e.memoizedState !== null
      ? ((e.child = n.child), (e.flags |= 128), null)
      : ((s = i.fallback),
        (r = e.mode),
        (i = gg({ mode: "visible", children: i.children }, r, 0, null)),
        (s = za(s, r, o, null)),
        (s.flags |= 2),
        (i.return = e),
        (s.return = e),
        (i.sibling = s),
        (e.child = i),
        e.mode & 1 && Pu(e, n.child, null, o),
        (e.child.memoizedState = Nx(o)),
        (e.memoizedState = Ix),
        s);
  if (!(e.mode & 1)) return Fd(n, e, o, null);
  if (r.data === "$!") {
    if (((i = r.nextSibling && r.nextSibling.dataset), i)) var a = i.dgst;
    return (
      (i = a), (s = Error(we(419))), (i = F0(s, i, void 0)), Fd(n, e, o, i)
    );
  }
  if (((a = (o & n.childLanes) !== 0), ki || a)) {
    if (((i = Xn), i !== null)) {
      switch (o & -o) {
        case 4:
          r = 2;
          break;
        case 16:
          r = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          r = 32;
          break;
        case 536870912:
          r = 268435456;
          break;
        default:
          r = 0;
      }
      (r = r & (i.suspendedLanes | o) ? 0 : r),
        r !== 0 &&
          r !== s.retryLane &&
          ((s.retryLane = r), Hs(n, r), zr(i, n, r, -1));
    }
    return k1(), (i = F0(Error(we(421)))), Fd(n, e, o, i);
  }
  return r.data === "$?"
    ? ((e.flags |= 128),
      (e.child = n.child),
      (e = rO.bind(null, n)),
      (r._reactRetry = e),
      null)
    : ((n = s.treeContext),
      ($i = Po(r.nextSibling)),
      (Ji = e),
      (nn = !0),
      (Dr = null),
      n !== null &&
        ((xr[_r++] = Ls),
        (xr[_r++] = Is),
        (xr[_r++] = Ya),
        (Ls = n.id),
        (Is = n.overflow),
        (Ya = e)),
      (e = L1(e, i.children)),
      (e.flags |= 4096),
      e);
}
function BE(n, e, t) {
  n.lanes |= e;
  var i = n.alternate;
  i !== null && (i.lanes |= e), Ax(n.return, e, t);
}
function z0(n, e, t, i, r) {
  var s = n.memoizedState;
  s === null
    ? (n.memoizedState = {
        isBackwards: e,
        rendering: null,
        renderingStartTime: 0,
        last: i,
        tail: t,
        tailMode: r,
      })
    : ((s.isBackwards = e),
      (s.rendering = null),
      (s.renderingStartTime = 0),
      (s.last = i),
      (s.tail = t),
      (s.tailMode = r));
}
function lP(n, e, t) {
  var i = e.pendingProps,
    r = i.revealOrder,
    s = i.tail;
  if ((Mi(n, e, i.children, t), (i = ln.current), i & 2))
    (i = (i & 1) | 2), (e.flags |= 128);
  else {
    if (n !== null && n.flags & 128)
      e: for (n = e.child; n !== null; ) {
        if (n.tag === 13) n.memoizedState !== null && BE(n, t, e);
        else if (n.tag === 19) BE(n, t, e);
        else if (n.child !== null) {
          (n.child.return = n), (n = n.child);
          continue;
        }
        if (n === e) break e;
        for (; n.sibling === null; ) {
          if (n.return === null || n.return === e) break e;
          n = n.return;
        }
        (n.sibling.return = n.return), (n = n.sibling);
      }
    i &= 1;
  }
  if ((Xt(ln, i), !(e.mode & 1))) e.memoizedState = null;
  else
    switch (r) {
      case "forwards":
        for (t = e.child, r = null; t !== null; )
          (n = t.alternate),
            n !== null && Lm(n) === null && (r = t),
            (t = t.sibling);
        (t = r),
          t === null
            ? ((r = e.child), (e.child = null))
            : ((r = t.sibling), (t.sibling = null)),
          z0(e, !1, r, t, s);
        break;
      case "backwards":
        for (t = null, r = e.child, e.child = null; r !== null; ) {
          if (((n = r.alternate), n !== null && Lm(n) === null)) {
            e.child = r;
            break;
          }
          (n = r.sibling), (r.sibling = t), (t = r), (r = n);
        }
        z0(e, !0, t, null, s);
        break;
      case "together":
        z0(e, !1, null, null, void 0);
        break;
      default:
        e.memoizedState = null;
    }
  return e.child;
}
function em(n, e) {
  !(e.mode & 1) &&
    n !== null &&
    ((n.alternate = null), (e.alternate = null), (e.flags |= 2));
}
function Gs(n, e, t) {
  if (
    (n !== null && (e.dependencies = n.dependencies),
    (Za |= e.lanes),
    !(t & e.childLanes))
  )
    return null;
  if (n !== null && e.child !== n.child) throw Error(we(153));
  if (e.child !== null) {
    for (
      n = e.child, t = No(n, n.pendingProps), e.child = t, t.return = e;
      n.sibling !== null;

    )
      (n = n.sibling), (t = t.sibling = No(n, n.pendingProps)), (t.return = e);
    t.sibling = null;
  }
  return e.child;
}
function X4(n, e, t) {
  switch (e.tag) {
    case 3:
      oP(e), Cu();
      break;
    case 5:
      DC(e);
      break;
    case 1:
      zi(e.type) && Tm(e);
      break;
    case 4:
      w1(e, e.stateNode.containerInfo);
      break;
    case 10:
      var i = e.type._context,
        r = e.memoizedProps.value;
      Xt(Cm, i._currentValue), (i._currentValue = r);
      break;
    case 13:
      if (((i = e.memoizedState), i !== null))
        return i.dehydrated !== null
          ? (Xt(ln, ln.current & 1), (e.flags |= 128), null)
          : t & e.child.childLanes
          ? aP(n, e, t)
          : (Xt(ln, ln.current & 1),
            (n = Gs(n, e, t)),
            n !== null ? n.sibling : null);
      Xt(ln, ln.current & 1);
      break;
    case 19:
      if (((i = (t & e.childLanes) !== 0), n.flags & 128)) {
        if (i) return lP(n, e, t);
        e.flags |= 128;
      }
      if (
        ((r = e.memoizedState),
        r !== null &&
          ((r.rendering = null), (r.tail = null), (r.lastEffect = null)),
        Xt(ln, ln.current),
        i)
      )
        break;
      return null;
    case 22:
    case 23:
      return (e.lanes = 0), rP(n, e, t);
  }
  return Gs(n, e, t);
}
var uP, Dx, cP, fP;
uP = function (n, e) {
  for (var t = e.child; t !== null; ) {
    if (t.tag === 5 || t.tag === 6) n.appendChild(t.stateNode);
    else if (t.tag !== 4 && t.child !== null) {
      (t.child.return = t), (t = t.child);
      continue;
    }
    if (t === e) break;
    for (; t.sibling === null; ) {
      if (t.return === null || t.return === e) return;
      t = t.return;
    }
    (t.sibling.return = t.return), (t = t.sibling);
  }
};
Dx = function () {};
cP = function (n, e, t, i) {
  var r = n.memoizedProps;
  if (r !== i) {
    (n = e.stateNode), Ia(as.current);
    var s = null;
    switch (t) {
      case "input":
        (r = nx(n, r)), (i = nx(n, i)), (s = []);
        break;
      case "select":
        (r = hn({}, r, { value: void 0 })),
          (i = hn({}, i, { value: void 0 })),
          (s = []);
        break;
      case "textarea":
        (r = sx(n, r)), (i = sx(n, i)), (s = []);
        break;
      default:
        typeof r.onClick != "function" &&
          typeof i.onClick == "function" &&
          (n.onclick = wm);
    }
    ax(t, i);
    var o;
    t = null;
    for (f in r)
      if (!i.hasOwnProperty(f) && r.hasOwnProperty(f) && r[f] != null)
        if (f === "style") {
          var a = r[f];
          for (o in a) a.hasOwnProperty(o) && (t || (t = {}), (t[o] = ""));
        } else
          f !== "dangerouslySetInnerHTML" &&
            f !== "children" &&
            f !== "suppressContentEditableWarning" &&
            f !== "suppressHydrationWarning" &&
            f !== "autoFocus" &&
            (ff.hasOwnProperty(f)
              ? s || (s = [])
              : (s = s || []).push(f, null));
    for (f in i) {
      var u = i[f];
      if (
        ((a = r != null ? r[f] : void 0),
        i.hasOwnProperty(f) && u !== a && (u != null || a != null))
      )
        if (f === "style")
          if (a) {
            for (o in a)
              !a.hasOwnProperty(o) ||
                (u && u.hasOwnProperty(o)) ||
                (t || (t = {}), (t[o] = ""));
            for (o in u)
              u.hasOwnProperty(o) &&
                a[o] !== u[o] &&
                (t || (t = {}), (t[o] = u[o]));
          } else t || (s || (s = []), s.push(f, t)), (t = u);
        else
          f === "dangerouslySetInnerHTML"
            ? ((u = u ? u.__html : void 0),
              (a = a ? a.__html : void 0),
              u != null && a !== u && (s = s || []).push(f, u))
            : f === "children"
            ? (typeof u != "string" && typeof u != "number") ||
              (s = s || []).push(f, "" + u)
            : f !== "suppressContentEditableWarning" &&
              f !== "suppressHydrationWarning" &&
              (ff.hasOwnProperty(f)
                ? (u != null && f === "onScroll" && qt("scroll", n),
                  s || a === u || (s = []))
                : (s = s || []).push(f, u));
    }
    t && (s = s || []).push("style", t);
    var f = s;
    (e.updateQueue = f) && (e.flags |= 4);
  }
};
fP = function (n, e, t, i) {
  t !== i && (e.flags |= 4);
};
function Mc(n, e) {
  if (!nn)
    switch (n.tailMode) {
      case "hidden":
        e = n.tail;
        for (var t = null; e !== null; )
          e.alternate !== null && (t = e), (e = e.sibling);
        t === null ? (n.tail = null) : (t.sibling = null);
        break;
      case "collapsed":
        t = n.tail;
        for (var i = null; t !== null; )
          t.alternate !== null && (i = t), (t = t.sibling);
        i === null
          ? e || n.tail === null
            ? (n.tail = null)
            : (n.tail.sibling = null)
          : (i.sibling = null);
    }
}
function si(n) {
  var e = n.alternate !== null && n.alternate.child === n.child,
    t = 0,
    i = 0;
  if (e)
    for (var r = n.child; r !== null; )
      (t |= r.lanes | r.childLanes),
        (i |= r.subtreeFlags & 14680064),
        (i |= r.flags & 14680064),
        (r.return = n),
        (r = r.sibling);
  else
    for (r = n.child; r !== null; )
      (t |= r.lanes | r.childLanes),
        (i |= r.subtreeFlags),
        (i |= r.flags),
        (r.return = n),
        (r = r.sibling);
  return (n.subtreeFlags |= i), (n.childLanes = t), e;
}
function Y4(n, e, t) {
  var i = e.pendingProps;
  switch ((g1(e), e.tag)) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return si(e), null;
    case 1:
      return zi(e.type) && Em(), si(e), null;
    case 3:
      return (
        (i = e.stateNode),
        Ru(),
        Qt(Fi),
        Qt(pi),
        T1(),
        i.pendingContext &&
          ((i.context = i.pendingContext), (i.pendingContext = null)),
        (n === null || n.child === null) &&
          (Ud(e)
            ? (e.flags |= 4)
            : n === null ||
              (n.memoizedState.isDehydrated && !(e.flags & 256)) ||
              ((e.flags |= 1024), Dr !== null && (Hx(Dr), (Dr = null)))),
        Dx(n, e),
        si(e),
        null
      );
    case 5:
      E1(e);
      var r = Ia(wf.current);
      if (((t = e.type), n !== null && e.stateNode != null))
        cP(n, e, t, i, r),
          n.ref !== e.ref && ((e.flags |= 512), (e.flags |= 2097152));
      else {
        if (!i) {
          if (e.stateNode === null) throw Error(we(166));
          return si(e), null;
        }
        if (((n = Ia(as.current)), Ud(e))) {
          (i = e.stateNode), (t = e.type);
          var s = e.memoizedProps;
          switch (((i[is] = e), (i[Sf] = s), (n = (e.mode & 1) !== 0), t)) {
            case "dialog":
              qt("cancel", i), qt("close", i);
              break;
            case "iframe":
            case "object":
            case "embed":
              qt("load", i);
              break;
            case "video":
            case "audio":
              for (r = 0; r < Hc.length; r++) qt(Hc[r], i);
              break;
            case "source":
              qt("error", i);
              break;
            case "img":
            case "image":
            case "link":
              qt("error", i), qt("load", i);
              break;
            case "details":
              qt("toggle", i);
              break;
            case "input":
              Zw(i, s), qt("invalid", i);
              break;
            case "select":
              (i._wrapperState = { wasMultiple: !!s.multiple }),
                qt("invalid", i);
              break;
            case "textarea":
              Qw(i, s), qt("invalid", i);
          }
          ax(t, s), (r = null);
          for (var o in s)
            if (s.hasOwnProperty(o)) {
              var a = s[o];
              o === "children"
                ? typeof a == "string"
                  ? i.textContent !== a &&
                    (s.suppressHydrationWarning !== !0 &&
                      Od(i.textContent, a, n),
                    (r = ["children", a]))
                  : typeof a == "number" &&
                    i.textContent !== "" + a &&
                    (s.suppressHydrationWarning !== !0 &&
                      Od(i.textContent, a, n),
                    (r = ["children", "" + a]))
                : ff.hasOwnProperty(o) &&
                  a != null &&
                  o === "onScroll" &&
                  qt("scroll", i);
            }
          switch (t) {
            case "input":
              bd(i), Kw(i, s, !0);
              break;
            case "textarea":
              bd(i), $w(i);
              break;
            case "select":
            case "option":
              break;
            default:
              typeof s.onClick == "function" && (i.onclick = wm);
          }
          (i = r), (e.updateQueue = i), i !== null && (e.flags |= 4);
        } else {
          (o = r.nodeType === 9 ? r : r.ownerDocument),
            n === "http://www.w3.org/1999/xhtml" && (n = zb(t)),
            n === "http://www.w3.org/1999/xhtml"
              ? t === "script"
                ? ((n = o.createElement("div")),
                  (n.innerHTML = "<script></script>"),
                  (n = n.removeChild(n.firstChild)))
                : typeof i.is == "string"
                ? (n = o.createElement(t, { is: i.is }))
                : ((n = o.createElement(t)),
                  t === "select" &&
                    ((o = n),
                    i.multiple
                      ? (o.multiple = !0)
                      : i.size && (o.size = i.size)))
              : (n = o.createElementNS(n, t)),
            (n[is] = e),
            (n[Sf] = i),
            uP(n, e, !1, !1),
            (e.stateNode = n);
          e: {
            switch (((o = lx(t, i)), t)) {
              case "dialog":
                qt("cancel", n), qt("close", n), (r = i);
                break;
              case "iframe":
              case "object":
              case "embed":
                qt("load", n), (r = i);
                break;
              case "video":
              case "audio":
                for (r = 0; r < Hc.length; r++) qt(Hc[r], n);
                r = i;
                break;
              case "source":
                qt("error", n), (r = i);
                break;
              case "img":
              case "image":
              case "link":
                qt("error", n), qt("load", n), (r = i);
                break;
              case "details":
                qt("toggle", n), (r = i);
                break;
              case "input":
                Zw(n, i), (r = nx(n, i)), qt("invalid", n);
                break;
              case "option":
                r = i;
                break;
              case "select":
                (n._wrapperState = { wasMultiple: !!i.multiple }),
                  (r = hn({}, i, { value: void 0 })),
                  qt("invalid", n);
                break;
              case "textarea":
                Qw(n, i), (r = sx(n, i)), qt("invalid", n);
                break;
              default:
                r = i;
            }
            ax(t, r), (a = r);
            for (s in a)
              if (a.hasOwnProperty(s)) {
                var u = a[s];
                s === "style"
                  ? Hb(n, u)
                  : s === "dangerouslySetInnerHTML"
                  ? ((u = u ? u.__html : void 0), u != null && Bb(n, u))
                  : s === "children"
                  ? typeof u == "string"
                    ? (t !== "textarea" || u !== "") && hf(n, u)
                    : typeof u == "number" && hf(n, "" + u)
                  : s !== "suppressContentEditableWarning" &&
                    s !== "suppressHydrationWarning" &&
                    s !== "autoFocus" &&
                    (ff.hasOwnProperty(s)
                      ? u != null && s === "onScroll" && qt("scroll", n)
                      : u != null && t1(n, s, u, o));
              }
            switch (t) {
              case "input":
                bd(n), Kw(n, i, !1);
                break;
              case "textarea":
                bd(n), $w(n);
                break;
              case "option":
                i.value != null && n.setAttribute("value", "" + zo(i.value));
                break;
              case "select":
                (n.multiple = !!i.multiple),
                  (s = i.value),
                  s != null
                    ? xu(n, !!i.multiple, s, !1)
                    : i.defaultValue != null &&
                      xu(n, !!i.multiple, i.defaultValue, !0);
                break;
              default:
                typeof r.onClick == "function" && (n.onclick = wm);
            }
            switch (t) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                i = !!i.autoFocus;
                break e;
              case "img":
                i = !0;
                break e;
              default:
                i = !1;
            }
          }
          i && (e.flags |= 4);
        }
        e.ref !== null && ((e.flags |= 512), (e.flags |= 2097152));
      }
      return si(e), null;
    case 6:
      if (n && e.stateNode != null) fP(n, e, n.memoizedProps, i);
      else {
        if (typeof i != "string" && e.stateNode === null) throw Error(we(166));
        if (((t = Ia(wf.current)), Ia(as.current), Ud(e))) {
          if (
            ((i = e.stateNode),
            (t = e.memoizedProps),
            (i[is] = e),
            (s = i.nodeValue !== t) && ((n = Ji), n !== null))
          )
            switch (n.tag) {
              case 3:
                Od(i.nodeValue, t, (n.mode & 1) !== 0);
                break;
              case 5:
                n.memoizedProps.suppressHydrationWarning !== !0 &&
                  Od(i.nodeValue, t, (n.mode & 1) !== 0);
            }
          s && (e.flags |= 4);
        } else
          (i = (t.nodeType === 9 ? t : t.ownerDocument).createTextNode(i)),
            (i[is] = e),
            (e.stateNode = i);
      }
      return si(e), null;
    case 13:
      if (
        (Qt(ln),
        (i = e.memoizedState),
        n === null ||
          (n.memoizedState !== null && n.memoizedState.dehydrated !== null))
      ) {
        if (nn && $i !== null && e.mode & 1 && !(e.flags & 128))
          PC(), Cu(), (e.flags |= 98560), (s = !1);
        else if (((s = Ud(e)), i !== null && i.dehydrated !== null)) {
          if (n === null) {
            if (!s) throw Error(we(318));
            if (
              ((s = e.memoizedState),
              (s = s !== null ? s.dehydrated : null),
              !s)
            )
              throw Error(we(317));
            s[is] = e;
          } else
            Cu(), !(e.flags & 128) && (e.memoizedState = null), (e.flags |= 4);
          si(e), (s = !1);
        } else Dr !== null && (Hx(Dr), (Dr = null)), (s = !0);
        if (!s) return e.flags & 65536 ? e : null;
      }
      return e.flags & 128
        ? ((e.lanes = t), e)
        : ((i = i !== null),
          i !== (n !== null && n.memoizedState !== null) &&
            i &&
            ((e.child.flags |= 8192),
            e.mode & 1 &&
              (n === null || ln.current & 1 ? On === 0 && (On = 3) : k1())),
          e.updateQueue !== null && (e.flags |= 4),
          si(e),
          null);
    case 4:
      return (
        Ru(), Dx(n, e), n === null && xf(e.stateNode.containerInfo), si(e), null
      );
    case 10:
      return _1(e.type._context), si(e), null;
    case 17:
      return zi(e.type) && Em(), si(e), null;
    case 19:
      if ((Qt(ln), (s = e.memoizedState), s === null)) return si(e), null;
      if (((i = (e.flags & 128) !== 0), (o = s.rendering), o === null))
        if (i) Mc(s, !1);
        else {
          if (On !== 0 || (n !== null && n.flags & 128))
            for (n = e.child; n !== null; ) {
              if (((o = Lm(n)), o !== null)) {
                for (
                  e.flags |= 128,
                    Mc(s, !1),
                    i = o.updateQueue,
                    i !== null && ((e.updateQueue = i), (e.flags |= 4)),
                    e.subtreeFlags = 0,
                    i = t,
                    t = e.child;
                  t !== null;

                )
                  (s = t),
                    (n = i),
                    (s.flags &= 14680066),
                    (o = s.alternate),
                    o === null
                      ? ((s.childLanes = 0),
                        (s.lanes = n),
                        (s.child = null),
                        (s.subtreeFlags = 0),
                        (s.memoizedProps = null),
                        (s.memoizedState = null),
                        (s.updateQueue = null),
                        (s.dependencies = null),
                        (s.stateNode = null))
                      : ((s.childLanes = o.childLanes),
                        (s.lanes = o.lanes),
                        (s.child = o.child),
                        (s.subtreeFlags = 0),
                        (s.deletions = null),
                        (s.memoizedProps = o.memoizedProps),
                        (s.memoizedState = o.memoizedState),
                        (s.updateQueue = o.updateQueue),
                        (s.type = o.type),
                        (n = o.dependencies),
                        (s.dependencies =
                          n === null
                            ? null
                            : {
                                lanes: n.lanes,
                                firstContext: n.firstContext,
                              })),
                    (t = t.sibling);
                return Xt(ln, (ln.current & 1) | 2), e.child;
              }
              n = n.sibling;
            }
          s.tail !== null &&
            Mn() > Iu &&
            ((e.flags |= 128), (i = !0), Mc(s, !1), (e.lanes = 4194304));
        }
      else {
        if (!i)
          if (((n = Lm(o)), n !== null)) {
            if (
              ((e.flags |= 128),
              (i = !0),
              (t = n.updateQueue),
              t !== null && ((e.updateQueue = t), (e.flags |= 4)),
              Mc(s, !0),
              s.tail === null && s.tailMode === "hidden" && !o.alternate && !nn)
            )
              return si(e), null;
          } else
            2 * Mn() - s.renderingStartTime > Iu &&
              t !== 1073741824 &&
              ((e.flags |= 128), (i = !0), Mc(s, !1), (e.lanes = 4194304));
        s.isBackwards
          ? ((o.sibling = e.child), (e.child = o))
          : ((t = s.last),
            t !== null ? (t.sibling = o) : (e.child = o),
            (s.last = o));
      }
      return s.tail !== null
        ? ((e = s.tail),
          (s.rendering = e),
          (s.tail = e.sibling),
          (s.renderingStartTime = Mn()),
          (e.sibling = null),
          (t = ln.current),
          Xt(ln, i ? (t & 1) | 2 : t & 1),
          e)
        : (si(e), null);
    case 22:
    case 23:
      return (
        U1(),
        (i = e.memoizedState !== null),
        n !== null && (n.memoizedState !== null) !== i && (e.flags |= 8192),
        i && e.mode & 1
          ? Ki & 1073741824 && (si(e), e.subtreeFlags & 6 && (e.flags |= 8192))
          : si(e),
        null
      );
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(we(156, e.tag));
}
function q4(n, e) {
  switch ((g1(e), e.tag)) {
    case 1:
      return (
        zi(e.type) && Em(),
        (n = e.flags),
        n & 65536 ? ((e.flags = (n & -65537) | 128), e) : null
      );
    case 3:
      return (
        Ru(),
        Qt(Fi),
        Qt(pi),
        T1(),
        (n = e.flags),
        n & 65536 && !(n & 128) ? ((e.flags = (n & -65537) | 128), e) : null
      );
    case 5:
      return E1(e), null;
    case 13:
      if (
        (Qt(ln), (n = e.memoizedState), n !== null && n.dehydrated !== null)
      ) {
        if (e.alternate === null) throw Error(we(340));
        Cu();
      }
      return (
        (n = e.flags), n & 65536 ? ((e.flags = (n & -65537) | 128), e) : null
      );
    case 19:
      return Qt(ln), null;
    case 4:
      return Ru(), null;
    case 10:
      return _1(e.type._context), null;
    case 22:
    case 23:
      return U1(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var zd = !1,
  ci = !1,
  Z4 = typeof WeakSet == "function" ? WeakSet : Set,
  Ge = null;
function au(n, e) {
  var t = n.ref;
  if (t !== null)
    if (typeof t == "function")
      try {
        t(null);
      } catch (i) {
        gn(n, e, i);
      }
    else t.current = null;
}
function Ox(n, e, t) {
  try {
    t();
  } catch (i) {
    gn(n, e, i);
  }
}
var VE = !1;
function K4(n, e) {
  if (((yx = _m), (n = gC()), p1(n))) {
    if ("selectionStart" in n)
      var t = { start: n.selectionStart, end: n.selectionEnd };
    else
      e: {
        t = ((t = n.ownerDocument) && t.defaultView) || window;
        var i = t.getSelection && t.getSelection();
        if (i && i.rangeCount !== 0) {
          t = i.anchorNode;
          var r = i.anchorOffset,
            s = i.focusNode;
          i = i.focusOffset;
          try {
            t.nodeType, s.nodeType;
          } catch {
            t = null;
            break e;
          }
          var o = 0,
            a = -1,
            u = -1,
            f = 0,
            h = 0,
            d = n,
            p = null;
          t: for (;;) {
            for (
              var m;
              d !== t || (r !== 0 && d.nodeType !== 3) || (a = o + r),
                d !== s || (i !== 0 && d.nodeType !== 3) || (u = o + i),
                d.nodeType === 3 && (o += d.nodeValue.length),
                (m = d.firstChild) !== null;

            )
              (p = d), (d = m);
            for (;;) {
              if (d === n) break t;
              if (
                (p === t && ++f === r && (a = o),
                p === s && ++h === i && (u = o),
                (m = d.nextSibling) !== null)
              )
                break;
              (d = p), (p = d.parentNode);
            }
            d = m;
          }
          t = a === -1 || u === -1 ? null : { start: a, end: u };
        } else t = null;
      }
    t = t || { start: 0, end: 0 };
  } else t = null;
  for (
    xx = { focusedElem: n, selectionRange: t }, _m = !1, Ge = e;
    Ge !== null;

  )
    if (((e = Ge), (n = e.child), (e.subtreeFlags & 1028) !== 0 && n !== null))
      (n.return = e), (Ge = n);
    else
      for (; Ge !== null; ) {
        e = Ge;
        try {
          var y = e.alternate;
          if (e.flags & 1024)
            switch (e.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (y !== null) {
                  var w = y.memoizedProps,
                    S = y.memoizedState,
                    v = e.stateNode,
                    M = v.getSnapshotBeforeUpdate(
                      e.elementType === e.type ? w : Lr(e.type, w),
                      S
                    );
                  v.__reactInternalSnapshotBeforeUpdate = M;
                }
                break;
              case 3:
                var _ = e.stateNode.containerInfo;
                _.nodeType === 1
                  ? (_.textContent = "")
                  : _.nodeType === 9 &&
                    _.documentElement &&
                    _.removeChild(_.documentElement);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(we(163));
            }
        } catch (T) {
          gn(e, e.return, T);
        }
        if (((n = e.sibling), n !== null)) {
          (n.return = e.return), (Ge = n);
          break;
        }
        Ge = e.return;
      }
  return (y = VE), (VE = !1), y;
}
function Qc(n, e, t) {
  var i = e.updateQueue;
  if (((i = i !== null ? i.lastEffect : null), i !== null)) {
    var r = (i = i.next);
    do {
      if ((r.tag & n) === n) {
        var s = r.destroy;
        (r.destroy = void 0), s !== void 0 && Ox(e, t, s);
      }
      r = r.next;
    } while (r !== i);
  }
}
function pg(n, e) {
  if (
    ((e = e.updateQueue), (e = e !== null ? e.lastEffect : null), e !== null)
  ) {
    var t = (e = e.next);
    do {
      if ((t.tag & n) === n) {
        var i = t.create;
        t.destroy = i();
      }
      t = t.next;
    } while (t !== e);
  }
}
function Ux(n) {
  var e = n.ref;
  if (e !== null) {
    var t = n.stateNode;
    switch (n.tag) {
      case 5:
        n = t;
        break;
      default:
        n = t;
    }
    typeof e == "function" ? e(n) : (e.current = n);
  }
}
function hP(n) {
  var e = n.alternate;
  e !== null && ((n.alternate = null), hP(e)),
    (n.child = null),
    (n.deletions = null),
    (n.sibling = null),
    n.tag === 5 &&
      ((e = n.stateNode),
      e !== null &&
        (delete e[is], delete e[Sf], delete e[Mx], delete e[I4], delete e[N4])),
    (n.stateNode = null),
    (n.return = null),
    (n.dependencies = null),
    (n.memoizedProps = null),
    (n.memoizedState = null),
    (n.pendingProps = null),
    (n.stateNode = null),
    (n.updateQueue = null);
}
function dP(n) {
  return n.tag === 5 || n.tag === 3 || n.tag === 4;
}
function HE(n) {
  e: for (;;) {
    for (; n.sibling === null; ) {
      if (n.return === null || dP(n.return)) return null;
      n = n.return;
    }
    for (
      n.sibling.return = n.return, n = n.sibling;
      n.tag !== 5 && n.tag !== 6 && n.tag !== 18;

    ) {
      if (n.flags & 2 || n.child === null || n.tag === 4) continue e;
      (n.child.return = n), (n = n.child);
    }
    if (!(n.flags & 2)) return n.stateNode;
  }
}
function kx(n, e, t) {
  var i = n.tag;
  if (i === 5 || i === 6)
    (n = n.stateNode),
      e
        ? t.nodeType === 8
          ? t.parentNode.insertBefore(n, e)
          : t.insertBefore(n, e)
        : (t.nodeType === 8
            ? ((e = t.parentNode), e.insertBefore(n, t))
            : ((e = t), e.appendChild(n)),
          (t = t._reactRootContainer),
          t != null || e.onclick !== null || (e.onclick = wm));
  else if (i !== 4 && ((n = n.child), n !== null))
    for (kx(n, e, t), n = n.sibling; n !== null; ) kx(n, e, t), (n = n.sibling);
}
function Fx(n, e, t) {
  var i = n.tag;
  if (i === 5 || i === 6)
    (n = n.stateNode), e ? t.insertBefore(n, e) : t.appendChild(n);
  else if (i !== 4 && ((n = n.child), n !== null))
    for (Fx(n, e, t), n = n.sibling; n !== null; ) Fx(n, e, t), (n = n.sibling);
}
var Qn = null,
  Nr = !1;
function so(n, e, t) {
  for (t = t.child; t !== null; ) pP(n, e, t), (t = t.sibling);
}
function pP(n, e, t) {
  if (os && typeof os.onCommitFiberUnmount == "function")
    try {
      os.onCommitFiberUnmount(og, t);
    } catch {}
  switch (t.tag) {
    case 5:
      ci || au(t, e);
    case 6:
      var i = Qn,
        r = Nr;
      (Qn = null),
        so(n, e, t),
        (Qn = i),
        (Nr = r),
        Qn !== null &&
          (Nr
            ? ((n = Qn),
              (t = t.stateNode),
              n.nodeType === 8 ? n.parentNode.removeChild(t) : n.removeChild(t))
            : Qn.removeChild(t.stateNode));
      break;
    case 18:
      Qn !== null &&
        (Nr
          ? ((n = Qn),
            (t = t.stateNode),
            n.nodeType === 8
              ? I0(n.parentNode, t)
              : n.nodeType === 1 && I0(n, t),
            gf(n))
          : I0(Qn, t.stateNode));
      break;
    case 4:
      (i = Qn),
        (r = Nr),
        (Qn = t.stateNode.containerInfo),
        (Nr = !0),
        so(n, e, t),
        (Qn = i),
        (Nr = r);
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (
        !ci &&
        ((i = t.updateQueue), i !== null && ((i = i.lastEffect), i !== null))
      ) {
        r = i = i.next;
        do {
          var s = r,
            o = s.destroy;
          (s = s.tag),
            o !== void 0 && (s & 2 || s & 4) && Ox(t, e, o),
            (r = r.next);
        } while (r !== i);
      }
      so(n, e, t);
      break;
    case 1:
      if (
        !ci &&
        (au(t, e),
        (i = t.stateNode),
        typeof i.componentWillUnmount == "function")
      )
        try {
          (i.props = t.memoizedProps),
            (i.state = t.memoizedState),
            i.componentWillUnmount();
        } catch (a) {
          gn(t, e, a);
        }
      so(n, e, t);
      break;
    case 21:
      so(n, e, t);
      break;
    case 22:
      t.mode & 1
        ? ((ci = (i = ci) || t.memoizedState !== null), so(n, e, t), (ci = i))
        : so(n, e, t);
      break;
    default:
      so(n, e, t);
  }
}
function GE(n) {
  var e = n.updateQueue;
  if (e !== null) {
    n.updateQueue = null;
    var t = n.stateNode;
    t === null && (t = n.stateNode = new Z4()),
      e.forEach(function (i) {
        var r = sO.bind(null, n, i);
        t.has(i) || (t.add(i), i.then(r, r));
      });
  }
}
function br(n, e) {
  var t = e.deletions;
  if (t !== null)
    for (var i = 0; i < t.length; i++) {
      var r = t[i];
      try {
        var s = n,
          o = e,
          a = o;
        e: for (; a !== null; ) {
          switch (a.tag) {
            case 5:
              (Qn = a.stateNode), (Nr = !1);
              break e;
            case 3:
              (Qn = a.stateNode.containerInfo), (Nr = !0);
              break e;
            case 4:
              (Qn = a.stateNode.containerInfo), (Nr = !0);
              break e;
          }
          a = a.return;
        }
        if (Qn === null) throw Error(we(160));
        pP(s, o, r), (Qn = null), (Nr = !1);
        var u = r.alternate;
        u !== null && (u.return = null), (r.return = null);
      } catch (f) {
        gn(r, e, f);
      }
    }
  if (e.subtreeFlags & 12854)
    for (e = e.child; e !== null; ) mP(e, n), (e = e.sibling);
}
function mP(n, e) {
  var t = n.alternate,
    i = n.flags;
  switch (n.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      if ((br(e, n), es(n), i & 4)) {
        try {
          Qc(3, n, n.return), pg(3, n);
        } catch (w) {
          gn(n, n.return, w);
        }
        try {
          Qc(5, n, n.return);
        } catch (w) {
          gn(n, n.return, w);
        }
      }
      break;
    case 1:
      br(e, n), es(n), i & 512 && t !== null && au(t, t.return);
      break;
    case 5:
      if (
        (br(e, n),
        es(n),
        i & 512 && t !== null && au(t, t.return),
        n.flags & 32)
      ) {
        var r = n.stateNode;
        try {
          hf(r, "");
        } catch (w) {
          gn(n, n.return, w);
        }
      }
      if (i & 4 && ((r = n.stateNode), r != null)) {
        var s = n.memoizedProps,
          o = t !== null ? t.memoizedProps : s,
          a = n.type,
          u = n.updateQueue;
        if (((n.updateQueue = null), u !== null))
          try {
            a === "input" && s.type === "radio" && s.name != null && kb(r, s),
              lx(a, o);
            var f = lx(a, s);
            for (o = 0; o < u.length; o += 2) {
              var h = u[o],
                d = u[o + 1];
              h === "style"
                ? Hb(r, d)
                : h === "dangerouslySetInnerHTML"
                ? Bb(r, d)
                : h === "children"
                ? hf(r, d)
                : t1(r, h, d, f);
            }
            switch (a) {
              case "input":
                ix(r, s);
                break;
              case "textarea":
                Fb(r, s);
                break;
              case "select":
                var p = r._wrapperState.wasMultiple;
                r._wrapperState.wasMultiple = !!s.multiple;
                var m = s.value;
                m != null
                  ? xu(r, !!s.multiple, m, !1)
                  : p !== !!s.multiple &&
                    (s.defaultValue != null
                      ? xu(r, !!s.multiple, s.defaultValue, !0)
                      : xu(r, !!s.multiple, s.multiple ? [] : "", !1));
            }
            r[Sf] = s;
          } catch (w) {
            gn(n, n.return, w);
          }
      }
      break;
    case 6:
      if ((br(e, n), es(n), i & 4)) {
        if (n.stateNode === null) throw Error(we(162));
        (r = n.stateNode), (s = n.memoizedProps);
        try {
          r.nodeValue = s;
        } catch (w) {
          gn(n, n.return, w);
        }
      }
      break;
    case 3:
      if (
        (br(e, n), es(n), i & 4 && t !== null && t.memoizedState.isDehydrated)
      )
        try {
          gf(e.containerInfo);
        } catch (w) {
          gn(n, n.return, w);
        }
      break;
    case 4:
      br(e, n), es(n);
      break;
    case 13:
      br(e, n),
        es(n),
        (r = n.child),
        r.flags & 8192 &&
          ((s = r.memoizedState !== null),
          (r.stateNode.isHidden = s),
          !s ||
            (r.alternate !== null && r.alternate.memoizedState !== null) ||
            (D1 = Mn())),
        i & 4 && GE(n);
      break;
    case 22:
      if (
        ((h = t !== null && t.memoizedState !== null),
        n.mode & 1 ? ((ci = (f = ci) || h), br(e, n), (ci = f)) : br(e, n),
        es(n),
        i & 8192)
      ) {
        if (
          ((f = n.memoizedState !== null),
          (n.stateNode.isHidden = f) && !h && n.mode & 1)
        )
          for (Ge = n, h = n.child; h !== null; ) {
            for (d = Ge = h; Ge !== null; ) {
              switch (((p = Ge), (m = p.child), p.tag)) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Qc(4, p, p.return);
                  break;
                case 1:
                  au(p, p.return);
                  var y = p.stateNode;
                  if (typeof y.componentWillUnmount == "function") {
                    (i = p), (t = p.return);
                    try {
                      (e = i),
                        (y.props = e.memoizedProps),
                        (y.state = e.memoizedState),
                        y.componentWillUnmount();
                    } catch (w) {
                      gn(i, t, w);
                    }
                  }
                  break;
                case 5:
                  au(p, p.return);
                  break;
                case 22:
                  if (p.memoizedState !== null) {
                    jE(d);
                    continue;
                  }
              }
              m !== null ? ((m.return = p), (Ge = m)) : jE(d);
            }
            h = h.sibling;
          }
        e: for (h = null, d = n; ; ) {
          if (d.tag === 5) {
            if (h === null) {
              h = d;
              try {
                (r = d.stateNode),
                  f
                    ? ((s = r.style),
                      typeof s.setProperty == "function"
                        ? s.setProperty("display", "none", "important")
                        : (s.display = "none"))
                    : ((a = d.stateNode),
                      (u = d.memoizedProps.style),
                      (o =
                        u != null && u.hasOwnProperty("display")
                          ? u.display
                          : null),
                      (a.style.display = Vb("display", o)));
              } catch (w) {
                gn(n, n.return, w);
              }
            }
          } else if (d.tag === 6) {
            if (h === null)
              try {
                d.stateNode.nodeValue = f ? "" : d.memoizedProps;
              } catch (w) {
                gn(n, n.return, w);
              }
          } else if (
            ((d.tag !== 22 && d.tag !== 23) ||
              d.memoizedState === null ||
              d === n) &&
            d.child !== null
          ) {
            (d.child.return = d), (d = d.child);
            continue;
          }
          if (d === n) break e;
          for (; d.sibling === null; ) {
            if (d.return === null || d.return === n) break e;
            h === d && (h = null), (d = d.return);
          }
          h === d && (h = null), (d.sibling.return = d.return), (d = d.sibling);
        }
      }
      break;
    case 19:
      br(e, n), es(n), i & 4 && GE(n);
      break;
    case 21:
      break;
    default:
      br(e, n), es(n);
  }
}
function es(n) {
  var e = n.flags;
  if (e & 2) {
    try {
      e: {
        for (var t = n.return; t !== null; ) {
          if (dP(t)) {
            var i = t;
            break e;
          }
          t = t.return;
        }
        throw Error(we(160));
      }
      switch (i.tag) {
        case 5:
          var r = i.stateNode;
          i.flags & 32 && (hf(r, ""), (i.flags &= -33));
          var s = HE(n);
          Fx(n, s, r);
          break;
        case 3:
        case 4:
          var o = i.stateNode.containerInfo,
            a = HE(n);
          kx(n, a, o);
          break;
        default:
          throw Error(we(161));
      }
    } catch (u) {
      gn(n, n.return, u);
    }
    n.flags &= -3;
  }
  e & 4096 && (n.flags &= -4097);
}
function Q4(n, e, t) {
  (Ge = n), gP(n);
}
function gP(n, e, t) {
  for (var i = (n.mode & 1) !== 0; Ge !== null; ) {
    var r = Ge,
      s = r.child;
    if (r.tag === 22 && i) {
      var o = r.memoizedState !== null || zd;
      if (!o) {
        var a = r.alternate,
          u = (a !== null && a.memoizedState !== null) || ci;
        a = zd;
        var f = ci;
        if (((zd = o), (ci = u) && !f))
          for (Ge = r; Ge !== null; )
            (o = Ge),
              (u = o.child),
              o.tag === 22 && o.memoizedState !== null
                ? XE(r)
                : u !== null
                ? ((u.return = o), (Ge = u))
                : XE(r);
        for (; s !== null; ) (Ge = s), gP(s), (s = s.sibling);
        (Ge = r), (zd = a), (ci = f);
      }
      WE(n);
    } else
      r.subtreeFlags & 8772 && s !== null ? ((s.return = r), (Ge = s)) : WE(n);
  }
}
function WE(n) {
  for (; Ge !== null; ) {
    var e = Ge;
    if (e.flags & 8772) {
      var t = e.alternate;
      try {
        if (e.flags & 8772)
          switch (e.tag) {
            case 0:
            case 11:
            case 15:
              ci || pg(5, e);
              break;
            case 1:
              var i = e.stateNode;
              if (e.flags & 4 && !ci)
                if (t === null) i.componentDidMount();
                else {
                  var r =
                    e.elementType === e.type
                      ? t.memoizedProps
                      : Lr(e.type, t.memoizedProps);
                  i.componentDidUpdate(
                    r,
                    t.memoizedState,
                    i.__reactInternalSnapshotBeforeUpdate
                  );
                }
              var s = e.updateQueue;
              s !== null && CE(e, s, i);
              break;
            case 3:
              var o = e.updateQueue;
              if (o !== null) {
                if (((t = null), e.child !== null))
                  switch (e.child.tag) {
                    case 5:
                      t = e.child.stateNode;
                      break;
                    case 1:
                      t = e.child.stateNode;
                  }
                CE(e, o, t);
              }
              break;
            case 5:
              var a = e.stateNode;
              if (t === null && e.flags & 4) {
                t = a;
                var u = e.memoizedProps;
                switch (e.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    u.autoFocus && t.focus();
                    break;
                  case "img":
                    u.src && (t.src = u.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (e.memoizedState === null) {
                var f = e.alternate;
                if (f !== null) {
                  var h = f.memoizedState;
                  if (h !== null) {
                    var d = h.dehydrated;
                    d !== null && gf(d);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(we(163));
          }
        ci || (e.flags & 512 && Ux(e));
      } catch (p) {
        gn(e, e.return, p);
      }
    }
    if (e === n) {
      Ge = null;
      break;
    }
    if (((t = e.sibling), t !== null)) {
      (t.return = e.return), (Ge = t);
      break;
    }
    Ge = e.return;
  }
}
function jE(n) {
  for (; Ge !== null; ) {
    var e = Ge;
    if (e === n) {
      Ge = null;
      break;
    }
    var t = e.sibling;
    if (t !== null) {
      (t.return = e.return), (Ge = t);
      break;
    }
    Ge = e.return;
  }
}
function XE(n) {
  for (; Ge !== null; ) {
    var e = Ge;
    try {
      switch (e.tag) {
        case 0:
        case 11:
        case 15:
          var t = e.return;
          try {
            pg(4, e);
          } catch (u) {
            gn(e, t, u);
          }
          break;
        case 1:
          var i = e.stateNode;
          if (typeof i.componentDidMount == "function") {
            var r = e.return;
            try {
              i.componentDidMount();
            } catch (u) {
              gn(e, r, u);
            }
          }
          var s = e.return;
          try {
            Ux(e);
          } catch (u) {
            gn(e, s, u);
          }
          break;
        case 5:
          var o = e.return;
          try {
            Ux(e);
          } catch (u) {
            gn(e, o, u);
          }
      }
    } catch (u) {
      gn(e, e.return, u);
    }
    if (e === n) {
      Ge = null;
      break;
    }
    var a = e.sibling;
    if (a !== null) {
      (a.return = e.return), (Ge = a);
      break;
    }
    Ge = e.return;
  }
}
var $4 = Math.ceil,
  Dm = qs.ReactCurrentDispatcher,
  I1 = qs.ReactCurrentOwner,
  Mr = qs.ReactCurrentBatchConfig,
  Dt = 0,
  Xn = null,
  Ln = null,
  $n = 0,
  Ki = 0,
  lu = Yo(0),
  On = 0,
  bf = null,
  Za = 0,
  mg = 0,
  N1 = 0,
  $c = null,
  Di = null,
  D1 = 0,
  Iu = 1 / 0,
  bs = null,
  Om = !1,
  zx = null,
  Lo = null,
  Bd = !1,
  To = null,
  Um = 0,
  Jc = 0,
  Bx = null,
  tm = -1,
  nm = 0;
function Ei() {
  return Dt & 6 ? Mn() : tm !== -1 ? tm : (tm = Mn());
}
function Io(n) {
  return n.mode & 1
    ? Dt & 2 && $n !== 0
      ? $n & -$n
      : O4.transition !== null
      ? (nm === 0 && (nm = eC()), nm)
      : ((n = Vt),
        n !== 0 || ((n = window.event), (n = n === void 0 ? 16 : aC(n.type))),
        n)
    : 1;
}
function zr(n, e, t, i) {
  if (50 < Jc) throw ((Jc = 0), (Bx = null), Error(we(185)));
  eh(n, t, i),
    (!(Dt & 2) || n !== Xn) &&
      (n === Xn && (!(Dt & 2) && (mg |= t), On === 4 && Mo(n, $n)),
      Bi(n, i),
      t === 1 && Dt === 0 && !(e.mode & 1) && ((Iu = Mn() + 500), fg && qo()));
}
function Bi(n, e) {
  var t = n.callbackNode;
  OD(n, e);
  var i = xm(n, n === Xn ? $n : 0);
  if (i === 0)
    t !== null && tE(t), (n.callbackNode = null), (n.callbackPriority = 0);
  else if (((e = i & -i), n.callbackPriority !== e)) {
    if ((t != null && tE(t), e === 1))
      n.tag === 0 ? D4(YE.bind(null, n)) : AC(YE.bind(null, n)),
        R4(function () {
          !(Dt & 6) && qo();
        }),
        (t = null);
    else {
      switch (tC(i)) {
        case 1:
          t = o1;
          break;
        case 4:
          t = $b;
          break;
        case 16:
          t = ym;
          break;
        case 536870912:
          t = Jb;
          break;
        default:
          t = ym;
      }
      t = EP(t, vP.bind(null, n));
    }
    (n.callbackPriority = e), (n.callbackNode = t);
  }
}
function vP(n, e) {
  if (((tm = -1), (nm = 0), Dt & 6)) throw Error(we(327));
  var t = n.callbackNode;
  if (Eu() && n.callbackNode !== t) return null;
  var i = xm(n, n === Xn ? $n : 0);
  if (i === 0) return null;
  if (i & 30 || i & n.expiredLanes || e) e = km(n, i);
  else {
    e = i;
    var r = Dt;
    Dt |= 2;
    var s = xP();
    (Xn !== n || $n !== e) && ((bs = null), (Iu = Mn() + 500), Fa(n, e));
    do
      try {
        tO();
        break;
      } catch (a) {
        yP(n, a);
      }
    while (!0);
    x1(),
      (Dm.current = s),
      (Dt = r),
      Ln !== null ? (e = 0) : ((Xn = null), ($n = 0), (e = On));
  }
  if (e !== 0) {
    if (
      (e === 2 && ((r = dx(n)), r !== 0 && ((i = r), (e = Vx(n, r)))), e === 1)
    )
      throw ((t = bf), Fa(n, 0), Mo(n, i), Bi(n, Mn()), t);
    if (e === 6) Mo(n, i);
    else {
      if (
        ((r = n.current.alternate),
        !(i & 30) &&
          !J4(r) &&
          ((e = km(n, i)),
          e === 2 && ((s = dx(n)), s !== 0 && ((i = s), (e = Vx(n, s)))),
          e === 1))
      )
        throw ((t = bf), Fa(n, 0), Mo(n, i), Bi(n, Mn()), t);
      switch (((n.finishedWork = r), (n.finishedLanes = i), e)) {
        case 0:
        case 1:
          throw Error(we(345));
        case 2:
          Ma(n, Di, bs);
          break;
        case 3:
          if (
            (Mo(n, i), (i & 130023424) === i && ((e = D1 + 500 - Mn()), 10 < e))
          ) {
            if (xm(n, 0) !== 0) break;
            if (((r = n.suspendedLanes), (r & i) !== i)) {
              Ei(), (n.pingedLanes |= n.suspendedLanes & r);
              break;
            }
            n.timeoutHandle = Sx(Ma.bind(null, n, Di, bs), e);
            break;
          }
          Ma(n, Di, bs);
          break;
        case 4:
          if ((Mo(n, i), (i & 4194240) === i)) break;
          for (e = n.eventTimes, r = -1; 0 < i; ) {
            var o = 31 - Fr(i);
            (s = 1 << o), (o = e[o]), o > r && (r = o), (i &= ~s);
          }
          if (
            ((i = r),
            (i = Mn() - i),
            (i =
              (120 > i
                ? 120
                : 480 > i
                ? 480
                : 1080 > i
                ? 1080
                : 1920 > i
                ? 1920
                : 3e3 > i
                ? 3e3
                : 4320 > i
                ? 4320
                : 1960 * $4(i / 1960)) - i),
            10 < i)
          ) {
            n.timeoutHandle = Sx(Ma.bind(null, n, Di, bs), i);
            break;
          }
          Ma(n, Di, bs);
          break;
        case 5:
          Ma(n, Di, bs);
          break;
        default:
          throw Error(we(329));
      }
    }
  }
  return Bi(n, Mn()), n.callbackNode === t ? vP.bind(null, n) : null;
}
function Vx(n, e) {
  var t = $c;
  return (
    n.current.memoizedState.isDehydrated && (Fa(n, e).flags |= 256),
    (n = km(n, e)),
    n !== 2 && ((e = Di), (Di = t), e !== null && Hx(e)),
    n
  );
}
function Hx(n) {
  Di === null ? (Di = n) : Di.push.apply(Di, n);
}
function J4(n) {
  for (var e = n; ; ) {
    if (e.flags & 16384) {
      var t = e.updateQueue;
      if (t !== null && ((t = t.stores), t !== null))
        for (var i = 0; i < t.length; i++) {
          var r = t[i],
            s = r.getSnapshot;
          r = r.value;
          try {
            if (!Br(s(), r)) return !1;
          } catch {
            return !1;
          }
        }
    }
    if (((t = e.child), e.subtreeFlags & 16384 && t !== null))
      (t.return = e), (e = t);
    else {
      if (e === n) break;
      for (; e.sibling === null; ) {
        if (e.return === null || e.return === n) return !0;
        e = e.return;
      }
      (e.sibling.return = e.return), (e = e.sibling);
    }
  }
  return !0;
}
function Mo(n, e) {
  for (
    e &= ~N1,
      e &= ~mg,
      n.suspendedLanes |= e,
      n.pingedLanes &= ~e,
      n = n.expirationTimes;
    0 < e;

  ) {
    var t = 31 - Fr(e),
      i = 1 << t;
    (n[t] = -1), (e &= ~i);
  }
}
function YE(n) {
  if (Dt & 6) throw Error(we(327));
  Eu();
  var e = xm(n, 0);
  if (!(e & 1)) return Bi(n, Mn()), null;
  var t = km(n, e);
  if (n.tag !== 0 && t === 2) {
    var i = dx(n);
    i !== 0 && ((e = i), (t = Vx(n, i)));
  }
  if (t === 1) throw ((t = bf), Fa(n, 0), Mo(n, e), Bi(n, Mn()), t);
  if (t === 6) throw Error(we(345));
  return (
    (n.finishedWork = n.current.alternate),
    (n.finishedLanes = e),
    Ma(n, Di, bs),
    Bi(n, Mn()),
    null
  );
}
function O1(n, e) {
  var t = Dt;
  Dt |= 1;
  try {
    return n(e);
  } finally {
    (Dt = t), Dt === 0 && ((Iu = Mn() + 500), fg && qo());
  }
}
function Ka(n) {
  To !== null && To.tag === 0 && !(Dt & 6) && Eu();
  var e = Dt;
  Dt |= 1;
  var t = Mr.transition,
    i = Vt;
  try {
    if (((Mr.transition = null), (Vt = 1), n)) return n();
  } finally {
    (Vt = i), (Mr.transition = t), (Dt = e), !(Dt & 6) && qo();
  }
}
function U1() {
  (Ki = lu.current), Qt(lu);
}
function Fa(n, e) {
  (n.finishedWork = null), (n.finishedLanes = 0);
  var t = n.timeoutHandle;
  if ((t !== -1 && ((n.timeoutHandle = -1), P4(t)), Ln !== null))
    for (t = Ln.return; t !== null; ) {
      var i = t;
      switch ((g1(i), i.tag)) {
        case 1:
          (i = i.type.childContextTypes), i != null && Em();
          break;
        case 3:
          Ru(), Qt(Fi), Qt(pi), T1();
          break;
        case 5:
          E1(i);
          break;
        case 4:
          Ru();
          break;
        case 13:
          Qt(ln);
          break;
        case 19:
          Qt(ln);
          break;
        case 10:
          _1(i.type._context);
          break;
        case 22:
        case 23:
          U1();
      }
      t = t.return;
    }
  if (
    ((Xn = n),
    (Ln = n = No(n.current, null)),
    ($n = Ki = e),
    (On = 0),
    (bf = null),
    (N1 = mg = Za = 0),
    (Di = $c = null),
    La !== null)
  ) {
    for (e = 0; e < La.length; e++)
      if (((t = La[e]), (i = t.interleaved), i !== null)) {
        t.interleaved = null;
        var r = i.next,
          s = t.pending;
        if (s !== null) {
          var o = s.next;
          (s.next = r), (i.next = o);
        }
        t.pending = i;
      }
    La = null;
  }
  return n;
}
function yP(n, e) {
  do {
    var t = Ln;
    try {
      if ((x1(), ($p.current = Nm), Im)) {
        for (var i = fn.memoizedState; i !== null; ) {
          var r = i.queue;
          r !== null && (r.pending = null), (i = i.next);
        }
        Im = !1;
      }
      if (
        ((qa = 0),
        (jn = Nn = fn = null),
        (Kc = !1),
        (Ef = 0),
        (I1.current = null),
        t === null || t.return === null)
      ) {
        (On = 1), (bf = e), (Ln = null);
        break;
      }
      e: {
        var s = n,
          o = t.return,
          a = t,
          u = e;
        if (
          ((e = $n),
          (a.flags |= 32768),
          u !== null && typeof u == "object" && typeof u.then == "function")
        ) {
          var f = u,
            h = a,
            d = h.tag;
          if (!(h.mode & 1) && (d === 0 || d === 11 || d === 15)) {
            var p = h.alternate;
            p
              ? ((h.updateQueue = p.updateQueue),
                (h.memoizedState = p.memoizedState),
                (h.lanes = p.lanes))
              : ((h.updateQueue = null), (h.memoizedState = null));
          }
          var m = DE(o);
          if (m !== null) {
            (m.flags &= -257),
              OE(m, o, a, s, e),
              m.mode & 1 && NE(s, f, e),
              (e = m),
              (u = f);
            var y = e.updateQueue;
            if (y === null) {
              var w = new Set();
              w.add(u), (e.updateQueue = w);
            } else y.add(u);
            break e;
          } else {
            if (!(e & 1)) {
              NE(s, f, e), k1();
              break e;
            }
            u = Error(we(426));
          }
        } else if (nn && a.mode & 1) {
          var S = DE(o);
          if (S !== null) {
            !(S.flags & 65536) && (S.flags |= 256),
              OE(S, o, a, s, e),
              v1(Lu(u, a));
            break e;
          }
        }
        (s = u = Lu(u, a)),
          On !== 4 && (On = 2),
          $c === null ? ($c = [s]) : $c.push(s),
          (s = o);
        do {
          switch (s.tag) {
            case 3:
              (s.flags |= 65536), (e &= -e), (s.lanes |= e);
              var v = tP(s, u, e);
              bE(s, v);
              break e;
            case 1:
              a = u;
              var M = s.type,
                _ = s.stateNode;
              if (
                !(s.flags & 128) &&
                (typeof M.getDerivedStateFromError == "function" ||
                  (_ !== null &&
                    typeof _.componentDidCatch == "function" &&
                    (Lo === null || !Lo.has(_))))
              ) {
                (s.flags |= 65536), (e &= -e), (s.lanes |= e);
                var T = nP(s, a, e);
                bE(s, T);
                break e;
              }
          }
          s = s.return;
        } while (s !== null);
      }
      SP(t);
    } catch (P) {
      (e = P), Ln === t && t !== null && (Ln = t = t.return);
      continue;
    }
    break;
  } while (!0);
}
function xP() {
  var n = Dm.current;
  return (Dm.current = Nm), n === null ? Nm : n;
}
function k1() {
  (On === 0 || On === 3 || On === 2) && (On = 4),
    Xn === null || (!(Za & 268435455) && !(mg & 268435455)) || Mo(Xn, $n);
}
function km(n, e) {
  var t = Dt;
  Dt |= 2;
  var i = xP();
  (Xn !== n || $n !== e) && ((bs = null), Fa(n, e));
  do
    try {
      eO();
      break;
    } catch (r) {
      yP(n, r);
    }
  while (!0);
  if ((x1(), (Dt = t), (Dm.current = i), Ln !== null)) throw Error(we(261));
  return (Xn = null), ($n = 0), On;
}
function eO() {
  for (; Ln !== null; ) _P(Ln);
}
function tO() {
  for (; Ln !== null && !AD(); ) _P(Ln);
}
function _P(n) {
  var e = wP(n.alternate, n, Ki);
  (n.memoizedProps = n.pendingProps),
    e === null ? SP(n) : (Ln = e),
    (I1.current = null);
}
function SP(n) {
  var e = n;
  do {
    var t = e.alternate;
    if (((n = e.return), e.flags & 32768)) {
      if (((t = q4(t, e)), t !== null)) {
        (t.flags &= 32767), (Ln = t);
        return;
      }
      if (n !== null)
        (n.flags |= 32768), (n.subtreeFlags = 0), (n.deletions = null);
      else {
        (On = 6), (Ln = null);
        return;
      }
    } else if (((t = Y4(t, e, Ki)), t !== null)) {
      Ln = t;
      return;
    }
    if (((e = e.sibling), e !== null)) {
      Ln = e;
      return;
    }
    Ln = e = n;
  } while (e !== null);
  On === 0 && (On = 5);
}
function Ma(n, e, t) {
  var i = Vt,
    r = Mr.transition;
  try {
    (Mr.transition = null), (Vt = 1), nO(n, e, t, i);
  } finally {
    (Mr.transition = r), (Vt = i);
  }
  return null;
}
function nO(n, e, t, i) {
  do Eu();
  while (To !== null);
  if (Dt & 6) throw Error(we(327));
  t = n.finishedWork;
  var r = n.finishedLanes;
  if (t === null) return null;
  if (((n.finishedWork = null), (n.finishedLanes = 0), t === n.current))
    throw Error(we(177));
  (n.callbackNode = null), (n.callbackPriority = 0);
  var s = t.lanes | t.childLanes;
  if (
    (UD(n, s),
    n === Xn && ((Ln = Xn = null), ($n = 0)),
    (!(t.subtreeFlags & 2064) && !(t.flags & 2064)) ||
      Bd ||
      ((Bd = !0),
      EP(ym, function () {
        return Eu(), null;
      })),
    (s = (t.flags & 15990) !== 0),
    t.subtreeFlags & 15990 || s)
  ) {
    (s = Mr.transition), (Mr.transition = null);
    var o = Vt;
    Vt = 1;
    var a = Dt;
    (Dt |= 4),
      (I1.current = null),
      K4(n, t),
      mP(t, n),
      M4(xx),
      (_m = !!yx),
      (xx = yx = null),
      (n.current = t),
      Q4(t),
      bD(),
      (Dt = a),
      (Vt = o),
      (Mr.transition = s);
  } else n.current = t;
  if (
    (Bd && ((Bd = !1), (To = n), (Um = r)),
    (s = n.pendingLanes),
    s === 0 && (Lo = null),
    RD(t.stateNode),
    Bi(n, Mn()),
    e !== null)
  )
    for (i = n.onRecoverableError, t = 0; t < e.length; t++)
      (r = e[t]), i(r.value, { componentStack: r.stack, digest: r.digest });
  if (Om) throw ((Om = !1), (n = zx), (zx = null), n);
  return (
    Um & 1 && n.tag !== 0 && Eu(),
    (s = n.pendingLanes),
    s & 1 ? (n === Bx ? Jc++ : ((Jc = 0), (Bx = n))) : (Jc = 0),
    qo(),
    null
  );
}
function Eu() {
  if (To !== null) {
    var n = tC(Um),
      e = Mr.transition,
      t = Vt;
    try {
      if (((Mr.transition = null), (Vt = 16 > n ? 16 : n), To === null))
        var i = !1;
      else {
        if (((n = To), (To = null), (Um = 0), Dt & 6)) throw Error(we(331));
        var r = Dt;
        for (Dt |= 4, Ge = n.current; Ge !== null; ) {
          var s = Ge,
            o = s.child;
          if (Ge.flags & 16) {
            var a = s.deletions;
            if (a !== null) {
              for (var u = 0; u < a.length; u++) {
                var f = a[u];
                for (Ge = f; Ge !== null; ) {
                  var h = Ge;
                  switch (h.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qc(8, h, s);
                  }
                  var d = h.child;
                  if (d !== null) (d.return = h), (Ge = d);
                  else
                    for (; Ge !== null; ) {
                      h = Ge;
                      var p = h.sibling,
                        m = h.return;
                      if ((hP(h), h === f)) {
                        Ge = null;
                        break;
                      }
                      if (p !== null) {
                        (p.return = m), (Ge = p);
                        break;
                      }
                      Ge = m;
                    }
                }
              }
              var y = s.alternate;
              if (y !== null) {
                var w = y.child;
                if (w !== null) {
                  y.child = null;
                  do {
                    var S = w.sibling;
                    (w.sibling = null), (w = S);
                  } while (w !== null);
                }
              }
              Ge = s;
            }
          }
          if (s.subtreeFlags & 2064 && o !== null) (o.return = s), (Ge = o);
          else
            e: for (; Ge !== null; ) {
              if (((s = Ge), s.flags & 2048))
                switch (s.tag) {
                  case 0:
                  case 11:
                  case 15:
                    Qc(9, s, s.return);
                }
              var v = s.sibling;
              if (v !== null) {
                (v.return = s.return), (Ge = v);
                break e;
              }
              Ge = s.return;
            }
        }
        var M = n.current;
        for (Ge = M; Ge !== null; ) {
          o = Ge;
          var _ = o.child;
          if (o.subtreeFlags & 2064 && _ !== null) (_.return = o), (Ge = _);
          else
            e: for (o = M; Ge !== null; ) {
              if (((a = Ge), a.flags & 2048))
                try {
                  switch (a.tag) {
                    case 0:
                    case 11:
                    case 15:
                      pg(9, a);
                  }
                } catch (P) {
                  gn(a, a.return, P);
                }
              if (a === o) {
                Ge = null;
                break e;
              }
              var T = a.sibling;
              if (T !== null) {
                (T.return = a.return), (Ge = T);
                break e;
              }
              Ge = a.return;
            }
        }
        if (
          ((Dt = r), qo(), os && typeof os.onPostCommitFiberRoot == "function")
        )
          try {
            os.onPostCommitFiberRoot(og, n);
          } catch {}
        i = !0;
      }
      return i;
    } finally {
      (Vt = t), (Mr.transition = e);
    }
  }
  return !1;
}
function qE(n, e, t) {
  (e = Lu(t, e)),
    (e = tP(n, e, 1)),
    (n = Ro(n, e, 1)),
    (e = Ei()),
    n !== null && (eh(n, 1, e), Bi(n, e));
}
function gn(n, e, t) {
  if (n.tag === 3) qE(n, n, t);
  else
    for (; e !== null; ) {
      if (e.tag === 3) {
        qE(e, n, t);
        break;
      } else if (e.tag === 1) {
        var i = e.stateNode;
        if (
          typeof e.type.getDerivedStateFromError == "function" ||
          (typeof i.componentDidCatch == "function" &&
            (Lo === null || !Lo.has(i)))
        ) {
          (n = Lu(t, n)),
            (n = nP(e, n, 1)),
            (e = Ro(e, n, 1)),
            (n = Ei()),
            e !== null && (eh(e, 1, n), Bi(e, n));
          break;
        }
      }
      e = e.return;
    }
}
function iO(n, e, t) {
  var i = n.pingCache;
  i !== null && i.delete(e),
    (e = Ei()),
    (n.pingedLanes |= n.suspendedLanes & t),
    Xn === n &&
      ($n & t) === t &&
      (On === 4 || (On === 3 && ($n & 130023424) === $n && 500 > Mn() - D1)
        ? Fa(n, 0)
        : (N1 |= t)),
    Bi(n, e);
}
function MP(n, e) {
  e === 0 &&
    (n.mode & 1
      ? ((e = Rd), (Rd <<= 1), !(Rd & 130023424) && (Rd = 4194304))
      : (e = 1));
  var t = Ei();
  (n = Hs(n, e)), n !== null && (eh(n, e, t), Bi(n, t));
}
function rO(n) {
  var e = n.memoizedState,
    t = 0;
  e !== null && (t = e.retryLane), MP(n, t);
}
function sO(n, e) {
  var t = 0;
  switch (n.tag) {
    case 13:
      var i = n.stateNode,
        r = n.memoizedState;
      r !== null && (t = r.retryLane);
      break;
    case 19:
      i = n.stateNode;
      break;
    default:
      throw Error(we(314));
  }
  i !== null && i.delete(e), MP(n, t);
}
var wP;
wP = function (n, e, t) {
  if (n !== null)
    if (n.memoizedProps !== e.pendingProps || Fi.current) ki = !0;
    else {
      if (!(n.lanes & t) && !(e.flags & 128)) return (ki = !1), X4(n, e, t);
      ki = !!(n.flags & 131072);
    }
  else (ki = !1), nn && e.flags & 1048576 && bC(e, bm, e.index);
  switch (((e.lanes = 0), e.tag)) {
    case 2:
      var i = e.type;
      em(n, e), (n = e.pendingProps);
      var r = bu(e, pi.current);
      wu(e, t), (r = b1(null, e, i, n, r, t));
      var s = C1();
      return (
        (e.flags |= 1),
        typeof r == "object" &&
        r !== null &&
        typeof r.render == "function" &&
        r.$$typeof === void 0
          ? ((e.tag = 1),
            (e.memoizedState = null),
            (e.updateQueue = null),
            zi(i) ? ((s = !0), Tm(e)) : (s = !1),
            (e.memoizedState =
              r.state !== null && r.state !== void 0 ? r.state : null),
            M1(e),
            (r.updater = dg),
            (e.stateNode = r),
            (r._reactInternals = e),
            Cx(e, i, n, t),
            (e = Lx(null, e, i, !0, s, t)))
          : ((e.tag = 0), nn && s && m1(e), Mi(null, e, r, t), (e = e.child)),
        e
      );
    case 16:
      i = e.elementType;
      e: {
        switch (
          (em(n, e),
          (n = e.pendingProps),
          (r = i._init),
          (i = r(i._payload)),
          (e.type = i),
          (r = e.tag = aO(i)),
          (n = Lr(i, n)),
          r)
        ) {
          case 0:
            e = Rx(null, e, i, n, t);
            break e;
          case 1:
            e = FE(null, e, i, n, t);
            break e;
          case 11:
            e = UE(null, e, i, n, t);
            break e;
          case 14:
            e = kE(null, e, i, Lr(i.type, n), t);
            break e;
        }
        throw Error(we(306, i, ""));
      }
      return e;
    case 0:
      return (
        (i = e.type),
        (r = e.pendingProps),
        (r = e.elementType === i ? r : Lr(i, r)),
        Rx(n, e, i, r, t)
      );
    case 1:
      return (
        (i = e.type),
        (r = e.pendingProps),
        (r = e.elementType === i ? r : Lr(i, r)),
        FE(n, e, i, r, t)
      );
    case 3:
      e: {
        if ((oP(e), n === null)) throw Error(we(387));
        (i = e.pendingProps),
          (s = e.memoizedState),
          (r = s.element),
          NC(n, e),
          Rm(e, i, null, t);
        var o = e.memoizedState;
        if (((i = o.element), s.isDehydrated))
          if (
            ((s = {
              element: i,
              isDehydrated: !1,
              cache: o.cache,
              pendingSuspenseBoundaries: o.pendingSuspenseBoundaries,
              transitions: o.transitions,
            }),
            (e.updateQueue.baseState = s),
            (e.memoizedState = s),
            e.flags & 256)
          ) {
            (r = Lu(Error(we(423)), e)), (e = zE(n, e, i, t, r));
            break e;
          } else if (i !== r) {
            (r = Lu(Error(we(424)), e)), (e = zE(n, e, i, t, r));
            break e;
          } else
            for (
              $i = Po(e.stateNode.containerInfo.firstChild),
                Ji = e,
                nn = !0,
                Dr = null,
                t = LC(e, null, i, t),
                e.child = t;
              t;

            )
              (t.flags = (t.flags & -3) | 4096), (t = t.sibling);
        else {
          if ((Cu(), i === r)) {
            e = Gs(n, e, t);
            break e;
          }
          Mi(n, e, i, t);
        }
        e = e.child;
      }
      return e;
    case 5:
      return (
        DC(e),
        n === null && Tx(e),
        (i = e.type),
        (r = e.pendingProps),
        (s = n !== null ? n.memoizedProps : null),
        (o = r.children),
        _x(i, r) ? (o = null) : s !== null && _x(i, s) && (e.flags |= 32),
        sP(n, e),
        Mi(n, e, o, t),
        e.child
      );
    case 6:
      return n === null && Tx(e), null;
    case 13:
      return aP(n, e, t);
    case 4:
      return (
        w1(e, e.stateNode.containerInfo),
        (i = e.pendingProps),
        n === null ? (e.child = Pu(e, null, i, t)) : Mi(n, e, i, t),
        e.child
      );
    case 11:
      return (
        (i = e.type),
        (r = e.pendingProps),
        (r = e.elementType === i ? r : Lr(i, r)),
        UE(n, e, i, r, t)
      );
    case 7:
      return Mi(n, e, e.pendingProps, t), e.child;
    case 8:
      return Mi(n, e, e.pendingProps.children, t), e.child;
    case 12:
      return Mi(n, e, e.pendingProps.children, t), e.child;
    case 10:
      e: {
        if (
          ((i = e.type._context),
          (r = e.pendingProps),
          (s = e.memoizedProps),
          (o = r.value),
          Xt(Cm, i._currentValue),
          (i._currentValue = o),
          s !== null)
        )
          if (Br(s.value, o)) {
            if (s.children === r.children && !Fi.current) {
              e = Gs(n, e, t);
              break e;
            }
          } else
            for (s = e.child, s !== null && (s.return = e); s !== null; ) {
              var a = s.dependencies;
              if (a !== null) {
                o = s.child;
                for (var u = a.firstContext; u !== null; ) {
                  if (u.context === i) {
                    if (s.tag === 1) {
                      (u = Us(-1, t & -t)), (u.tag = 2);
                      var f = s.updateQueue;
                      if (f !== null) {
                        f = f.shared;
                        var h = f.pending;
                        h === null
                          ? (u.next = u)
                          : ((u.next = h.next), (h.next = u)),
                          (f.pending = u);
                      }
                    }
                    (s.lanes |= t),
                      (u = s.alternate),
                      u !== null && (u.lanes |= t),
                      Ax(s.return, t, e),
                      (a.lanes |= t);
                    break;
                  }
                  u = u.next;
                }
              } else if (s.tag === 10) o = s.type === e.type ? null : s.child;
              else if (s.tag === 18) {
                if (((o = s.return), o === null)) throw Error(we(341));
                (o.lanes |= t),
                  (a = o.alternate),
                  a !== null && (a.lanes |= t),
                  Ax(o, t, e),
                  (o = s.sibling);
              } else o = s.child;
              if (o !== null) o.return = s;
              else
                for (o = s; o !== null; ) {
                  if (o === e) {
                    o = null;
                    break;
                  }
                  if (((s = o.sibling), s !== null)) {
                    (s.return = o.return), (o = s);
                    break;
                  }
                  o = o.return;
                }
              s = o;
            }
        Mi(n, e, r.children, t), (e = e.child);
      }
      return e;
    case 9:
      return (
        (r = e.type),
        (i = e.pendingProps.children),
        wu(e, t),
        (r = wr(r)),
        (i = i(r)),
        (e.flags |= 1),
        Mi(n, e, i, t),
        e.child
      );
    case 14:
      return (
        (i = e.type),
        (r = Lr(i, e.pendingProps)),
        (r = Lr(i.type, r)),
        kE(n, e, i, r, t)
      );
    case 15:
      return iP(n, e, e.type, e.pendingProps, t);
    case 17:
      return (
        (i = e.type),
        (r = e.pendingProps),
        (r = e.elementType === i ? r : Lr(i, r)),
        em(n, e),
        (e.tag = 1),
        zi(i) ? ((n = !0), Tm(e)) : (n = !1),
        wu(e, t),
        eP(e, i, r),
        Cx(e, i, r, t),
        Lx(null, e, i, !0, n, t)
      );
    case 19:
      return lP(n, e, t);
    case 22:
      return rP(n, e, t);
  }
  throw Error(we(156, e.tag));
};
function EP(n, e) {
  return Qb(n, e);
}
function oO(n, e, t, i) {
  (this.tag = n),
    (this.key = t),
    (this.sibling =
      this.child =
      this.return =
      this.stateNode =
      this.type =
      this.elementType =
        null),
    (this.index = 0),
    (this.ref = null),
    (this.pendingProps = e),
    (this.dependencies =
      this.memoizedState =
      this.updateQueue =
      this.memoizedProps =
        null),
    (this.mode = i),
    (this.subtreeFlags = this.flags = 0),
    (this.deletions = null),
    (this.childLanes = this.lanes = 0),
    (this.alternate = null);
}
function Sr(n, e, t, i) {
  return new oO(n, e, t, i);
}
function F1(n) {
  return (n = n.prototype), !(!n || !n.isReactComponent);
}
function aO(n) {
  if (typeof n == "function") return F1(n) ? 1 : 0;
  if (n != null) {
    if (((n = n.$$typeof), n === i1)) return 11;
    if (n === r1) return 14;
  }
  return 2;
}
function No(n, e) {
  var t = n.alternate;
  return (
    t === null
      ? ((t = Sr(n.tag, e, n.key, n.mode)),
        (t.elementType = n.elementType),
        (t.type = n.type),
        (t.stateNode = n.stateNode),
        (t.alternate = n),
        (n.alternate = t))
      : ((t.pendingProps = e),
        (t.type = n.type),
        (t.flags = 0),
        (t.subtreeFlags = 0),
        (t.deletions = null)),
    (t.flags = n.flags & 14680064),
    (t.childLanes = n.childLanes),
    (t.lanes = n.lanes),
    (t.child = n.child),
    (t.memoizedProps = n.memoizedProps),
    (t.memoizedState = n.memoizedState),
    (t.updateQueue = n.updateQueue),
    (e = n.dependencies),
    (t.dependencies =
      e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }),
    (t.sibling = n.sibling),
    (t.index = n.index),
    (t.ref = n.ref),
    t
  );
}
function im(n, e, t, i, r, s) {
  var o = 2;
  if (((i = n), typeof n == "function")) F1(n) && (o = 1);
  else if (typeof n == "string") o = 5;
  else
    e: switch (n) {
      case $l:
        return za(t.children, r, s, e);
      case n1:
        (o = 8), (r |= 8);
        break;
      case $y:
        return (
          (n = Sr(12, t, e, r | 2)), (n.elementType = $y), (n.lanes = s), n
        );
      case Jy:
        return (n = Sr(13, t, e, r)), (n.elementType = Jy), (n.lanes = s), n;
      case ex:
        return (n = Sr(19, t, e, r)), (n.elementType = ex), (n.lanes = s), n;
      case Db:
        return gg(t, r, s, e);
      default:
        if (typeof n == "object" && n !== null)
          switch (n.$$typeof) {
            case Ib:
              o = 10;
              break e;
            case Nb:
              o = 9;
              break e;
            case i1:
              o = 11;
              break e;
            case r1:
              o = 14;
              break e;
            case yo:
              (o = 16), (i = null);
              break e;
          }
        throw Error(we(130, n == null ? n : typeof n, ""));
    }
  return (
    (e = Sr(o, t, e, r)), (e.elementType = n), (e.type = i), (e.lanes = s), e
  );
}
function za(n, e, t, i) {
  return (n = Sr(7, n, i, e)), (n.lanes = t), n;
}
function gg(n, e, t, i) {
  return (
    (n = Sr(22, n, i, e)),
    (n.elementType = Db),
    (n.lanes = t),
    (n.stateNode = { isHidden: !1 }),
    n
  );
}
function B0(n, e, t) {
  return (n = Sr(6, n, null, e)), (n.lanes = t), n;
}
function V0(n, e, t) {
  return (
    (e = Sr(4, n.children !== null ? n.children : [], n.key, e)),
    (e.lanes = t),
    (e.stateNode = {
      containerInfo: n.containerInfo,
      pendingChildren: null,
      implementation: n.implementation,
    }),
    e
  );
}
function lO(n, e, t, i, r) {
  (this.tag = e),
    (this.containerInfo = n),
    (this.finishedWork =
      this.pingCache =
      this.current =
      this.pendingChildren =
        null),
    (this.timeoutHandle = -1),
    (this.callbackNode = this.pendingContext = this.context = null),
    (this.callbackPriority = 0),
    (this.eventTimes = S0(0)),
    (this.expirationTimes = S0(-1)),
    (this.entangledLanes =
      this.finishedLanes =
      this.mutableReadLanes =
      this.expiredLanes =
      this.pingedLanes =
      this.suspendedLanes =
      this.pendingLanes =
        0),
    (this.entanglements = S0(0)),
    (this.identifierPrefix = i),
    (this.onRecoverableError = r),
    (this.mutableSourceEagerHydrationData = null);
}
function z1(n, e, t, i, r, s, o, a, u) {
  return (
    (n = new lO(n, e, t, a, u)),
    e === 1 ? ((e = 1), s === !0 && (e |= 8)) : (e = 0),
    (s = Sr(3, null, null, e)),
    (n.current = s),
    (s.stateNode = n),
    (s.memoizedState = {
      element: i,
      isDehydrated: t,
      cache: null,
      transitions: null,
      pendingSuspenseBoundaries: null,
    }),
    M1(s),
    n
  );
}
function uO(n, e, t) {
  var i = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
  return {
    $$typeof: Ql,
    key: i == null ? null : "" + i,
    children: n,
    containerInfo: e,
    implementation: t,
  };
}
function TP(n) {
  if (!n) return Bo;
  n = n._reactInternals;
  e: {
    if (tl(n) !== n || n.tag !== 1) throw Error(we(170));
    var e = n;
    do {
      switch (e.tag) {
        case 3:
          e = e.stateNode.context;
          break e;
        case 1:
          if (zi(e.type)) {
            e = e.stateNode.__reactInternalMemoizedMergedChildContext;
            break e;
          }
      }
      e = e.return;
    } while (e !== null);
    throw Error(we(171));
  }
  if (n.tag === 1) {
    var t = n.type;
    if (zi(t)) return TC(n, t, e);
  }
  return e;
}
function AP(n, e, t, i, r, s, o, a, u) {
  return (
    (n = z1(t, i, !0, n, r, s, o, a, u)),
    (n.context = TP(null)),
    (t = n.current),
    (i = Ei()),
    (r = Io(t)),
    (s = Us(i, r)),
    (s.callback = e ?? null),
    Ro(t, s, r),
    (n.current.lanes = r),
    eh(n, r, i),
    Bi(n, i),
    n
  );
}
function vg(n, e, t, i) {
  var r = e.current,
    s = Ei(),
    o = Io(r);
  return (
    (t = TP(t)),
    e.context === null ? (e.context = t) : (e.pendingContext = t),
    (e = Us(s, o)),
    (e.payload = { element: n }),
    (i = i === void 0 ? null : i),
    i !== null && (e.callback = i),
    (n = Ro(r, e, o)),
    n !== null && (zr(n, r, o, s), Qp(n, r, o)),
    o
  );
}
function Fm(n) {
  if (((n = n.current), !n.child)) return null;
  switch (n.child.tag) {
    case 5:
      return n.child.stateNode;
    default:
      return n.child.stateNode;
  }
}
function ZE(n, e) {
  if (((n = n.memoizedState), n !== null && n.dehydrated !== null)) {
    var t = n.retryLane;
    n.retryLane = t !== 0 && t < e ? t : e;
  }
}
function B1(n, e) {
  ZE(n, e), (n = n.alternate) && ZE(n, e);
}
function cO() {
  return null;
}
var bP =
  typeof reportError == "function"
    ? reportError
    : function (n) {
        console.error(n);
      };
function V1(n) {
  this._internalRoot = n;
}
yg.prototype.render = V1.prototype.render = function (n) {
  var e = this._internalRoot;
  if (e === null) throw Error(we(409));
  vg(n, e, null, null);
};
yg.prototype.unmount = V1.prototype.unmount = function () {
  var n = this._internalRoot;
  if (n !== null) {
    this._internalRoot = null;
    var e = n.containerInfo;
    Ka(function () {
      vg(null, n, null, null);
    }),
      (e[Vs] = null);
  }
};
function yg(n) {
  this._internalRoot = n;
}
yg.prototype.unstable_scheduleHydration = function (n) {
  if (n) {
    var e = rC();
    n = { blockedOn: null, target: n, priority: e };
    for (var t = 0; t < So.length && e !== 0 && e < So[t].priority; t++);
    So.splice(t, 0, n), t === 0 && oC(n);
  }
};
function H1(n) {
  return !(!n || (n.nodeType !== 1 && n.nodeType !== 9 && n.nodeType !== 11));
}
function xg(n) {
  return !(
    !n ||
    (n.nodeType !== 1 &&
      n.nodeType !== 9 &&
      n.nodeType !== 11 &&
      (n.nodeType !== 8 || n.nodeValue !== " react-mount-point-unstable "))
  );
}
function KE() {}
function fO(n, e, t, i, r) {
  if (r) {
    if (typeof i == "function") {
      var s = i;
      i = function () {
        var f = Fm(o);
        s.call(f);
      };
    }
    var o = AP(e, i, n, 0, null, !1, !1, "", KE);
    return (
      (n._reactRootContainer = o),
      (n[Vs] = o.current),
      xf(n.nodeType === 8 ? n.parentNode : n),
      Ka(),
      o
    );
  }
  for (; (r = n.lastChild); ) n.removeChild(r);
  if (typeof i == "function") {
    var a = i;
    i = function () {
      var f = Fm(u);
      a.call(f);
    };
  }
  var u = z1(n, 0, !1, null, null, !1, !1, "", KE);
  return (
    (n._reactRootContainer = u),
    (n[Vs] = u.current),
    xf(n.nodeType === 8 ? n.parentNode : n),
    Ka(function () {
      vg(e, u, t, i);
    }),
    u
  );
}
function _g(n, e, t, i, r) {
  var s = t._reactRootContainer;
  if (s) {
    var o = s;
    if (typeof r == "function") {
      var a = r;
      r = function () {
        var u = Fm(o);
        a.call(u);
      };
    }
    vg(e, o, n, r);
  } else o = fO(t, e, n, r, i);
  return Fm(o);
}
nC = function (n) {
  switch (n.tag) {
    case 3:
      var e = n.stateNode;
      if (e.current.memoizedState.isDehydrated) {
        var t = Vc(e.pendingLanes);
        t !== 0 &&
          (a1(e, t | 1), Bi(e, Mn()), !(Dt & 6) && ((Iu = Mn() + 500), qo()));
      }
      break;
    case 13:
      Ka(function () {
        var i = Hs(n, 1);
        if (i !== null) {
          var r = Ei();
          zr(i, n, 1, r);
        }
      }),
        B1(n, 1);
  }
};
l1 = function (n) {
  if (n.tag === 13) {
    var e = Hs(n, 134217728);
    if (e !== null) {
      var t = Ei();
      zr(e, n, 134217728, t);
    }
    B1(n, 134217728);
  }
};
iC = function (n) {
  if (n.tag === 13) {
    var e = Io(n),
      t = Hs(n, e);
    if (t !== null) {
      var i = Ei();
      zr(t, n, e, i);
    }
    B1(n, e);
  }
};
rC = function () {
  return Vt;
};
sC = function (n, e) {
  var t = Vt;
  try {
    return (Vt = n), e();
  } finally {
    Vt = t;
  }
};
cx = function (n, e, t) {
  switch (e) {
    case "input":
      if ((ix(n, t), (e = t.name), t.type === "radio" && e != null)) {
        for (t = n; t.parentNode; ) t = t.parentNode;
        for (
          t = t.querySelectorAll(
            "input[name=" + JSON.stringify("" + e) + '][type="radio"]'
          ),
            e = 0;
          e < t.length;
          e++
        ) {
          var i = t[e];
          if (i !== n && i.form === n.form) {
            var r = cg(i);
            if (!r) throw Error(we(90));
            Ub(i), ix(i, r);
          }
        }
      }
      break;
    case "textarea":
      Fb(n, t);
      break;
    case "select":
      (e = t.value), e != null && xu(n, !!t.multiple, e, !1);
  }
};
jb = O1;
Xb = Ka;
var hO = { usingClientEntryPoint: !1, Events: [nh, nu, cg, Gb, Wb, O1] },
  wc = {
    findFiberByHostInstance: Ra,
    bundleType: 0,
    version: "18.3.1",
    rendererPackageName: "react-dom",
  },
  dO = {
    bundleType: wc.bundleType,
    version: wc.version,
    rendererPackageName: wc.rendererPackageName,
    rendererConfig: wc.rendererConfig,
    overrideHookState: null,
    overrideHookStateDeletePath: null,
    overrideHookStateRenamePath: null,
    overrideProps: null,
    overridePropsDeletePath: null,
    overridePropsRenamePath: null,
    setErrorHandler: null,
    setSuspenseHandler: null,
    scheduleUpdate: null,
    currentDispatcherRef: qs.ReactCurrentDispatcher,
    findHostInstanceByFiber: function (n) {
      return (n = Zb(n)), n === null ? null : n.stateNode;
    },
    findFiberByHostInstance: wc.findFiberByHostInstance || cO,
    findHostInstancesForRefresh: null,
    scheduleRefresh: null,
    scheduleRoot: null,
    setRefreshHandler: null,
    getCurrentFiber: null,
    reconcilerVersion: "18.3.1-next-f1338f8080-20240426",
  };
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
  var Vd = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!Vd.isDisabled && Vd.supportsFiber)
    try {
      (og = Vd.inject(dO)), (os = Vd);
    } catch {}
}
ir.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = hO;
ir.createPortal = function (n, e) {
  var t = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
  if (!H1(e)) throw Error(we(200));
  return uO(n, e, null, t);
};
ir.createRoot = function (n, e) {
  if (!H1(n)) throw Error(we(299));
  var t = !1,
    i = "",
    r = bP;
  return (
    e != null &&
      (e.unstable_strictMode === !0 && (t = !0),
      e.identifierPrefix !== void 0 && (i = e.identifierPrefix),
      e.onRecoverableError !== void 0 && (r = e.onRecoverableError)),
    (e = z1(n, 1, !1, null, null, t, !1, i, r)),
    (n[Vs] = e.current),
    xf(n.nodeType === 8 ? n.parentNode : n),
    new V1(e)
  );
};
ir.findDOMNode = function (n) {
  if (n == null) return null;
  if (n.nodeType === 1) return n;
  var e = n._reactInternals;
  if (e === void 0)
    throw typeof n.render == "function"
      ? Error(we(188))
      : ((n = Object.keys(n).join(",")), Error(we(268, n)));
  return (n = Zb(e)), (n = n === null ? null : n.stateNode), n;
};
ir.flushSync = function (n) {
  return Ka(n);
};
ir.hydrate = function (n, e, t) {
  if (!xg(e)) throw Error(we(200));
  return _g(null, n, e, !0, t);
};
ir.hydrateRoot = function (n, e, t) {
  if (!H1(n)) throw Error(we(405));
  var i = (t != null && t.hydratedSources) || null,
    r = !1,
    s = "",
    o = bP;
  if (
    (t != null &&
      (t.unstable_strictMode === !0 && (r = !0),
      t.identifierPrefix !== void 0 && (s = t.identifierPrefix),
      t.onRecoverableError !== void 0 && (o = t.onRecoverableError)),
    (e = AP(e, null, n, 1, t ?? null, r, !1, s, o)),
    (n[Vs] = e.current),
    xf(n),
    i)
  )
    for (n = 0; n < i.length; n++)
      (t = i[n]),
        (r = t._getVersion),
        (r = r(t._source)),
        e.mutableSourceEagerHydrationData == null
          ? (e.mutableSourceEagerHydrationData = [t, r])
          : e.mutableSourceEagerHydrationData.push(t, r);
  return new yg(e);
};
ir.render = function (n, e, t) {
  if (!xg(e)) throw Error(we(200));
  return _g(null, n, e, !1, t);
};
ir.unmountComponentAtNode = function (n) {
  if (!xg(n)) throw Error(we(40));
  return n._reactRootContainer
    ? (Ka(function () {
        _g(null, null, n, !1, function () {
          (n._reactRootContainer = null), (n[Vs] = null);
        });
      }),
      !0)
    : !1;
};
ir.unstable_batchedUpdates = O1;
ir.unstable_renderSubtreeIntoContainer = function (n, e, t, i) {
  if (!xg(t)) throw Error(we(200));
  if (n == null || n._reactInternals === void 0) throw Error(we(38));
  return _g(n, e, t, !1, i);
};
ir.version = "18.3.1-next-f1338f8080-20240426";
function CP() {
  if (
    !(
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" ||
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"
    )
  )
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(CP);
    } catch (n) {
      console.error(n);
    }
}
CP(), (Cb.exports = ir);
var PP = Cb.exports,
  QE = PP;
(Ky.createRoot = QE.createRoot), (Ky.hydrateRoot = QE.hydrateRoot);
const RP = se.createContext({
    transformPagePoint: (n) => n,
    isStatic: !1,
    reducedMotion: "never",
  }),
  Sg = se.createContext({}),
  G1 = se.createContext(null),
  Mg = typeof document < "u",
  pO = Mg ? se.useLayoutEffect : se.useEffect,
  LP = se.createContext({ strict: !1 }),
  W1 = (n) => n.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(),
  mO = "framerAppearId",
  IP = "data-" + W1(mO);
function gO(n, e, t, i) {
  const { visualElement: r } = se.useContext(Sg),
    s = se.useContext(LP),
    o = se.useContext(G1),
    a = se.useContext(RP).reducedMotion,
    u = se.useRef();
  (i = i || s.renderer),
    !u.current &&
      i &&
      (u.current = i(n, {
        visualState: e,
        parent: r,
        props: t,
        presenceContext: o,
        blockInitialAnimation: o ? o.initial === !1 : !1,
        reducedMotionConfig: a,
      }));
  const f = u.current;
  se.useInsertionEffect(() => {
    f && f.update(t, o);
  });
  const h = se.useRef(!!(t[IP] && !window.HandoffComplete));
  return (
    pO(() => {
      f &&
        (f.render(),
        h.current && f.animationState && f.animationState.animateChanges());
    }),
    se.useEffect(() => {
      f &&
        (f.updateFeatures(),
        !h.current && f.animationState && f.animationState.animateChanges(),
        h.current && ((h.current = !1), (window.HandoffComplete = !0)));
    }),
    f
  );
}
function uu(n) {
  return (
    n &&
    typeof n == "object" &&
    Object.prototype.hasOwnProperty.call(n, "current")
  );
}
function vO(n, e, t) {
  return se.useCallback(
    (i) => {
      i && n.mount && n.mount(i),
        e && (i ? e.mount(i) : e.unmount()),
        t && (typeof t == "function" ? t(i) : uu(t) && (t.current = i));
    },
    [e]
  );
}
function Cf(n) {
  return typeof n == "string" || Array.isArray(n);
}
function wg(n) {
  return n !== null && typeof n == "object" && typeof n.start == "function";
}
const j1 = [
    "animate",
    "whileInView",
    "whileFocus",
    "whileHover",
    "whileTap",
    "whileDrag",
    "exit",
  ],
  X1 = ["initial", ...j1];
function Eg(n) {
  return wg(n.animate) || X1.some((e) => Cf(n[e]));
}
function NP(n) {
  return !!(Eg(n) || n.variants);
}
function yO(n, e) {
  if (Eg(n)) {
    const { initial: t, animate: i } = n;
    return {
      initial: t === !1 || Cf(t) ? t : void 0,
      animate: Cf(i) ? i : void 0,
    };
  }
  return n.inherit !== !1 ? e : {};
}
function xO(n) {
  const { initial: e, animate: t } = yO(n, se.useContext(Sg));
  return se.useMemo(() => ({ initial: e, animate: t }), [$E(e), $E(t)]);
}
function $E(n) {
  return Array.isArray(n) ? n.join(" ") : n;
}
const JE = {
    animation: [
      "animate",
      "variants",
      "whileHover",
      "whileTap",
      "exit",
      "whileInView",
      "whileFocus",
      "whileDrag",
    ],
    exit: ["exit"],
    drag: ["drag", "dragControls"],
    focus: ["whileFocus"],
    hover: ["whileHover", "onHoverStart", "onHoverEnd"],
    tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
    pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
    inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
    layout: ["layout", "layoutId"],
  },
  Pf = {};
for (const n in JE) Pf[n] = { isEnabled: (e) => JE[n].some((t) => !!e[t]) };
function _O(n) {
  for (const e in n) Pf[e] = { ...Pf[e], ...n[e] };
}
const DP = se.createContext({}),
  OP = se.createContext({}),
  SO = Symbol.for("motionComponentSymbol");
function MO({
  preloadedFeatures: n,
  createVisualElement: e,
  useRender: t,
  useVisualState: i,
  Component: r,
}) {
  n && _O(n);
  function s(a, u) {
    let f;
    const h = { ...se.useContext(RP), ...a, layoutId: wO(a) },
      { isStatic: d } = h,
      p = xO(a),
      m = i(a, d);
    if (!d && Mg) {
      p.visualElement = gO(r, m, h, e);
      const y = se.useContext(OP),
        w = se.useContext(LP).strict;
      p.visualElement && (f = p.visualElement.loadFeatures(h, w, n, y));
    }
    return se.createElement(
      Sg.Provider,
      { value: p },
      f && p.visualElement
        ? se.createElement(f, { visualElement: p.visualElement, ...h })
        : null,
      t(r, a, vO(m, p.visualElement, u), m, d, p.visualElement)
    );
  }
  const o = se.forwardRef(s);
  return (o[SO] = r), o;
}
function wO({ layoutId: n }) {
  const e = se.useContext(DP).id;
  return e && n !== void 0 ? e + "-" + n : n;
}
function EO(n) {
  function e(i, r = {}) {
    return MO(n(i, r));
  }
  if (typeof Proxy > "u") return e;
  const t = new Map();
  return new Proxy(e, {
    get: (i, r) => (t.has(r) || t.set(r, e(r)), t.get(r)),
  });
}
const TO = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view",
];
function Y1(n) {
  return typeof n != "string" || n.includes("-")
    ? !1
    : !!(TO.indexOf(n) > -1 || /[A-Z]/.test(n));
}
const zm = {};
function AO(n) {
  Object.assign(zm, n);
}
const rh = [
    "transformPerspective",
    "x",
    "y",
    "z",
    "translateX",
    "translateY",
    "translateZ",
    "scale",
    "scaleX",
    "scaleY",
    "rotate",
    "rotateX",
    "rotateY",
    "rotateZ",
    "skew",
    "skewX",
    "skewY",
  ],
  nl = new Set(rh);
function UP(n, { layout: e, layoutId: t }) {
  return (
    nl.has(n) ||
    n.startsWith("origin") ||
    ((e || t !== void 0) && (!!zm[n] || n === "opacity"))
  );
}
const Vi = (n) => !!(n && n.getVelocity),
  bO = {
    x: "translateX",
    y: "translateY",
    z: "translateZ",
    transformPerspective: "perspective",
  },
  CO = rh.length;
function PO(
  n,
  { enableHardwareAcceleration: e = !0, allowTransformNone: t = !0 },
  i,
  r
) {
  let s = "";
  for (let o = 0; o < CO; o++) {
    const a = rh[o];
    if (n[a] !== void 0) {
      const u = bO[a] || a;
      s += `${u}(${n[a]}) `;
    }
  }
  return (
    e && !n.z && (s += "translateZ(0)"),
    (s = s.trim()),
    r ? (s = r(n, i ? "" : s)) : t && i && (s = "none"),
    s
  );
}
const kP = (n) => (e) => typeof e == "string" && e.startsWith(n),
  FP = kP("--"),
  Gx = kP("var(--"),
  RO =
    /var\s*\(\s*--[\w-]+(\s*,\s*(?:(?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)+)?\s*\)/g,
  LO = (n, e) => (e && typeof n == "number" ? e.transform(n) : n),
  Vo = (n, e, t) => Math.min(Math.max(t, n), e),
  il = {
    test: (n) => typeof n == "number",
    parse: parseFloat,
    transform: (n) => n,
  },
  ef = { ...il, transform: (n) => Vo(0, 1, n) },
  Hd = { ...il, default: 1 },
  tf = (n) => Math.round(n * 1e5) / 1e5,
  Tg = /(-)?([\d]*\.?[\d])+/g,
  zP =
    /(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))/gi,
  IO =
    /^(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))$/i;
function sh(n) {
  return typeof n == "string";
}
const oh = (n) => ({
    test: (e) => sh(e) && e.endsWith(n) && e.split(" ").length === 1,
    parse: parseFloat,
    transform: (e) => `${e}${n}`,
  }),
  vo = oh("deg"),
  ls = oh("%"),
  ft = oh("px"),
  NO = oh("vh"),
  DO = oh("vw"),
  eT = {
    ...ls,
    parse: (n) => ls.parse(n) / 100,
    transform: (n) => ls.transform(n * 100),
  },
  tT = { ...il, transform: Math.round },
  BP = {
    borderWidth: ft,
    borderTopWidth: ft,
    borderRightWidth: ft,
    borderBottomWidth: ft,
    borderLeftWidth: ft,
    borderRadius: ft,
    radius: ft,
    borderTopLeftRadius: ft,
    borderTopRightRadius: ft,
    borderBottomRightRadius: ft,
    borderBottomLeftRadius: ft,
    width: ft,
    maxWidth: ft,
    height: ft,
    maxHeight: ft,
    size: ft,
    top: ft,
    right: ft,
    bottom: ft,
    left: ft,
    padding: ft,
    paddingTop: ft,
    paddingRight: ft,
    paddingBottom: ft,
    paddingLeft: ft,
    margin: ft,
    marginTop: ft,
    marginRight: ft,
    marginBottom: ft,
    marginLeft: ft,
    rotate: vo,
    rotateX: vo,
    rotateY: vo,
    rotateZ: vo,
    scale: Hd,
    scaleX: Hd,
    scaleY: Hd,
    scaleZ: Hd,
    skew: vo,
    skewX: vo,
    skewY: vo,
    distance: ft,
    translateX: ft,
    translateY: ft,
    translateZ: ft,
    x: ft,
    y: ft,
    z: ft,
    perspective: ft,
    transformPerspective: ft,
    opacity: ef,
    originX: eT,
    originY: eT,
    originZ: ft,
    zIndex: tT,
    fillOpacity: ef,
    strokeOpacity: ef,
    numOctaves: tT,
  };
function q1(n, e, t, i) {
  const { style: r, vars: s, transform: o, transformOrigin: a } = n;
  let u = !1,
    f = !1,
    h = !0;
  for (const d in e) {
    const p = e[d];
    if (FP(d)) {
      s[d] = p;
      continue;
    }
    const m = BP[d],
      y = LO(p, m);
    if (nl.has(d)) {
      if (((u = !0), (o[d] = y), !h)) continue;
      p !== (m.default || 0) && (h = !1);
    } else d.startsWith("origin") ? ((f = !0), (a[d] = y)) : (r[d] = y);
  }
  if (
    (e.transform ||
      (u || i
        ? (r.transform = PO(n.transform, t, h, i))
        : r.transform && (r.transform = "none")),
    f)
  ) {
    const { originX: d = "50%", originY: p = "50%", originZ: m = 0 } = a;
    r.transformOrigin = `${d} ${p} ${m}`;
  }
}
const Z1 = () => ({ style: {}, transform: {}, transformOrigin: {}, vars: {} });
function VP(n, e, t) {
  for (const i in e) !Vi(e[i]) && !UP(i, t) && (n[i] = e[i]);
}
function OO({ transformTemplate: n }, e, t) {
  return se.useMemo(() => {
    const i = Z1();
    return (
      q1(i, e, { enableHardwareAcceleration: !t }, n),
      Object.assign({}, i.vars, i.style)
    );
  }, [e]);
}
function UO(n, e, t) {
  const i = n.style || {},
    r = {};
  return (
    VP(r, i, n),
    Object.assign(r, OO(n, e, t)),
    n.transformValues ? n.transformValues(r) : r
  );
}
function kO(n, e, t) {
  const i = {},
    r = UO(n, e, t);
  return (
    n.drag &&
      n.dragListener !== !1 &&
      ((i.draggable = !1),
      (r.userSelect = r.WebkitUserSelect = r.WebkitTouchCallout = "none"),
      (r.touchAction =
        n.drag === !0 ? "none" : `pan-${n.drag === "x" ? "y" : "x"}`)),
    n.tabIndex === void 0 &&
      (n.onTap || n.onTapStart || n.whileTap) &&
      (i.tabIndex = 0),
    (i.style = r),
    i
  );
}
const FO = new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "transformValues",
  "custom",
  "inherit",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "globalTapTarget",
  "ignoreStrict",
  "viewport",
]);
function Bm(n) {
  return (
    n.startsWith("while") ||
    (n.startsWith("drag") && n !== "draggable") ||
    n.startsWith("layout") ||
    n.startsWith("onTap") ||
    n.startsWith("onPan") ||
    n.startsWith("onLayout") ||
    FO.has(n)
  );
}
let HP = (n) => !Bm(n);
function zO(n) {
  n && (HP = (e) => (e.startsWith("on") ? !Bm(e) : n(e)));
}
try {
  zO(require("@emotion/is-prop-valid").default);
} catch {}
function BO(n, e, t) {
  const i = {};
  for (const r in n)
    (r === "values" && typeof n.values == "object") ||
      ((HP(r) ||
        (t === !0 && Bm(r)) ||
        (!e && !Bm(r)) ||
        (n.draggable && r.startsWith("onDrag"))) &&
        (i[r] = n[r]));
  return i;
}
function nT(n, e, t) {
  return typeof n == "string" ? n : ft.transform(e + t * n);
}
function VO(n, e, t) {
  const i = nT(e, n.x, n.width),
    r = nT(t, n.y, n.height);
  return `${i} ${r}`;
}
const HO = { offset: "stroke-dashoffset", array: "stroke-dasharray" },
  GO = { offset: "strokeDashoffset", array: "strokeDasharray" };
function WO(n, e, t = 1, i = 0, r = !0) {
  n.pathLength = 1;
  const s = r ? HO : GO;
  n[s.offset] = ft.transform(-i);
  const o = ft.transform(e),
    a = ft.transform(t);
  n[s.array] = `${o} ${a}`;
}
function K1(
  n,
  {
    attrX: e,
    attrY: t,
    attrScale: i,
    originX: r,
    originY: s,
    pathLength: o,
    pathSpacing: a = 1,
    pathOffset: u = 0,
    ...f
  },
  h,
  d,
  p
) {
  if ((q1(n, f, h, p), d)) {
    n.style.viewBox && (n.attrs.viewBox = n.style.viewBox);
    return;
  }
  (n.attrs = n.style), (n.style = {});
  const { attrs: m, style: y, dimensions: w } = n;
  m.transform && (w && (y.transform = m.transform), delete m.transform),
    w &&
      (r !== void 0 || s !== void 0 || y.transform) &&
      (y.transformOrigin = VO(
        w,
        r !== void 0 ? r : 0.5,
        s !== void 0 ? s : 0.5
      )),
    e !== void 0 && (m.x = e),
    t !== void 0 && (m.y = t),
    i !== void 0 && (m.scale = i),
    o !== void 0 && WO(m, o, a, u, !1);
}
const GP = () => ({ ...Z1(), attrs: {} }),
  Q1 = (n) => typeof n == "string" && n.toLowerCase() === "svg";
function jO(n, e, t, i) {
  const r = se.useMemo(() => {
    const s = GP();
    return (
      K1(s, e, { enableHardwareAcceleration: !1 }, Q1(i), n.transformTemplate),
      { ...s.attrs, style: { ...s.style } }
    );
  }, [e]);
  if (n.style) {
    const s = {};
    VP(s, n.style, n), (r.style = { ...s, ...r.style });
  }
  return r;
}
function XO(n = !1) {
  return (t, i, r, { latestValues: s }, o) => {
    const u = (Y1(t) ? jO : kO)(i, s, o, t),
      h = { ...BO(i, typeof t == "string", n), ...u, ref: r },
      { children: d } = i,
      p = se.useMemo(() => (Vi(d) ? d.get() : d), [d]);
    return se.createElement(t, { ...h, children: p });
  };
}
function WP(n, { style: e, vars: t }, i, r) {
  Object.assign(n.style, e, r && r.getProjectionStyles(i));
  for (const s in t) n.style.setProperty(s, t[s]);
}
const jP = new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust",
]);
function XP(n, e, t, i) {
  WP(n, e, void 0, i);
  for (const r in e.attrs) n.setAttribute(jP.has(r) ? r : W1(r), e.attrs[r]);
}
function $1(n, e) {
  const { style: t } = n,
    i = {};
  for (const r in t)
    (Vi(t[r]) || (e.style && Vi(e.style[r])) || UP(r, n)) && (i[r] = t[r]);
  return i;
}
function YP(n, e) {
  const t = $1(n, e);
  for (const i in n)
    if (Vi(n[i]) || Vi(e[i])) {
      const r =
        rh.indexOf(i) !== -1
          ? "attr" + i.charAt(0).toUpperCase() + i.substring(1)
          : i;
      t[r] = n[i];
    }
  return t;
}
function J1(n, e, t, i = {}, r = {}) {
  return (
    typeof e == "function" && (e = e(t !== void 0 ? t : n.custom, i, r)),
    typeof e == "string" && (e = n.variants && n.variants[e]),
    typeof e == "function" && (e = e(t !== void 0 ? t : n.custom, i, r)),
    e
  );
}
function YO(n) {
  const e = se.useRef(null);
  return e.current === null && (e.current = n()), e.current;
}
const Vm = (n) => Array.isArray(n),
  qO = (n) => !!(n && typeof n == "object" && n.mix && n.toValue),
  ZO = (n) => (Vm(n) ? n[n.length - 1] || 0 : n);
function rm(n) {
  const e = Vi(n) ? n.get() : n;
  return qO(e) ? e.toValue() : e;
}
function KO(
  { scrapeMotionValuesFromProps: n, createRenderState: e, onMount: t },
  i,
  r,
  s
) {
  const o = { latestValues: QO(i, r, s, n), renderState: e() };
  return t && (o.mount = (a) => t(i, a, o)), o;
}
const qP = (n) => (e, t) => {
  const i = se.useContext(Sg),
    r = se.useContext(G1),
    s = () => KO(n, e, i, r);
  return t ? s() : YO(s);
};
function QO(n, e, t, i) {
  const r = {},
    s = i(n, {});
  for (const p in s) r[p] = rm(s[p]);
  let { initial: o, animate: a } = n;
  const u = Eg(n),
    f = NP(n);
  e &&
    f &&
    !u &&
    n.inherit !== !1 &&
    (o === void 0 && (o = e.initial), a === void 0 && (a = e.animate));
  let h = t ? t.initial === !1 : !1;
  h = h || o === !1;
  const d = h ? a : o;
  return (
    d &&
      typeof d != "boolean" &&
      !wg(d) &&
      (Array.isArray(d) ? d : [d]).forEach((m) => {
        const y = J1(n, m);
        if (!y) return;
        const { transitionEnd: w, transition: S, ...v } = y;
        for (const M in v) {
          let _ = v[M];
          if (Array.isArray(_)) {
            const T = h ? _.length - 1 : 0;
            _ = _[T];
          }
          _ !== null && (r[M] = _);
        }
        for (const M in w) r[M] = w[M];
      }),
    r
  );
}
const Tn = (n) => n;
class iT {
  constructor() {
    (this.order = []), (this.scheduled = new Set());
  }
  add(e) {
    if (!this.scheduled.has(e))
      return this.scheduled.add(e), this.order.push(e), !0;
  }
  remove(e) {
    const t = this.order.indexOf(e);
    t !== -1 && (this.order.splice(t, 1), this.scheduled.delete(e));
  }
  clear() {
    (this.order.length = 0), this.scheduled.clear();
  }
}
function $O(n) {
  let e = new iT(),
    t = new iT(),
    i = 0,
    r = !1,
    s = !1;
  const o = new WeakSet(),
    a = {
      schedule: (u, f = !1, h = !1) => {
        const d = h && r,
          p = d ? e : t;
        return f && o.add(u), p.add(u) && d && r && (i = e.order.length), u;
      },
      cancel: (u) => {
        t.remove(u), o.delete(u);
      },
      process: (u) => {
        if (r) {
          s = !0;
          return;
        }
        if (((r = !0), ([e, t] = [t, e]), t.clear(), (i = e.order.length), i))
          for (let f = 0; f < i; f++) {
            const h = e.order[f];
            h(u), o.has(h) && (a.schedule(h), n());
          }
        (r = !1), s && ((s = !1), a.process(u));
      },
    };
  return a;
}
const Gd = ["prepare", "read", "update", "preRender", "render", "postRender"],
  JO = 40;
function eU(n, e) {
  let t = !1,
    i = !0;
  const r = { delta: 0, timestamp: 0, isProcessing: !1 },
    s = Gd.reduce((d, p) => ((d[p] = $O(() => (t = !0))), d), {}),
    o = (d) => s[d].process(r),
    a = () => {
      const d = performance.now();
      (t = !1),
        (r.delta = i ? 1e3 / 60 : Math.max(Math.min(d - r.timestamp, JO), 1)),
        (r.timestamp = d),
        (r.isProcessing = !0),
        Gd.forEach(o),
        (r.isProcessing = !1),
        t && e && ((i = !1), n(a));
    },
    u = () => {
      (t = !0), (i = !0), r.isProcessing || n(a);
    };
  return {
    schedule: Gd.reduce((d, p) => {
      const m = s[p];
      return (d[p] = (y, w = !1, S = !1) => (t || u(), m.schedule(y, w, S))), d;
    }, {}),
    cancel: (d) => Gd.forEach((p) => s[p].cancel(d)),
    state: r,
    steps: s,
  };
}
const {
    schedule: $t,
    cancel: Ws,
    state: ui,
    steps: H0,
  } = eU(typeof requestAnimationFrame < "u" ? requestAnimationFrame : Tn, !0),
  tU = {
    useVisualState: qP({
      scrapeMotionValuesFromProps: YP,
      createRenderState: GP,
      onMount: (n, e, { renderState: t, latestValues: i }) => {
        $t.read(() => {
          try {
            t.dimensions =
              typeof e.getBBox == "function"
                ? e.getBBox()
                : e.getBoundingClientRect();
          } catch {
            t.dimensions = { x: 0, y: 0, width: 0, height: 0 };
          }
        }),
          $t.render(() => {
            K1(
              t,
              i,
              { enableHardwareAcceleration: !1 },
              Q1(e.tagName),
              n.transformTemplate
            ),
              XP(e, t);
          });
      },
    }),
  },
  nU = {
    useVisualState: qP({
      scrapeMotionValuesFromProps: $1,
      createRenderState: Z1,
    }),
  };
function iU(n, { forwardMotionProps: e = !1 }, t, i) {
  return {
    ...(Y1(n) ? tU : nU),
    preloadedFeatures: t,
    useRender: XO(e),
    createVisualElement: i,
    Component: n,
  };
}
function Ns(n, e, t, i = { passive: !0 }) {
  return n.addEventListener(e, t, i), () => n.removeEventListener(e, t);
}
const ZP = (n) =>
  n.pointerType === "mouse"
    ? typeof n.button != "number" || n.button <= 0
    : n.isPrimary !== !1;
function Ag(n, e = "page") {
  return { point: { x: n[e + "X"], y: n[e + "Y"] } };
}
const rU = (n) => (e) => ZP(e) && n(e, Ag(e));
function ks(n, e, t, i) {
  return Ns(n, e, rU(t), i);
}
const sU = (n, e) => (t) => e(n(t)),
  Do = (...n) => n.reduce(sU);
function KP(n) {
  let e = null;
  return () => {
    const t = () => {
      e = null;
    };
    return e === null ? ((e = n), t) : !1;
  };
}
const rT = KP("dragHorizontal"),
  sT = KP("dragVertical");
function QP(n) {
  let e = !1;
  if (n === "y") e = sT();
  else if (n === "x") e = rT();
  else {
    const t = rT(),
      i = sT();
    t && i
      ? (e = () => {
          t(), i();
        })
      : (t && t(), i && i());
  }
  return e;
}
function $P() {
  const n = QP(!0);
  return n ? (n(), !1) : !0;
}
class Zo {
  constructor(e) {
    (this.isMounted = !1), (this.node = e);
  }
  update() {}
}
function oT(n, e) {
  const t = "pointer" + (e ? "enter" : "leave"),
    i = "onHover" + (e ? "Start" : "End"),
    r = (s, o) => {
      if (s.pointerType === "touch" || $P()) return;
      const a = n.getProps();
      n.animationState &&
        a.whileHover &&
        n.animationState.setActive("whileHover", e),
        a[i] && $t.update(() => a[i](s, o));
    };
  return ks(n.current, t, r, { passive: !n.getProps()[i] });
}
class oU extends Zo {
  mount() {
    this.unmount = Do(oT(this.node, !0), oT(this.node, !1));
  }
  unmount() {}
}
class aU extends Zo {
  constructor() {
    super(...arguments), (this.isActive = !1);
  }
  onFocus() {
    let e = !1;
    try {
      e = this.node.current.matches(":focus-visible");
    } catch {
      e = !0;
    }
    !e ||
      !this.node.animationState ||
      (this.node.animationState.setActive("whileFocus", !0),
      (this.isActive = !0));
  }
  onBlur() {
    !this.isActive ||
      !this.node.animationState ||
      (this.node.animationState.setActive("whileFocus", !1),
      (this.isActive = !1));
  }
  mount() {
    this.unmount = Do(
      Ns(this.node.current, "focus", () => this.onFocus()),
      Ns(this.node.current, "blur", () => this.onBlur())
    );
  }
  unmount() {}
}
const JP = (n, e) => (e ? (n === e ? !0 : JP(n, e.parentElement)) : !1);
function G0(n, e) {
  if (!e) return;
  const t = new PointerEvent("pointer" + n);
  e(t, Ag(t));
}
class lU extends Zo {
  constructor() {
    super(...arguments),
      (this.removeStartListeners = Tn),
      (this.removeEndListeners = Tn),
      (this.removeAccessibleListeners = Tn),
      (this.startPointerPress = (e, t) => {
        if (this.isPressing) return;
        this.removeEndListeners();
        const i = this.node.getProps(),
          s = ks(
            window,
            "pointerup",
            (a, u) => {
              if (!this.checkPressEnd()) return;
              const {
                onTap: f,
                onTapCancel: h,
                globalTapTarget: d,
              } = this.node.getProps();
              $t.update(() => {
                !d && !JP(this.node.current, a.target)
                  ? h && h(a, u)
                  : f && f(a, u);
              });
            },
            { passive: !(i.onTap || i.onPointerUp) }
          ),
          o = ks(window, "pointercancel", (a, u) => this.cancelPress(a, u), {
            passive: !(i.onTapCancel || i.onPointerCancel),
          });
        (this.removeEndListeners = Do(s, o)), this.startPress(e, t);
      }),
      (this.startAccessiblePress = () => {
        const e = (s) => {
            if (s.key !== "Enter" || this.isPressing) return;
            const o = (a) => {
              a.key !== "Enter" ||
                !this.checkPressEnd() ||
                G0("up", (u, f) => {
                  const { onTap: h } = this.node.getProps();
                  h && $t.update(() => h(u, f));
                });
            };
            this.removeEndListeners(),
              (this.removeEndListeners = Ns(this.node.current, "keyup", o)),
              G0("down", (a, u) => {
                this.startPress(a, u);
              });
          },
          t = Ns(this.node.current, "keydown", e),
          i = () => {
            this.isPressing && G0("cancel", (s, o) => this.cancelPress(s, o));
          },
          r = Ns(this.node.current, "blur", i);
        this.removeAccessibleListeners = Do(t, r);
      });
  }
  startPress(e, t) {
    this.isPressing = !0;
    const { onTapStart: i, whileTap: r } = this.node.getProps();
    r &&
      this.node.animationState &&
      this.node.animationState.setActive("whileTap", !0),
      i && $t.update(() => i(e, t));
  }
  checkPressEnd() {
    return (
      this.removeEndListeners(),
      (this.isPressing = !1),
      this.node.getProps().whileTap &&
        this.node.animationState &&
        this.node.animationState.setActive("whileTap", !1),
      !$P()
    );
  }
  cancelPress(e, t) {
    if (!this.checkPressEnd()) return;
    const { onTapCancel: i } = this.node.getProps();
    i && $t.update(() => i(e, t));
  }
  mount() {
    const e = this.node.getProps(),
      t = ks(
        e.globalTapTarget ? window : this.node.current,
        "pointerdown",
        this.startPointerPress,
        { passive: !(e.onTapStart || e.onPointerStart) }
      ),
      i = Ns(this.node.current, "focus", this.startAccessiblePress);
    this.removeStartListeners = Do(t, i);
  }
  unmount() {
    this.removeStartListeners(),
      this.removeEndListeners(),
      this.removeAccessibleListeners();
  }
}
const Wx = new WeakMap(),
  W0 = new WeakMap(),
  uU = (n) => {
    const e = Wx.get(n.target);
    e && e(n);
  },
  cU = (n) => {
    n.forEach(uU);
  };
function fU({ root: n, ...e }) {
  const t = n || document;
  W0.has(t) || W0.set(t, {});
  const i = W0.get(t),
    r = JSON.stringify(e);
  return i[r] || (i[r] = new IntersectionObserver(cU, { root: n, ...e })), i[r];
}
function hU(n, e, t) {
  const i = fU(e);
  return (
    Wx.set(n, t),
    i.observe(n),
    () => {
      Wx.delete(n), i.unobserve(n);
    }
  );
}
const dU = { some: 0, all: 1 };
class pU extends Zo {
  constructor() {
    super(...arguments), (this.hasEnteredView = !1), (this.isInView = !1);
  }
  startObserver() {
    this.unmount();
    const { viewport: e = {} } = this.node.getProps(),
      { root: t, margin: i, amount: r = "some", once: s } = e,
      o = {
        root: t ? t.current : void 0,
        rootMargin: i,
        threshold: typeof r == "number" ? r : dU[r],
      },
      a = (u) => {
        const { isIntersecting: f } = u;
        if (
          this.isInView === f ||
          ((this.isInView = f), s && !f && this.hasEnteredView)
        )
          return;
        f && (this.hasEnteredView = !0),
          this.node.animationState &&
            this.node.animationState.setActive("whileInView", f);
        const { onViewportEnter: h, onViewportLeave: d } = this.node.getProps(),
          p = f ? h : d;
        p && p(u);
      };
    return hU(this.node.current, o, a);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver > "u") return;
    const { props: e, prevProps: t } = this.node;
    ["amount", "margin", "root"].some(mU(e, t)) && this.startObserver();
  }
  unmount() {}
}
function mU({ viewport: n = {} }, { viewport: e = {} } = {}) {
  return (t) => n[t] !== e[t];
}
const gU = {
  inView: { Feature: pU },
  tap: { Feature: lU },
  focus: { Feature: aU },
  hover: { Feature: oU },
};
function e3(n, e) {
  if (!Array.isArray(e)) return !1;
  const t = e.length;
  if (t !== n.length) return !1;
  for (let i = 0; i < t; i++) if (e[i] !== n[i]) return !1;
  return !0;
}
function vU(n) {
  const e = {};
  return n.values.forEach((t, i) => (e[i] = t.get())), e;
}
function yU(n) {
  const e = {};
  return n.values.forEach((t, i) => (e[i] = t.getVelocity())), e;
}
function bg(n, e, t) {
  const i = n.getProps();
  return J1(i, e, t !== void 0 ? t : i.custom, vU(n), yU(n));
}
let eS = Tn;
const Ba = (n) => n * 1e3,
  Fs = (n) => n / 1e3,
  xU = { current: !1 },
  t3 = (n) => Array.isArray(n) && typeof n[0] == "number";
function n3(n) {
  return !!(
    !n ||
    (typeof n == "string" && i3[n]) ||
    t3(n) ||
    (Array.isArray(n) && n.every(n3))
  );
}
const Gc = ([n, e, t, i]) => `cubic-bezier(${n}, ${e}, ${t}, ${i})`,
  i3 = {
    linear: "linear",
    ease: "ease",
    easeIn: "ease-in",
    easeOut: "ease-out",
    easeInOut: "ease-in-out",
    circIn: Gc([0, 0.65, 0.55, 1]),
    circOut: Gc([0.55, 0, 1, 0.45]),
    backIn: Gc([0.31, 0.01, 0.66, -0.59]),
    backOut: Gc([0.33, 1.53, 0.69, 0.99]),
  };
function r3(n) {
  if (n) return t3(n) ? Gc(n) : Array.isArray(n) ? n.map(r3) : i3[n];
}
function _U(
  n,
  e,
  t,
  {
    delay: i = 0,
    duration: r,
    repeat: s = 0,
    repeatType: o = "loop",
    ease: a,
    times: u,
  } = {}
) {
  const f = { [e]: t };
  u && (f.offset = u);
  const h = r3(a);
  return (
    Array.isArray(h) && (f.easing = h),
    n.animate(f, {
      delay: i,
      duration: r,
      easing: Array.isArray(h) ? "linear" : h,
      fill: "both",
      iterations: s + 1,
      direction: o === "reverse" ? "alternate" : "normal",
    })
  );
}
function SU(n, { repeat: e, repeatType: t = "loop" }) {
  const i = e && t !== "loop" && e % 2 === 1 ? 0 : n.length - 1;
  return n[i];
}
const s3 = (n, e, t) =>
    (((1 - 3 * t + 3 * e) * n + (3 * t - 6 * e)) * n + 3 * e) * n,
  MU = 1e-7,
  wU = 12;
function EU(n, e, t, i, r) {
  let s,
    o,
    a = 0;
  do (o = e + (t - e) / 2), (s = s3(o, i, r) - n), s > 0 ? (t = o) : (e = o);
  while (Math.abs(s) > MU && ++a < wU);
  return o;
}
function ah(n, e, t, i) {
  if (n === e && t === i) return Tn;
  const r = (s) => EU(s, 0, 1, n, t);
  return (s) => (s === 0 || s === 1 ? s : s3(r(s), e, i));
}
const TU = ah(0.42, 0, 1, 1),
  AU = ah(0, 0, 0.58, 1),
  o3 = ah(0.42, 0, 0.58, 1),
  bU = (n) => Array.isArray(n) && typeof n[0] != "number",
  a3 = (n) => (e) => e <= 0.5 ? n(2 * e) / 2 : (2 - n(2 * (1 - e))) / 2,
  l3 = (n) => (e) => 1 - n(1 - e),
  tS = (n) => 1 - Math.sin(Math.acos(n)),
  u3 = l3(tS),
  CU = a3(tS),
  c3 = ah(0.33, 1.53, 0.69, 0.99),
  nS = l3(c3),
  PU = a3(nS),
  RU = (n) =>
    (n *= 2) < 1 ? 0.5 * nS(n) : 0.5 * (2 - Math.pow(2, -10 * (n - 1))),
  LU = {
    linear: Tn,
    easeIn: TU,
    easeInOut: o3,
    easeOut: AU,
    circIn: tS,
    circInOut: CU,
    circOut: u3,
    backIn: nS,
    backInOut: PU,
    backOut: c3,
    anticipate: RU,
  },
  aT = (n) => {
    if (Array.isArray(n)) {
      eS(n.length === 4);
      const [e, t, i, r] = n;
      return ah(e, t, i, r);
    } else if (typeof n == "string") return LU[n];
    return n;
  },
  iS = (n, e) => (t) =>
    !!(
      (sh(t) && IO.test(t) && t.startsWith(n)) ||
      (e && Object.prototype.hasOwnProperty.call(t, e))
    ),
  f3 = (n, e, t) => (i) => {
    if (!sh(i)) return i;
    const [r, s, o, a] = i.match(Tg);
    return {
      [n]: parseFloat(r),
      [e]: parseFloat(s),
      [t]: parseFloat(o),
      alpha: a !== void 0 ? parseFloat(a) : 1,
    };
  },
  IU = (n) => Vo(0, 255, n),
  j0 = { ...il, transform: (n) => Math.round(IU(n)) },
  Na = {
    test: iS("rgb", "red"),
    parse: f3("red", "green", "blue"),
    transform: ({ red: n, green: e, blue: t, alpha: i = 1 }) =>
      "rgba(" +
      j0.transform(n) +
      ", " +
      j0.transform(e) +
      ", " +
      j0.transform(t) +
      ", " +
      tf(ef.transform(i)) +
      ")",
  };
function NU(n) {
  let e = "",
    t = "",
    i = "",
    r = "";
  return (
    n.length > 5
      ? ((e = n.substring(1, 3)),
        (t = n.substring(3, 5)),
        (i = n.substring(5, 7)),
        (r = n.substring(7, 9)))
      : ((e = n.substring(1, 2)),
        (t = n.substring(2, 3)),
        (i = n.substring(3, 4)),
        (r = n.substring(4, 5)),
        (e += e),
        (t += t),
        (i += i),
        (r += r)),
    {
      red: parseInt(e, 16),
      green: parseInt(t, 16),
      blue: parseInt(i, 16),
      alpha: r ? parseInt(r, 16) / 255 : 1,
    }
  );
}
const jx = { test: iS("#"), parse: NU, transform: Na.transform },
  cu = {
    test: iS("hsl", "hue"),
    parse: f3("hue", "saturation", "lightness"),
    transform: ({ hue: n, saturation: e, lightness: t, alpha: i = 1 }) =>
      "hsla(" +
      Math.round(n) +
      ", " +
      ls.transform(tf(e)) +
      ", " +
      ls.transform(tf(t)) +
      ", " +
      tf(ef.transform(i)) +
      ")",
  },
  Si = {
    test: (n) => Na.test(n) || jx.test(n) || cu.test(n),
    parse: (n) =>
      Na.test(n) ? Na.parse(n) : cu.test(n) ? cu.parse(n) : jx.parse(n),
    transform: (n) =>
      sh(n) ? n : n.hasOwnProperty("red") ? Na.transform(n) : cu.transform(n),
  },
  un = (n, e, t) => -t * n + t * e + n;
function X0(n, e, t) {
  return (
    t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6
      ? n + (e - n) * 6 * t
      : t < 1 / 2
      ? e
      : t < 2 / 3
      ? n + (e - n) * (2 / 3 - t) * 6
      : n
  );
}
function DU({ hue: n, saturation: e, lightness: t, alpha: i }) {
  (n /= 360), (e /= 100), (t /= 100);
  let r = 0,
    s = 0,
    o = 0;
  if (!e) r = s = o = t;
  else {
    const a = t < 0.5 ? t * (1 + e) : t + e - t * e,
      u = 2 * t - a;
    (r = X0(u, a, n + 1 / 3)), (s = X0(u, a, n)), (o = X0(u, a, n - 1 / 3));
  }
  return {
    red: Math.round(r * 255),
    green: Math.round(s * 255),
    blue: Math.round(o * 255),
    alpha: i,
  };
}
const Y0 = (n, e, t) => {
    const i = n * n;
    return Math.sqrt(Math.max(0, t * (e * e - i) + i));
  },
  OU = [jx, Na, cu],
  UU = (n) => OU.find((e) => e.test(n));
function lT(n) {
  const e = UU(n);
  let t = e.parse(n);
  return e === cu && (t = DU(t)), t;
}
const h3 = (n, e) => {
  const t = lT(n),
    i = lT(e),
    r = { ...t };
  return (s) => (
    (r.red = Y0(t.red, i.red, s)),
    (r.green = Y0(t.green, i.green, s)),
    (r.blue = Y0(t.blue, i.blue, s)),
    (r.alpha = un(t.alpha, i.alpha, s)),
    Na.transform(r)
  );
};
function kU(n) {
  var e, t;
  return (
    isNaN(n) &&
    sh(n) &&
    (((e = n.match(Tg)) === null || e === void 0 ? void 0 : e.length) || 0) +
      (((t = n.match(zP)) === null || t === void 0 ? void 0 : t.length) || 0) >
      0
  );
}
const d3 = { regex: RO, countKey: "Vars", token: "${v}", parse: Tn },
  p3 = { regex: zP, countKey: "Colors", token: "${c}", parse: Si.parse },
  m3 = { regex: Tg, countKey: "Numbers", token: "${n}", parse: il.parse };
function q0(n, { regex: e, countKey: t, token: i, parse: r }) {
  const s = n.tokenised.match(e);
  s &&
    ((n["num" + t] = s.length),
    (n.tokenised = n.tokenised.replace(e, i)),
    n.values.push(...s.map(r)));
}
function Hm(n) {
  const e = n.toString(),
    t = {
      value: e,
      tokenised: e,
      values: [],
      numVars: 0,
      numColors: 0,
      numNumbers: 0,
    };
  return t.value.includes("var(--") && q0(t, d3), q0(t, p3), q0(t, m3), t;
}
function g3(n) {
  return Hm(n).values;
}
function v3(n) {
  const { values: e, numColors: t, numVars: i, tokenised: r } = Hm(n),
    s = e.length;
  return (o) => {
    let a = r;
    for (let u = 0; u < s; u++)
      u < i
        ? (a = a.replace(d3.token, o[u]))
        : u < i + t
        ? (a = a.replace(p3.token, Si.transform(o[u])))
        : (a = a.replace(m3.token, tf(o[u])));
    return a;
  };
}
const FU = (n) => (typeof n == "number" ? 0 : n);
function zU(n) {
  const e = g3(n);
  return v3(n)(e.map(FU));
}
const Ho = {
    test: kU,
    parse: g3,
    createTransformer: v3,
    getAnimatableNone: zU,
  },
  y3 = (n, e) => (t) => `${t > 0 ? e : n}`;
function x3(n, e) {
  return typeof n == "number"
    ? (t) => un(n, e, t)
    : Si.test(n)
    ? h3(n, e)
    : n.startsWith("var(")
    ? y3(n, e)
    : S3(n, e);
}
const _3 = (n, e) => {
    const t = [...n],
      i = t.length,
      r = n.map((s, o) => x3(s, e[o]));
    return (s) => {
      for (let o = 0; o < i; o++) t[o] = r[o](s);
      return t;
    };
  },
  BU = (n, e) => {
    const t = { ...n, ...e },
      i = {};
    for (const r in t)
      n[r] !== void 0 && e[r] !== void 0 && (i[r] = x3(n[r], e[r]));
    return (r) => {
      for (const s in i) t[s] = i[s](r);
      return t;
    };
  },
  S3 = (n, e) => {
    const t = Ho.createTransformer(e),
      i = Hm(n),
      r = Hm(e);
    return i.numVars === r.numVars &&
      i.numColors === r.numColors &&
      i.numNumbers >= r.numNumbers
      ? Do(_3(i.values, r.values), t)
      : y3(n, e);
  },
  Rf = (n, e, t) => {
    const i = e - n;
    return i === 0 ? 1 : (t - n) / i;
  },
  uT = (n, e) => (t) => un(n, e, t);
function VU(n) {
  return typeof n == "number"
    ? uT
    : typeof n == "string"
    ? Si.test(n)
      ? h3
      : S3
    : Array.isArray(n)
    ? _3
    : typeof n == "object"
    ? BU
    : uT;
}
function HU(n, e, t) {
  const i = [],
    r = t || VU(n[0]),
    s = n.length - 1;
  for (let o = 0; o < s; o++) {
    let a = r(n[o], n[o + 1]);
    if (e) {
      const u = Array.isArray(e) ? e[o] || Tn : e;
      a = Do(u, a);
    }
    i.push(a);
  }
  return i;
}
function M3(n, e, { clamp: t = !0, ease: i, mixer: r } = {}) {
  const s = n.length;
  if ((eS(s === e.length), s === 1)) return () => e[0];
  n[0] > n[s - 1] && ((n = [...n].reverse()), (e = [...e].reverse()));
  const o = HU(e, i, r),
    a = o.length,
    u = (f) => {
      let h = 0;
      if (a > 1) for (; h < n.length - 2 && !(f < n[h + 1]); h++);
      const d = Rf(n[h], n[h + 1], f);
      return o[h](d);
    };
  return t ? (f) => u(Vo(n[0], n[s - 1], f)) : u;
}
function GU(n, e) {
  const t = n[n.length - 1];
  for (let i = 1; i <= e; i++) {
    const r = Rf(0, e, i);
    n.push(un(t, 1, r));
  }
}
function WU(n) {
  const e = [0];
  return GU(e, n.length - 1), e;
}
function jU(n, e) {
  return n.map((t) => t * e);
}
function XU(n, e) {
  return n.map(() => e || o3).splice(0, n.length - 1);
}
function Gm({
  duration: n = 300,
  keyframes: e,
  times: t,
  ease: i = "easeInOut",
}) {
  const r = bU(i) ? i.map(aT) : aT(i),
    s = { done: !1, value: e[0] },
    o = jU(t && t.length === e.length ? t : WU(e), n),
    a = M3(o, e, { ease: Array.isArray(r) ? r : XU(e, r) });
  return {
    calculatedDuration: n,
    next: (u) => ((s.value = a(u)), (s.done = u >= n), s),
  };
}
function w3(n, e) {
  return e ? n * (1e3 / e) : 0;
}
const YU = 5;
function E3(n, e, t) {
  const i = Math.max(e - YU, 0);
  return w3(t - n(i), e - i);
}
const Z0 = 0.001,
  qU = 0.01,
  ZU = 10,
  KU = 0.05,
  QU = 1;
function $U({
  duration: n = 800,
  bounce: e = 0.25,
  velocity: t = 0,
  mass: i = 1,
}) {
  let r,
    s,
    o = 1 - e;
  (o = Vo(KU, QU, o)),
    (n = Vo(qU, ZU, Fs(n))),
    o < 1
      ? ((r = (f) => {
          const h = f * o,
            d = h * n,
            p = h - t,
            m = Xx(f, o),
            y = Math.exp(-d);
          return Z0 - (p / m) * y;
        }),
        (s = (f) => {
          const d = f * o * n,
            p = d * t + t,
            m = Math.pow(o, 2) * Math.pow(f, 2) * n,
            y = Math.exp(-d),
            w = Xx(Math.pow(f, 2), o);
          return ((-r(f) + Z0 > 0 ? -1 : 1) * ((p - m) * y)) / w;
        }))
      : ((r = (f) => {
          const h = Math.exp(-f * n),
            d = (f - t) * n + 1;
          return -Z0 + h * d;
        }),
        (s = (f) => {
          const h = Math.exp(-f * n),
            d = (t - f) * (n * n);
          return h * d;
        }));
  const a = 5 / n,
    u = ek(r, s, a);
  if (((n = Ba(n)), isNaN(u)))
    return { stiffness: 100, damping: 10, duration: n };
  {
    const f = Math.pow(u, 2) * i;
    return { stiffness: f, damping: o * 2 * Math.sqrt(i * f), duration: n };
  }
}
const JU = 12;
function ek(n, e, t) {
  let i = t;
  for (let r = 1; r < JU; r++) i = i - n(i) / e(i);
  return i;
}
function Xx(n, e) {
  return n * Math.sqrt(1 - e * e);
}
const tk = ["duration", "bounce"],
  nk = ["stiffness", "damping", "mass"];
function cT(n, e) {
  return e.some((t) => n[t] !== void 0);
}
function ik(n) {
  let e = {
    velocity: 0,
    stiffness: 100,
    damping: 10,
    mass: 1,
    isResolvedFromDuration: !1,
    ...n,
  };
  if (!cT(n, nk) && cT(n, tk)) {
    const t = $U(n);
    (e = { ...e, ...t, mass: 1 }), (e.isResolvedFromDuration = !0);
  }
  return e;
}
function T3({ keyframes: n, restDelta: e, restSpeed: t, ...i }) {
  const r = n[0],
    s = n[n.length - 1],
    o = { done: !1, value: r },
    {
      stiffness: a,
      damping: u,
      mass: f,
      duration: h,
      velocity: d,
      isResolvedFromDuration: p,
    } = ik({ ...i, velocity: -Fs(i.velocity || 0) }),
    m = d || 0,
    y = u / (2 * Math.sqrt(a * f)),
    w = s - r,
    S = Fs(Math.sqrt(a / f)),
    v = Math.abs(w) < 5;
  t || (t = v ? 0.01 : 2), e || (e = v ? 0.005 : 0.5);
  let M;
  if (y < 1) {
    const _ = Xx(S, y);
    M = (T) => {
      const P = Math.exp(-y * S * T);
      return (
        s - P * (((m + y * S * w) / _) * Math.sin(_ * T) + w * Math.cos(_ * T))
      );
    };
  } else if (y === 1) M = (_) => s - Math.exp(-S * _) * (w + (m + S * w) * _);
  else {
    const _ = S * Math.sqrt(y * y - 1);
    M = (T) => {
      const P = Math.exp(-y * S * T),
        b = Math.min(_ * T, 300);
      return (
        s - (P * ((m + y * S * w) * Math.sinh(b) + _ * w * Math.cosh(b))) / _
      );
    };
  }
  return {
    calculatedDuration: (p && h) || null,
    next: (_) => {
      const T = M(_);
      if (p) o.done = _ >= h;
      else {
        let P = m;
        _ !== 0 && (y < 1 ? (P = E3(M, _, T)) : (P = 0));
        const b = Math.abs(P) <= t,
          L = Math.abs(s - T) <= e;
        o.done = b && L;
      }
      return (o.value = o.done ? s : T), o;
    },
  };
}
function fT({
  keyframes: n,
  velocity: e = 0,
  power: t = 0.8,
  timeConstant: i = 325,
  bounceDamping: r = 10,
  bounceStiffness: s = 500,
  modifyTarget: o,
  min: a,
  max: u,
  restDelta: f = 0.5,
  restSpeed: h,
}) {
  const d = n[0],
    p = { done: !1, value: d },
    m = (N) => (a !== void 0 && N < a) || (u !== void 0 && N > u),
    y = (N) =>
      a === void 0
        ? u
        : u === void 0 || Math.abs(a - N) < Math.abs(u - N)
        ? a
        : u;
  let w = t * e;
  const S = d + w,
    v = o === void 0 ? S : o(S);
  v !== S && (w = v - d);
  const M = (N) => -w * Math.exp(-N / i),
    _ = (N) => v + M(N),
    T = (N) => {
      const C = M(N),
        R = _(N);
      (p.done = Math.abs(C) <= f), (p.value = p.done ? v : R);
    };
  let P, b;
  const L = (N) => {
    m(p.value) &&
      ((P = N),
      (b = T3({
        keyframes: [p.value, y(p.value)],
        velocity: E3(_, N, p.value),
        damping: r,
        stiffness: s,
        restDelta: f,
        restSpeed: h,
      })));
  };
  return (
    L(0),
    {
      calculatedDuration: null,
      next: (N) => {
        let C = !1;
        return (
          !b && P === void 0 && ((C = !0), T(N), L(N)),
          P !== void 0 && N > P ? b.next(N - P) : (!C && T(N), p)
        );
      },
    }
  );
}
const rk = (n) => {
    const e = ({ timestamp: t }) => n(t);
    return {
      start: () => $t.update(e, !0),
      stop: () => Ws(e),
      now: () => (ui.isProcessing ? ui.timestamp : performance.now()),
    };
  },
  hT = 2e4;
function dT(n) {
  let e = 0;
  const t = 50;
  let i = n.next(e);
  for (; !i.done && e < hT; ) (e += t), (i = n.next(e));
  return e >= hT ? 1 / 0 : e;
}
const sk = { decay: fT, inertia: fT, tween: Gm, keyframes: Gm, spring: T3 };
function Wm({
  autoplay: n = !0,
  delay: e = 0,
  driver: t = rk,
  keyframes: i,
  type: r = "keyframes",
  repeat: s = 0,
  repeatDelay: o = 0,
  repeatType: a = "loop",
  onPlay: u,
  onStop: f,
  onComplete: h,
  onUpdate: d,
  ...p
}) {
  let m = 1,
    y = !1,
    w,
    S;
  const v = () => {
    S = new Promise((Y) => {
      w = Y;
    });
  };
  v();
  let M;
  const _ = sk[r] || Gm;
  let T;
  _ !== Gm &&
    typeof i[0] != "number" &&
    ((T = M3([0, 100], i, { clamp: !1 })), (i = [0, 100]));
  const P = _({ ...p, keyframes: i });
  let b;
  a === "mirror" &&
    (b = _({
      ...p,
      keyframes: [...i].reverse(),
      velocity: -(p.velocity || 0),
    }));
  let L = "idle",
    N = null,
    C = null,
    R = null;
  P.calculatedDuration === null && s && (P.calculatedDuration = dT(P));
  const { calculatedDuration: B } = P;
  let Z = 1 / 0,
    ae = 1 / 0;
  B !== null && ((Z = B + o), (ae = Z * (s + 1) - o));
  let V = 0;
  const Q = (Y) => {
      if (C === null) return;
      m > 0 && (C = Math.min(C, Y)),
        m < 0 && (C = Math.min(Y - ae / m, C)),
        N !== null ? (V = N) : (V = Math.round(Y - C) * m);
      const ie = V - e * (m >= 0 ? 1 : -1),
        J = m >= 0 ? ie < 0 : ie > ae;
      (V = Math.max(ie, 0)), L === "finished" && N === null && (V = ae);
      let he = V,
        Ee = P;
      if (s) {
        const rt = Math.min(V, ae) / Z;
        let Ve = Math.floor(rt),
          We = rt % 1;
        !We && rt >= 1 && (We = 1),
          We === 1 && Ve--,
          (Ve = Math.min(Ve, s + 1)),
          !!(Ve % 2) &&
            (a === "reverse"
              ? ((We = 1 - We), o && (We -= o / Z))
              : a === "mirror" && (Ee = b)),
          (he = Vo(0, 1, We) * Z);
      }
      const be = J ? { done: !1, value: i[0] } : Ee.next(he);
      T && (be.value = T(be.value));
      let { done: Pe } = be;
      !J && B !== null && (Pe = m >= 0 ? V >= ae : V <= 0);
      const it = N === null && (L === "finished" || (L === "running" && Pe));
      return d && d(be.value), it && k(), be;
    },
    $ = () => {
      M && M.stop(), (M = void 0);
    },
    ce = () => {
      (L = "idle"), $(), w(), v(), (C = R = null);
    },
    k = () => {
      (L = "finished"), h && h(), $(), w();
    },
    G = () => {
      if (y) return;
      M || (M = t(Q));
      const Y = M.now();
      u && u(),
        N !== null ? (C = Y - N) : (!C || L === "finished") && (C = Y),
        L === "finished" && v(),
        (R = C),
        (N = null),
        (L = "running"),
        M.start();
    };
  n && G();
  const W = {
    then(Y, ie) {
      return S.then(Y, ie);
    },
    get time() {
      return Fs(V);
    },
    set time(Y) {
      (Y = Ba(Y)),
        (V = Y),
        N !== null || !M || m === 0 ? (N = Y) : (C = M.now() - Y / m);
    },
    get duration() {
      const Y = P.calculatedDuration === null ? dT(P) : P.calculatedDuration;
      return Fs(Y);
    },
    get speed() {
      return m;
    },
    set speed(Y) {
      Y === m || !M || ((m = Y), (W.time = Fs(V)));
    },
    get state() {
      return L;
    },
    play: G,
    pause: () => {
      (L = "paused"), (N = V);
    },
    stop: () => {
      (y = !0), L !== "idle" && ((L = "idle"), f && f(), ce());
    },
    cancel: () => {
      R !== null && Q(R), ce();
    },
    complete: () => {
      L = "finished";
    },
    sample: (Y) => ((C = 0), Q(Y)),
  };
  return W;
}
function ok(n) {
  let e;
  return () => (e === void 0 && (e = n()), e);
}
const ak = ok(() => Object.hasOwnProperty.call(Element.prototype, "animate")),
  lk = new Set([
    "opacity",
    "clipPath",
    "filter",
    "transform",
    "backgroundColor",
  ]),
  Wd = 10,
  uk = 2e4,
  ck = (n, e) => e.type === "spring" || n === "backgroundColor" || !n3(e.ease);
function fk(n, e, { onUpdate: t, onComplete: i, ...r }) {
  if (
    !(
      ak() &&
      lk.has(e) &&
      !r.repeatDelay &&
      r.repeatType !== "mirror" &&
      r.damping !== 0 &&
      r.type !== "inertia"
    )
  )
    return !1;
  let o = !1,
    a,
    u,
    f = !1;
  const h = () => {
    u = new Promise((_) => {
      a = _;
    });
  };
  h();
  let { keyframes: d, duration: p = 300, ease: m, times: y } = r;
  if (ck(e, r)) {
    const _ = Wm({ ...r, repeat: 0, delay: 0 });
    let T = { done: !1, value: d[0] };
    const P = [];
    let b = 0;
    for (; !T.done && b < uk; ) (T = _.sample(b)), P.push(T.value), (b += Wd);
    (y = void 0), (d = P), (p = b - Wd), (m = "linear");
  }
  const w = _U(n.owner.current, e, d, { ...r, duration: p, ease: m, times: y }),
    S = () => {
      (f = !1), w.cancel();
    },
    v = () => {
      (f = !0), $t.update(S), a(), h();
    };
  return (
    (w.onfinish = () => {
      f || (n.set(SU(d, r)), i && i(), v());
    }),
    {
      then(_, T) {
        return u.then(_, T);
      },
      attachTimeline(_) {
        return (w.timeline = _), (w.onfinish = null), Tn;
      },
      get time() {
        return Fs(w.currentTime || 0);
      },
      set time(_) {
        w.currentTime = Ba(_);
      },
      get speed() {
        return w.playbackRate;
      },
      set speed(_) {
        w.playbackRate = _;
      },
      get duration() {
        return Fs(p);
      },
      play: () => {
        o || (w.play(), Ws(S));
      },
      pause: () => w.pause(),
      stop: () => {
        if (((o = !0), w.playState === "idle")) return;
        const { currentTime: _ } = w;
        if (_) {
          const T = Wm({ ...r, autoplay: !1 });
          n.setWithVelocity(T.sample(_ - Wd).value, T.sample(_).value, Wd);
        }
        v();
      },
      complete: () => {
        f || w.finish();
      },
      cancel: v,
    }
  );
}
function hk({ keyframes: n, delay: e, onUpdate: t, onComplete: i }) {
  const r = () => (
    t && t(n[n.length - 1]),
    i && i(),
    {
      time: 0,
      speed: 1,
      duration: 0,
      play: Tn,
      pause: Tn,
      stop: Tn,
      then: (s) => (s(), Promise.resolve()),
      cancel: Tn,
      complete: Tn,
    }
  );
  return e
    ? Wm({ keyframes: [0, 1], duration: 0, delay: e, onComplete: r })
    : r();
}
const dk = { type: "spring", stiffness: 500, damping: 25, restSpeed: 10 },
  pk = (n) => ({
    type: "spring",
    stiffness: 550,
    damping: n === 0 ? 2 * Math.sqrt(550) : 30,
    restSpeed: 10,
  }),
  mk = { type: "keyframes", duration: 0.8 },
  gk = { type: "keyframes", ease: [0.25, 0.1, 0.35, 1], duration: 0.3 },
  vk = (n, { keyframes: e }) =>
    e.length > 2
      ? mk
      : nl.has(n)
      ? n.startsWith("scale")
        ? pk(e[1])
        : dk
      : gk,
  Yx = (n, e) =>
    n === "zIndex"
      ? !1
      : !!(
          typeof e == "number" ||
          Array.isArray(e) ||
          (typeof e == "string" &&
            (Ho.test(e) || e === "0") &&
            !e.startsWith("url("))
        ),
  yk = new Set(["brightness", "contrast", "saturate", "opacity"]);
function xk(n) {
  const [e, t] = n.slice(0, -1).split("(");
  if (e === "drop-shadow") return n;
  const [i] = t.match(Tg) || [];
  if (!i) return n;
  const r = t.replace(i, "");
  let s = yk.has(e) ? 1 : 0;
  return i !== t && (s *= 100), e + "(" + s + r + ")";
}
const _k = /([a-z-]*)\(.*?\)/g,
  qx = {
    ...Ho,
    getAnimatableNone: (n) => {
      const e = n.match(_k);
      return e ? e.map(xk).join(" ") : n;
    },
  },
  Sk = {
    ...BP,
    color: Si,
    backgroundColor: Si,
    outlineColor: Si,
    fill: Si,
    stroke: Si,
    borderColor: Si,
    borderTopColor: Si,
    borderRightColor: Si,
    borderBottomColor: Si,
    borderLeftColor: Si,
    filter: qx,
    WebkitFilter: qx,
  },
  rS = (n) => Sk[n];
function A3(n, e) {
  let t = rS(n);
  return (
    t !== qx && (t = Ho), t.getAnimatableNone ? t.getAnimatableNone(e) : void 0
  );
}
const b3 = (n) => /^0[^.\s]+$/.test(n);
function Mk(n) {
  if (typeof n == "number") return n === 0;
  if (n !== null) return n === "none" || n === "0" || b3(n);
}
function wk(n, e, t, i) {
  const r = Yx(e, t);
  let s;
  Array.isArray(t) ? (s = [...t]) : (s = [null, t]);
  const o = i.from !== void 0 ? i.from : n.get();
  let a;
  const u = [];
  for (let f = 0; f < s.length; f++)
    s[f] === null && (s[f] = f === 0 ? o : s[f - 1]),
      Mk(s[f]) && u.push(f),
      typeof s[f] == "string" && s[f] !== "none" && s[f] !== "0" && (a = s[f]);
  if (r && u.length && a)
    for (let f = 0; f < u.length; f++) {
      const h = u[f];
      s[h] = A3(e, a);
    }
  return s;
}
function Ek({
  when: n,
  delay: e,
  delayChildren: t,
  staggerChildren: i,
  staggerDirection: r,
  repeat: s,
  repeatType: o,
  repeatDelay: a,
  from: u,
  elapsed: f,
  ...h
}) {
  return !!Object.keys(h).length;
}
function sS(n, e) {
  return n[e] || n.default || n;
}
const Tk = { skipAnimations: !1 },
  oS =
    (n, e, t, i = {}) =>
    (r) => {
      const s = sS(i, n) || {},
        o = s.delay || i.delay || 0;
      let { elapsed: a = 0 } = i;
      a = a - Ba(o);
      const u = wk(e, n, t, s),
        f = u[0],
        h = u[u.length - 1],
        d = Yx(n, f),
        p = Yx(n, h);
      let m = {
        keyframes: u,
        velocity: e.getVelocity(),
        ease: "easeOut",
        ...s,
        delay: -a,
        onUpdate: (y) => {
          e.set(y), s.onUpdate && s.onUpdate(y);
        },
        onComplete: () => {
          r(), s.onComplete && s.onComplete();
        },
      };
      if (
        (Ek(s) || (m = { ...m, ...vk(n, m) }),
        m.duration && (m.duration = Ba(m.duration)),
        m.repeatDelay && (m.repeatDelay = Ba(m.repeatDelay)),
        !d || !p || xU.current || s.type === !1 || Tk.skipAnimations)
      )
        return hk(m);
      if (
        !i.isHandoff &&
        e.owner &&
        e.owner.current instanceof HTMLElement &&
        !e.owner.getProps().onUpdate
      ) {
        const y = fk(e, n, m);
        if (y) return y;
      }
      return Wm(m);
    };
function jm(n) {
  return !!(Vi(n) && n.add);
}
const C3 = (n) => /^\-?\d*\.?\d+$/.test(n);
function aS(n, e) {
  n.indexOf(e) === -1 && n.push(e);
}
function lS(n, e) {
  const t = n.indexOf(e);
  t > -1 && n.splice(t, 1);
}
class uS {
  constructor() {
    this.subscriptions = [];
  }
  add(e) {
    return aS(this.subscriptions, e), () => lS(this.subscriptions, e);
  }
  notify(e, t, i) {
    const r = this.subscriptions.length;
    if (r)
      if (r === 1) this.subscriptions[0](e, t, i);
      else
        for (let s = 0; s < r; s++) {
          const o = this.subscriptions[s];
          o && o(e, t, i);
        }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
}
const Ak = (n) => !isNaN(parseFloat(n));
class bk {
  constructor(e, t = {}) {
    (this.version = "10.18.0"),
      (this.timeDelta = 0),
      (this.lastUpdated = 0),
      (this.canTrackVelocity = !1),
      (this.events = {}),
      (this.updateAndNotify = (i, r = !0) => {
        (this.prev = this.current), (this.current = i);
        const { delta: s, timestamp: o } = ui;
        this.lastUpdated !== o &&
          ((this.timeDelta = s),
          (this.lastUpdated = o),
          $t.postRender(this.scheduleVelocityCheck)),
          this.prev !== this.current &&
            this.events.change &&
            this.events.change.notify(this.current),
          this.events.velocityChange &&
            this.events.velocityChange.notify(this.getVelocity()),
          r &&
            this.events.renderRequest &&
            this.events.renderRequest.notify(this.current);
      }),
      (this.scheduleVelocityCheck = () => $t.postRender(this.velocityCheck)),
      (this.velocityCheck = ({ timestamp: i }) => {
        i !== this.lastUpdated &&
          ((this.prev = this.current),
          this.events.velocityChange &&
            this.events.velocityChange.notify(this.getVelocity()));
      }),
      (this.hasAnimated = !1),
      (this.prev = this.current = e),
      (this.canTrackVelocity = Ak(this.current)),
      (this.owner = t.owner);
  }
  onChange(e) {
    return this.on("change", e);
  }
  on(e, t) {
    this.events[e] || (this.events[e] = new uS());
    const i = this.events[e].add(t);
    return e === "change"
      ? () => {
          i(),
            $t.read(() => {
              this.events.change.getSize() || this.stop();
            });
        }
      : i;
  }
  clearListeners() {
    for (const e in this.events) this.events[e].clear();
  }
  attach(e, t) {
    (this.passiveEffect = e), (this.stopPassiveEffect = t);
  }
  set(e, t = !0) {
    !t || !this.passiveEffect
      ? this.updateAndNotify(e, t)
      : this.passiveEffect(e, this.updateAndNotify);
  }
  setWithVelocity(e, t, i) {
    this.set(t), (this.prev = e), (this.timeDelta = i);
  }
  jump(e) {
    this.updateAndNotify(e),
      (this.prev = e),
      this.stop(),
      this.stopPassiveEffect && this.stopPassiveEffect();
  }
  get() {
    return this.current;
  }
  getPrevious() {
    return this.prev;
  }
  getVelocity() {
    return this.canTrackVelocity
      ? w3(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta)
      : 0;
  }
  start(e) {
    return (
      this.stop(),
      new Promise((t) => {
        (this.hasAnimated = !0),
          (this.animation = e(t)),
          this.events.animationStart && this.events.animationStart.notify();
      }).then(() => {
        this.events.animationComplete && this.events.animationComplete.notify(),
          this.clearAnimation();
      })
    );
  }
  stop() {
    this.animation &&
      (this.animation.stop(),
      this.events.animationCancel && this.events.animationCancel.notify()),
      this.clearAnimation();
  }
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  destroy() {
    this.clearListeners(),
      this.stop(),
      this.stopPassiveEffect && this.stopPassiveEffect();
  }
}
function Nu(n, e) {
  return new bk(n, e);
}
const P3 = (n) => (e) => e.test(n),
  Ck = { test: (n) => n === "auto", parse: (n) => n },
  R3 = [il, ft, ls, vo, DO, NO, Ck],
  Ec = (n) => R3.find(P3(n)),
  Pk = [...R3, Si, Ho],
  Rk = (n) => Pk.find(P3(n));
function Lk(n, e, t) {
  n.hasValue(e) ? n.getValue(e).set(t) : n.addValue(e, Nu(t));
}
function Ik(n, e) {
  const t = bg(n, e);
  let {
    transitionEnd: i = {},
    transition: r = {},
    ...s
  } = t ? n.makeTargetAnimatable(t, !1) : {};
  s = { ...s, ...i };
  for (const o in s) {
    const a = ZO(s[o]);
    Lk(n, o, a);
  }
}
function Nk(n, e, t) {
  var i, r;
  const s = Object.keys(e).filter((a) => !n.hasValue(a)),
    o = s.length;
  if (o)
    for (let a = 0; a < o; a++) {
      const u = s[a],
        f = e[u];
      let h = null;
      Array.isArray(f) && (h = f[0]),
        h === null &&
          (h =
            (r = (i = t[u]) !== null && i !== void 0 ? i : n.readValue(u)) !==
              null && r !== void 0
              ? r
              : e[u]),
        h != null &&
          (typeof h == "string" && (C3(h) || b3(h))
            ? (h = parseFloat(h))
            : !Rk(h) && Ho.test(f) && (h = A3(u, f)),
          n.addValue(u, Nu(h, { owner: n })),
          t[u] === void 0 && (t[u] = h),
          h !== null && n.setBaseTarget(u, h));
    }
}
function Dk(n, e) {
  return e ? (e[n] || e.default || e).from : void 0;
}
function Ok(n, e, t) {
  const i = {};
  for (const r in n) {
    const s = Dk(r, e);
    if (s !== void 0) i[r] = s;
    else {
      const o = t.getValue(r);
      o && (i[r] = o.get());
    }
  }
  return i;
}
function Uk({ protectedKeys: n, needsAnimating: e }, t) {
  const i = n.hasOwnProperty(t) && e[t] !== !0;
  return (e[t] = !1), i;
}
function kk(n, e) {
  const t = n.get();
  if (Array.isArray(e)) {
    for (let i = 0; i < e.length; i++) if (e[i] !== t) return !0;
  } else return t !== e;
}
function L3(n, e, { delay: t = 0, transitionOverride: i, type: r } = {}) {
  let {
    transition: s = n.getDefaultTransition(),
    transitionEnd: o,
    ...a
  } = n.makeTargetAnimatable(e);
  const u = n.getValue("willChange");
  i && (s = i);
  const f = [],
    h = r && n.animationState && n.animationState.getState()[r];
  for (const d in a) {
    const p = n.getValue(d),
      m = a[d];
    if (!p || m === void 0 || (h && Uk(h, d))) continue;
    const y = { delay: t, elapsed: 0, ...sS(s || {}, d) };
    if (window.HandoffAppearAnimations) {
      const v = n.getProps()[IP];
      if (v) {
        const M = window.HandoffAppearAnimations(v, d, p, $t);
        M !== null && ((y.elapsed = M), (y.isHandoff = !0));
      }
    }
    let w = !y.isHandoff && !kk(p, m);
    if (
      (y.type === "spring" && (p.getVelocity() || y.velocity) && (w = !1),
      p.animation && (w = !1),
      w)
    )
      continue;
    p.start(oS(d, p, m, n.shouldReduceMotion && nl.has(d) ? { type: !1 } : y));
    const S = p.animation;
    jm(u) && (u.add(d), S.then(() => u.remove(d))), f.push(S);
  }
  return (
    o &&
      Promise.all(f).then(() => {
        o && Ik(n, o);
      }),
    f
  );
}
function Zx(n, e, t = {}) {
  const i = bg(n, e, t.custom);
  let { transition: r = n.getDefaultTransition() || {} } = i || {};
  t.transitionOverride && (r = t.transitionOverride);
  const s = i ? () => Promise.all(L3(n, i, t)) : () => Promise.resolve(),
    o =
      n.variantChildren && n.variantChildren.size
        ? (u = 0) => {
            const {
              delayChildren: f = 0,
              staggerChildren: h,
              staggerDirection: d,
            } = r;
            return Fk(n, e, f + u, h, d, t);
          }
        : () => Promise.resolve(),
    { when: a } = r;
  if (a) {
    const [u, f] = a === "beforeChildren" ? [s, o] : [o, s];
    return u().then(() => f());
  } else return Promise.all([s(), o(t.delay)]);
}
function Fk(n, e, t = 0, i = 0, r = 1, s) {
  const o = [],
    a = (n.variantChildren.size - 1) * i,
    u = r === 1 ? (f = 0) => f * i : (f = 0) => a - f * i;
  return (
    Array.from(n.variantChildren)
      .sort(zk)
      .forEach((f, h) => {
        f.notify("AnimationStart", e),
          o.push(
            Zx(f, e, { ...s, delay: t + u(h) }).then(() =>
              f.notify("AnimationComplete", e)
            )
          );
      }),
    Promise.all(o)
  );
}
function zk(n, e) {
  return n.sortNodePosition(e);
}
function Bk(n, e, t = {}) {
  n.notify("AnimationStart", e);
  let i;
  if (Array.isArray(e)) {
    const r = e.map((s) => Zx(n, s, t));
    i = Promise.all(r);
  } else if (typeof e == "string") i = Zx(n, e, t);
  else {
    const r = typeof e == "function" ? bg(n, e, t.custom) : e;
    i = Promise.all(L3(n, r, t));
  }
  return i.then(() => n.notify("AnimationComplete", e));
}
const Vk = [...j1].reverse(),
  Hk = j1.length;
function Gk(n) {
  return (e) =>
    Promise.all(e.map(({ animation: t, options: i }) => Bk(n, t, i)));
}
function Wk(n) {
  let e = Gk(n);
  const t = Xk();
  let i = !0;
  const r = (u, f) => {
    const h = bg(n, f);
    if (h) {
      const { transition: d, transitionEnd: p, ...m } = h;
      u = { ...u, ...m, ...p };
    }
    return u;
  };
  function s(u) {
    e = u(n);
  }
  function o(u, f) {
    const h = n.getProps(),
      d = n.getVariantContext(!0) || {},
      p = [],
      m = new Set();
    let y = {},
      w = 1 / 0;
    for (let v = 0; v < Hk; v++) {
      const M = Vk[v],
        _ = t[M],
        T = h[M] !== void 0 ? h[M] : d[M],
        P = Cf(T),
        b = M === f ? _.isActive : null;
      b === !1 && (w = v);
      let L = T === d[M] && T !== h[M] && P;
      if (
        (L && i && n.manuallyAnimateOnMount && (L = !1),
        (_.protectedKeys = { ...y }),
        (!_.isActive && b === null) ||
          (!T && !_.prevProp) ||
          wg(T) ||
          typeof T == "boolean")
      )
        continue;
      let C =
          jk(_.prevProp, T) ||
          (M === f && _.isActive && !L && P) ||
          (v > w && P),
        R = !1;
      const B = Array.isArray(T) ? T : [T];
      let Z = B.reduce(r, {});
      b === !1 && (Z = {});
      const { prevResolvedValues: ae = {} } = _,
        V = { ...ae, ...Z },
        Q = ($) => {
          (C = !0),
            m.has($) && ((R = !0), m.delete($)),
            (_.needsAnimating[$] = !0);
        };
      for (const $ in V) {
        const ce = Z[$],
          k = ae[$];
        if (y.hasOwnProperty($)) continue;
        let G = !1;
        Vm(ce) && Vm(k) ? (G = !e3(ce, k)) : (G = ce !== k),
          G
            ? ce !== void 0
              ? Q($)
              : m.add($)
            : ce !== void 0 && m.has($)
            ? Q($)
            : (_.protectedKeys[$] = !0);
      }
      (_.prevProp = T),
        (_.prevResolvedValues = Z),
        _.isActive && (y = { ...y, ...Z }),
        i && n.blockInitialAnimation && (C = !1),
        C &&
          (!L || R) &&
          p.push(
            ...B.map(($) => ({ animation: $, options: { type: M, ...u } }))
          );
    }
    if (m.size) {
      const v = {};
      m.forEach((M) => {
        const _ = n.getBaseTarget(M);
        _ !== void 0 && (v[M] = _);
      }),
        p.push({ animation: v });
    }
    let S = !!p.length;
    return (
      i &&
        (h.initial === !1 || h.initial === h.animate) &&
        !n.manuallyAnimateOnMount &&
        (S = !1),
      (i = !1),
      S ? e(p) : Promise.resolve()
    );
  }
  function a(u, f, h) {
    var d;
    if (t[u].isActive === f) return Promise.resolve();
    (d = n.variantChildren) === null ||
      d === void 0 ||
      d.forEach((m) => {
        var y;
        return (y = m.animationState) === null || y === void 0
          ? void 0
          : y.setActive(u, f);
      }),
      (t[u].isActive = f);
    const p = o(h, u);
    for (const m in t) t[m].protectedKeys = {};
    return p;
  }
  return {
    animateChanges: o,
    setActive: a,
    setAnimateFunction: s,
    getState: () => t,
  };
}
function jk(n, e) {
  return typeof e == "string" ? e !== n : Array.isArray(e) ? !e3(e, n) : !1;
}
function ua(n = !1) {
  return {
    isActive: n,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {},
  };
}
function Xk() {
  return {
    animate: ua(!0),
    whileInView: ua(),
    whileHover: ua(),
    whileTap: ua(),
    whileDrag: ua(),
    whileFocus: ua(),
    exit: ua(),
  };
}
class Yk extends Zo {
  constructor(e) {
    super(e), e.animationState || (e.animationState = Wk(e));
  }
  updateAnimationControlsSubscription() {
    const { animate: e } = this.node.getProps();
    this.unmount(), wg(e) && (this.unmount = e.subscribe(this.node));
  }
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate: e } = this.node.getProps(),
      { animate: t } = this.node.prevProps || {};
    e !== t && this.updateAnimationControlsSubscription();
  }
  unmount() {}
}
let qk = 0;
class Zk extends Zo {
  constructor() {
    super(...arguments), (this.id = qk++);
  }
  update() {
    if (!this.node.presenceContext) return;
    const {
        isPresent: e,
        onExitComplete: t,
        custom: i,
      } = this.node.presenceContext,
      { isPresent: r } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || e === r) return;
    const s = this.node.animationState.setActive("exit", !e, {
      custom: i ?? this.node.getProps().custom,
    });
    t && !e && s.then(() => t(this.id));
  }
  mount() {
    const { register: e } = this.node.presenceContext || {};
    e && (this.unmount = e(this.id));
  }
  unmount() {}
}
const Kk = { animation: { Feature: Yk }, exit: { Feature: Zk } },
  pT = (n, e) => Math.abs(n - e);
function Qk(n, e) {
  const t = pT(n.x, e.x),
    i = pT(n.y, e.y);
  return Math.sqrt(t ** 2 + i ** 2);
}
class I3 {
  constructor(
    e,
    t,
    { transformPagePoint: i, contextWindow: r, dragSnapToOrigin: s = !1 } = {}
  ) {
    if (
      ((this.startEvent = null),
      (this.lastMoveEvent = null),
      (this.lastMoveEventInfo = null),
      (this.handlers = {}),
      (this.contextWindow = window),
      (this.updatePoint = () => {
        if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return;
        const d = Q0(this.lastMoveEventInfo, this.history),
          p = this.startEvent !== null,
          m = Qk(d.offset, { x: 0, y: 0 }) >= 3;
        if (!p && !m) return;
        const { point: y } = d,
          { timestamp: w } = ui;
        this.history.push({ ...y, timestamp: w });
        const { onStart: S, onMove: v } = this.handlers;
        p ||
          (S && S(this.lastMoveEvent, d),
          (this.startEvent = this.lastMoveEvent)),
          v && v(this.lastMoveEvent, d);
      }),
      (this.handlePointerMove = (d, p) => {
        (this.lastMoveEvent = d),
          (this.lastMoveEventInfo = K0(p, this.transformPagePoint)),
          $t.update(this.updatePoint, !0);
      }),
      (this.handlePointerUp = (d, p) => {
        this.end();
        const { onEnd: m, onSessionEnd: y, resumeAnimation: w } = this.handlers;
        if (
          (this.dragSnapToOrigin && w && w(),
          !(this.lastMoveEvent && this.lastMoveEventInfo))
        )
          return;
        const S = Q0(
          d.type === "pointercancel"
            ? this.lastMoveEventInfo
            : K0(p, this.transformPagePoint),
          this.history
        );
        this.startEvent && m && m(d, S), y && y(d, S);
      }),
      !ZP(e))
    )
      return;
    (this.dragSnapToOrigin = s),
      (this.handlers = t),
      (this.transformPagePoint = i),
      (this.contextWindow = r || window);
    const o = Ag(e),
      a = K0(o, this.transformPagePoint),
      { point: u } = a,
      { timestamp: f } = ui;
    this.history = [{ ...u, timestamp: f }];
    const { onSessionStart: h } = t;
    h && h(e, Q0(a, this.history)),
      (this.removeListeners = Do(
        ks(this.contextWindow, "pointermove", this.handlePointerMove),
        ks(this.contextWindow, "pointerup", this.handlePointerUp),
        ks(this.contextWindow, "pointercancel", this.handlePointerUp)
      ));
  }
  updateHandlers(e) {
    this.handlers = e;
  }
  end() {
    this.removeListeners && this.removeListeners(), Ws(this.updatePoint);
  }
}
function K0(n, e) {
  return e ? { point: e(n.point) } : n;
}
function mT(n, e) {
  return { x: n.x - e.x, y: n.y - e.y };
}
function Q0({ point: n }, e) {
  return {
    point: n,
    delta: mT(n, N3(e)),
    offset: mT(n, $k(e)),
    velocity: Jk(e, 0.1),
  };
}
function $k(n) {
  return n[0];
}
function N3(n) {
  return n[n.length - 1];
}
function Jk(n, e) {
  if (n.length < 2) return { x: 0, y: 0 };
  let t = n.length - 1,
    i = null;
  const r = N3(n);
  for (; t >= 0 && ((i = n[t]), !(r.timestamp - i.timestamp > Ba(e))); ) t--;
  if (!i) return { x: 0, y: 0 };
  const s = Fs(r.timestamp - i.timestamp);
  if (s === 0) return { x: 0, y: 0 };
  const o = { x: (r.x - i.x) / s, y: (r.y - i.y) / s };
  return o.x === 1 / 0 && (o.x = 0), o.y === 1 / 0 && (o.y = 0), o;
}
function nr(n) {
  return n.max - n.min;
}
function Kx(n, e = 0, t = 0.01) {
  return Math.abs(n - e) <= t;
}
function gT(n, e, t, i = 0.5) {
  (n.origin = i),
    (n.originPoint = un(e.min, e.max, n.origin)),
    (n.scale = nr(t) / nr(e)),
    (Kx(n.scale, 1, 1e-4) || isNaN(n.scale)) && (n.scale = 1),
    (n.translate = un(t.min, t.max, n.origin) - n.originPoint),
    (Kx(n.translate) || isNaN(n.translate)) && (n.translate = 0);
}
function nf(n, e, t, i) {
  gT(n.x, e.x, t.x, i ? i.originX : void 0),
    gT(n.y, e.y, t.y, i ? i.originY : void 0);
}
function vT(n, e, t) {
  (n.min = t.min + e.min), (n.max = n.min + nr(e));
}
function eF(n, e, t) {
  vT(n.x, e.x, t.x), vT(n.y, e.y, t.y);
}
function yT(n, e, t) {
  (n.min = e.min - t.min), (n.max = n.min + nr(e));
}
function rf(n, e, t) {
  yT(n.x, e.x, t.x), yT(n.y, e.y, t.y);
}
function tF(n, { min: e, max: t }, i) {
  return (
    e !== void 0 && n < e
      ? (n = i ? un(e, n, i.min) : Math.max(n, e))
      : t !== void 0 && n > t && (n = i ? un(t, n, i.max) : Math.min(n, t)),
    n
  );
}
function xT(n, e, t) {
  return {
    min: e !== void 0 ? n.min + e : void 0,
    max: t !== void 0 ? n.max + t - (n.max - n.min) : void 0,
  };
}
function nF(n, { top: e, left: t, bottom: i, right: r }) {
  return { x: xT(n.x, t, r), y: xT(n.y, e, i) };
}
function _T(n, e) {
  let t = e.min - n.min,
    i = e.max - n.max;
  return e.max - e.min < n.max - n.min && ([t, i] = [i, t]), { min: t, max: i };
}
function iF(n, e) {
  return { x: _T(n.x, e.x), y: _T(n.y, e.y) };
}
function rF(n, e) {
  let t = 0.5;
  const i = nr(n),
    r = nr(e);
  return (
    r > i
      ? (t = Rf(e.min, e.max - i, n.min))
      : i > r && (t = Rf(n.min, n.max - r, e.min)),
    Vo(0, 1, t)
  );
}
function sF(n, e) {
  const t = {};
  return (
    e.min !== void 0 && (t.min = e.min - n.min),
    e.max !== void 0 && (t.max = e.max - n.min),
    t
  );
}
const Qx = 0.35;
function oF(n = Qx) {
  return (
    n === !1 ? (n = 0) : n === !0 && (n = Qx),
    { x: ST(n, "left", "right"), y: ST(n, "top", "bottom") }
  );
}
function ST(n, e, t) {
  return { min: MT(n, e), max: MT(n, t) };
}
function MT(n, e) {
  return typeof n == "number" ? n : n[e] || 0;
}
const wT = () => ({ translate: 0, scale: 1, origin: 0, originPoint: 0 }),
  fu = () => ({ x: wT(), y: wT() }),
  ET = () => ({ min: 0, max: 0 }),
  Rn = () => ({ x: ET(), y: ET() });
function yr(n) {
  return [n("x"), n("y")];
}
function D3({ top: n, left: e, right: t, bottom: i }) {
  return { x: { min: e, max: t }, y: { min: n, max: i } };
}
function aF({ x: n, y: e }) {
  return { top: e.min, right: n.max, bottom: e.max, left: n.min };
}
function lF(n, e) {
  if (!e) return n;
  const t = e({ x: n.left, y: n.top }),
    i = e({ x: n.right, y: n.bottom });
  return { top: t.y, left: t.x, bottom: i.y, right: i.x };
}
function $0(n) {
  return n === void 0 || n === 1;
}
function $x({ scale: n, scaleX: e, scaleY: t }) {
  return !$0(n) || !$0(e) || !$0(t);
}
function wa(n) {
  return $x(n) || O3(n) || n.z || n.rotate || n.rotateX || n.rotateY;
}
function O3(n) {
  return TT(n.x) || TT(n.y);
}
function TT(n) {
  return n && n !== "0%";
}
function Xm(n, e, t) {
  const i = n - t,
    r = e * i;
  return t + r;
}
function AT(n, e, t, i, r) {
  return r !== void 0 && (n = Xm(n, r, i)), Xm(n, t, i) + e;
}
function Jx(n, e = 0, t = 1, i, r) {
  (n.min = AT(n.min, e, t, i, r)), (n.max = AT(n.max, e, t, i, r));
}
function U3(n, { x: e, y: t }) {
  Jx(n.x, e.translate, e.scale, e.originPoint),
    Jx(n.y, t.translate, t.scale, t.originPoint);
}
function uF(n, e, t, i = !1) {
  const r = t.length;
  if (!r) return;
  e.x = e.y = 1;
  let s, o;
  for (let a = 0; a < r; a++) {
    (s = t[a]), (o = s.projectionDelta);
    const u = s.instance;
    (u && u.style && u.style.display === "contents") ||
      (i &&
        s.options.layoutScroll &&
        s.scroll &&
        s !== s.root &&
        hu(n, { x: -s.scroll.offset.x, y: -s.scroll.offset.y }),
      o && ((e.x *= o.x.scale), (e.y *= o.y.scale), U3(n, o)),
      i && wa(s.latestValues) && hu(n, s.latestValues));
  }
  (e.x = bT(e.x)), (e.y = bT(e.y));
}
function bT(n) {
  return Number.isInteger(n) || n > 1.0000000000001 || n < 0.999999999999
    ? n
    : 1;
}
function _o(n, e) {
  (n.min = n.min + e), (n.max = n.max + e);
}
function CT(n, e, [t, i, r]) {
  const s = e[r] !== void 0 ? e[r] : 0.5,
    o = un(n.min, n.max, s);
  Jx(n, e[t], e[i], o, e.scale);
}
const cF = ["x", "scaleX", "originX"],
  fF = ["y", "scaleY", "originY"];
function hu(n, e) {
  CT(n.x, e, cF), CT(n.y, e, fF);
}
function k3(n, e) {
  return D3(lF(n.getBoundingClientRect(), e));
}
function hF(n, e, t) {
  const i = k3(n, t),
    { scroll: r } = e;
  return r && (_o(i.x, r.offset.x), _o(i.y, r.offset.y)), i;
}
const F3 = ({ current: n }) => (n ? n.ownerDocument.defaultView : null),
  dF = new WeakMap();
class pF {
  constructor(e) {
    (this.openGlobalLock = null),
      (this.isDragging = !1),
      (this.currentDirection = null),
      (this.originPoint = { x: 0, y: 0 }),
      (this.constraints = !1),
      (this.hasMutatedConstraints = !1),
      (this.elastic = Rn()),
      (this.visualElement = e);
  }
  start(e, { snapToCursor: t = !1 } = {}) {
    const { presenceContext: i } = this.visualElement;
    if (i && i.isPresent === !1) return;
    const r = (h) => {
        const { dragSnapToOrigin: d } = this.getProps();
        d ? this.pauseAnimation() : this.stopAnimation(),
          t && this.snapToCursor(Ag(h, "page").point);
      },
      s = (h, d) => {
        const { drag: p, dragPropagation: m, onDragStart: y } = this.getProps();
        if (
          p &&
          !m &&
          (this.openGlobalLock && this.openGlobalLock(),
          (this.openGlobalLock = QP(p)),
          !this.openGlobalLock)
        )
          return;
        (this.isDragging = !0),
          (this.currentDirection = null),
          this.resolveConstraints(),
          this.visualElement.projection &&
            ((this.visualElement.projection.isAnimationBlocked = !0),
            (this.visualElement.projection.target = void 0)),
          yr((S) => {
            let v = this.getAxisMotionValue(S).get() || 0;
            if (ls.test(v)) {
              const { projection: M } = this.visualElement;
              if (M && M.layout) {
                const _ = M.layout.layoutBox[S];
                _ && (v = nr(_) * (parseFloat(v) / 100));
              }
            }
            this.originPoint[S] = v;
          }),
          y && $t.update(() => y(h, d), !1, !0);
        const { animationState: w } = this.visualElement;
        w && w.setActive("whileDrag", !0);
      },
      o = (h, d) => {
        const {
          dragPropagation: p,
          dragDirectionLock: m,
          onDirectionLock: y,
          onDrag: w,
        } = this.getProps();
        if (!p && !this.openGlobalLock) return;
        const { offset: S } = d;
        if (m && this.currentDirection === null) {
          (this.currentDirection = mF(S)),
            this.currentDirection !== null && y && y(this.currentDirection);
          return;
        }
        this.updateAxis("x", d.point, S),
          this.updateAxis("y", d.point, S),
          this.visualElement.render(),
          w && w(h, d);
      },
      a = (h, d) => this.stop(h, d),
      u = () =>
        yr((h) => {
          var d;
          return (
            this.getAnimationState(h) === "paused" &&
            ((d = this.getAxisMotionValue(h).animation) === null || d === void 0
              ? void 0
              : d.play())
          );
        }),
      { dragSnapToOrigin: f } = this.getProps();
    this.panSession = new I3(
      e,
      {
        onSessionStart: r,
        onStart: s,
        onMove: o,
        onSessionEnd: a,
        resumeAnimation: u,
      },
      {
        transformPagePoint: this.visualElement.getTransformPagePoint(),
        dragSnapToOrigin: f,
        contextWindow: F3(this.visualElement),
      }
    );
  }
  stop(e, t) {
    const i = this.isDragging;
    if ((this.cancel(), !i)) return;
    const { velocity: r } = t;
    this.startAnimation(r);
    const { onDragEnd: s } = this.getProps();
    s && $t.update(() => s(e, t));
  }
  cancel() {
    this.isDragging = !1;
    const { projection: e, animationState: t } = this.visualElement;
    e && (e.isAnimationBlocked = !1),
      this.panSession && this.panSession.end(),
      (this.panSession = void 0);
    const { dragPropagation: i } = this.getProps();
    !i &&
      this.openGlobalLock &&
      (this.openGlobalLock(), (this.openGlobalLock = null)),
      t && t.setActive("whileDrag", !1);
  }
  updateAxis(e, t, i) {
    const { drag: r } = this.getProps();
    if (!i || !jd(e, r, this.currentDirection)) return;
    const s = this.getAxisMotionValue(e);
    let o = this.originPoint[e] + i[e];
    this.constraints &&
      this.constraints[e] &&
      (o = tF(o, this.constraints[e], this.elastic[e])),
      s.set(o);
  }
  resolveConstraints() {
    var e;
    const { dragConstraints: t, dragElastic: i } = this.getProps(),
      r =
        this.visualElement.projection && !this.visualElement.projection.layout
          ? this.visualElement.projection.measure(!1)
          : (e = this.visualElement.projection) === null || e === void 0
          ? void 0
          : e.layout,
      s = this.constraints;
    t && uu(t)
      ? this.constraints || (this.constraints = this.resolveRefConstraints())
      : t && r
      ? (this.constraints = nF(r.layoutBox, t))
      : (this.constraints = !1),
      (this.elastic = oF(i)),
      s !== this.constraints &&
        r &&
        this.constraints &&
        !this.hasMutatedConstraints &&
        yr((o) => {
          this.getAxisMotionValue(o) &&
            (this.constraints[o] = sF(r.layoutBox[o], this.constraints[o]));
        });
  }
  resolveRefConstraints() {
    const { dragConstraints: e, onMeasureDragConstraints: t } = this.getProps();
    if (!e || !uu(e)) return !1;
    const i = e.current,
      { projection: r } = this.visualElement;
    if (!r || !r.layout) return !1;
    const s = hF(i, r.root, this.visualElement.getTransformPagePoint());
    let o = iF(r.layout.layoutBox, s);
    if (t) {
      const a = t(aF(o));
      (this.hasMutatedConstraints = !!a), a && (o = D3(a));
    }
    return o;
  }
  startAnimation(e) {
    const {
        drag: t,
        dragMomentum: i,
        dragElastic: r,
        dragTransition: s,
        dragSnapToOrigin: o,
        onDragTransitionEnd: a,
      } = this.getProps(),
      u = this.constraints || {},
      f = yr((h) => {
        if (!jd(h, t, this.currentDirection)) return;
        let d = (u && u[h]) || {};
        o && (d = { min: 0, max: 0 });
        const p = r ? 200 : 1e6,
          m = r ? 40 : 1e7,
          y = {
            type: "inertia",
            velocity: i ? e[h] : 0,
            bounceStiffness: p,
            bounceDamping: m,
            timeConstant: 750,
            restDelta: 1,
            restSpeed: 10,
            ...s,
            ...d,
          };
        return this.startAxisValueAnimation(h, y);
      });
    return Promise.all(f).then(a);
  }
  startAxisValueAnimation(e, t) {
    const i = this.getAxisMotionValue(e);
    return i.start(oS(e, i, 0, t));
  }
  stopAnimation() {
    yr((e) => this.getAxisMotionValue(e).stop());
  }
  pauseAnimation() {
    yr((e) => {
      var t;
      return (t = this.getAxisMotionValue(e).animation) === null || t === void 0
        ? void 0
        : t.pause();
    });
  }
  getAnimationState(e) {
    var t;
    return (t = this.getAxisMotionValue(e).animation) === null || t === void 0
      ? void 0
      : t.state;
  }
  getAxisMotionValue(e) {
    const t = "_drag" + e.toUpperCase(),
      i = this.visualElement.getProps(),
      r = i[t];
    return (
      r ||
      this.visualElement.getValue(e, (i.initial ? i.initial[e] : void 0) || 0)
    );
  }
  snapToCursor(e) {
    yr((t) => {
      const { drag: i } = this.getProps();
      if (!jd(t, i, this.currentDirection)) return;
      const { projection: r } = this.visualElement,
        s = this.getAxisMotionValue(t);
      if (r && r.layout) {
        const { min: o, max: a } = r.layout.layoutBox[t];
        s.set(e[t] - un(o, a, 0.5));
      }
    });
  }
  scalePositionWithinConstraints() {
    if (!this.visualElement.current) return;
    const { drag: e, dragConstraints: t } = this.getProps(),
      { projection: i } = this.visualElement;
    if (!uu(t) || !i || !this.constraints) return;
    this.stopAnimation();
    const r = { x: 0, y: 0 };
    yr((o) => {
      const a = this.getAxisMotionValue(o);
      if (a) {
        const u = a.get();
        r[o] = rF({ min: u, max: u }, this.constraints[o]);
      }
    });
    const { transformTemplate: s } = this.visualElement.getProps();
    (this.visualElement.current.style.transform = s ? s({}, "") : "none"),
      i.root && i.root.updateScroll(),
      i.updateLayout(),
      this.resolveConstraints(),
      yr((o) => {
        if (!jd(o, e, null)) return;
        const a = this.getAxisMotionValue(o),
          { min: u, max: f } = this.constraints[o];
        a.set(un(u, f, r[o]));
      });
  }
  addListeners() {
    if (!this.visualElement.current) return;
    dF.set(this.visualElement, this);
    const e = this.visualElement.current,
      t = ks(e, "pointerdown", (u) => {
        const { drag: f, dragListener: h = !0 } = this.getProps();
        f && h && this.start(u);
      }),
      i = () => {
        const { dragConstraints: u } = this.getProps();
        uu(u) && (this.constraints = this.resolveRefConstraints());
      },
      { projection: r } = this.visualElement,
      s = r.addEventListener("measure", i);
    r && !r.layout && (r.root && r.root.updateScroll(), r.updateLayout()), i();
    const o = Ns(window, "resize", () => this.scalePositionWithinConstraints()),
      a = r.addEventListener(
        "didUpdate",
        ({ delta: u, hasLayoutChanged: f }) => {
          this.isDragging &&
            f &&
            (yr((h) => {
              const d = this.getAxisMotionValue(h);
              d &&
                ((this.originPoint[h] += u[h].translate),
                d.set(d.get() + u[h].translate));
            }),
            this.visualElement.render());
        }
      );
    return () => {
      o(), t(), s(), a && a();
    };
  }
  getProps() {
    const e = this.visualElement.getProps(),
      {
        drag: t = !1,
        dragDirectionLock: i = !1,
        dragPropagation: r = !1,
        dragConstraints: s = !1,
        dragElastic: o = Qx,
        dragMomentum: a = !0,
      } = e;
    return {
      ...e,
      drag: t,
      dragDirectionLock: i,
      dragPropagation: r,
      dragConstraints: s,
      dragElastic: o,
      dragMomentum: a,
    };
  }
}
function jd(n, e, t) {
  return (e === !0 || e === n) && (t === null || t === n);
}
function mF(n, e = 10) {
  let t = null;
  return Math.abs(n.y) > e ? (t = "y") : Math.abs(n.x) > e && (t = "x"), t;
}
class gF extends Zo {
  constructor(e) {
    super(e),
      (this.removeGroupControls = Tn),
      (this.removeListeners = Tn),
      (this.controls = new pF(e));
  }
  mount() {
    const { dragControls: e } = this.node.getProps();
    e && (this.removeGroupControls = e.subscribe(this.controls)),
      (this.removeListeners = this.controls.addListeners() || Tn);
  }
  unmount() {
    this.removeGroupControls(), this.removeListeners();
  }
}
const PT = (n) => (e, t) => {
  n && $t.update(() => n(e, t));
};
class vF extends Zo {
  constructor() {
    super(...arguments), (this.removePointerDownListener = Tn);
  }
  onPointerDown(e) {
    this.session = new I3(e, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
      contextWindow: F3(this.node),
    });
  }
  createPanHandlers() {
    const {
      onPanSessionStart: e,
      onPanStart: t,
      onPan: i,
      onPanEnd: r,
    } = this.node.getProps();
    return {
      onSessionStart: PT(e),
      onStart: PT(t),
      onMove: i,
      onEnd: (s, o) => {
        delete this.session, r && $t.update(() => r(s, o));
      },
    };
  }
  mount() {
    this.removePointerDownListener = ks(this.node.current, "pointerdown", (e) =>
      this.onPointerDown(e)
    );
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers());
  }
  unmount() {
    this.removePointerDownListener(), this.session && this.session.end();
  }
}
function yF() {
  const n = se.useContext(G1);
  if (n === null) return [!0, null];
  const { isPresent: e, onExitComplete: t, register: i } = n,
    r = se.useId();
  return se.useEffect(() => i(r), []), !e && t ? [!1, () => t && t(r)] : [!0];
}
const sm = { hasAnimatedSinceResize: !0, hasEverUpdated: !1 };
function RT(n, e) {
  return e.max === e.min ? 0 : (n / (e.max - e.min)) * 100;
}
const Tc = {
    correct: (n, e) => {
      if (!e.target) return n;
      if (typeof n == "string")
        if (ft.test(n)) n = parseFloat(n);
        else return n;
      const t = RT(n, e.target.x),
        i = RT(n, e.target.y);
      return `${t}% ${i}%`;
    },
  },
  xF = {
    correct: (n, { treeScale: e, projectionDelta: t }) => {
      const i = n,
        r = Ho.parse(n);
      if (r.length > 5) return i;
      const s = Ho.createTransformer(n),
        o = typeof r[0] != "number" ? 1 : 0,
        a = t.x.scale * e.x,
        u = t.y.scale * e.y;
      (r[0 + o] /= a), (r[1 + o] /= u);
      const f = un(a, u, 0.5);
      return (
        typeof r[2 + o] == "number" && (r[2 + o] /= f),
        typeof r[3 + o] == "number" && (r[3 + o] /= f),
        s(r)
      );
    },
  };
class _F extends ss.Component {
  componentDidMount() {
    const {
        visualElement: e,
        layoutGroup: t,
        switchLayoutGroup: i,
        layoutId: r,
      } = this.props,
      { projection: s } = e;
    AO(SF),
      s &&
        (t.group && t.group.add(s),
        i && i.register && r && i.register(s),
        s.root.didUpdate(),
        s.addEventListener("animationComplete", () => {
          this.safeToRemove();
        }),
        s.setOptions({
          ...s.options,
          onExitComplete: () => this.safeToRemove(),
        })),
      (sm.hasEverUpdated = !0);
  }
  getSnapshotBeforeUpdate(e) {
    const {
        layoutDependency: t,
        visualElement: i,
        drag: r,
        isPresent: s,
      } = this.props,
      o = i.projection;
    return (
      o &&
        ((o.isPresent = s),
        r || e.layoutDependency !== t || t === void 0
          ? o.willUpdate()
          : this.safeToRemove(),
        e.isPresent !== s &&
          (s
            ? o.promote()
            : o.relegate() ||
              $t.postRender(() => {
                const a = o.getStack();
                (!a || !a.members.length) && this.safeToRemove();
              }))),
      null
    );
  }
  componentDidUpdate() {
    const { projection: e } = this.props.visualElement;
    e &&
      (e.root.didUpdate(),
      queueMicrotask(() => {
        !e.currentAnimation && e.isLead() && this.safeToRemove();
      }));
  }
  componentWillUnmount() {
    const {
        visualElement: e,
        layoutGroup: t,
        switchLayoutGroup: i,
      } = this.props,
      { projection: r } = e;
    r &&
      (r.scheduleCheckAfterUnmount(),
      t && t.group && t.group.remove(r),
      i && i.deregister && i.deregister(r));
  }
  safeToRemove() {
    const { safeToRemove: e } = this.props;
    e && e();
  }
  render() {
    return null;
  }
}
function z3(n) {
  const [e, t] = yF(),
    i = se.useContext(DP);
  return ss.createElement(_F, {
    ...n,
    layoutGroup: i,
    switchLayoutGroup: se.useContext(OP),
    isPresent: e,
    safeToRemove: t,
  });
}
const SF = {
    borderRadius: {
      ...Tc,
      applyTo: [
        "borderTopLeftRadius",
        "borderTopRightRadius",
        "borderBottomLeftRadius",
        "borderBottomRightRadius",
      ],
    },
    borderTopLeftRadius: Tc,
    borderTopRightRadius: Tc,
    borderBottomLeftRadius: Tc,
    borderBottomRightRadius: Tc,
    boxShadow: xF,
  },
  B3 = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"],
  MF = B3.length,
  LT = (n) => (typeof n == "string" ? parseFloat(n) : n),
  IT = (n) => typeof n == "number" || ft.test(n);
function wF(n, e, t, i, r, s) {
  r
    ? ((n.opacity = un(0, t.opacity !== void 0 ? t.opacity : 1, EF(i))),
      (n.opacityExit = un(e.opacity !== void 0 ? e.opacity : 1, 0, TF(i))))
    : s &&
      (n.opacity = un(
        e.opacity !== void 0 ? e.opacity : 1,
        t.opacity !== void 0 ? t.opacity : 1,
        i
      ));
  for (let o = 0; o < MF; o++) {
    const a = `border${B3[o]}Radius`;
    let u = NT(e, a),
      f = NT(t, a);
    if (u === void 0 && f === void 0) continue;
    u || (u = 0),
      f || (f = 0),
      u === 0 || f === 0 || IT(u) === IT(f)
        ? ((n[a] = Math.max(un(LT(u), LT(f), i), 0)),
          (ls.test(f) || ls.test(u)) && (n[a] += "%"))
        : (n[a] = f);
  }
  (e.rotate || t.rotate) && (n.rotate = un(e.rotate || 0, t.rotate || 0, i));
}
function NT(n, e) {
  return n[e] !== void 0 ? n[e] : n.borderRadius;
}
const EF = V3(0, 0.5, u3),
  TF = V3(0.5, 0.95, Tn);
function V3(n, e, t) {
  return (i) => (i < n ? 0 : i > e ? 1 : t(Rf(n, e, i)));
}
function DT(n, e) {
  (n.min = e.min), (n.max = e.max);
}
function gr(n, e) {
  DT(n.x, e.x), DT(n.y, e.y);
}
function OT(n, e, t, i, r) {
  return (
    (n -= e), (n = Xm(n, 1 / t, i)), r !== void 0 && (n = Xm(n, 1 / r, i)), n
  );
}
function AF(n, e = 0, t = 1, i = 0.5, r, s = n, o = n) {
  if (
    (ls.test(e) &&
      ((e = parseFloat(e)), (e = un(o.min, o.max, e / 100) - o.min)),
    typeof e != "number")
  )
    return;
  let a = un(s.min, s.max, i);
  n === s && (a -= e),
    (n.min = OT(n.min, e, t, a, r)),
    (n.max = OT(n.max, e, t, a, r));
}
function UT(n, e, [t, i, r], s, o) {
  AF(n, e[t], e[i], e[r], e.scale, s, o);
}
const bF = ["x", "scaleX", "originX"],
  CF = ["y", "scaleY", "originY"];
function kT(n, e, t, i) {
  UT(n.x, e, bF, t ? t.x : void 0, i ? i.x : void 0),
    UT(n.y, e, CF, t ? t.y : void 0, i ? i.y : void 0);
}
function FT(n) {
  return n.translate === 0 && n.scale === 1;
}
function H3(n) {
  return FT(n.x) && FT(n.y);
}
function PF(n, e) {
  return (
    n.x.min === e.x.min &&
    n.x.max === e.x.max &&
    n.y.min === e.y.min &&
    n.y.max === e.y.max
  );
}
function G3(n, e) {
  return (
    Math.round(n.x.min) === Math.round(e.x.min) &&
    Math.round(n.x.max) === Math.round(e.x.max) &&
    Math.round(n.y.min) === Math.round(e.y.min) &&
    Math.round(n.y.max) === Math.round(e.y.max)
  );
}
function zT(n) {
  return nr(n.x) / nr(n.y);
}
class RF {
  constructor() {
    this.members = [];
  }
  add(e) {
    aS(this.members, e), e.scheduleRender();
  }
  remove(e) {
    if (
      (lS(this.members, e),
      e === this.prevLead && (this.prevLead = void 0),
      e === this.lead)
    ) {
      const t = this.members[this.members.length - 1];
      t && this.promote(t);
    }
  }
  relegate(e) {
    const t = this.members.findIndex((r) => e === r);
    if (t === 0) return !1;
    let i;
    for (let r = t; r >= 0; r--) {
      const s = this.members[r];
      if (s.isPresent !== !1) {
        i = s;
        break;
      }
    }
    return i ? (this.promote(i), !0) : !1;
  }
  promote(e, t) {
    const i = this.lead;
    if (e !== i && ((this.prevLead = i), (this.lead = e), e.show(), i)) {
      i.instance && i.scheduleRender(),
        e.scheduleRender(),
        (e.resumeFrom = i),
        t && (e.resumeFrom.preserveOpacity = !0),
        i.snapshot &&
          ((e.snapshot = i.snapshot),
          (e.snapshot.latestValues = i.animationValues || i.latestValues)),
        e.root && e.root.isUpdating && (e.isLayoutDirty = !0);
      const { crossfade: r } = e.options;
      r === !1 && i.hide();
    }
  }
  exitAnimationComplete() {
    this.members.forEach((e) => {
      const { options: t, resumingFrom: i } = e;
      t.onExitComplete && t.onExitComplete(),
        i && i.options.onExitComplete && i.options.onExitComplete();
    });
  }
  scheduleRender() {
    this.members.forEach((e) => {
      e.instance && e.scheduleRender(!1);
    });
  }
  removeLeadSnapshot() {
    this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);
  }
}
function BT(n, e, t) {
  let i = "";
  const r = n.x.translate / e.x,
    s = n.y.translate / e.y;
  if (
    ((r || s) && (i = `translate3d(${r}px, ${s}px, 0) `),
    (e.x !== 1 || e.y !== 1) && (i += `scale(${1 / e.x}, ${1 / e.y}) `),
    t)
  ) {
    const { rotate: u, rotateX: f, rotateY: h } = t;
    u && (i += `rotate(${u}deg) `),
      f && (i += `rotateX(${f}deg) `),
      h && (i += `rotateY(${h}deg) `);
  }
  const o = n.x.scale * e.x,
    a = n.y.scale * e.y;
  return (o !== 1 || a !== 1) && (i += `scale(${o}, ${a})`), i || "none";
}
const LF = (n, e) => n.depth - e.depth;
class IF {
  constructor() {
    (this.children = []), (this.isDirty = !1);
  }
  add(e) {
    aS(this.children, e), (this.isDirty = !0);
  }
  remove(e) {
    lS(this.children, e), (this.isDirty = !0);
  }
  forEach(e) {
    this.isDirty && this.children.sort(LF),
      (this.isDirty = !1),
      this.children.forEach(e);
  }
}
function NF(n, e) {
  const t = performance.now(),
    i = ({ timestamp: r }) => {
      const s = r - t;
      s >= e && (Ws(i), n(s - e));
    };
  return $t.read(i, !0), () => Ws(i);
}
function DF(n) {
  window.MotionDebug && window.MotionDebug.record(n);
}
function OF(n) {
  return n instanceof SVGElement && n.tagName !== "svg";
}
function UF(n, e, t) {
  const i = Vi(n) ? n : Nu(n);
  return i.start(oS("", i, e, t)), i.animation;
}
const VT = ["", "X", "Y", "Z"],
  kF = { visibility: "hidden" },
  HT = 1e3;
let FF = 0;
const Ea = {
  type: "projectionFrame",
  totalNodes: 0,
  resolvedTargetDeltas: 0,
  recalculatedProjection: 0,
};
function W3({
  attachResizeListener: n,
  defaultParent: e,
  measureScroll: t,
  checkIsScrollRoot: i,
  resetTransform: r,
}) {
  return class {
    constructor(o = {}, a = e == null ? void 0 : e()) {
      (this.id = FF++),
        (this.animationId = 0),
        (this.children = new Set()),
        (this.options = {}),
        (this.isTreeAnimating = !1),
        (this.isAnimationBlocked = !1),
        (this.isLayoutDirty = !1),
        (this.isProjectionDirty = !1),
        (this.isSharedProjectionDirty = !1),
        (this.isTransformDirty = !1),
        (this.updateManuallyBlocked = !1),
        (this.updateBlockedByResize = !1),
        (this.isUpdating = !1),
        (this.isSVG = !1),
        (this.needsReset = !1),
        (this.shouldResetTransform = !1),
        (this.treeScale = { x: 1, y: 1 }),
        (this.eventHandlers = new Map()),
        (this.hasTreeAnimated = !1),
        (this.updateScheduled = !1),
        (this.projectionUpdateScheduled = !1),
        (this.checkUpdateFailed = () => {
          this.isUpdating && ((this.isUpdating = !1), this.clearAllSnapshots());
        }),
        (this.updateProjection = () => {
          (this.projectionUpdateScheduled = !1),
            (Ea.totalNodes =
              Ea.resolvedTargetDeltas =
              Ea.recalculatedProjection =
                0),
            this.nodes.forEach(VF),
            this.nodes.forEach(XF),
            this.nodes.forEach(YF),
            this.nodes.forEach(HF),
            DF(Ea);
        }),
        (this.hasProjected = !1),
        (this.isVisible = !0),
        (this.animationProgress = 0),
        (this.sharedNodes = new Map()),
        (this.latestValues = o),
        (this.root = a ? a.root || a : this),
        (this.path = a ? [...a.path, a] : []),
        (this.parent = a),
        (this.depth = a ? a.depth + 1 : 0);
      for (let u = 0; u < this.path.length; u++)
        this.path[u].shouldResetTransform = !0;
      this.root === this && (this.nodes = new IF());
    }
    addEventListener(o, a) {
      return (
        this.eventHandlers.has(o) || this.eventHandlers.set(o, new uS()),
        this.eventHandlers.get(o).add(a)
      );
    }
    notifyListeners(o, ...a) {
      const u = this.eventHandlers.get(o);
      u && u.notify(...a);
    }
    hasListeners(o) {
      return this.eventHandlers.has(o);
    }
    mount(o, a = this.root.hasTreeAnimated) {
      if (this.instance) return;
      (this.isSVG = OF(o)), (this.instance = o);
      const { layoutId: u, layout: f, visualElement: h } = this.options;
      if (
        (h && !h.current && h.mount(o),
        this.root.nodes.add(this),
        this.parent && this.parent.children.add(this),
        a && (f || u) && (this.isLayoutDirty = !0),
        n)
      ) {
        let d;
        const p = () => (this.root.updateBlockedByResize = !1);
        n(o, () => {
          (this.root.updateBlockedByResize = !0),
            d && d(),
            (d = NF(p, 250)),
            sm.hasAnimatedSinceResize &&
              ((sm.hasAnimatedSinceResize = !1), this.nodes.forEach(WT));
        });
      }
      u && this.root.registerSharedNode(u, this),
        this.options.animate !== !1 &&
          h &&
          (u || f) &&
          this.addEventListener(
            "didUpdate",
            ({
              delta: d,
              hasLayoutChanged: p,
              hasRelativeTargetChanged: m,
              layout: y,
            }) => {
              if (this.isTreeAnimationBlocked()) {
                (this.target = void 0), (this.relativeTarget = void 0);
                return;
              }
              const w =
                  this.options.transition || h.getDefaultTransition() || $F,
                { onLayoutAnimationStart: S, onLayoutAnimationComplete: v } =
                  h.getProps(),
                M = !this.targetLayout || !G3(this.targetLayout, y) || m,
                _ = !p && m;
              if (
                this.options.layoutRoot ||
                (this.resumeFrom && this.resumeFrom.instance) ||
                _ ||
                (p && (M || !this.currentAnimation))
              ) {
                this.resumeFrom &&
                  ((this.resumingFrom = this.resumeFrom),
                  (this.resumingFrom.resumingFrom = void 0)),
                  this.setAnimationOrigin(d, _);
                const T = { ...sS(w, "layout"), onPlay: S, onComplete: v };
                (h.shouldReduceMotion || this.options.layoutRoot) &&
                  ((T.delay = 0), (T.type = !1)),
                  this.startAnimation(T);
              } else
                p || WT(this),
                  this.isLead() &&
                    this.options.onExitComplete &&
                    this.options.onExitComplete();
              this.targetLayout = y;
            }
          );
    }
    unmount() {
      this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);
      const o = this.getStack();
      o && o.remove(this),
        this.parent && this.parent.children.delete(this),
        (this.instance = void 0),
        Ws(this.updateProjection);
    }
    blockUpdate() {
      this.updateManuallyBlocked = !0;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = !1;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return (
        this.isAnimationBlocked ||
        (this.parent && this.parent.isTreeAnimationBlocked()) ||
        !1
      );
    }
    startUpdate() {
      this.isUpdateBlocked() ||
        ((this.isUpdating = !0),
        this.nodes && this.nodes.forEach(qF),
        this.animationId++);
    }
    getTransformTemplate() {
      const { visualElement: o } = this.options;
      return o && o.getProps().transformTemplate;
    }
    willUpdate(o = !0) {
      if (((this.root.hasTreeAnimated = !0), this.root.isUpdateBlocked())) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      if (
        (!this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty)
      )
        return;
      this.isLayoutDirty = !0;
      for (let h = 0; h < this.path.length; h++) {
        const d = this.path[h];
        (d.shouldResetTransform = !0),
          d.updateScroll("snapshot"),
          d.options.layoutRoot && d.willUpdate(!1);
      }
      const { layoutId: a, layout: u } = this.options;
      if (a === void 0 && !u) return;
      const f = this.getTransformTemplate();
      (this.prevTransformTemplateValue = f ? f(this.latestValues, "") : void 0),
        this.updateSnapshot(),
        o && this.notifyListeners("willUpdate");
    }
    update() {
      if (((this.updateScheduled = !1), this.isUpdateBlocked())) {
        this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(GT);
        return;
      }
      this.isUpdating || this.nodes.forEach(WF),
        (this.isUpdating = !1),
        this.nodes.forEach(jF),
        this.nodes.forEach(zF),
        this.nodes.forEach(BF),
        this.clearAllSnapshots();
      const a = performance.now();
      (ui.delta = Vo(0, 1e3 / 60, a - ui.timestamp)),
        (ui.timestamp = a),
        (ui.isProcessing = !0),
        H0.update.process(ui),
        H0.preRender.process(ui),
        H0.render.process(ui),
        (ui.isProcessing = !1);
    }
    didUpdate() {
      this.updateScheduled ||
        ((this.updateScheduled = !0), queueMicrotask(() => this.update()));
    }
    clearAllSnapshots() {
      this.nodes.forEach(GF), this.sharedNodes.forEach(ZF);
    }
    scheduleUpdateProjection() {
      this.projectionUpdateScheduled ||
        ((this.projectionUpdateScheduled = !0),
        $t.preRender(this.updateProjection, !1, !0));
    }
    scheduleCheckAfterUnmount() {
      $t.postRender(() => {
        this.isLayoutDirty
          ? this.root.didUpdate()
          : this.root.checkUpdateFailed();
      });
    }
    updateSnapshot() {
      this.snapshot || !this.instance || (this.snapshot = this.measure());
    }
    updateLayout() {
      if (
        !this.instance ||
        (this.updateScroll(),
        !(this.options.alwaysMeasureLayout && this.isLead()) &&
          !this.isLayoutDirty)
      )
        return;
      if (this.resumeFrom && !this.resumeFrom.instance)
        for (let u = 0; u < this.path.length; u++) this.path[u].updateScroll();
      const o = this.layout;
      (this.layout = this.measure(!1)),
        (this.layoutCorrected = Rn()),
        (this.isLayoutDirty = !1),
        (this.projectionDelta = void 0),
        this.notifyListeners("measure", this.layout.layoutBox);
      const { visualElement: a } = this.options;
      a &&
        a.notify(
          "LayoutMeasure",
          this.layout.layoutBox,
          o ? o.layoutBox : void 0
        );
    }
    updateScroll(o = "measure") {
      let a = !!(this.options.layoutScroll && this.instance);
      this.scroll &&
        this.scroll.animationId === this.root.animationId &&
        this.scroll.phase === o &&
        (a = !1),
        a &&
          (this.scroll = {
            animationId: this.root.animationId,
            phase: o,
            isRoot: i(this.instance),
            offset: t(this.instance),
          });
    }
    resetTransform() {
      if (!r) return;
      const o = this.isLayoutDirty || this.shouldResetTransform,
        a = this.projectionDelta && !H3(this.projectionDelta),
        u = this.getTransformTemplate(),
        f = u ? u(this.latestValues, "") : void 0,
        h = f !== this.prevTransformTemplateValue;
      o &&
        (a || wa(this.latestValues) || h) &&
        (r(this.instance, f),
        (this.shouldResetTransform = !1),
        this.scheduleRender());
    }
    measure(o = !0) {
      const a = this.measurePageBox();
      let u = this.removeElementScroll(a);
      return (
        o && (u = this.removeTransform(u)),
        JF(u),
        {
          animationId: this.root.animationId,
          measuredBox: a,
          layoutBox: u,
          latestValues: {},
          source: this.id,
        }
      );
    }
    measurePageBox() {
      const { visualElement: o } = this.options;
      if (!o) return Rn();
      const a = o.measureViewportBox(),
        { scroll: u } = this.root;
      return u && (_o(a.x, u.offset.x), _o(a.y, u.offset.y)), a;
    }
    removeElementScroll(o) {
      const a = Rn();
      gr(a, o);
      for (let u = 0; u < this.path.length; u++) {
        const f = this.path[u],
          { scroll: h, options: d } = f;
        if (f !== this.root && h && d.layoutScroll) {
          if (h.isRoot) {
            gr(a, o);
            const { scroll: p } = this.root;
            p && (_o(a.x, -p.offset.x), _o(a.y, -p.offset.y));
          }
          _o(a.x, h.offset.x), _o(a.y, h.offset.y);
        }
      }
      return a;
    }
    applyTransform(o, a = !1) {
      const u = Rn();
      gr(u, o);
      for (let f = 0; f < this.path.length; f++) {
        const h = this.path[f];
        !a &&
          h.options.layoutScroll &&
          h.scroll &&
          h !== h.root &&
          hu(u, { x: -h.scroll.offset.x, y: -h.scroll.offset.y }),
          wa(h.latestValues) && hu(u, h.latestValues);
      }
      return wa(this.latestValues) && hu(u, this.latestValues), u;
    }
    removeTransform(o) {
      const a = Rn();
      gr(a, o);
      for (let u = 0; u < this.path.length; u++) {
        const f = this.path[u];
        if (!f.instance || !wa(f.latestValues)) continue;
        $x(f.latestValues) && f.updateSnapshot();
        const h = Rn(),
          d = f.measurePageBox();
        gr(h, d),
          kT(a, f.latestValues, f.snapshot ? f.snapshot.layoutBox : void 0, h);
      }
      return wa(this.latestValues) && kT(a, this.latestValues), a;
    }
    setTargetDelta(o) {
      (this.targetDelta = o),
        this.root.scheduleUpdateProjection(),
        (this.isProjectionDirty = !0);
    }
    setOptions(o) {
      this.options = {
        ...this.options,
        ...o,
        crossfade: o.crossfade !== void 0 ? o.crossfade : !0,
      };
    }
    clearMeasurements() {
      (this.scroll = void 0),
        (this.layout = void 0),
        (this.snapshot = void 0),
        (this.prevTransformTemplateValue = void 0),
        (this.targetDelta = void 0),
        (this.target = void 0),
        (this.isLayoutDirty = !1);
    }
    forceRelativeParentToResolveTarget() {
      this.relativeParent &&
        this.relativeParent.resolvedRelativeTargetAt !== ui.timestamp &&
        this.relativeParent.resolveTargetDelta(!0);
    }
    resolveTargetDelta(o = !1) {
      var a;
      const u = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = u.isProjectionDirty),
        this.isTransformDirty || (this.isTransformDirty = u.isTransformDirty),
        this.isSharedProjectionDirty ||
          (this.isSharedProjectionDirty = u.isSharedProjectionDirty);
      const f = !!this.resumingFrom || this !== u;
      if (
        !(
          o ||
          (f && this.isSharedProjectionDirty) ||
          this.isProjectionDirty ||
          (!((a = this.parent) === null || a === void 0) &&
            a.isProjectionDirty) ||
          this.attemptToResolveRelativeTarget
        )
      )
        return;
      const { layout: d, layoutId: p } = this.options;
      if (!(!this.layout || !(d || p))) {
        if (
          ((this.resolvedRelativeTargetAt = ui.timestamp),
          !this.targetDelta && !this.relativeTarget)
        ) {
          const m = this.getClosestProjectingParent();
          m && m.layout && this.animationProgress !== 1
            ? ((this.relativeParent = m),
              this.forceRelativeParentToResolveTarget(),
              (this.relativeTarget = Rn()),
              (this.relativeTargetOrigin = Rn()),
              rf(
                this.relativeTargetOrigin,
                this.layout.layoutBox,
                m.layout.layoutBox
              ),
              gr(this.relativeTarget, this.relativeTargetOrigin))
            : (this.relativeParent = this.relativeTarget = void 0);
        }
        if (!(!this.relativeTarget && !this.targetDelta)) {
          if (
            (this.target ||
              ((this.target = Rn()), (this.targetWithTransforms = Rn())),
            this.relativeTarget &&
            this.relativeTargetOrigin &&
            this.relativeParent &&
            this.relativeParent.target
              ? (this.forceRelativeParentToResolveTarget(),
                eF(
                  this.target,
                  this.relativeTarget,
                  this.relativeParent.target
                ))
              : this.targetDelta
              ? (this.resumingFrom
                  ? (this.target = this.applyTransform(this.layout.layoutBox))
                  : gr(this.target, this.layout.layoutBox),
                U3(this.target, this.targetDelta))
              : gr(this.target, this.layout.layoutBox),
            this.attemptToResolveRelativeTarget)
          ) {
            this.attemptToResolveRelativeTarget = !1;
            const m = this.getClosestProjectingParent();
            m &&
            !!m.resumingFrom == !!this.resumingFrom &&
            !m.options.layoutScroll &&
            m.target &&
            this.animationProgress !== 1
              ? ((this.relativeParent = m),
                this.forceRelativeParentToResolveTarget(),
                (this.relativeTarget = Rn()),
                (this.relativeTargetOrigin = Rn()),
                rf(this.relativeTargetOrigin, this.target, m.target),
                gr(this.relativeTarget, this.relativeTargetOrigin))
              : (this.relativeParent = this.relativeTarget = void 0);
          }
          Ea.resolvedTargetDeltas++;
        }
      }
    }
    getClosestProjectingParent() {
      if (
        !(
          !this.parent ||
          $x(this.parent.latestValues) ||
          O3(this.parent.latestValues)
        )
      )
        return this.parent.isProjecting()
          ? this.parent
          : this.parent.getClosestProjectingParent();
    }
    isProjecting() {
      return !!(
        (this.relativeTarget || this.targetDelta || this.options.layoutRoot) &&
        this.layout
      );
    }
    calcProjection() {
      var o;
      const a = this.getLead(),
        u = !!this.resumingFrom || this !== a;
      let f = !0;
      if (
        ((this.isProjectionDirty ||
          (!((o = this.parent) === null || o === void 0) &&
            o.isProjectionDirty)) &&
          (f = !1),
        u &&
          (this.isSharedProjectionDirty || this.isTransformDirty) &&
          (f = !1),
        this.resolvedRelativeTargetAt === ui.timestamp && (f = !1),
        f)
      )
        return;
      const { layout: h, layoutId: d } = this.options;
      if (
        ((this.isTreeAnimating = !!(
          (this.parent && this.parent.isTreeAnimating) ||
          this.currentAnimation ||
          this.pendingAnimation
        )),
        this.isTreeAnimating ||
          (this.targetDelta = this.relativeTarget = void 0),
        !this.layout || !(h || d))
      )
        return;
      gr(this.layoutCorrected, this.layout.layoutBox);
      const p = this.treeScale.x,
        m = this.treeScale.y;
      uF(this.layoutCorrected, this.treeScale, this.path, u),
        a.layout &&
          !a.target &&
          (this.treeScale.x !== 1 || this.treeScale.y !== 1) &&
          (a.target = a.layout.layoutBox);
      const { target: y } = a;
      if (!y) {
        this.projectionTransform &&
          ((this.projectionDelta = fu()),
          (this.projectionTransform = "none"),
          this.scheduleRender());
        return;
      }
      this.projectionDelta ||
        ((this.projectionDelta = fu()),
        (this.projectionDeltaWithTransform = fu()));
      const w = this.projectionTransform;
      nf(this.projectionDelta, this.layoutCorrected, y, this.latestValues),
        (this.projectionTransform = BT(this.projectionDelta, this.treeScale)),
        (this.projectionTransform !== w ||
          this.treeScale.x !== p ||
          this.treeScale.y !== m) &&
          ((this.hasProjected = !0),
          this.scheduleRender(),
          this.notifyListeners("projectionUpdate", y)),
        Ea.recalculatedProjection++;
    }
    hide() {
      this.isVisible = !1;
    }
    show() {
      this.isVisible = !0;
    }
    scheduleRender(o = !0) {
      if ((this.options.scheduleRender && this.options.scheduleRender(), o)) {
        const a = this.getStack();
        a && a.scheduleRender();
      }
      this.resumingFrom &&
        !this.resumingFrom.instance &&
        (this.resumingFrom = void 0);
    }
    setAnimationOrigin(o, a = !1) {
      const u = this.snapshot,
        f = u ? u.latestValues : {},
        h = { ...this.latestValues },
        d = fu();
      (!this.relativeParent || !this.relativeParent.options.layoutRoot) &&
        (this.relativeTarget = this.relativeTargetOrigin = void 0),
        (this.attemptToResolveRelativeTarget = !a);
      const p = Rn(),
        m = u ? u.source : void 0,
        y = this.layout ? this.layout.source : void 0,
        w = m !== y,
        S = this.getStack(),
        v = !S || S.members.length <= 1,
        M = !!(w && !v && this.options.crossfade === !0 && !this.path.some(QF));
      this.animationProgress = 0;
      let _;
      (this.mixTargetDelta = (T) => {
        const P = T / 1e3;
        jT(d.x, o.x, P),
          jT(d.y, o.y, P),
          this.setTargetDelta(d),
          this.relativeTarget &&
            this.relativeTargetOrigin &&
            this.layout &&
            this.relativeParent &&
            this.relativeParent.layout &&
            (rf(p, this.layout.layoutBox, this.relativeParent.layout.layoutBox),
            KF(this.relativeTarget, this.relativeTargetOrigin, p, P),
            _ && PF(this.relativeTarget, _) && (this.isProjectionDirty = !1),
            _ || (_ = Rn()),
            gr(_, this.relativeTarget)),
          w &&
            ((this.animationValues = h), wF(h, f, this.latestValues, P, M, v)),
          this.root.scheduleUpdateProjection(),
          this.scheduleRender(),
          (this.animationProgress = P);
      }),
        this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(o) {
      this.notifyListeners("animationStart"),
        this.currentAnimation && this.currentAnimation.stop(),
        this.resumingFrom &&
          this.resumingFrom.currentAnimation &&
          this.resumingFrom.currentAnimation.stop(),
        this.pendingAnimation &&
          (Ws(this.pendingAnimation), (this.pendingAnimation = void 0)),
        (this.pendingAnimation = $t.update(() => {
          (sm.hasAnimatedSinceResize = !0),
            (this.currentAnimation = UF(0, HT, {
              ...o,
              onUpdate: (a) => {
                this.mixTargetDelta(a), o.onUpdate && o.onUpdate(a);
              },
              onComplete: () => {
                o.onComplete && o.onComplete(), this.completeAnimation();
              },
            })),
            this.resumingFrom &&
              (this.resumingFrom.currentAnimation = this.currentAnimation),
            (this.pendingAnimation = void 0);
        }));
    }
    completeAnimation() {
      this.resumingFrom &&
        ((this.resumingFrom.currentAnimation = void 0),
        (this.resumingFrom.preserveOpacity = void 0));
      const o = this.getStack();
      o && o.exitAnimationComplete(),
        (this.resumingFrom =
          this.currentAnimation =
          this.animationValues =
            void 0),
        this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      this.currentAnimation &&
        (this.mixTargetDelta && this.mixTargetDelta(HT),
        this.currentAnimation.stop()),
        this.completeAnimation();
    }
    applyTransformsToTarget() {
      const o = this.getLead();
      let {
        targetWithTransforms: a,
        target: u,
        layout: f,
        latestValues: h,
      } = o;
      if (!(!a || !u || !f)) {
        if (
          this !== o &&
          this.layout &&
          f &&
          j3(this.options.animationType, this.layout.layoutBox, f.layoutBox)
        ) {
          u = this.target || Rn();
          const d = nr(this.layout.layoutBox.x);
          (u.x.min = o.target.x.min), (u.x.max = u.x.min + d);
          const p = nr(this.layout.layoutBox.y);
          (u.y.min = o.target.y.min), (u.y.max = u.y.min + p);
        }
        gr(a, u),
          hu(a, h),
          nf(this.projectionDeltaWithTransform, this.layoutCorrected, a, h);
      }
    }
    registerSharedNode(o, a) {
      this.sharedNodes.has(o) || this.sharedNodes.set(o, new RF()),
        this.sharedNodes.get(o).add(a);
      const f = a.options.initialPromotionConfig;
      a.promote({
        transition: f ? f.transition : void 0,
        preserveFollowOpacity:
          f && f.shouldPreserveFollowOpacity
            ? f.shouldPreserveFollowOpacity(a)
            : void 0,
      });
    }
    isLead() {
      const o = this.getStack();
      return o ? o.lead === this : !0;
    }
    getLead() {
      var o;
      const { layoutId: a } = this.options;
      return a
        ? ((o = this.getStack()) === null || o === void 0 ? void 0 : o.lead) ||
            this
        : this;
    }
    getPrevLead() {
      var o;
      const { layoutId: a } = this.options;
      return a
        ? (o = this.getStack()) === null || o === void 0
          ? void 0
          : o.prevLead
        : void 0;
    }
    getStack() {
      const { layoutId: o } = this.options;
      if (o) return this.root.sharedNodes.get(o);
    }
    promote({ needsReset: o, transition: a, preserveFollowOpacity: u } = {}) {
      const f = this.getStack();
      f && f.promote(this, u),
        o && ((this.projectionDelta = void 0), (this.needsReset = !0)),
        a && this.setOptions({ transition: a });
    }
    relegate() {
      const o = this.getStack();
      return o ? o.relegate(this) : !1;
    }
    resetRotation() {
      const { visualElement: o } = this.options;
      if (!o) return;
      let a = !1;
      const { latestValues: u } = o;
      if (((u.rotate || u.rotateX || u.rotateY || u.rotateZ) && (a = !0), !a))
        return;
      const f = {};
      for (let h = 0; h < VT.length; h++) {
        const d = "rotate" + VT[h];
        u[d] && ((f[d] = u[d]), o.setStaticValue(d, 0));
      }
      o.render();
      for (const h in f) o.setStaticValue(h, f[h]);
      o.scheduleRender();
    }
    getProjectionStyles(o) {
      var a, u;
      if (!this.instance || this.isSVG) return;
      if (!this.isVisible) return kF;
      const f = { visibility: "" },
        h = this.getTransformTemplate();
      if (this.needsReset)
        return (
          (this.needsReset = !1),
          (f.opacity = ""),
          (f.pointerEvents = rm(o == null ? void 0 : o.pointerEvents) || ""),
          (f.transform = h ? h(this.latestValues, "") : "none"),
          f
        );
      const d = this.getLead();
      if (!this.projectionDelta || !this.layout || !d.target) {
        const w = {};
        return (
          this.options.layoutId &&
            ((w.opacity =
              this.latestValues.opacity !== void 0
                ? this.latestValues.opacity
                : 1),
            (w.pointerEvents = rm(o == null ? void 0 : o.pointerEvents) || "")),
          this.hasProjected &&
            !wa(this.latestValues) &&
            ((w.transform = h ? h({}, "") : "none"), (this.hasProjected = !1)),
          w
        );
      }
      const p = d.animationValues || d.latestValues;
      this.applyTransformsToTarget(),
        (f.transform = BT(
          this.projectionDeltaWithTransform,
          this.treeScale,
          p
        )),
        h && (f.transform = h(p, f.transform));
      const { x: m, y } = this.projectionDelta;
      (f.transformOrigin = `${m.origin * 100}% ${y.origin * 100}% 0`),
        d.animationValues
          ? (f.opacity =
              d === this
                ? (u =
                    (a = p.opacity) !== null && a !== void 0
                      ? a
                      : this.latestValues.opacity) !== null && u !== void 0
                  ? u
                  : 1
                : this.preserveOpacity
                ? this.latestValues.opacity
                : p.opacityExit)
          : (f.opacity =
              d === this
                ? p.opacity !== void 0
                  ? p.opacity
                  : ""
                : p.opacityExit !== void 0
                ? p.opacityExit
                : 0);
      for (const w in zm) {
        if (p[w] === void 0) continue;
        const { correct: S, applyTo: v } = zm[w],
          M = f.transform === "none" ? p[w] : S(p[w], d);
        if (v) {
          const _ = v.length;
          for (let T = 0; T < _; T++) f[v[T]] = M;
        } else f[w] = M;
      }
      return (
        this.options.layoutId &&
          (f.pointerEvents =
            d === this
              ? rm(o == null ? void 0 : o.pointerEvents) || ""
              : "none"),
        f
      );
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    resetTree() {
      this.root.nodes.forEach((o) => {
        var a;
        return (a = o.currentAnimation) === null || a === void 0
          ? void 0
          : a.stop();
      }),
        this.root.nodes.forEach(GT),
        this.root.sharedNodes.clear();
    }
  };
}
function zF(n) {
  n.updateLayout();
}
function BF(n) {
  var e;
  const t =
    ((e = n.resumeFrom) === null || e === void 0 ? void 0 : e.snapshot) ||
    n.snapshot;
  if (n.isLead() && n.layout && t && n.hasListeners("didUpdate")) {
    const { layoutBox: i, measuredBox: r } = n.layout,
      { animationType: s } = n.options,
      o = t.source !== n.layout.source;
    s === "size"
      ? yr((d) => {
          const p = o ? t.measuredBox[d] : t.layoutBox[d],
            m = nr(p);
          (p.min = i[d].min), (p.max = p.min + m);
        })
      : j3(s, t.layoutBox, i) &&
        yr((d) => {
          const p = o ? t.measuredBox[d] : t.layoutBox[d],
            m = nr(i[d]);
          (p.max = p.min + m),
            n.relativeTarget &&
              !n.currentAnimation &&
              ((n.isProjectionDirty = !0),
              (n.relativeTarget[d].max = n.relativeTarget[d].min + m));
        });
    const a = fu();
    nf(a, i, t.layoutBox);
    const u = fu();
    o ? nf(u, n.applyTransform(r, !0), t.measuredBox) : nf(u, i, t.layoutBox);
    const f = !H3(a);
    let h = !1;
    if (!n.resumeFrom) {
      const d = n.getClosestProjectingParent();
      if (d && !d.resumeFrom) {
        const { snapshot: p, layout: m } = d;
        if (p && m) {
          const y = Rn();
          rf(y, t.layoutBox, p.layoutBox);
          const w = Rn();
          rf(w, i, m.layoutBox),
            G3(y, w) || (h = !0),
            d.options.layoutRoot &&
              ((n.relativeTarget = w),
              (n.relativeTargetOrigin = y),
              (n.relativeParent = d));
        }
      }
    }
    n.notifyListeners("didUpdate", {
      layout: i,
      snapshot: t,
      delta: u,
      layoutDelta: a,
      hasLayoutChanged: f,
      hasRelativeTargetChanged: h,
    });
  } else if (n.isLead()) {
    const { onExitComplete: i } = n.options;
    i && i();
  }
  n.options.transition = void 0;
}
function VF(n) {
  Ea.totalNodes++,
    n.parent &&
      (n.isProjecting() || (n.isProjectionDirty = n.parent.isProjectionDirty),
      n.isSharedProjectionDirty ||
        (n.isSharedProjectionDirty = !!(
          n.isProjectionDirty ||
          n.parent.isProjectionDirty ||
          n.parent.isSharedProjectionDirty
        )),
      n.isTransformDirty || (n.isTransformDirty = n.parent.isTransformDirty));
}
function HF(n) {
  n.isProjectionDirty = n.isSharedProjectionDirty = n.isTransformDirty = !1;
}
function GF(n) {
  n.clearSnapshot();
}
function GT(n) {
  n.clearMeasurements();
}
function WF(n) {
  n.isLayoutDirty = !1;
}
function jF(n) {
  const { visualElement: e } = n.options;
  e && e.getProps().onBeforeLayoutMeasure && e.notify("BeforeLayoutMeasure"),
    n.resetTransform();
}
function WT(n) {
  n.finishAnimation(),
    (n.targetDelta = n.relativeTarget = n.target = void 0),
    (n.isProjectionDirty = !0);
}
function XF(n) {
  n.resolveTargetDelta();
}
function YF(n) {
  n.calcProjection();
}
function qF(n) {
  n.resetRotation();
}
function ZF(n) {
  n.removeLeadSnapshot();
}
function jT(n, e, t) {
  (n.translate = un(e.translate, 0, t)),
    (n.scale = un(e.scale, 1, t)),
    (n.origin = e.origin),
    (n.originPoint = e.originPoint);
}
function XT(n, e, t, i) {
  (n.min = un(e.min, t.min, i)), (n.max = un(e.max, t.max, i));
}
function KF(n, e, t, i) {
  XT(n.x, e.x, t.x, i), XT(n.y, e.y, t.y, i);
}
function QF(n) {
  return n.animationValues && n.animationValues.opacityExit !== void 0;
}
const $F = { duration: 0.45, ease: [0.4, 0, 0.1, 1] },
  YT = (n) =>
    typeof navigator < "u" && navigator.userAgent.toLowerCase().includes(n),
  qT = YT("applewebkit/") && !YT("chrome/") ? Math.round : Tn;
function ZT(n) {
  (n.min = qT(n.min)), (n.max = qT(n.max));
}
function JF(n) {
  ZT(n.x), ZT(n.y);
}
function j3(n, e, t) {
  return (
    n === "position" || (n === "preserve-aspect" && !Kx(zT(e), zT(t), 0.2))
  );
}
const ez = W3({
    attachResizeListener: (n, e) => Ns(n, "resize", e),
    measureScroll: () => ({
      x: document.documentElement.scrollLeft || document.body.scrollLeft,
      y: document.documentElement.scrollTop || document.body.scrollTop,
    }),
    checkIsScrollRoot: () => !0,
  }),
  J0 = { current: void 0 },
  X3 = W3({
    measureScroll: (n) => ({ x: n.scrollLeft, y: n.scrollTop }),
    defaultParent: () => {
      if (!J0.current) {
        const n = new ez({});
        n.mount(window), n.setOptions({ layoutScroll: !0 }), (J0.current = n);
      }
      return J0.current;
    },
    resetTransform: (n, e) => {
      n.style.transform = e !== void 0 ? e : "none";
    },
    checkIsScrollRoot: (n) => window.getComputedStyle(n).position === "fixed",
  }),
  tz = {
    pan: { Feature: vF },
    drag: { Feature: gF, ProjectionNode: X3, MeasureLayout: z3 },
  },
  nz = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
function iz(n) {
  const e = nz.exec(n);
  if (!e) return [,];
  const [, t, i] = e;
  return [t, i];
}
function e_(n, e, t = 1) {
  const [i, r] = iz(n);
  if (!i) return;
  const s = window.getComputedStyle(e).getPropertyValue(i);
  if (s) {
    const o = s.trim();
    return C3(o) ? parseFloat(o) : o;
  } else return Gx(r) ? e_(r, e, t + 1) : r;
}
function rz(n, { ...e }, t) {
  const i = n.current;
  if (!(i instanceof Element)) return { target: e, transitionEnd: t };
  t && (t = { ...t }),
    n.values.forEach((r) => {
      const s = r.get();
      if (!Gx(s)) return;
      const o = e_(s, i);
      o && r.set(o);
    });
  for (const r in e) {
    const s = e[r];
    if (!Gx(s)) continue;
    const o = e_(s, i);
    o && ((e[r] = o), t || (t = {}), t[r] === void 0 && (t[r] = s));
  }
  return { target: e, transitionEnd: t };
}
const sz = new Set([
    "width",
    "height",
    "top",
    "left",
    "right",
    "bottom",
    "x",
    "y",
    "translateX",
    "translateY",
  ]),
  Y3 = (n) => sz.has(n),
  oz = (n) => Object.keys(n).some(Y3),
  KT = (n) => n === il || n === ft,
  QT = (n, e) => parseFloat(n.split(", ")[e]),
  $T =
    (n, e) =>
    (t, { transform: i }) => {
      if (i === "none" || !i) return 0;
      const r = i.match(/^matrix3d\((.+)\)$/);
      if (r) return QT(r[1], e);
      {
        const s = i.match(/^matrix\((.+)\)$/);
        return s ? QT(s[1], n) : 0;
      }
    },
  az = new Set(["x", "y", "z"]),
  lz = rh.filter((n) => !az.has(n));
function uz(n) {
  const e = [];
  return (
    lz.forEach((t) => {
      const i = n.getValue(t);
      i !== void 0 &&
        (e.push([t, i.get()]), i.set(t.startsWith("scale") ? 1 : 0));
    }),
    e.length && n.render(),
    e
  );
}
const Du = {
  width: ({ x: n }, { paddingLeft: e = "0", paddingRight: t = "0" }) =>
    n.max - n.min - parseFloat(e) - parseFloat(t),
  height: ({ y: n }, { paddingTop: e = "0", paddingBottom: t = "0" }) =>
    n.max - n.min - parseFloat(e) - parseFloat(t),
  top: (n, { top: e }) => parseFloat(e),
  left: (n, { left: e }) => parseFloat(e),
  bottom: ({ y: n }, { top: e }) => parseFloat(e) + (n.max - n.min),
  right: ({ x: n }, { left: e }) => parseFloat(e) + (n.max - n.min),
  x: $T(4, 13),
  y: $T(5, 14),
};
Du.translateX = Du.x;
Du.translateY = Du.y;
const cz = (n, e, t) => {
    const i = e.measureViewportBox(),
      r = e.current,
      s = getComputedStyle(r),
      { display: o } = s,
      a = {};
    o === "none" && e.setStaticValue("display", n.display || "block"),
      t.forEach((f) => {
        a[f] = Du[f](i, s);
      }),
      e.render();
    const u = e.measureViewportBox();
    return (
      t.forEach((f) => {
        const h = e.getValue(f);
        h && h.jump(a[f]), (n[f] = Du[f](u, s));
      }),
      n
    );
  },
  fz = (n, e, t = {}, i = {}) => {
    (e = { ...e }), (i = { ...i });
    const r = Object.keys(e).filter(Y3);
    let s = [],
      o = !1;
    const a = [];
    if (
      (r.forEach((u) => {
        const f = n.getValue(u);
        if (!n.hasValue(u)) return;
        let h = t[u],
          d = Ec(h);
        const p = e[u];
        let m;
        if (Vm(p)) {
          const y = p.length,
            w = p[0] === null ? 1 : 0;
          (h = p[w]), (d = Ec(h));
          for (let S = w; S < y && p[S] !== null; S++)
            m ? eS(Ec(p[S]) === m) : (m = Ec(p[S]));
        } else m = Ec(p);
        if (d !== m)
          if (KT(d) && KT(m)) {
            const y = f.get();
            typeof y == "string" && f.set(parseFloat(y)),
              typeof p == "string"
                ? (e[u] = parseFloat(p))
                : Array.isArray(p) && m === ft && (e[u] = p.map(parseFloat));
          } else
            d != null &&
            d.transform &&
            m != null &&
            m.transform &&
            (h === 0 || p === 0)
              ? h === 0
                ? f.set(m.transform(h))
                : (e[u] = d.transform(p))
              : (o || ((s = uz(n)), (o = !0)),
                a.push(u),
                (i[u] = i[u] !== void 0 ? i[u] : e[u]),
                f.jump(p));
      }),
      a.length)
    ) {
      const u = a.indexOf("height") >= 0 ? window.pageYOffset : null,
        f = cz(e, n, a);
      return (
        s.length &&
          s.forEach(([h, d]) => {
            n.getValue(h).set(d);
          }),
        n.render(),
        Mg && u !== null && window.scrollTo({ top: u }),
        { target: f, transitionEnd: i }
      );
    } else return { target: e, transitionEnd: i };
  };
function hz(n, e, t, i) {
  return oz(e) ? fz(n, e, t, i) : { target: e, transitionEnd: i };
}
const dz = (n, e, t, i) => {
    const r = rz(n, e, i);
    return (e = r.target), (i = r.transitionEnd), hz(n, e, t, i);
  },
  t_ = { current: null },
  q3 = { current: !1 };
function pz() {
  if (((q3.current = !0), !!Mg))
    if (window.matchMedia) {
      const n = window.matchMedia("(prefers-reduced-motion)"),
        e = () => (t_.current = n.matches);
      n.addListener(e), e();
    } else t_.current = !1;
}
function mz(n, e, t) {
  const { willChange: i } = e;
  for (const r in e) {
    const s = e[r],
      o = t[r];
    if (Vi(s)) n.addValue(r, s), jm(i) && i.add(r);
    else if (Vi(o)) n.addValue(r, Nu(s, { owner: n })), jm(i) && i.remove(r);
    else if (o !== s)
      if (n.hasValue(r)) {
        const a = n.getValue(r);
        !a.hasAnimated && a.set(s);
      } else {
        const a = n.getStaticValue(r);
        n.addValue(r, Nu(a !== void 0 ? a : s, { owner: n }));
      }
  }
  for (const r in t) e[r] === void 0 && n.removeValue(r);
  return e;
}
const JT = new WeakMap(),
  Z3 = Object.keys(Pf),
  gz = Z3.length,
  e2 = [
    "AnimationStart",
    "AnimationComplete",
    "Update",
    "BeforeLayoutMeasure",
    "LayoutMeasure",
    "LayoutAnimationStart",
    "LayoutAnimationComplete",
  ],
  vz = X1.length;
class yz {
  constructor(
    {
      parent: e,
      props: t,
      presenceContext: i,
      reducedMotionConfig: r,
      visualState: s,
    },
    o = {}
  ) {
    (this.current = null),
      (this.children = new Set()),
      (this.isVariantNode = !1),
      (this.isControllingVariants = !1),
      (this.shouldReduceMotion = null),
      (this.values = new Map()),
      (this.features = {}),
      (this.valueSubscriptions = new Map()),
      (this.prevMotionValues = {}),
      (this.events = {}),
      (this.propEventSubscriptions = {}),
      (this.notifyUpdate = () => this.notify("Update", this.latestValues)),
      (this.render = () => {
        this.current &&
          (this.triggerBuild(),
          this.renderInstance(
            this.current,
            this.renderState,
            this.props.style,
            this.projection
          ));
      }),
      (this.scheduleRender = () => $t.render(this.render, !1, !0));
    const { latestValues: a, renderState: u } = s;
    (this.latestValues = a),
      (this.baseTarget = { ...a }),
      (this.initialValues = t.initial ? { ...a } : {}),
      (this.renderState = u),
      (this.parent = e),
      (this.props = t),
      (this.presenceContext = i),
      (this.depth = e ? e.depth + 1 : 0),
      (this.reducedMotionConfig = r),
      (this.options = o),
      (this.isControllingVariants = Eg(t)),
      (this.isVariantNode = NP(t)),
      this.isVariantNode && (this.variantChildren = new Set()),
      (this.manuallyAnimateOnMount = !!(e && e.current));
    const { willChange: f, ...h } = this.scrapeMotionValuesFromProps(t, {});
    for (const d in h) {
      const p = h[d];
      a[d] !== void 0 && Vi(p) && (p.set(a[d], !1), jm(f) && f.add(d));
    }
  }
  scrapeMotionValuesFromProps(e, t) {
    return {};
  }
  mount(e) {
    (this.current = e),
      JT.set(e, this),
      this.projection && !this.projection.instance && this.projection.mount(e),
      this.parent &&
        this.isVariantNode &&
        !this.isControllingVariants &&
        (this.removeFromVariantTree = this.parent.addVariantChild(this)),
      this.values.forEach((t, i) => this.bindToMotionValue(i, t)),
      q3.current || pz(),
      (this.shouldReduceMotion =
        this.reducedMotionConfig === "never"
          ? !1
          : this.reducedMotionConfig === "always"
          ? !0
          : t_.current),
      this.parent && this.parent.children.add(this),
      this.update(this.props, this.presenceContext);
  }
  unmount() {
    JT.delete(this.current),
      this.projection && this.projection.unmount(),
      Ws(this.notifyUpdate),
      Ws(this.render),
      this.valueSubscriptions.forEach((e) => e()),
      this.removeFromVariantTree && this.removeFromVariantTree(),
      this.parent && this.parent.children.delete(this);
    for (const e in this.events) this.events[e].clear();
    for (const e in this.features) this.features[e].unmount();
    this.current = null;
  }
  bindToMotionValue(e, t) {
    const i = nl.has(e),
      r = t.on("change", (o) => {
        (this.latestValues[e] = o),
          this.props.onUpdate && $t.update(this.notifyUpdate, !1, !0),
          i && this.projection && (this.projection.isTransformDirty = !0);
      }),
      s = t.on("renderRequest", this.scheduleRender);
    this.valueSubscriptions.set(e, () => {
      r(), s();
    });
  }
  sortNodePosition(e) {
    return !this.current ||
      !this.sortInstanceNodePosition ||
      this.type !== e.type
      ? 0
      : this.sortInstanceNodePosition(this.current, e.current);
  }
  loadFeatures({ children: e, ...t }, i, r, s) {
    let o, a;
    for (let u = 0; u < gz; u++) {
      const f = Z3[u],
        {
          isEnabled: h,
          Feature: d,
          ProjectionNode: p,
          MeasureLayout: m,
        } = Pf[f];
      p && (o = p),
        h(t) &&
          (!this.features[f] && d && (this.features[f] = new d(this)),
          m && (a = m));
    }
    if (
      (this.type === "html" || this.type === "svg") &&
      !this.projection &&
      o
    ) {
      this.projection = new o(
        this.latestValues,
        this.parent && this.parent.projection
      );
      const {
        layoutId: u,
        layout: f,
        drag: h,
        dragConstraints: d,
        layoutScroll: p,
        layoutRoot: m,
      } = t;
      this.projection.setOptions({
        layoutId: u,
        layout: f,
        alwaysMeasureLayout: !!h || (d && uu(d)),
        visualElement: this,
        scheduleRender: () => this.scheduleRender(),
        animationType: typeof f == "string" ? f : "both",
        initialPromotionConfig: s,
        layoutScroll: p,
        layoutRoot: m,
      });
    }
    return a;
  }
  updateFeatures() {
    for (const e in this.features) {
      const t = this.features[e];
      t.isMounted ? t.update() : (t.mount(), (t.isMounted = !0));
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.options, this.props);
  }
  measureViewportBox() {
    return this.current
      ? this.measureInstanceViewportBox(this.current, this.props)
      : Rn();
  }
  getStaticValue(e) {
    return this.latestValues[e];
  }
  setStaticValue(e, t) {
    this.latestValues[e] = t;
  }
  makeTargetAnimatable(e, t = !0) {
    return this.makeTargetAnimatableFromInstance(e, this.props, t);
  }
  update(e, t) {
    (e.transformTemplate || this.props.transformTemplate) &&
      this.scheduleRender(),
      (this.prevProps = this.props),
      (this.props = e),
      (this.prevPresenceContext = this.presenceContext),
      (this.presenceContext = t);
    for (let i = 0; i < e2.length; i++) {
      const r = e2[i];
      this.propEventSubscriptions[r] &&
        (this.propEventSubscriptions[r](),
        delete this.propEventSubscriptions[r]);
      const s = e["on" + r];
      s && (this.propEventSubscriptions[r] = this.on(r, s));
    }
    (this.prevMotionValues = mz(
      this,
      this.scrapeMotionValuesFromProps(e, this.prevProps),
      this.prevMotionValues
    )),
      this.handleChildMotionValue && this.handleChildMotionValue();
  }
  getProps() {
    return this.props;
  }
  getVariant(e) {
    return this.props.variants ? this.props.variants[e] : void 0;
  }
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode
      ? this
      : this.parent
      ? this.parent.getClosestVariantNode()
      : void 0;
  }
  getVariantContext(e = !1) {
    if (e) return this.parent ? this.parent.getVariantContext() : void 0;
    if (!this.isControllingVariants) {
      const i = this.parent ? this.parent.getVariantContext() || {} : {};
      return (
        this.props.initial !== void 0 && (i.initial = this.props.initial), i
      );
    }
    const t = {};
    for (let i = 0; i < vz; i++) {
      const r = X1[i],
        s = this.props[r];
      (Cf(s) || s === !1) && (t[r] = s);
    }
    return t;
  }
  addVariantChild(e) {
    const t = this.getClosestVariantNode();
    if (t)
      return (
        t.variantChildren && t.variantChildren.add(e),
        () => t.variantChildren.delete(e)
      );
  }
  addValue(e, t) {
    t !== this.values.get(e) &&
      (this.removeValue(e), this.bindToMotionValue(e, t)),
      this.values.set(e, t),
      (this.latestValues[e] = t.get());
  }
  removeValue(e) {
    this.values.delete(e);
    const t = this.valueSubscriptions.get(e);
    t && (t(), this.valueSubscriptions.delete(e)),
      delete this.latestValues[e],
      this.removeValueFromRenderState(e, this.renderState);
  }
  hasValue(e) {
    return this.values.has(e);
  }
  getValue(e, t) {
    if (this.props.values && this.props.values[e]) return this.props.values[e];
    let i = this.values.get(e);
    return (
      i === void 0 &&
        t !== void 0 &&
        ((i = Nu(t, { owner: this })), this.addValue(e, i)),
      i
    );
  }
  readValue(e) {
    var t;
    return this.latestValues[e] !== void 0 || !this.current
      ? this.latestValues[e]
      : (t = this.getBaseTargetFromProps(this.props, e)) !== null &&
        t !== void 0
      ? t
      : this.readValueFromInstance(this.current, e, this.options);
  }
  setBaseTarget(e, t) {
    this.baseTarget[e] = t;
  }
  getBaseTarget(e) {
    var t;
    const { initial: i } = this.props,
      r =
        typeof i == "string" || typeof i == "object"
          ? (t = J1(this.props, i)) === null || t === void 0
            ? void 0
            : t[e]
          : void 0;
    if (i && r !== void 0) return r;
    const s = this.getBaseTargetFromProps(this.props, e);
    return s !== void 0 && !Vi(s)
      ? s
      : this.initialValues[e] !== void 0 && r === void 0
      ? void 0
      : this.baseTarget[e];
  }
  on(e, t) {
    return this.events[e] || (this.events[e] = new uS()), this.events[e].add(t);
  }
  notify(e, ...t) {
    this.events[e] && this.events[e].notify(...t);
  }
}
class K3 extends yz {
  sortInstanceNodePosition(e, t) {
    return e.compareDocumentPosition(t) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(e, t) {
    return e.style ? e.style[t] : void 0;
  }
  removeValueFromRenderState(e, { vars: t, style: i }) {
    delete t[e], delete i[e];
  }
  makeTargetAnimatableFromInstance(
    { transition: e, transitionEnd: t, ...i },
    { transformValues: r },
    s
  ) {
    let o = Ok(i, e || {}, this);
    if ((r && (t && (t = r(t)), i && (i = r(i)), o && (o = r(o))), s)) {
      Nk(this, i, o);
      const a = dz(this, i, o, t);
      (t = a.transitionEnd), (i = a.target);
    }
    return { transition: e, transitionEnd: t, ...i };
  }
}
function xz(n) {
  return window.getComputedStyle(n);
}
class _z extends K3 {
  constructor() {
    super(...arguments), (this.type = "html");
  }
  readValueFromInstance(e, t) {
    if (nl.has(t)) {
      const i = rS(t);
      return (i && i.default) || 0;
    } else {
      const i = xz(e),
        r = (FP(t) ? i.getPropertyValue(t) : i[t]) || 0;
      return typeof r == "string" ? r.trim() : r;
    }
  }
  measureInstanceViewportBox(e, { transformPagePoint: t }) {
    return k3(e, t);
  }
  build(e, t, i, r) {
    q1(e, t, i, r.transformTemplate);
  }
  scrapeMotionValuesFromProps(e, t) {
    return $1(e, t);
  }
  handleChildMotionValue() {
    this.childSubscription &&
      (this.childSubscription(), delete this.childSubscription);
    const { children: e } = this.props;
    Vi(e) &&
      (this.childSubscription = e.on("change", (t) => {
        this.current && (this.current.textContent = `${t}`);
      }));
  }
  renderInstance(e, t, i, r) {
    WP(e, t, i, r);
  }
}
class Sz extends K3 {
  constructor() {
    super(...arguments), (this.type = "svg"), (this.isSVGTag = !1);
  }
  getBaseTargetFromProps(e, t) {
    return e[t];
  }
  readValueFromInstance(e, t) {
    if (nl.has(t)) {
      const i = rS(t);
      return (i && i.default) || 0;
    }
    return (t = jP.has(t) ? t : W1(t)), e.getAttribute(t);
  }
  measureInstanceViewportBox() {
    return Rn();
  }
  scrapeMotionValuesFromProps(e, t) {
    return YP(e, t);
  }
  build(e, t, i, r) {
    K1(e, t, i, this.isSVGTag, r.transformTemplate);
  }
  renderInstance(e, t, i, r) {
    XP(e, t, i, r);
  }
  mount(e) {
    (this.isSVGTag = Q1(e.tagName)), super.mount(e);
  }
}
const Mz = (n, e) =>
    Y1(n)
      ? new Sz(e, { enableHardwareAcceleration: !1 })
      : new _z(e, { enableHardwareAcceleration: !0 }),
  wz = { layout: { ProjectionNode: X3, MeasureLayout: z3 } },
  Ez = { ...Kk, ...gU, ...tz, ...wz },
  nt = EO((n, e) => iU(n, e, Ez, Mz));
var Q3 = {
    color: void 0,
    size: void 0,
    className: void 0,
    style: void 0,
    attr: void 0,
  },
  t2 = ss.createContext && ss.createContext(Q3),
  Tz = ["attr", "size", "title"];
function Az(n, e) {
  if (n == null) return {};
  var t = bz(n, e),
    i,
    r;
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(n);
    for (r = 0; r < s.length; r++)
      (i = s[r]),
        !(e.indexOf(i) >= 0) &&
          Object.prototype.propertyIsEnumerable.call(n, i) &&
          (t[i] = n[i]);
  }
  return t;
}
function bz(n, e) {
  if (n == null) return {};
  var t = {};
  for (var i in n)
    if (Object.prototype.hasOwnProperty.call(n, i)) {
      if (e.indexOf(i) >= 0) continue;
      t[i] = n[i];
    }
  return t;
}
function Ym() {
  return (
    (Ym = Object.assign
      ? Object.assign.bind()
      : function (n) {
          for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var i in t)
              Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i]);
          }
          return n;
        }),
    Ym.apply(this, arguments)
  );
}
function n2(n, e) {
  var t = Object.keys(n);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(n);
    e &&
      (i = i.filter(function (r) {
        return Object.getOwnPropertyDescriptor(n, r).enumerable;
      })),
      t.push.apply(t, i);
  }
  return t;
}
function qm(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2
      ? n2(Object(t), !0).forEach(function (i) {
          Cz(n, i, t[i]);
        })
      : Object.getOwnPropertyDescriptors
      ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t))
      : n2(Object(t)).forEach(function (i) {
          Object.defineProperty(n, i, Object.getOwnPropertyDescriptor(t, i));
        });
  }
  return n;
}
function Cz(n, e, t) {
  return (
    (e = Pz(e)),
    e in n
      ? Object.defineProperty(n, e, {
          value: t,
          enumerable: !0,
          configurable: !0,
          writable: !0,
        })
      : (n[e] = t),
    n
  );
}
function Pz(n) {
  var e = Rz(n, "string");
  return typeof e == "symbol" ? e : e + "";
}
function Rz(n, e) {
  if (typeof n != "object" || !n) return n;
  var t = n[Symbol.toPrimitive];
  if (t !== void 0) {
    var i = t.call(n, e);
    if (typeof i != "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(n);
}
function $3(n) {
  return (
    n &&
    n.map((e, t) =>
      ss.createElement(e.tag, qm({ key: t }, e.attr), $3(e.child))
    )
  );
}
function mi(n) {
  return (e) =>
    ss.createElement(Lz, Ym({ attr: qm({}, n.attr) }, e), $3(n.child));
}
function Lz(n) {
  var e = (t) => {
    var { attr: i, size: r, title: s } = n,
      o = Az(n, Tz),
      a = r || t.size || "1em",
      u;
    return (
      t.className && (u = t.className),
      n.className && (u = (u ? u + " " : "") + n.className),
      ss.createElement(
        "svg",
        Ym(
          { stroke: "currentColor", fill: "currentColor", strokeWidth: "0" },
          t.attr,
          i,
          o,
          {
            className: u,
            style: qm(qm({ color: n.color || t.color }, t.style), n.style),
            height: a,
            width: a,
            xmlns: "http://www.w3.org/2000/svg",
          }
        ),
        s && ss.createElement("title", null, s),
        n.children
      )
    );
  };
  return t2 !== void 0
    ? ss.createElement(t2.Consumer, null, (t) => e(t))
    : e(Q3);
}
function Cg(n) {
  return mi({
    attr: { viewBox: "0 0 496 512" },
    child: [
      {
        tag: "path",
        attr: {
          d: "M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z",
        },
        child: [],
      },
    ],
  })(n);
}
function cS(n) {
  return mi({
    attr: { viewBox: "0 0 448 512" },
    child: [
      {
        tag: "path",
        attr: {
          d: "M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z",
        },
        child: [],
      },
    ],
  })(n);
}
function Iz(n) {
  return mi({
    attr: { viewBox: "0 0 448 512" },
    child: [
      {
        tag: "path",
        attr: {
          d: "M224 508c-6.7 0-13.5-1.8-19.4-5.2l-61.7-36.5c-9.2-5.2-4.7-7-1.7-8 12.3-4.3 14.8-5.2 27.9-12.7 1.4-.8 3.2-.5 4.6.4l47.4 28.1c1.7 1 4.1 1 5.7 0l184.7-106.6c1.7-1 2.8-3 2.8-5V149.3c0-2.1-1.1-4-2.9-5.1L226.8 37.7c-1.7-1-4-1-5.7 0L36.6 144.3c-1.8 1-2.9 3-2.9 5.1v213.1c0 2 1.1 4 2.9 4.9l50.6 29.2c27.5 13.7 44.3-2.4 44.3-18.7V167.5c0-3 2.4-5.3 5.4-5.3h23.4c2.9 0 5.4 2.3 5.4 5.3V378c0 36.6-20 57.6-54.7 57.6-10.7 0-19.1 0-42.5-11.6l-48.4-27.9C8.1 389.2.7 376.3.7 362.4V149.3c0-13.8 7.4-26.8 19.4-33.7L204.6 9c11.7-6.6 27.2-6.6 38.8 0l184.7 106.7c12 6.9 19.4 19.8 19.4 33.7v213.1c0 13.8-7.4 26.7-19.4 33.7L243.4 502.8c-5.9 3.4-12.6 5.2-19.4 5.2zm149.1-210.1c0-39.9-27-50.5-83.7-58-57.4-7.6-63.2-11.5-63.2-24.9 0-11.1 4.9-25.9 47.4-25.9 37.9 0 51.9 8.2 57.7 33.8.5 2.4 2.7 4.2 5.2 4.2h24c1.5 0 2.9-.6 3.9-1.7s1.5-2.6 1.4-4.1c-3.7-44.1-33-64.6-92.2-64.6-52.7 0-84.1 22.2-84.1 59.5 0 40.4 31.3 51.6 81.8 56.6 60.5 5.9 65.2 14.8 65.2 26.7 0 20.6-16.6 29.4-55.5 29.4-48.9 0-59.6-12.3-63.2-36.6-.4-2.6-2.6-4.5-5.3-4.5h-23.9c-3 0-5.3 2.4-5.3 5.3 0 31.1 16.9 68.2 97.8 68.2 58.4-.1 92-23.2 92-63.4z",
        },
        child: [],
      },
    ],
  })(n);
}
function Nz(n) {
  return mi({
    attr: { viewBox: "0 0 512 512" },
    child: [
      {
        tag: "path",
        attr: {
          d: "M418.2 177.2c-5.4-1.8-10.8-3.5-16.2-5.1.9-3.7 1.7-7.4 2.5-11.1 12.3-59.6 4.2-107.5-23.1-123.3-26.3-15.1-69.2.6-112.6 38.4-4.3 3.7-8.5 7.6-12.5 11.5-2.7-2.6-5.5-5.2-8.3-7.7-45.5-40.4-91.1-57.4-118.4-41.5-26.2 15.2-34 60.3-23 116.7 1.1 5.6 2.3 11.1 3.7 16.7-6.4 1.8-12.7 3.8-18.6 5.9C38.3 196.2 0 225.4 0 255.6c0 31.2 40.8 62.5 96.3 81.5 4.5 1.5 9 3 13.6 4.3-1.5 6-2.8 11.9-4 18-10.5 55.5-2.3 99.5 23.9 114.6 27 15.6 72.4-.4 116.6-39.1 3.5-3.1 7-6.3 10.5-9.7 4.4 4.3 9 8.4 13.6 12.4 42.8 36.8 85.1 51.7 111.2 36.6 27-15.6 35.8-62.9 24.4-120.5-.9-4.4-1.9-8.9-3-13.5 3.2-.9 6.3-1.9 9.4-2.9 57.7-19.1 99.5-50 99.5-81.7 0-30.3-39.4-59.7-93.8-78.4zM282.9 92.3c37.2-32.4 71.9-45.1 87.7-36 16.9 9.7 23.4 48.9 12.8 100.4-.7 3.4-1.4 6.7-2.3 10-22.2-5-44.7-8.6-67.3-10.6-13-18.6-27.2-36.4-42.6-53.1 3.9-3.7 7.7-7.2 11.7-10.7zM167.2 307.5c5.1 8.7 10.3 17.4 15.8 25.9-15.6-1.7-31.1-4.2-46.4-7.5 4.4-14.4 9.9-29.3 16.3-44.5 4.6 8.8 9.3 17.5 14.3 26.1zm-30.3-120.3c14.4-3.2 29.7-5.8 45.6-7.8-5.3 8.3-10.5 16.8-15.4 25.4-4.9 8.5-9.7 17.2-14.2 26-6.3-14.9-11.6-29.5-16-43.6zm27.4 68.9c6.6-13.8 13.8-27.3 21.4-40.6s15.8-26.2 24.4-38.9c15-1.1 30.3-1.7 45.9-1.7s31 .6 45.9 1.7c8.5 12.6 16.6 25.5 24.3 38.7s14.9 26.7 21.7 40.4c-6.7 13.8-13.9 27.4-21.6 40.8-7.6 13.3-15.7 26.2-24.2 39-14.9 1.1-30.4 1.6-46.1 1.6s-30.9-.5-45.6-1.4c-8.7-12.7-16.9-25.7-24.6-39s-14.8-26.8-21.5-40.6zm180.6 51.2c5.1-8.8 9.9-17.7 14.6-26.7 6.4 14.5 12 29.2 16.9 44.3-15.5 3.5-31.2 6.2-47 8 5.4-8.4 10.5-17 15.5-25.6zm14.4-76.5c-4.7-8.8-9.5-17.6-14.5-26.2-4.9-8.5-10-16.9-15.3-25.2 16.1 2 31.5 4.7 45.9 8-4.6 14.8-10 29.2-16.1 43.4zM256.2 118.3c10.5 11.4 20.4 23.4 29.6 35.8-19.8-.9-39.7-.9-59.5 0 9.8-12.9 19.9-24.9 29.9-35.8zM140.2 57c16.8-9.8 54.1 4.2 93.4 39 2.5 2.2 5 4.6 7.6 7-15.5 16.7-29.8 34.5-42.9 53.1-22.6 2-45 5.5-67.2 10.4-1.3-5.1-2.4-10.3-3.5-15.5-9.4-48.4-3.2-84.9 12.6-94zm-24.5 263.6c-4.2-1.2-8.3-2.5-12.4-3.9-21.3-6.7-45.5-17.3-63-31.2-10.1-7-16.9-17.8-18.8-29.9 0-18.3 31.6-41.7 77.2-57.6 5.7-2 11.5-3.8 17.3-5.5 6.8 21.7 15 43 24.5 63.6-9.6 20.9-17.9 42.5-24.8 64.5zm116.6 98c-16.5 15.1-35.6 27.1-56.4 35.3-11.1 5.3-23.9 5.8-35.3 1.3-15.9-9.2-22.5-44.5-13.5-92 1.1-5.6 2.3-11.2 3.7-16.7 22.4 4.8 45 8.1 67.9 9.8 13.2 18.7 27.7 36.6 43.2 53.4-3.2 3.1-6.4 6.1-9.6 8.9zm24.5-24.3c-10.2-11-20.4-23.2-30.3-36.3 9.6.4 19.5.6 29.5.6 10.3 0 20.4-.2 30.4-.7-9.2 12.7-19.1 24.8-29.6 36.4zm130.7 30c-.9 12.2-6.9 23.6-16.5 31.3-15.9 9.2-49.8-2.8-86.4-34.2-4.2-3.6-8.4-7.5-12.7-11.5 15.3-16.9 29.4-34.8 42.2-53.6 22.9-1.9 45.7-5.4 68.2-10.5 1 4.1 1.9 8.2 2.7 12.2 4.9 21.6 5.7 44.1 2.5 66.3zm18.2-107.5c-2.8.9-5.6 1.8-8.5 2.6-7-21.8-15.6-43.1-25.5-63.8 9.6-20.4 17.7-41.4 24.5-62.9 5.2 1.5 10.2 3.1 15 4.7 46.6 16 79.3 39.8 79.3 58 0 19.6-34.9 44.9-84.8 61.4zm-149.7-15c25.3 0 45.8-20.5 45.8-45.8s-20.5-45.8-45.8-45.8c-25.3 0-45.8 20.5-45.8 45.8s20.5 45.8 45.8 45.8z",
        },
        child: [],
      },
    ],
  })(n);
}
function fS(n) {
  return mi({
    attr: { viewBox: "0 0 512 512" },
    child: [
      {
        tag: "path",
        attr: {
          d: "M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z",
        },
        child: [],
      },
    ],
  })(n);
}
function Dz(n) {
  return mi({
    attr: { viewBox: "0 0 448 512" },
    child: [
      {
        tag: "path",
        attr: {
          d: "M16 132h416c8.837 0 16-7.163 16-16V76c0-8.837-7.163-16-16-16H16C7.163 60 0 67.163 0 76v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16z",
        },
        child: [],
      },
    ],
  })(n);
}
function Oz(n) {
  return mi({
    attr: { viewBox: "0 0 640 512" },
    child: [
      {
        tag: "path",
        attr: {
          d: "M537.6 226.6c4.1-10.7 6.4-22.4 6.4-34.6 0-53-43-96-96-96-19.7 0-38.1 6-53.3 16.2C367 64.2 315.3 32 256 32c-88.4 0-160 71.6-160 160 0 2.7.1 5.4.2 8.1C40.2 219.8 0 273.2 0 336c0 79.5 64.5 144 144 144h368c70.7 0 128-57.3 128-128 0-61.9-44-113.6-102.4-125.4z",
        },
        child: [],
      },
    ],
  })(n);
}
function Uz(n) {
  return mi({
    attr: { viewBox: "0 0 640 512" },
    child: [
      {
        tag: "path",
        attr: {
          d: "M278.9 511.5l-61-17.7c-6.4-1.8-10-8.5-8.2-14.9L346.2 8.7c1.8-6.4 8.5-10 14.9-8.2l61 17.7c6.4 1.8 10 8.5 8.2 14.9L293.8 503.3c-1.9 6.4-8.5 10.1-14.9 8.2zm-114-112.2l43.5-46.4c4.6-4.9 4.3-12.7-.8-17.2L117 256l90.6-79.7c5.1-4.5 5.5-12.3.8-17.2l-43.5-46.4c-4.5-4.8-12.1-5.1-17-.5L3.8 247.2c-5.1 4.7-5.1 12.8 0 17.5l144.1 135.1c4.9 4.6 12.5 4.4 17-.5zm327.2.6l144.1-135.1c5.1-4.7 5.1-12.8 0-17.5L492.1 112.1c-4.8-4.5-12.4-4.3-17 .5L431.6 159c-4.6 4.9-4.3 12.7.8 17.2L523 256l-90.6 79.7c-5.1 4.5-5.5 12.3-.8 17.2l43.5 46.4c4.5 4.9 12.1 5.1 17 .6z",
        },
        child: [],
      },
    ],
  })(n);
}
function kz(n) {
  return mi({
    attr: { viewBox: "0 0 448 512" },
    child: [
      {
        tag: "path",
        attr: {
          d: "M448 73.143v45.714C448 159.143 347.667 192 224 192S0 159.143 0 118.857V73.143C0 32.857 100.333 0 224 0s224 32.857 224 73.143zM448 176v102.857C448 319.143 347.667 352 224 352S0 319.143 0 278.857V176c48.125 33.143 136.208 48.572 224 48.572S399.874 209.143 448 176zm0 160v102.857C448 479.143 347.667 512 224 512S0 479.143 0 438.857V336c48.125 33.143 136.208 48.572 224 48.572S399.874 369.143 448 336z",
        },
        child: [],
      },
    ],
  })(n);
}
function Fz(n) {
  return mi({
    attr: { viewBox: "0 0 512 512" },
    child: [
      {
        tag: "path",
        attr: {
          d: "M502.3 190.8c3.9-3.1 9.7-.2 9.7 4.7V400c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V195.6c0-5 5.7-7.8 9.7-4.7 22.4 17.4 52.1 39.5 154.1 113.6 21.1 15.4 56.7 47.8 92.2 47.6 35.7.3 72-32.8 92.3-47.6 102-74.1 131.6-96.3 154-113.7zM256 320c23.2.4 56.6-29.2 73.4-41.4 132.7-96.3 142.8-104.7 173.4-128.7 5.8-4.5 9.2-11.5 9.2-18.9v-19c0-26.5-21.5-48-48-48H48C21.5 64 0 85.5 0 112v19c0 7.4 3.4 14.3 9.2 18.9 30.6 23.9 40.7 32.4 173.4 128.7 16.8 12.2 50.2 41.8 73.4 41.4z",
        },
        child: [],
      },
    ],
  })(n);
}
function J3(n) {
  return mi({
    attr: { viewBox: "0 0 512 512" },
    child: [
      {
        tag: "path",
        attr: {
          d: "M432,320H400a16,16,0,0,0-16,16V448H64V128H208a16,16,0,0,0,16-16V80a16,16,0,0,0-16-16H48A48,48,0,0,0,0,112V464a48,48,0,0,0,48,48H400a48,48,0,0,0,48-48V336A16,16,0,0,0,432,320ZM488,0h-128c-21.37,0-32.05,25.91-17,41l35.73,35.73L135,320.37a24,24,0,0,0,0,34L157.67,377a24,24,0,0,0,34,0L435.28,133.32,471,169c15,15,41,4.5,41-17V24A24,24,0,0,0,488,0Z",
        },
        child: [],
      },
    ],
  })(n);
}
function zz(n) {
  return mi({
    attr: { viewBox: "0 0 512 512" },
    child: [
      {
        tag: "path",
        attr: {
          d: "M462.3 62.6C407.5 15.9 326 24.3 275.7 76.2L256 96.5l-19.7-20.3C186.1 24.3 104.5 15.9 49.7 62.6c-62.8 53.6-66.1 149.8-9.9 207.9l193.5 199.8c12.5 12.9 32.8 12.9 45.3 0l193.5-199.8c56.3-58.1 53-154.3-9.8-207.9z",
        },
        child: [],
      },
    ],
  })(n);
}
function Bz(n) {
  return mi({
    attr: { viewBox: "0 0 512 512" },
    child: [
      {
        tag: "path",
        attr: {
          d: "M12.41 148.02l232.94 105.67c6.8 3.09 14.49 3.09 21.29 0l232.94-105.67c16.55-7.51 16.55-32.52 0-40.03L266.65 2.31a25.607 25.607 0 0 0-21.29 0L12.41 107.98c-16.55 7.51-16.55 32.53 0 40.04zm487.18 88.28l-58.09-26.33-161.64 73.27c-7.56 3.43-15.59 5.17-23.86 5.17s-16.29-1.74-23.86-5.17L70.51 209.97l-58.1 26.33c-16.55 7.5-16.55 32.5 0 40l232.94 105.59c6.8 3.08 14.49 3.08 21.29 0L499.59 276.3c16.55-7.5 16.55-32.5 0-40zm0 127.8l-57.87-26.23-161.86 73.37c-7.56 3.43-15.59 5.17-23.86 5.17s-16.29-1.74-23.86-5.17L70.29 337.87 12.41 364.1c-16.55 7.5-16.55 32.5 0 40l232.94 105.59c6.8 3.08 14.49 3.08 21.29 0L499.59 404.1c16.55-7.5 16.55-32.5 0-40z",
        },
        child: [],
      },
    ],
  })(n);
}
function Vz(n) {
  return mi({
    attr: { viewBox: "0 0 384 512" },
    child: [
      {
        tag: "path",
        attr: {
          d: "M172.268 501.67C26.97 291.031 0 269.413 0 192 0 85.961 85.961 0 192 0s192 85.961 192 192c0 77.413-26.97 99.031-172.268 309.67-9.535 13.774-29.93 13.773-39.464 0zM192 272c44.183 0 80-35.817 80-80s-35.817-80-80-80-80 35.817-80 80 35.817 80 80 80z",
        },
        child: [],
      },
    ],
  })(n);
}
function Hz(n) {
  return mi({
    attr: { viewBox: "0 0 512 512" },
    child: [
      {
        tag: "path",
        attr: {
          d: "M493.4 24.6l-104-24c-11.3-2.6-22.9 3.3-27.5 13.9l-48 112c-4.2 9.8-1.4 21.3 6.9 28l60.6 49.6c-36 76.7-98.9 140.5-177.2 177.2l-49.6-60.6c-6.8-8.3-18.2-11.1-28-6.9l-112 48C3.9 366.5-2 378.1.6 389.4l24 104C27.1 504.2 36.7 512 48 512c256.1 0 464-207.5 464-464 0-11.2-7.7-20.9-18.6-23.4z",
        },
        child: [],
      },
    ],
  })(n);
}
function Gz(n) {
  return mi({
    attr: { viewBox: "0 0 352 512" },
    child: [
      {
        tag: "path",
        attr: {
          d: "M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z",
        },
        child: [],
      },
    ],
  })(n);
}
var Zt = {},
  hS = {},
  lh = {},
  uh = {},
  eR = "Expected a function",
  i2 = NaN,
  Wz = "[object Symbol]",
  jz = /^\s+|\s+$/g,
  Xz = /^[-+]0x[0-9a-f]+$/i,
  Yz = /^0b[01]+$/i,
  qz = /^0o[0-7]+$/i,
  Zz = parseInt,
  Kz = typeof Ed == "object" && Ed && Ed.Object === Object && Ed,
  Qz = typeof self == "object" && self && self.Object === Object && self,
  $z = Kz || Qz || Function("return this")(),
  Jz = Object.prototype,
  e5 = Jz.toString,
  t5 = Math.max,
  n5 = Math.min,
  ey = function () {
    return $z.Date.now();
  };
function i5(n, e, t) {
  var i,
    r,
    s,
    o,
    a,
    u,
    f = 0,
    h = !1,
    d = !1,
    p = !0;
  if (typeof n != "function") throw new TypeError(eR);
  (e = r2(e) || 0),
    Zm(t) &&
      ((h = !!t.leading),
      (d = "maxWait" in t),
      (s = d ? t5(r2(t.maxWait) || 0, e) : s),
      (p = "trailing" in t ? !!t.trailing : p));
  function m(b) {
    var L = i,
      N = r;
    return (i = r = void 0), (f = b), (o = n.apply(N, L)), o;
  }
  function y(b) {
    return (f = b), (a = setTimeout(v, e)), h ? m(b) : o;
  }
  function w(b) {
    var L = b - u,
      N = b - f,
      C = e - L;
    return d ? n5(C, s - N) : C;
  }
  function S(b) {
    var L = b - u,
      N = b - f;
    return u === void 0 || L >= e || L < 0 || (d && N >= s);
  }
  function v() {
    var b = ey();
    if (S(b)) return M(b);
    a = setTimeout(v, w(b));
  }
  function M(b) {
    return (a = void 0), p && i ? m(b) : ((i = r = void 0), o);
  }
  function _() {
    a !== void 0 && clearTimeout(a), (f = 0), (i = u = r = a = void 0);
  }
  function T() {
    return a === void 0 ? o : M(ey());
  }
  function P() {
    var b = ey(),
      L = S(b);
    if (((i = arguments), (r = this), (u = b), L)) {
      if (a === void 0) return y(u);
      if (d) return (a = setTimeout(v, e)), m(u);
    }
    return a === void 0 && (a = setTimeout(v, e)), o;
  }
  return (P.cancel = _), (P.flush = T), P;
}
function r5(n, e, t) {
  var i = !0,
    r = !0;
  if (typeof n != "function") throw new TypeError(eR);
  return (
    Zm(t) &&
      ((i = "leading" in t ? !!t.leading : i),
      (r = "trailing" in t ? !!t.trailing : r)),
    i5(n, e, { leading: i, maxWait: e, trailing: r })
  );
}
function Zm(n) {
  var e = typeof n;
  return !!n && (e == "object" || e == "function");
}
function s5(n) {
  return !!n && typeof n == "object";
}
function o5(n) {
  return typeof n == "symbol" || (s5(n) && e5.call(n) == Wz);
}
function r2(n) {
  if (typeof n == "number") return n;
  if (o5(n)) return i2;
  if (Zm(n)) {
    var e = typeof n.valueOf == "function" ? n.valueOf() : n;
    n = Zm(e) ? e + "" : e;
  }
  if (typeof n != "string") return n === 0 ? n : +n;
  n = n.replace(jz, "");
  var t = Yz.test(n);
  return t || qz.test(n) ? Zz(n.slice(2), t ? 2 : 8) : Xz.test(n) ? i2 : +n;
}
var a5 = r5,
  ch = {};
Object.defineProperty(ch, "__esModule", { value: !0 });
ch.addPassiveEventListener = function (e, t, i) {
  var r = i.name;
  r || ((r = t), console.warn("Listener must be a named function.")),
    om.has(t) || om.set(t, new Set());
  var s = om.get(t);
  if (!s.has(r)) {
    var o = (function () {
      var a = !1;
      try {
        var u = Object.defineProperty({}, "passive", {
          get: function () {
            a = !0;
          },
        });
        window.addEventListener("test", null, u);
      } catch {}
      return a;
    })();
    e.addEventListener(t, i, o ? { passive: !0 } : !1), s.add(r);
  }
};
ch.removePassiveEventListener = function (e, t, i) {
  e.removeEventListener(t, i), om.get(t).delete(i.name || t);
};
var om = new Map();
Object.defineProperty(uh, "__esModule", { value: !0 });
var l5 = a5,
  u5 = c5(l5),
  s2 = ch;
function c5(n) {
  return n && n.__esModule ? n : { default: n };
}
var f5 = function (e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
    return (0, u5.default)(e, t);
  },
  on = {
    spyCallbacks: [],
    spySetState: [],
    scrollSpyContainers: [],
    mount: function (e, t) {
      if (e) {
        var i = f5(function (r) {
          on.scrollHandler(e);
        }, t);
        return (
          on.scrollSpyContainers.push(e),
          (0, s2.addPassiveEventListener)(e, "scroll", i),
          function () {
            (0, s2.removePassiveEventListener)(e, "scroll", i),
              on.scrollSpyContainers.splice(
                on.scrollSpyContainers.indexOf(e),
                1
              );
          }
        );
      }
      return function () {};
    },
    isMounted: function (e) {
      return on.scrollSpyContainers.indexOf(e) !== -1;
    },
    currentPositionX: function (e) {
      if (e === document) {
        var t = window.scrollY !== void 0,
          i = (document.compatMode || "") === "CSS1Compat";
        return t
          ? window.scrollX
          : i
          ? document.documentElement.scrollLeft
          : document.body.scrollLeft;
      } else return e.scrollLeft;
    },
    currentPositionY: function (e) {
      if (e === document) {
        var t = window.scrollX !== void 0,
          i = (document.compatMode || "") === "CSS1Compat";
        return t
          ? window.scrollY
          : i
          ? document.documentElement.scrollTop
          : document.body.scrollTop;
      } else return e.scrollTop;
    },
    scrollHandler: function (e) {
      var t =
        on.scrollSpyContainers[on.scrollSpyContainers.indexOf(e)]
          .spyCallbacks || [];
      t.forEach(function (i) {
        return i(on.currentPositionX(e), on.currentPositionY(e));
      });
    },
    addStateHandler: function (e) {
      on.spySetState.push(e);
    },
    addSpyHandler: function (e, t) {
      var i = on.scrollSpyContainers[on.scrollSpyContainers.indexOf(t)];
      i.spyCallbacks || (i.spyCallbacks = []), i.spyCallbacks.push(e);
    },
    updateStates: function () {
      on.spySetState.forEach(function (e) {
        return e();
      });
    },
    unmount: function (e, t) {
      on.scrollSpyContainers.forEach(function (i) {
        return (
          i.spyCallbacks &&
          i.spyCallbacks.length &&
          i.spyCallbacks.indexOf(t) > -1 &&
          i.spyCallbacks.splice(i.spyCallbacks.indexOf(t), 1)
        );
      }),
        on.spySetState &&
          on.spySetState.length &&
          on.spySetState.indexOf(e) > -1 &&
          on.spySetState.splice(on.spySetState.indexOf(e), 1),
        document.removeEventListener("scroll", on.scrollHandler);
    },
    update: function () {
      return on.scrollSpyContainers.forEach(function (e) {
        return on.scrollHandler(e);
      });
    },
  };
uh.default = on;
var Wu = {},
  fh = {};
Object.defineProperty(fh, "__esModule", { value: !0 });
var h5 = function (e, t) {
    var i = e.indexOf("#") === 0 ? e.substring(1) : e,
      r = i ? "#" + i : "",
      s = window && window.location,
      o = r ? s.pathname + s.search + r : s.pathname + s.search;
    t
      ? history.pushState(history.state, "", o)
      : history.replaceState(history.state, "", o);
  },
  d5 = function () {
    return window.location.hash.replace(/^#/, "");
  },
  p5 = function (e) {
    return function (t) {
      return e.contains
        ? e != t && e.contains(t)
        : !!(e.compareDocumentPosition(t) & 16);
    };
  },
  m5 = function (e) {
    return getComputedStyle(e).position !== "static";
  },
  ty = function (e, t) {
    for (var i = e.offsetTop, r = e.offsetParent; r && !t(r); )
      (i += r.offsetTop), (r = r.offsetParent);
    return { offsetTop: i, offsetParent: r };
  },
  g5 = function (e, t, i) {
    if (i)
      return e === document
        ? t.getBoundingClientRect().left +
            (window.scrollX || window.pageXOffset)
        : getComputedStyle(e).position !== "static"
        ? t.offsetLeft
        : t.offsetLeft - e.offsetLeft;
    if (e === document)
      return (
        t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset)
      );
    if (m5(e)) {
      if (t.offsetParent !== e) {
        var r = function (h) {
            return h === e || h === document;
          },
          s = ty(t, r),
          o = s.offsetTop,
          a = s.offsetParent;
        if (a !== e)
          throw new Error(
            "Seems containerElement is not an ancestor of the Element"
          );
        return o;
      }
      return t.offsetTop;
    }
    if (t.offsetParent === e.offsetParent) return t.offsetTop - e.offsetTop;
    var u = function (h) {
      return h === document;
    };
    return ty(t, u).offsetTop - ty(e, u).offsetTop;
  };
fh.default = {
  updateHash: h5,
  getHash: d5,
  filterElementInContainer: p5,
  scrollOffset: g5,
};
var Pg = {},
  dS = {};
Object.defineProperty(dS, "__esModule", { value: !0 });
dS.default = {
  defaultEasing: function (e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  linear: function (e) {
    return e;
  },
  easeInQuad: function (e) {
    return e * e;
  },
  easeOutQuad: function (e) {
    return e * (2 - e);
  },
  easeInOutQuad: function (e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  easeInCubic: function (e) {
    return e * e * e;
  },
  easeOutCubic: function (e) {
    return --e * e * e + 1;
  },
  easeInOutCubic: function (e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  easeInQuart: function (e) {
    return e * e * e * e;
  },
  easeOutQuart: function (e) {
    return 1 - --e * e * e * e;
  },
  easeInOutQuart: function (e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  easeInQuint: function (e) {
    return e * e * e * e * e;
  },
  easeOutQuint: function (e) {
    return 1 + --e * e * e * e * e;
  },
  easeInOutQuint: function (e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  },
};
var pS = {};
Object.defineProperty(pS, "__esModule", { value: !0 });
var v5 = ch,
  y5 = ["mousedown", "wheel", "touchmove", "keydown"];
pS.default = {
  subscribe: function (e) {
    return (
      typeof document < "u" &&
      y5.forEach(function (t) {
        return (0, v5.addPassiveEventListener)(document, t, e);
      })
    );
  },
};
var hh = {};
Object.defineProperty(hh, "__esModule", { value: !0 });
var n_ = {
  registered: {},
  scrollEvent: {
    register: function (e, t) {
      n_.registered[e] = t;
    },
    remove: function (e) {
      n_.registered[e] = null;
    },
  },
};
hh.default = n_;
Object.defineProperty(Pg, "__esModule", { value: !0 });
var x5 =
    Object.assign ||
    function (n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var i in t)
          Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i]);
      }
      return n;
    },
  _5 = fh;
Rg(_5);
var S5 = dS,
  o2 = Rg(S5),
  M5 = pS,
  w5 = Rg(M5),
  E5 = hh,
  ns = Rg(E5);
function Rg(n) {
  return n && n.__esModule ? n : { default: n };
}
var tR = function (e) {
    return o2.default[e.smooth] || o2.default.defaultEasing;
  },
  T5 = function (e) {
    return typeof e == "function"
      ? e
      : function () {
          return e;
        };
  },
  A5 = function () {
    if (typeof window < "u")
      return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
  },
  i_ = (function () {
    return (
      A5() ||
      function (n, e, t) {
        window.setTimeout(n, t || 1e3 / 60, new Date().getTime());
      }
    );
  })(),
  nR = function () {
    return {
      currentPosition: 0,
      startPosition: 0,
      targetPosition: 0,
      progress: 0,
      duration: 0,
      cancel: !1,
      target: null,
      containerElement: null,
      to: null,
      start: null,
      delta: null,
      percent: null,
      delayTimeout: null,
    };
  },
  iR = function (e) {
    var t = e.data.containerElement;
    if (t && t !== document && t !== document.body) return t.scrollLeft;
    var i = window.pageXOffset !== void 0,
      r = (document.compatMode || "") === "CSS1Compat";
    return i
      ? window.pageXOffset
      : r
      ? document.documentElement.scrollLeft
      : document.body.scrollLeft;
  },
  rR = function (e) {
    var t = e.data.containerElement;
    if (t && t !== document && t !== document.body) return t.scrollTop;
    var i = window.pageXOffset !== void 0,
      r = (document.compatMode || "") === "CSS1Compat";
    return i
      ? window.pageYOffset
      : r
      ? document.documentElement.scrollTop
      : document.body.scrollTop;
  },
  b5 = function (e) {
    var t = e.data.containerElement;
    if (t && t !== document && t !== document.body)
      return t.scrollWidth - t.offsetWidth;
    var i = document.body,
      r = document.documentElement;
    return Math.max(
      i.scrollWidth,
      i.offsetWidth,
      r.clientWidth,
      r.scrollWidth,
      r.offsetWidth
    );
  },
  C5 = function (e) {
    var t = e.data.containerElement;
    if (t && t !== document && t !== document.body)
      return t.scrollHeight - t.offsetHeight;
    var i = document.body,
      r = document.documentElement;
    return Math.max(
      i.scrollHeight,
      i.offsetHeight,
      r.clientHeight,
      r.scrollHeight,
      r.offsetHeight
    );
  },
  P5 = function n(e, t, i) {
    var r = t.data;
    if (!t.ignoreCancelEvents && r.cancel) {
      ns.default.registered.end &&
        ns.default.registered.end(r.to, r.target, r.currentPositionY);
      return;
    }
    if (
      ((r.delta = Math.round(r.targetPosition - r.startPosition)),
      r.start === null && (r.start = i),
      (r.progress = i - r.start),
      (r.percent = r.progress >= r.duration ? 1 : e(r.progress / r.duration)),
      (r.currentPosition = r.startPosition + Math.ceil(r.delta * r.percent)),
      r.containerElement &&
      r.containerElement !== document &&
      r.containerElement !== document.body
        ? t.horizontal
          ? (r.containerElement.scrollLeft = r.currentPosition)
          : (r.containerElement.scrollTop = r.currentPosition)
        : t.horizontal
        ? window.scrollTo(r.currentPosition, 0)
        : window.scrollTo(0, r.currentPosition),
      r.percent < 1)
    ) {
      var s = n.bind(null, e, t);
      i_.call(window, s);
      return;
    }
    ns.default.registered.end &&
      ns.default.registered.end(r.to, r.target, r.currentPosition);
  },
  mS = function (e) {
    e.data.containerElement = e
      ? e.containerId
        ? document.getElementById(e.containerId)
        : e.container && e.container.nodeType
        ? e.container
        : document
      : null;
  },
  dh = function (e, t, i, r) {
    (t.data = t.data || nR()), window.clearTimeout(t.data.delayTimeout);
    var s = function () {
      t.data.cancel = !0;
    };
    if (
      (w5.default.subscribe(s),
      mS(t),
      (t.data.start = null),
      (t.data.cancel = !1),
      (t.data.startPosition = t.horizontal ? iR(t) : rR(t)),
      (t.data.targetPosition = t.absolute ? e : e + t.data.startPosition),
      t.data.startPosition === t.data.targetPosition)
    ) {
      ns.default.registered.end &&
        ns.default.registered.end(
          t.data.to,
          t.data.target,
          t.data.currentPosition
        );
      return;
    }
    (t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition)),
      (t.data.duration = T5(t.duration)(t.data.delta)),
      (t.data.duration = isNaN(parseFloat(t.data.duration))
        ? 1e3
        : parseFloat(t.data.duration)),
      (t.data.to = i),
      (t.data.target = r);
    var o = tR(t),
      a = P5.bind(null, o, t);
    if (t && t.delay > 0) {
      t.data.delayTimeout = window.setTimeout(function () {
        ns.default.registered.begin &&
          ns.default.registered.begin(t.data.to, t.data.target),
          i_.call(window, a);
      }, t.delay);
      return;
    }
    ns.default.registered.begin &&
      ns.default.registered.begin(t.data.to, t.data.target),
      i_.call(window, a);
  },
  Lg = function (e) {
    return (e = x5({}, e)), (e.data = e.data || nR()), (e.absolute = !0), e;
  },
  R5 = function (e) {
    dh(0, Lg(e));
  },
  L5 = function (e, t) {
    dh(e, Lg(t));
  },
  I5 = function (e) {
    (e = Lg(e)), mS(e), dh(e.horizontal ? b5(e) : C5(e), e);
  },
  N5 = function (e, t) {
    (t = Lg(t)), mS(t);
    var i = t.horizontal ? iR(t) : rR(t);
    dh(e + i, t);
  };
Pg.default = {
  animateTopScroll: dh,
  getAnimationType: tR,
  scrollToTop: R5,
  scrollToBottom: I5,
  scrollTo: L5,
  scrollMore: N5,
};
Object.defineProperty(Wu, "__esModule", { value: !0 });
var D5 =
    Object.assign ||
    function (n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var i in t)
          Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i]);
      }
      return n;
    },
  O5 = fh,
  U5 = gS(O5),
  k5 = Pg,
  F5 = gS(k5),
  z5 = hh,
  Xd = gS(z5);
function gS(n) {
  return n && n.__esModule ? n : { default: n };
}
var Yd = {},
  a2 = void 0;
Wu.default = {
  unmount: function () {
    Yd = {};
  },
  register: function (e, t) {
    Yd[e] = t;
  },
  unregister: function (e) {
    delete Yd[e];
  },
  get: function (e) {
    return (
      Yd[e] ||
      document.getElementById(e) ||
      document.getElementsByName(e)[0] ||
      document.getElementsByClassName(e)[0]
    );
  },
  setActiveLink: function (e) {
    return (a2 = e);
  },
  getActiveLink: function () {
    return a2;
  },
  scrollTo: function (e, t) {
    var i = this.get(e);
    if (!i) {
      console.warn("target Element not found");
      return;
    }
    t = D5({}, t, { absolute: !1 });
    var r = t.containerId,
      s = t.container,
      o = void 0;
    r
      ? (o = document.getElementById(r))
      : s && s.nodeType
      ? (o = s)
      : (o = document),
      (t.absolute = !0);
    var a = t.horizontal,
      u = U5.default.scrollOffset(o, i, a) + (t.offset || 0);
    if (!t.smooth) {
      Xd.default.registered.begin && Xd.default.registered.begin(e, i),
        o === document
          ? t.horizontal
            ? window.scrollTo(u, 0)
            : window.scrollTo(0, u)
          : (o.scrollTop = u),
        Xd.default.registered.end && Xd.default.registered.end(e, i);
      return;
    }
    F5.default.animateTopScroll(u, t, e, i);
  },
};
var sR = { exports: {} },
  B5 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED",
  V5 = B5,
  H5 = V5;
function oR() {}
function aR() {}
aR.resetWarningCache = oR;
var G5 = function () {
  function n(i, r, s, o, a, u) {
    if (u !== H5) {
      var f = new Error(
        "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
      );
      throw ((f.name = "Invariant Violation"), f);
    }
  }
  n.isRequired = n;
  function e() {
    return n;
  }
  var t = {
    array: n,
    bigint: n,
    bool: n,
    func: n,
    number: n,
    object: n,
    string: n,
    symbol: n,
    any: n,
    arrayOf: e,
    element: n,
    elementType: n,
    instanceOf: e,
    node: n,
    objectOf: e,
    oneOf: e,
    oneOfType: e,
    shape: e,
    exact: e,
    checkPropTypes: aR,
    resetWarningCache: oR,
  };
  return (t.PropTypes = t), t;
};
sR.exports = G5();
var Ig = sR.exports,
  Ng = {};
Object.defineProperty(Ng, "__esModule", { value: !0 });
var W5 = fh,
  ny = j5(W5);
function j5(n) {
  return n && n.__esModule ? n : { default: n };
}
var X5 = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function (e) {
    (this.scroller = e),
      (this.handleHashChange = this.handleHashChange.bind(this)),
      window.addEventListener("hashchange", this.handleHashChange),
      this.initStateFromHash(),
      (this.mountFlag = !0);
  },
  mapContainer: function (e, t) {
    this.containers[e] = t;
  },
  isMounted: function () {
    return this.mountFlag;
  },
  isInitialized: function () {
    return this.initialized;
  },
  initStateFromHash: function () {
    var e = this,
      t = this.getHash();
    t
      ? window.setTimeout(function () {
          e.scrollTo(t, !0), (e.initialized = !0);
        }, 10)
      : (this.initialized = !0);
  },
  scrollTo: function (e, t) {
    var i = this.scroller,
      r = i.get(e);
    if (r && (t || e !== i.getActiveLink())) {
      var s = this.containers[e] || document;
      i.scrollTo(e, { container: s });
    }
  },
  getHash: function () {
    return ny.default.getHash();
  },
  changeHash: function (e, t) {
    this.isInitialized() &&
      ny.default.getHash() !== e &&
      ny.default.updateHash(e, t);
  },
  handleHashChange: function () {
    this.scrollTo(this.getHash());
  },
  unmount: function () {
    (this.scroller = null),
      (this.containers = null),
      window.removeEventListener("hashchange", this.handleHashChange);
  },
};
Ng.default = X5;
Object.defineProperty(lh, "__esModule", { value: !0 });
var qd =
    Object.assign ||
    function (n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var i in t)
          Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i]);
      }
      return n;
    },
  Y5 = (function () {
    function n(e, t) {
      for (var i = 0; i < t.length; i++) {
        var r = t[i];
        (r.enumerable = r.enumerable || !1),
          (r.configurable = !0),
          "value" in r && (r.writable = !0),
          Object.defineProperty(e, r.key, r);
      }
    }
    return function (e, t, i) {
      return t && n(e.prototype, t), i && n(e, i), e;
    };
  })(),
  q5 = se,
  l2 = ph(q5),
  Z5 = uh,
  Zd = ph(Z5),
  K5 = Wu,
  Q5 = ph(K5),
  $5 = Ig,
  tn = ph($5),
  J5 = Ng,
  oo = ph(J5);
function ph(n) {
  return n && n.__esModule ? n : { default: n };
}
function eB(n, e) {
  if (!(n instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function tB(n, e) {
  if (!n)
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    );
  return e && (typeof e == "object" || typeof e == "function") ? e : n;
}
function nB(n, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError(
      "Super expression must either be null or a function, not " + typeof e
    );
  (n.prototype = Object.create(e && e.prototype, {
    constructor: { value: n, enumerable: !1, writable: !0, configurable: !0 },
  })),
    e &&
      (Object.setPrototypeOf ? Object.setPrototypeOf(n, e) : (n.__proto__ = e));
}
var u2 = {
  to: tn.default.string.isRequired,
  containerId: tn.default.string,
  container: tn.default.object,
  activeClass: tn.default.string,
  activeStyle: tn.default.object,
  spy: tn.default.bool,
  horizontal: tn.default.bool,
  smooth: tn.default.oneOfType([tn.default.bool, tn.default.string]),
  offset: tn.default.number,
  delay: tn.default.number,
  isDynamic: tn.default.bool,
  onClick: tn.default.func,
  duration: tn.default.oneOfType([tn.default.number, tn.default.func]),
  absolute: tn.default.bool,
  onSetActive: tn.default.func,
  onSetInactive: tn.default.func,
  ignoreCancelEvents: tn.default.bool,
  hashSpy: tn.default.bool,
  saveHashHistory: tn.default.bool,
  spyThrottle: tn.default.number,
};
lh.default = function (n, e) {
  var t = e || Q5.default,
    i = (function (s) {
      nB(o, s);
      function o(a) {
        eB(this, o);
        var u = tB(
          this,
          (o.__proto__ || Object.getPrototypeOf(o)).call(this, a)
        );
        return (
          r.call(u),
          (u.state = { active: !1 }),
          (u.beforeUnmountCallbacks = []),
          u
        );
      }
      return (
        Y5(o, [
          {
            key: "getScrollSpyContainer",
            value: function () {
              var u = this.props.containerId,
                f = this.props.container;
              return u && !f
                ? document.getElementById(u)
                : f && f.nodeType
                ? f
                : document;
            },
          },
          {
            key: "componentDidMount",
            value: function () {
              if (this.props.spy || this.props.hashSpy) {
                var u = this.getScrollSpyContainer();
                if (!Zd.default.isMounted(u)) {
                  var f = Zd.default.mount(u, this.props.spyThrottle);
                  this.beforeUnmountCallbacks.push(f);
                }
                this.props.hashSpy &&
                  (oo.default.isMounted() || oo.default.mount(t),
                  oo.default.mapContainer(this.props.to, u)),
                  Zd.default.addSpyHandler(this.spyHandler, u),
                  this.setState({ container: u });
              }
            },
          },
          {
            key: "componentWillUnmount",
            value: function () {
              Zd.default.unmount(this.stateHandler, this.spyHandler),
                this.beforeUnmountCallbacks.forEach(function (u) {
                  return u();
                });
            },
          },
          {
            key: "render",
            value: function () {
              var u = "";
              this.state && this.state.active
                ? (u = (
                    (this.props.className || "") +
                    " " +
                    (this.props.activeClass || "active")
                  ).trim())
                : (u = this.props.className);
              var f = {};
              this.state && this.state.active
                ? (f = qd({}, this.props.style, this.props.activeStyle))
                : (f = qd({}, this.props.style));
              var h = qd({}, this.props);
              for (var d in u2) h.hasOwnProperty(d) && delete h[d];
              return (
                (h.className = u),
                (h.style = f),
                (h.onClick = this.handleClick),
                l2.default.createElement(n, h)
              );
            },
          },
        ]),
        o
      );
    })(l2.default.PureComponent),
    r = function () {
      var o = this;
      (this.scrollTo = function (a, u) {
        t.scrollTo(a, qd({}, o.state, u));
      }),
        (this.handleClick = function (a) {
          o.props.onClick && o.props.onClick(a),
            a.stopPropagation && a.stopPropagation(),
            a.preventDefault && a.preventDefault(),
            o.scrollTo(o.props.to, o.props);
        }),
        (this.spyHandler = function (a, u) {
          var f = o.getScrollSpyContainer();
          if (!(oo.default.isMounted() && !oo.default.isInitialized())) {
            var h = o.props.horizontal,
              d = o.props.to,
              p = null,
              m = void 0,
              y = void 0;
            if (h) {
              var w = 0,
                S = 0,
                v = 0;
              if (f.getBoundingClientRect) {
                var M = f.getBoundingClientRect();
                v = M.left;
              }
              if (!p || o.props.isDynamic) {
                if (((p = t.get(d)), !p)) return;
                var _ = p.getBoundingClientRect();
                (w = _.left - v + a), (S = w + _.width);
              }
              var T = a - o.props.offset;
              (m = T >= Math.floor(w) && T < Math.floor(S)),
                (y = T < Math.floor(w) || T >= Math.floor(S));
            } else {
              var P = 0,
                b = 0,
                L = 0;
              if (f.getBoundingClientRect) {
                var N = f.getBoundingClientRect();
                L = N.top;
              }
              if (!p || o.props.isDynamic) {
                if (((p = t.get(d)), !p)) return;
                var C = p.getBoundingClientRect();
                (P = C.top - L + u), (b = P + C.height);
              }
              var R = u - o.props.offset;
              (m = R >= Math.floor(P) && R < Math.floor(b)),
                (y = R < Math.floor(P) || R >= Math.floor(b));
            }
            var B = t.getActiveLink();
            if (y) {
              if (
                (d === B && t.setActiveLink(void 0),
                o.props.hashSpy && oo.default.getHash() === d)
              ) {
                var Z = o.props.saveHashHistory,
                  ae = Z === void 0 ? !1 : Z;
                oo.default.changeHash("", ae);
              }
              o.props.spy &&
                o.state.active &&
                (o.setState({ active: !1 }),
                o.props.onSetInactive && o.props.onSetInactive(d, p));
            }
            if (m && (B !== d || o.state.active === !1)) {
              t.setActiveLink(d);
              var V = o.props.saveHashHistory,
                Q = V === void 0 ? !1 : V;
              o.props.hashSpy && oo.default.changeHash(d, Q),
                o.props.spy &&
                  (o.setState({ active: !0 }),
                  o.props.onSetActive && o.props.onSetActive(d, p));
            }
          }
        });
    };
  return (i.propTypes = u2), (i.defaultProps = { offset: 0 }), i;
};
Object.defineProperty(hS, "__esModule", { value: !0 });
var iB = se,
  c2 = lR(iB),
  rB = lh,
  sB = lR(rB);
function lR(n) {
  return n && n.__esModule ? n : { default: n };
}
function oB(n, e) {
  if (!(n instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function f2(n, e) {
  if (!n)
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    );
  return e && (typeof e == "object" || typeof e == "function") ? e : n;
}
function aB(n, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError(
      "Super expression must either be null or a function, not " + typeof e
    );
  (n.prototype = Object.create(e && e.prototype, {
    constructor: { value: n, enumerable: !1, writable: !0, configurable: !0 },
  })),
    e &&
      (Object.setPrototypeOf ? Object.setPrototypeOf(n, e) : (n.__proto__ = e));
}
var lB = (function (n) {
  aB(e, n);
  function e() {
    var t, i, r, s;
    oB(this, e);
    for (var o = arguments.length, a = Array(o), u = 0; u < o; u++)
      a[u] = arguments[u];
    return (
      (s =
        ((i =
          ((r = f2(
            this,
            (t = e.__proto__ || Object.getPrototypeOf(e)).call.apply(
              t,
              [this].concat(a)
            )
          )),
          r)),
        (r.render = function () {
          return c2.default.createElement("a", r.props, r.props.children);
        }),
        i)),
      f2(r, s)
    );
  }
  return e;
})(c2.default.Component);
hS.default = (0, sB.default)(lB);
var vS = {};
Object.defineProperty(vS, "__esModule", { value: !0 });
var uB = (function () {
    function n(e, t) {
      for (var i = 0; i < t.length; i++) {
        var r = t[i];
        (r.enumerable = r.enumerable || !1),
          (r.configurable = !0),
          "value" in r && (r.writable = !0),
          Object.defineProperty(e, r.key, r);
      }
    }
    return function (e, t, i) {
      return t && n(e.prototype, t), i && n(e, i), e;
    };
  })(),
  cB = se,
  h2 = uR(cB),
  fB = lh,
  hB = uR(fB);
function uR(n) {
  return n && n.__esModule ? n : { default: n };
}
function dB(n, e) {
  if (!(n instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function pB(n, e) {
  if (!n)
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    );
  return e && (typeof e == "object" || typeof e == "function") ? e : n;
}
function mB(n, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError(
      "Super expression must either be null or a function, not " + typeof e
    );
  (n.prototype = Object.create(e && e.prototype, {
    constructor: { value: n, enumerable: !1, writable: !0, configurable: !0 },
  })),
    e &&
      (Object.setPrototypeOf ? Object.setPrototypeOf(n, e) : (n.__proto__ = e));
}
var gB = (function (n) {
  mB(e, n);
  function e() {
    return (
      dB(this, e),
      pB(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments))
    );
  }
  return (
    uB(e, [
      {
        key: "render",
        value: function () {
          return h2.default.createElement(
            "button",
            this.props,
            this.props.children
          );
        },
      },
    ]),
    e
  );
})(h2.default.Component);
vS.default = (0, hB.default)(gB);
var yS = {},
  Dg = {};
Object.defineProperty(Dg, "__esModule", { value: !0 });
var vB =
    Object.assign ||
    function (n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var i in t)
          Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i]);
      }
      return n;
    },
  yB = (function () {
    function n(e, t) {
      for (var i = 0; i < t.length; i++) {
        var r = t[i];
        (r.enumerable = r.enumerable || !1),
          (r.configurable = !0),
          "value" in r && (r.writable = !0),
          Object.defineProperty(e, r.key, r);
      }
    }
    return function (e, t, i) {
      return t && n(e.prototype, t), i && n(e, i), e;
    };
  })(),
  xB = se,
  d2 = Og(xB),
  _B = PP;
Og(_B);
var SB = Wu,
  p2 = Og(SB),
  MB = Ig,
  m2 = Og(MB);
function Og(n) {
  return n && n.__esModule ? n : { default: n };
}
function wB(n, e) {
  if (!(n instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function EB(n, e) {
  if (!n)
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    );
  return e && (typeof e == "object" || typeof e == "function") ? e : n;
}
function TB(n, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError(
      "Super expression must either be null or a function, not " + typeof e
    );
  (n.prototype = Object.create(e && e.prototype, {
    constructor: { value: n, enumerable: !1, writable: !0, configurable: !0 },
  })),
    e &&
      (Object.setPrototypeOf ? Object.setPrototypeOf(n, e) : (n.__proto__ = e));
}
Dg.default = function (n) {
  var e = (function (t) {
    TB(i, t);
    function i(r) {
      wB(this, i);
      var s = EB(this, (i.__proto__ || Object.getPrototypeOf(i)).call(this, r));
      return (s.childBindings = { domNode: null }), s;
    }
    return (
      yB(i, [
        {
          key: "componentDidMount",
          value: function () {
            if (typeof window > "u") return !1;
            this.registerElems(this.props.name);
          },
        },
        {
          key: "componentDidUpdate",
          value: function (s) {
            this.props.name !== s.name && this.registerElems(this.props.name);
          },
        },
        {
          key: "componentWillUnmount",
          value: function () {
            if (typeof window > "u") return !1;
            p2.default.unregister(this.props.name);
          },
        },
        {
          key: "registerElems",
          value: function (s) {
            p2.default.register(s, this.childBindings.domNode);
          },
        },
        {
          key: "render",
          value: function () {
            return d2.default.createElement(
              n,
              vB({}, this.props, { parentBindings: this.childBindings })
            );
          },
        },
      ]),
      i
    );
  })(d2.default.Component);
  return (e.propTypes = { name: m2.default.string, id: m2.default.string }), e;
};
Object.defineProperty(yS, "__esModule", { value: !0 });
var g2 =
    Object.assign ||
    function (n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var i in t)
          Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i]);
      }
      return n;
    },
  AB = (function () {
    function n(e, t) {
      for (var i = 0; i < t.length; i++) {
        var r = t[i];
        (r.enumerable = r.enumerable || !1),
          (r.configurable = !0),
          "value" in r && (r.writable = !0),
          Object.defineProperty(e, r.key, r);
      }
    }
    return function (e, t, i) {
      return t && n(e.prototype, t), i && n(e, i), e;
    };
  })(),
  bB = se,
  v2 = xS(bB),
  CB = Dg,
  PB = xS(CB),
  RB = Ig,
  y2 = xS(RB);
function xS(n) {
  return n && n.__esModule ? n : { default: n };
}
function LB(n, e) {
  if (!(n instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function IB(n, e) {
  if (!n)
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    );
  return e && (typeof e == "object" || typeof e == "function") ? e : n;
}
function NB(n, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError(
      "Super expression must either be null or a function, not " + typeof e
    );
  (n.prototype = Object.create(e && e.prototype, {
    constructor: { value: n, enumerable: !1, writable: !0, configurable: !0 },
  })),
    e &&
      (Object.setPrototypeOf ? Object.setPrototypeOf(n, e) : (n.__proto__ = e));
}
var cR = (function (n) {
  NB(e, n);
  function e() {
    return (
      LB(this, e),
      IB(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments))
    );
  }
  return (
    AB(e, [
      {
        key: "render",
        value: function () {
          var i = this,
            r = g2({}, this.props);
          return (
            delete r.name,
            r.parentBindings && delete r.parentBindings,
            v2.default.createElement(
              "div",
              g2({}, r, {
                ref: function (o) {
                  i.props.parentBindings.domNode = o;
                },
              }),
              this.props.children
            )
          );
        },
      },
    ]),
    e
  );
})(v2.default.Component);
cR.propTypes = { name: y2.default.string, id: y2.default.string };
yS.default = (0, PB.default)(cR);
var iy =
    Object.assign ||
    function (n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var i in t)
          Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i]);
      }
      return n;
    },
  x2 = (function () {
    function n(e, t) {
      for (var i = 0; i < t.length; i++) {
        var r = t[i];
        (r.enumerable = r.enumerable || !1),
          (r.configurable = !0),
          "value" in r && (r.writable = !0),
          Object.defineProperty(e, r.key, r);
      }
    }
    return function (e, t, i) {
      return t && n(e.prototype, t), i && n(e, i), e;
    };
  })();
function _2(n, e) {
  if (!(n instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function S2(n, e) {
  if (!n)
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    );
  return e && (typeof e == "object" || typeof e == "function") ? e : n;
}
function M2(n, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError(
      "Super expression must either be null or a function, not " + typeof e
    );
  (n.prototype = Object.create(e && e.prototype, {
    constructor: { value: n, enumerable: !1, writable: !0, configurable: !0 },
  })),
    e &&
      (Object.setPrototypeOf ? Object.setPrototypeOf(n, e) : (n.__proto__ = e));
}
var Kd = se,
  ca = uh,
  ry = Wu,
  an = Ig,
  ao = Ng,
  w2 = {
    to: an.string.isRequired,
    containerId: an.string,
    container: an.object,
    activeClass: an.string,
    spy: an.bool,
    smooth: an.oneOfType([an.bool, an.string]),
    offset: an.number,
    delay: an.number,
    isDynamic: an.bool,
    onClick: an.func,
    duration: an.oneOfType([an.number, an.func]),
    absolute: an.bool,
    onSetActive: an.func,
    onSetInactive: an.func,
    ignoreCancelEvents: an.bool,
    hashSpy: an.bool,
    spyThrottle: an.number,
  },
  DB = {
    Scroll: function (e, t) {
      console.warn("Helpers.Scroll is deprecated since v1.7.0");
      var i = t || ry,
        r = (function (o) {
          M2(a, o);
          function a(u) {
            _2(this, a);
            var f = S2(
              this,
              (a.__proto__ || Object.getPrototypeOf(a)).call(this, u)
            );
            return s.call(f), (f.state = { active: !1 }), f;
          }
          return (
            x2(a, [
              {
                key: "getScrollSpyContainer",
                value: function () {
                  var f = this.props.containerId,
                    h = this.props.container;
                  return f
                    ? document.getElementById(f)
                    : h && h.nodeType
                    ? h
                    : document;
                },
              },
              {
                key: "componentDidMount",
                value: function () {
                  if (this.props.spy || this.props.hashSpy) {
                    var f = this.getScrollSpyContainer();
                    ca.isMounted(f) || ca.mount(f, this.props.spyThrottle),
                      this.props.hashSpy &&
                        (ao.isMounted() || ao.mount(i),
                        ao.mapContainer(this.props.to, f)),
                      this.props.spy && ca.addStateHandler(this.stateHandler),
                      ca.addSpyHandler(this.spyHandler, f),
                      this.setState({ container: f });
                  }
                },
              },
              {
                key: "componentWillUnmount",
                value: function () {
                  ca.unmount(this.stateHandler, this.spyHandler);
                },
              },
              {
                key: "render",
                value: function () {
                  var f = "";
                  this.state && this.state.active
                    ? (f = (
                        (this.props.className || "") +
                        " " +
                        (this.props.activeClass || "active")
                      ).trim())
                    : (f = this.props.className);
                  var h = iy({}, this.props);
                  for (var d in w2) h.hasOwnProperty(d) && delete h[d];
                  return (
                    (h.className = f),
                    (h.onClick = this.handleClick),
                    Kd.createElement(e, h)
                  );
                },
              },
            ]),
            a
          );
        })(Kd.Component),
        s = function () {
          var a = this;
          (this.scrollTo = function (u, f) {
            i.scrollTo(u, iy({}, a.state, f));
          }),
            (this.handleClick = function (u) {
              a.props.onClick && a.props.onClick(u),
                u.stopPropagation && u.stopPropagation(),
                u.preventDefault && u.preventDefault(),
                a.scrollTo(a.props.to, a.props);
            }),
            (this.stateHandler = function () {
              i.getActiveLink() !== a.props.to &&
                (a.state !== null &&
                  a.state.active &&
                  a.props.onSetInactive &&
                  a.props.onSetInactive(),
                a.setState({ active: !1 }));
            }),
            (this.spyHandler = function (u) {
              var f = a.getScrollSpyContainer();
              if (!(ao.isMounted() && !ao.isInitialized())) {
                var h = a.props.to,
                  d = null,
                  p = 0,
                  m = 0,
                  y = 0;
                if (f.getBoundingClientRect) {
                  var w = f.getBoundingClientRect();
                  y = w.top;
                }
                if (!d || a.props.isDynamic) {
                  if (((d = i.get(h)), !d)) return;
                  var S = d.getBoundingClientRect();
                  (p = S.top - y + u), (m = p + S.height);
                }
                var v = u - a.props.offset,
                  M = v >= Math.floor(p) && v < Math.floor(m),
                  _ = v < Math.floor(p) || v >= Math.floor(m),
                  T = i.getActiveLink();
                if (_)
                  return (
                    h === T && i.setActiveLink(void 0),
                    a.props.hashSpy && ao.getHash() === h && ao.changeHash(),
                    a.props.spy &&
                      a.state.active &&
                      (a.setState({ active: !1 }),
                      a.props.onSetInactive && a.props.onSetInactive()),
                    ca.updateStates()
                  );
                if (M && T !== h)
                  return (
                    i.setActiveLink(h),
                    a.props.hashSpy && ao.changeHash(h),
                    a.props.spy &&
                      (a.setState({ active: !0 }),
                      a.props.onSetActive && a.props.onSetActive(h)),
                    ca.updateStates()
                  );
              }
            });
        };
      return (r.propTypes = w2), (r.defaultProps = { offset: 0 }), r;
    },
    Element: function (e) {
      console.warn("Helpers.Element is deprecated since v1.7.0");
      var t = (function (i) {
        M2(r, i);
        function r(s) {
          _2(this, r);
          var o = S2(
            this,
            (r.__proto__ || Object.getPrototypeOf(r)).call(this, s)
          );
          return (o.childBindings = { domNode: null }), o;
        }
        return (
          x2(r, [
            {
              key: "componentDidMount",
              value: function () {
                if (typeof window > "u") return !1;
                this.registerElems(this.props.name);
              },
            },
            {
              key: "componentDidUpdate",
              value: function (o) {
                this.props.name !== o.name &&
                  this.registerElems(this.props.name);
              },
            },
            {
              key: "componentWillUnmount",
              value: function () {
                if (typeof window > "u") return !1;
                ry.unregister(this.props.name);
              },
            },
            {
              key: "registerElems",
              value: function (o) {
                ry.register(o, this.childBindings.domNode);
              },
            },
            {
              key: "render",
              value: function () {
                return Kd.createElement(
                  e,
                  iy({}, this.props, { parentBindings: this.childBindings })
                );
              },
            },
          ]),
          r
        );
      })(Kd.Component);
      return (t.propTypes = { name: an.string, id: an.string }), t;
    },
  },
  OB = DB;
Object.defineProperty(Zt, "__esModule", { value: !0 });
Zt.Helpers =
  Zt.ScrollElement =
  Zt.ScrollLink =
  Zt.animateScroll =
  Zt.scrollSpy =
  Zt.Events =
  Zt.scroller =
  Zt.Element =
  Zt.Button =
  Zt.Link =
    void 0;
var UB = hS,
  fR = ds(UB),
  kB = vS,
  hR = ds(kB),
  FB = yS,
  dR = ds(FB),
  zB = Wu,
  pR = ds(zB),
  BB = hh,
  mR = ds(BB),
  VB = uh,
  gR = ds(VB),
  HB = Pg,
  vR = ds(HB),
  GB = lh,
  yR = ds(GB),
  WB = Dg,
  xR = ds(WB),
  jB = OB,
  _R = ds(jB);
function ds(n) {
  return n && n.__esModule ? n : { default: n };
}
Zt.Link = fR.default;
Zt.Button = hR.default;
Zt.Element = dR.default;
Zt.scroller = pR.default;
Zt.Events = mR.default;
Zt.scrollSpy = gR.default;
Zt.animateScroll = vR.default;
Zt.ScrollLink = yR.default;
Zt.ScrollElement = xR.default;
Zt.Helpers = _R.default;
Zt.default = {
  Link: fR.default,
  Button: hR.default,
  Element: dR.default,
  scroller: pR.default,
  Events: mR.default,
  scrollSpy: gR.default,
  animateScroll: vR.default,
  ScrollLink: yR.default,
  ScrollElement: xR.default,
  Helpers: _R.default,
};
function XB() {
  const [n, e] = se.useState(!1),
    [t, i] = se.useState(!1);
  se.useEffect(() => {
    const o = () => {
      e(window.scrollY > 50);
    };
    return (
      window.addEventListener("scroll", o),
      () => window.removeEventListener("scroll", o)
    );
  }, []);
  const r = [
      { name: "About", section: "about" },
      { name: "Work", section: "projects" },
      { name: "Contact", section: "contact" },
    ],
    s = [
      {
        icon: Cg,
        href: "https://github.com/Oumaima-El-Badraouy",
        label: "GitHub",
      },
      {
        icon: cS,
        href: "https://www.linkedin.com/in/oumaima-el-badraouy/",
        label: "LinkedIn",
      },
      { icon: fS, href: "https://twitter.com", label: "Twitter" },
    ];
  return z.jsx(nt.nav, {
    initial: { y: -100 },
    animate: { y: 0 },
    transition: { duration: 0.8, ease: "easeOut" },
    className: `fixed top-0 left-0 right-0 z-40 transition-all duration-500 ${
      n ? "glass py-4" : "bg-transparent py-6"
    }`,
    children: z.jsxs("div", {
      className: "max-w-7xl mx-auto px-6 md:px-12",
      children: [
        z.jsxs("div", {
          className: "flex items-center justify-between",
          children: [
            z.jsxs(nt.div, {
              className: "flex items-center gap-3 cursor-pointer",
              whileHover: { scale: 1.02 },
              whileTap: { scale: 0.98 },
              children: [
                z.jsx("div", {
                  className:
                    "w-10 h-10 glass-surface rounded-full flex items-center justify-center",
                  children: z.jsx("span", {
                    className: "text-lg font-display text-accent",
                    children: "A",
                  }),
                }),
                z.jsx("span", {
                  className:
                    "font-display text-lg tracking-wide hidden md:block",
                  children: "Portfolio",
                }),
              ],
            }),
            z.jsxs("div", {
              className: "hidden md:flex items-center gap-10",
              children: [
                r.map((o, a) =>
                  z.jsx(
                    nt.button,
                    {
                      onClick: () => Zt.scrollTo(o.section),
                      initial: { opacity: 0, y: -20 },
                      animate: { opacity: 1, y: 0 },
                      transition: { delay: 0.2 + a * 0.1 },
                      whileHover: { y: -2 },
                      className:
                        "text-sm uppercase tracking-widest text-textMuted hover:text-text transition-colors font-light magnetic",
                      children: o.name,
                    },
                    o.name
                  )
                ),
                z.jsx("div", {
                  className:
                    "flex items-center gap-6 pl-8 border-l border-border",
                  children: s.map((o) =>
                    z.jsx(
                      nt.a,
                      {
                        href: o.href,
                        target: "_blank",
                        rel: "noopener noreferrer",
                        whileHover: { scale: 1.1, y: -2 },
                        whileTap: { scale: 0.95 },
                        className:
                          "text-textMuted hover:text-accent transition-colors text-lg magnetic",
                        "aria-label": o.label,
                        children: z.jsx(o.icon, {}),
                      },
                      o.label
                    )
                  ),
                }),
              ],
            }),
            z.jsx("button", {
              className:
                "md:hidden text-textMuted hover:text-text transition-colors p-2",
              onClick: () => i(!t),
              children: t ? z.jsx(Gz, { size: 24 }) : z.jsx(Dz, { size: 24 }),
            }),
          ],
        }),
        t &&
          z.jsx(nt.div, {
            initial: { opacity: 0, height: 0 },
            animate: { opacity: 1, height: "auto" },
            exit: { opacity: 0, height: 0 },
            className: "md:hidden overflow-hidden",
            children: z.jsxs("div", {
              className: "glass mt-4 rounded-2xl p-6 space-y-4",
              children: [
                r.map((o) =>
                  z.jsx(
                    "button",
                    {
                      onClick: () => {
                        Zt.scrollTo(o.section), i(!1);
                      },
                      className:
                        "block w-full text-left text-body text-textMuted hover:text-text transition-colors py-2 magnetic",
                      children: o.name,
                    },
                    o.name
                  )
                ),
                z.jsx("div", {
                  className:
                    "flex items-center gap-5 pt-4 border-t border-border",
                  children: s.map((o) =>
                    z.jsx(
                      "a",
                      {
                        href: o.href,
                        target: "_blank",
                        rel: "noopener noreferrer",
                        className:
                          "text-textMuted hover:text-accent transition-colors text-xl magnetic",
                        children: z.jsx(o.icon, {}),
                      },
                      o.label
                    )
                  ),
                }),
              ],
            }),
          }),
      ],
    }),
  });
}
/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */ const mh = "160",
  Ta = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 },
  Aa = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 },
  SR = 0,
  r_ = 1,
  MR = 2,
  YB = 3,
  wR = 0,
  Ug = 1,
  sf = 2,
  Ir = 3,
  js = 0,
  Ti = 1,
  rs = 2,
  qB = 2,
  zs = 0,
  Va = 1,
  Km = 2,
  s_ = 3,
  o_ = 4,
  ER = 5,
  wo = 100,
  TR = 101,
  AR = 102,
  a_ = 103,
  l_ = 104,
  bR = 200,
  CR = 201,
  PR = 202,
  RR = 203,
  Qm = 204,
  $m = 205,
  LR = 206,
  IR = 207,
  NR = 208,
  DR = 209,
  OR = 210,
  UR = 211,
  kR = 212,
  FR = 213,
  zR = 214,
  BR = 0,
  VR = 1,
  HR = 2,
  Lf = 3,
  GR = 4,
  WR = 5,
  jR = 6,
  XR = 7,
  gh = 0,
  YR = 1,
  qR = 2,
  us = 0,
  ZR = 1,
  KR = 2,
  QR = 3,
  _S = 4,
  $R = 5,
  JR = 6,
  u_ = "attached",
  eL = "detached",
  kg = 300,
  Xs = 301,
  Go = 302,
  If = 303,
  Nf = 304,
  ju = 306,
  Df = 1e3,
  fi = 1001,
  Of = 1002,
  Sn = 1003,
  Jm = 1004,
  ZB = 1004,
  of = 1005,
  KB = 1005,
  wn = 1006,
  SS = 1007,
  QB = 1007,
  Wo = 1008,
  $B = 1008,
  cs = 1009,
  tL = 1010,
  nL = 1011,
  Fg = 1012,
  MS = 1013,
  Ds = 1014,
  Ur = 1015,
  Ou = 1016,
  wS = 1017,
  ES = 1018,
  Oo = 1020,
  iL = 1021,
  wi = 1023,
  rL = 1024,
  sL = 1025,
  Uo = 1026,
  Qa = 1027,
  oL = 1028,
  TS = 1029,
  aL = 1030,
  AS = 1031,
  bS = 1033,
  am = 33776,
  lm = 33777,
  um = 33778,
  cm = 33779,
  c_ = 35840,
  f_ = 35841,
  h_ = 35842,
  d_ = 35843,
  CS = 36196,
  p_ = 37492,
  m_ = 37496,
  g_ = 37808,
  v_ = 37809,
  y_ = 37810,
  x_ = 37811,
  __ = 37812,
  S_ = 37813,
  M_ = 37814,
  w_ = 37815,
  E_ = 37816,
  T_ = 37817,
  A_ = 37818,
  b_ = 37819,
  C_ = 37820,
  P_ = 37821,
  fm = 36492,
  R_ = 36494,
  L_ = 36495,
  lL = 36283,
  I_ = 36284,
  N_ = 36285,
  D_ = 36286,
  uL = 2200,
  cL = 2201,
  fL = 2202,
  Uf = 2300,
  kf = 2301,
  hm = 2302,
  Da = 2400,
  Oa = 2401,
  Ff = 2402,
  zg = 2500,
  PS = 2501,
  JB = 0,
  e6 = 1,
  t6 = 2,
  RS = 3e3,
  ko = 3001,
  hL = 3200,
  dL = 3201,
  Ko = 0,
  pL = 1,
  Qi = "",
  Dn = "srgb",
  hs = "srgb-linear",
  Bg = "display-p3",
  vh = "display-p3-linear",
  zf = "linear",
  jt = "srgb",
  Bf = "rec709",
  Vf = "p3",
  n6 = 0,
  ba = 7680,
  i6 = 7681,
  r6 = 7682,
  s6 = 7683,
  o6 = 34055,
  a6 = 34056,
  l6 = 5386,
  u6 = 512,
  c6 = 513,
  f6 = 514,
  h6 = 515,
  d6 = 516,
  p6 = 517,
  m6 = 518,
  O_ = 519,
  mL = 512,
  gL = 513,
  vL = 514,
  LS = 515,
  yL = 516,
  xL = 517,
  _L = 518,
  SL = 519,
  Hf = 35044,
  g6 = 35048,
  v6 = 35040,
  y6 = 35045,
  x6 = 35049,
  _6 = 35041,
  S6 = 35046,
  M6 = 35050,
  w6 = 35042,
  E6 = "100",
  U_ = "300 es",
  eg = 1035,
  kr = 2e3,
  Uu = 2001;
let Zs = class {
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const i = this._listeners;
    i[e] === void 0 && (i[e] = []), i[e].indexOf(t) === -1 && i[e].push(t);
  }
  hasEventListener(e, t) {
    if (this._listeners === void 0) return !1;
    const i = this._listeners;
    return i[e] !== void 0 && i[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    if (this._listeners === void 0) return;
    const r = this._listeners[e];
    if (r !== void 0) {
      const s = r.indexOf(t);
      s !== -1 && r.splice(s, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return;
    const i = this._listeners[e.type];
    if (i !== void 0) {
      e.target = this;
      const r = i.slice(0);
      for (let s = 0, o = r.length; s < o; s++) r[s].call(this, e);
      e.target = null;
    }
  }
};
const oi = [
  "00",
  "01",
  "02",
  "03",
  "04",
  "05",
  "06",
  "07",
  "08",
  "09",
  "0a",
  "0b",
  "0c",
  "0d",
  "0e",
  "0f",
  "10",
  "11",
  "12",
  "13",
  "14",
  "15",
  "16",
  "17",
  "18",
  "19",
  "1a",
  "1b",
  "1c",
  "1d",
  "1e",
  "1f",
  "20",
  "21",
  "22",
  "23",
  "24",
  "25",
  "26",
  "27",
  "28",
  "29",
  "2a",
  "2b",
  "2c",
  "2d",
  "2e",
  "2f",
  "30",
  "31",
  "32",
  "33",
  "34",
  "35",
  "36",
  "37",
  "38",
  "39",
  "3a",
  "3b",
  "3c",
  "3d",
  "3e",
  "3f",
  "40",
  "41",
  "42",
  "43",
  "44",
  "45",
  "46",
  "47",
  "48",
  "49",
  "4a",
  "4b",
  "4c",
  "4d",
  "4e",
  "4f",
  "50",
  "51",
  "52",
  "53",
  "54",
  "55",
  "56",
  "57",
  "58",
  "59",
  "5a",
  "5b",
  "5c",
  "5d",
  "5e",
  "5f",
  "60",
  "61",
  "62",
  "63",
  "64",
  "65",
  "66",
  "67",
  "68",
  "69",
  "6a",
  "6b",
  "6c",
  "6d",
  "6e",
  "6f",
  "70",
  "71",
  "72",
  "73",
  "74",
  "75",
  "76",
  "77",
  "78",
  "79",
  "7a",
  "7b",
  "7c",
  "7d",
  "7e",
  "7f",
  "80",
  "81",
  "82",
  "83",
  "84",
  "85",
  "86",
  "87",
  "88",
  "89",
  "8a",
  "8b",
  "8c",
  "8d",
  "8e",
  "8f",
  "90",
  "91",
  "92",
  "93",
  "94",
  "95",
  "96",
  "97",
  "98",
  "99",
  "9a",
  "9b",
  "9c",
  "9d",
  "9e",
  "9f",
  "a0",
  "a1",
  "a2",
  "a3",
  "a4",
  "a5",
  "a6",
  "a7",
  "a8",
  "a9",
  "aa",
  "ab",
  "ac",
  "ad",
  "ae",
  "af",
  "b0",
  "b1",
  "b2",
  "b3",
  "b4",
  "b5",
  "b6",
  "b7",
  "b8",
  "b9",
  "ba",
  "bb",
  "bc",
  "bd",
  "be",
  "bf",
  "c0",
  "c1",
  "c2",
  "c3",
  "c4",
  "c5",
  "c6",
  "c7",
  "c8",
  "c9",
  "ca",
  "cb",
  "cc",
  "cd",
  "ce",
  "cf",
  "d0",
  "d1",
  "d2",
  "d3",
  "d4",
  "d5",
  "d6",
  "d7",
  "d8",
  "d9",
  "da",
  "db",
  "dc",
  "dd",
  "de",
  "df",
  "e0",
  "e1",
  "e2",
  "e3",
  "e4",
  "e5",
  "e6",
  "e7",
  "e8",
  "e9",
  "ea",
  "eb",
  "ec",
  "ed",
  "ee",
  "ef",
  "f0",
  "f1",
  "f2",
  "f3",
  "f4",
  "f5",
  "f6",
  "f7",
  "f8",
  "f9",
  "fa",
  "fb",
  "fc",
  "fd",
  "fe",
  "ff",
];
let E2 = 1234567;
const Ha = Math.PI / 180,
  ku = 180 / Math.PI;
function er() {
  const n = (Math.random() * 4294967295) | 0,
    e = (Math.random() * 4294967295) | 0,
    t = (Math.random() * 4294967295) | 0,
    i = (Math.random() * 4294967295) | 0;
  return (
    oi[n & 255] +
    oi[(n >> 8) & 255] +
    oi[(n >> 16) & 255] +
    oi[(n >> 24) & 255] +
    "-" +
    oi[e & 255] +
    oi[(e >> 8) & 255] +
    "-" +
    oi[((e >> 16) & 15) | 64] +
    oi[(e >> 24) & 255] +
    "-" +
    oi[(t & 63) | 128] +
    oi[(t >> 8) & 255] +
    "-" +
    oi[(t >> 16) & 255] +
    oi[(t >> 24) & 255] +
    oi[i & 255] +
    oi[(i >> 8) & 255] +
    oi[(i >> 16) & 255] +
    oi[(i >> 24) & 255]
  ).toLowerCase();
}
function vn(n, e, t) {
  return Math.max(e, Math.min(t, n));
}
function IS(n, e) {
  return ((n % e) + e) % e;
}
function T6(n, e, t, i, r) {
  return i + ((n - e) * (r - i)) / (t - e);
}
function A6(n, e, t) {
  return n !== e ? (t - n) / (e - n) : 0;
}
function af(n, e, t) {
  return (1 - t) * n + t * e;
}
function b6(n, e, t, i) {
  return af(n, e, 1 - Math.exp(-t * i));
}
function C6(n, e = 1) {
  return e - Math.abs(IS(n, e * 2) - e);
}
function P6(n, e, t) {
  return n <= e
    ? 0
    : n >= t
    ? 1
    : ((n = (n - e) / (t - e)), n * n * (3 - 2 * n));
}
function R6(n, e, t) {
  return n <= e
    ? 0
    : n >= t
    ? 1
    : ((n = (n - e) / (t - e)), n * n * n * (n * (n * 6 - 15) + 10));
}
function L6(n, e) {
  return n + Math.floor(Math.random() * (e - n + 1));
}
function I6(n, e) {
  return n + Math.random() * (e - n);
}
function N6(n) {
  return n * (0.5 - Math.random());
}
function D6(n) {
  n !== void 0 && (E2 = n);
  let e = (E2 += 1831565813);
  return (
    (e = Math.imul(e ^ (e >>> 15), e | 1)),
    (e ^= e + Math.imul(e ^ (e >>> 7), e | 61)),
    ((e ^ (e >>> 14)) >>> 0) / 4294967296
  );
}
function O6(n) {
  return n * Ha;
}
function U6(n) {
  return n * ku;
}
function k_(n) {
  return (n & (n - 1)) === 0 && n !== 0;
}
function k6(n) {
  return Math.pow(2, Math.ceil(Math.log(n) / Math.LN2));
}
function tg(n) {
  return Math.pow(2, Math.floor(Math.log(n) / Math.LN2));
}
function F6(n, e, t, i, r) {
  const s = Math.cos,
    o = Math.sin,
    a = s(t / 2),
    u = o(t / 2),
    f = s((e + i) / 2),
    h = o((e + i) / 2),
    d = s((e - i) / 2),
    p = o((e - i) / 2),
    m = s((i - e) / 2),
    y = o((i - e) / 2);
  switch (r) {
    case "XYX":
      n.set(a * h, u * d, u * p, a * f);
      break;
    case "YZY":
      n.set(u * p, a * h, u * d, a * f);
      break;
    case "ZXZ":
      n.set(u * d, u * p, a * h, a * f);
      break;
    case "XZX":
      n.set(a * h, u * y, u * m, a * f);
      break;
    case "YXY":
      n.set(u * m, a * h, u * y, a * f);
      break;
    case "ZYZ":
      n.set(u * y, u * m, a * h, a * f);
      break;
    default:
      console.warn(
        "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
          r
      );
  }
}
function Ui(n, e) {
  switch (e.constructor) {
    case Float32Array:
      return n;
    case Uint32Array:
      return n / 4294967295;
    case Uint16Array:
      return n / 65535;
    case Uint8Array:
      return n / 255;
    case Int32Array:
      return Math.max(n / 2147483647, -1);
    case Int16Array:
      return Math.max(n / 32767, -1);
    case Int8Array:
      return Math.max(n / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function Mt(n, e) {
  switch (e.constructor) {
    case Float32Array:
      return n;
    case Uint32Array:
      return Math.round(n * 4294967295);
    case Uint16Array:
      return Math.round(n * 65535);
    case Uint8Array:
      return Math.round(n * 255);
    case Int32Array:
      return Math.round(n * 2147483647);
    case Int16Array:
      return Math.round(n * 32767);
    case Int8Array:
      return Math.round(n * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const ML = {
  DEG2RAD: Ha,
  RAD2DEG: ku,
  generateUUID: er,
  clamp: vn,
  euclideanModulo: IS,
  mapLinear: T6,
  inverseLerp: A6,
  lerp: af,
  damp: b6,
  pingpong: C6,
  smoothstep: P6,
  smootherstep: R6,
  randInt: L6,
  randFloat: I6,
  randFloatSpread: N6,
  seededRandom: D6,
  degToRad: O6,
  radToDeg: U6,
  isPowerOfTwo: k_,
  ceilPowerOfTwo: k6,
  floorPowerOfTwo: tg,
  setQuaternionFromProperEuler: F6,
  normalize: Mt,
  denormalize: Ui,
};
class de {
  constructor(e = 0, t = 0) {
    (de.prototype.isVector2 = !0), (this.x = e), (this.y = t);
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, t) {
    return (this.x = e), (this.y = t), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), this;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), this;
  }
  addVectors(e, t) {
    return (this.x = e.x + t.x), (this.y = e.y + t.y), this;
  }
  addScaledVector(e, t) {
    return (this.x += e.x * t), (this.y += e.y * t), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), this;
  }
  subVectors(e, t) {
    return (this.x = e.x - t.x), (this.y = e.y - t.y), this;
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), this;
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const t = this.x,
      i = this.y,
      r = e.elements;
    return (
      (this.x = r[0] * t + r[3] * i + r[6]),
      (this.y = r[1] * t + r[4] * i + r[7]),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)), (this.y = Math.min(this.y, e.y)), this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)), (this.y = Math.max(this.y, e.y)), this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      this
    );
  }
  clampLength(e, t) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(
      Math.max(e, Math.min(t, i))
    );
  }
  floor() {
    return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
  }
  ceil() {
    return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
  }
  round() {
    return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
  }
  roundToZero() {
    return (this.x = Math.trunc(this.x)), (this.y = Math.trunc(this.y)), this;
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const i = this.dot(e) / t;
    return Math.acos(vn(i, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      i = this.y - e.y;
    return t * t + i * i;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), this;
  }
  lerpVectors(e, t, i) {
    return (
      (this.x = e.x + (t.x - e.x) * i), (this.y = e.y + (t.y - e.y) * i), this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, t = 0) {
    return (this.x = e[t]), (this.y = e[t + 1]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.x), (e[t + 1] = this.y), e;
  }
  fromBufferAttribute(e, t) {
    return (this.x = e.getX(t)), (this.y = e.getY(t)), this;
  }
  rotateAround(e, t) {
    const i = Math.cos(t),
      r = Math.sin(t),
      s = this.x - e.x,
      o = this.y - e.y;
    return (this.x = s * i - o * r + e.x), (this.y = s * r + o * i + e.y), this;
  }
  random() {
    return (this.x = Math.random()), (this.y = Math.random()), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class Et {
  constructor(e, t, i, r, s, o, a, u, f) {
    (Et.prototype.isMatrix3 = !0),
      (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
      e !== void 0 && this.set(e, t, i, r, s, o, a, u, f);
  }
  set(e, t, i, r, s, o, a, u, f) {
    const h = this.elements;
    return (
      (h[0] = e),
      (h[1] = r),
      (h[2] = a),
      (h[3] = t),
      (h[4] = s),
      (h[5] = u),
      (h[6] = i),
      (h[7] = o),
      (h[8] = f),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
  }
  copy(e) {
    const t = this.elements,
      i = e.elements;
    return (
      (t[0] = i[0]),
      (t[1] = i[1]),
      (t[2] = i[2]),
      (t[3] = i[3]),
      (t[4] = i[4]),
      (t[5] = i[5]),
      (t[6] = i[6]),
      (t[7] = i[7]),
      (t[8] = i[8]),
      this
    );
  }
  extractBasis(e, t, i) {
    return (
      e.setFromMatrix3Column(this, 0),
      t.setFromMatrix3Column(this, 1),
      i.setFromMatrix3Column(this, 2),
      this
    );
  }
  setFromMatrix4(e) {
    const t = e.elements;
    return (
      this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const i = e.elements,
      r = t.elements,
      s = this.elements,
      o = i[0],
      a = i[3],
      u = i[6],
      f = i[1],
      h = i[4],
      d = i[7],
      p = i[2],
      m = i[5],
      y = i[8],
      w = r[0],
      S = r[3],
      v = r[6],
      M = r[1],
      _ = r[4],
      T = r[7],
      P = r[2],
      b = r[5],
      L = r[8];
    return (
      (s[0] = o * w + a * M + u * P),
      (s[3] = o * S + a * _ + u * b),
      (s[6] = o * v + a * T + u * L),
      (s[1] = f * w + h * M + d * P),
      (s[4] = f * S + h * _ + d * b),
      (s[7] = f * v + h * T + d * L),
      (s[2] = p * w + m * M + y * P),
      (s[5] = p * S + m * _ + y * b),
      (s[8] = p * v + m * T + y * L),
      this
    );
  }
  multiplyScalar(e) {
    const t = this.elements;
    return (
      (t[0] *= e),
      (t[3] *= e),
      (t[6] *= e),
      (t[1] *= e),
      (t[4] *= e),
      (t[7] *= e),
      (t[2] *= e),
      (t[5] *= e),
      (t[8] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      i = e[1],
      r = e[2],
      s = e[3],
      o = e[4],
      a = e[5],
      u = e[6],
      f = e[7],
      h = e[8];
    return (
      t * o * h - t * a * f - i * s * h + i * a * u + r * s * f - r * o * u
    );
  }
  invert() {
    const e = this.elements,
      t = e[0],
      i = e[1],
      r = e[2],
      s = e[3],
      o = e[4],
      a = e[5],
      u = e[6],
      f = e[7],
      h = e[8],
      d = h * o - a * f,
      p = a * u - h * s,
      m = f * s - o * u,
      y = t * d + i * p + r * m;
    if (y === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const w = 1 / y;
    return (
      (e[0] = d * w),
      (e[1] = (r * f - h * i) * w),
      (e[2] = (a * i - r * o) * w),
      (e[3] = p * w),
      (e[4] = (h * t - r * u) * w),
      (e[5] = (r * s - a * t) * w),
      (e[6] = m * w),
      (e[7] = (i * u - f * t) * w),
      (e[8] = (o * t - i * s) * w),
      this
    );
  }
  transpose() {
    let e;
    const t = this.elements;
    return (
      (e = t[1]),
      (t[1] = t[3]),
      (t[3] = e),
      (e = t[2]),
      (t[2] = t[6]),
      (t[6] = e),
      (e = t[5]),
      (t[5] = t[7]),
      (t[7] = e),
      this
    );
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const t = this.elements;
    return (
      (e[0] = t[0]),
      (e[1] = t[3]),
      (e[2] = t[6]),
      (e[3] = t[1]),
      (e[4] = t[4]),
      (e[5] = t[7]),
      (e[6] = t[2]),
      (e[7] = t[5]),
      (e[8] = t[8]),
      this
    );
  }
  setUvTransform(e, t, i, r, s, o, a) {
    const u = Math.cos(s),
      f = Math.sin(s);
    return (
      this.set(
        i * u,
        i * f,
        -i * (u * o + f * a) + o + e,
        -r * f,
        r * u,
        -r * (-f * o + u * a) + a + t,
        0,
        0,
        1
      ),
      this
    );
  }
  scale(e, t) {
    return this.premultiply(sy.makeScale(e, t)), this;
  }
  rotate(e) {
    return this.premultiply(sy.makeRotation(-e)), this;
  }
  translate(e, t) {
    return this.premultiply(sy.makeTranslation(e, t)), this;
  }
  makeTranslation(e, t) {
    return (
      e.isVector2
        ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1)
        : this.set(1, 0, e, 0, 1, t, 0, 0, 1),
      this
    );
  }
  makeRotation(e) {
    const t = Math.cos(e),
      i = Math.sin(e);
    return this.set(t, -i, 0, i, t, 0, 0, 0, 1), this;
  }
  makeScale(e, t) {
    return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this;
  }
  equals(e) {
    const t = this.elements,
      i = e.elements;
    for (let r = 0; r < 9; r++) if (t[r] !== i[r]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let i = 0; i < 9; i++) this.elements[i] = e[i + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const i = this.elements;
    return (
      (e[t] = i[0]),
      (e[t + 1] = i[1]),
      (e[t + 2] = i[2]),
      (e[t + 3] = i[3]),
      (e[t + 4] = i[4]),
      (e[t + 5] = i[5]),
      (e[t + 6] = i[6]),
      (e[t + 7] = i[7]),
      (e[t + 8] = i[8]),
      e
    );
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const sy = new Et();
function wL(n) {
  for (let e = n.length - 1; e >= 0; --e) if (n[e] >= 65535) return !0;
  return !1;
}
const z6 = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array,
};
function du(n, e) {
  return new z6[n](e);
}
function Gf(n) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", n);
}
function EL() {
  const n = Gf("canvas");
  return (n.style.display = "block"), n;
}
const T2 = {};
function lf(n) {
  n in T2 || ((T2[n] = !0), console.warn(n));
}
const A2 = new Et().set(
    0.8224621,
    0.177538,
    0,
    0.0331941,
    0.9668058,
    0,
    0.0170827,
    0.0723974,
    0.9105199
  ),
  b2 = new Et().set(
    1.2249401,
    -0.2249404,
    0,
    -0.0420569,
    1.0420571,
    0,
    -0.0196376,
    -0.0786361,
    1.0982735
  ),
  Qd = {
    [hs]: {
      transfer: zf,
      primaries: Bf,
      toReference: (n) => n,
      fromReference: (n) => n,
    },
    [Dn]: {
      transfer: jt,
      primaries: Bf,
      toReference: (n) => n.convertSRGBToLinear(),
      fromReference: (n) => n.convertLinearToSRGB(),
    },
    [vh]: {
      transfer: zf,
      primaries: Vf,
      toReference: (n) => n.applyMatrix3(b2),
      fromReference: (n) => n.applyMatrix3(A2),
    },
    [Bg]: {
      transfer: jt,
      primaries: Vf,
      toReference: (n) => n.convertSRGBToLinear().applyMatrix3(b2),
      fromReference: (n) => n.applyMatrix3(A2).convertLinearToSRGB(),
    },
  },
  B6 = new Set([hs, vh]),
  zt = {
    enabled: !0,
    _workingColorSpace: hs,
    get workingColorSpace() {
      return this._workingColorSpace;
    },
    set workingColorSpace(n) {
      if (!B6.has(n))
        throw new Error(`Unsupported working color space, "${n}".`);
      this._workingColorSpace = n;
    },
    convert: function (n, e, t) {
      if (this.enabled === !1 || e === t || !e || !t) return n;
      const i = Qd[e].toReference,
        r = Qd[t].fromReference;
      return r(i(n));
    },
    fromWorkingColorSpace: function (n, e) {
      return this.convert(n, this._workingColorSpace, e);
    },
    toWorkingColorSpace: function (n, e) {
      return this.convert(n, e, this._workingColorSpace);
    },
    getPrimaries: function (n) {
      return Qd[n].primaries;
    },
    getTransfer: function (n) {
      return n === Qi ? zf : Qd[n].transfer;
    },
  };
function Tu(n) {
  return n < 0.04045
    ? n * 0.0773993808
    : Math.pow(n * 0.9478672986 + 0.0521327014, 2.4);
}
function oy(n) {
  return n < 0.0031308 ? n * 12.92 : 1.055 * Math.pow(n, 0.41666) - 0.055;
}
let Al;
class NS {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src;
    let t;
    if (e instanceof HTMLCanvasElement) t = e;
    else {
      Al === void 0 && (Al = Gf("canvas")),
        (Al.width = e.width),
        (Al.height = e.height);
      const i = Al.getContext("2d");
      e instanceof ImageData
        ? i.putImageData(e, 0, 0)
        : i.drawImage(e, 0, 0, e.width, e.height),
        (t = Al);
    }
    return t.width > 2048 || t.height > 2048
      ? (console.warn(
          "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
          e
        ),
        t.toDataURL("image/jpeg", 0.6))
      : t.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if (
      (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement) ||
      (typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement) ||
      (typeof ImageBitmap < "u" && e instanceof ImageBitmap)
    ) {
      const t = Gf("canvas");
      (t.width = e.width), (t.height = e.height);
      const i = t.getContext("2d");
      i.drawImage(e, 0, 0, e.width, e.height);
      const r = i.getImageData(0, 0, e.width, e.height),
        s = r.data;
      for (let o = 0; o < s.length; o++) s[o] = Tu(s[o] / 255) * 255;
      return i.putImageData(r, 0, 0), t;
    } else if (e.data) {
      const t = e.data.slice(0);
      for (let i = 0; i < t.length; i++)
        t instanceof Uint8Array || t instanceof Uint8ClampedArray
          ? (t[i] = Math.floor(Tu(t[i] / 255) * 255))
          : (t[i] = Tu(t[i]));
      return { data: t, width: e.width, height: e.height };
    } else
      return (
        console.warn(
          "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."
        ),
        e
      );
  }
}
let V6 = 0;
class Ua {
  constructor(e = null) {
    (this.isSource = !0),
      Object.defineProperty(this, "id", { value: V6++ }),
      (this.uuid = er()),
      (this.data = e),
      (this.version = 0);
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid];
    const i = { uuid: this.uuid, url: "" },
      r = this.data;
    if (r !== null) {
      let s;
      if (Array.isArray(r)) {
        s = [];
        for (let o = 0, a = r.length; o < a; o++)
          r[o].isDataTexture ? s.push(ay(r[o].image)) : s.push(ay(r[o]));
      } else s = ay(r);
      i.url = s;
    }
    return t || (e.images[this.uuid] = i), i;
  }
}
function ay(n) {
  return (typeof HTMLImageElement < "u" && n instanceof HTMLImageElement) ||
    (typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement) ||
    (typeof ImageBitmap < "u" && n instanceof ImageBitmap)
    ? NS.getDataURL(n)
    : n.data
    ? {
        data: Array.from(n.data),
        width: n.width,
        height: n.height,
        type: n.data.constructor.name,
      }
    : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let H6 = 0;
class An extends Zs {
  constructor(
    e = An.DEFAULT_IMAGE,
    t = An.DEFAULT_MAPPING,
    i = fi,
    r = fi,
    s = wn,
    o = Wo,
    a = wi,
    u = cs,
    f = An.DEFAULT_ANISOTROPY,
    h = Qi
  ) {
    super(),
      (this.isTexture = !0),
      Object.defineProperty(this, "id", { value: H6++ }),
      (this.uuid = er()),
      (this.name = ""),
      (this.source = new Ua(e)),
      (this.mipmaps = []),
      (this.mapping = t),
      (this.channel = 0),
      (this.wrapS = i),
      (this.wrapT = r),
      (this.magFilter = s),
      (this.minFilter = o),
      (this.anisotropy = f),
      (this.format = a),
      (this.internalFormat = null),
      (this.type = u),
      (this.offset = new de(0, 0)),
      (this.repeat = new de(1, 1)),
      (this.center = new de(0, 0)),
      (this.rotation = 0),
      (this.matrixAutoUpdate = !0),
      (this.matrix = new Et()),
      (this.generateMipmaps = !0),
      (this.premultiplyAlpha = !1),
      (this.flipY = !0),
      (this.unpackAlignment = 4),
      typeof h == "string"
        ? (this.colorSpace = h)
        : (lf(
            "THREE.Texture: Property .encoding has been replaced by .colorSpace."
          ),
          (this.colorSpace = h === ko ? Dn : Qi)),
      (this.userData = {}),
      (this.version = 0),
      (this.onUpdate = null),
      (this.isRenderTargetTexture = !1),
      (this.needsPMREMUpdate = !1);
  }
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(
      this.offset.x,
      this.offset.y,
      this.repeat.x,
      this.repeat.y,
      this.rotation,
      this.center.x,
      this.center.y
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.source = e.source),
      (this.mipmaps = e.mipmaps.slice(0)),
      (this.mapping = e.mapping),
      (this.channel = e.channel),
      (this.wrapS = e.wrapS),
      (this.wrapT = e.wrapT),
      (this.magFilter = e.magFilter),
      (this.minFilter = e.minFilter),
      (this.anisotropy = e.anisotropy),
      (this.format = e.format),
      (this.internalFormat = e.internalFormat),
      (this.type = e.type),
      this.offset.copy(e.offset),
      this.repeat.copy(e.repeat),
      this.center.copy(e.center),
      (this.rotation = e.rotation),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this.matrix.copy(e.matrix),
      (this.generateMipmaps = e.generateMipmaps),
      (this.premultiplyAlpha = e.premultiplyAlpha),
      (this.flipY = e.flipY),
      (this.unpackAlignment = e.unpackAlignment),
      (this.colorSpace = e.colorSpace),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      (this.needsUpdate = !0),
      this
    );
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
    const i = {
      metadata: { version: 4.6, type: "Texture", generator: "Texture.toJSON" },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment,
    };
    return (
      Object.keys(this.userData).length > 0 && (i.userData = this.userData),
      t || (e.textures[this.uuid] = i),
      i
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== kg) return e;
    if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
      switch (this.wrapS) {
        case Df:
          e.x = e.x - Math.floor(e.x);
          break;
        case fi:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case Of:
          Math.abs(Math.floor(e.x) % 2) === 1
            ? (e.x = Math.ceil(e.x) - e.x)
            : (e.x = e.x - Math.floor(e.x));
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case Df:
          e.y = e.y - Math.floor(e.y);
          break;
        case fi:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case Of:
          Math.abs(Math.floor(e.y) % 2) === 1
            ? (e.y = Math.ceil(e.y) - e.y)
            : (e.y = e.y - Math.floor(e.y));
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, (this.source.needsUpdate = !0));
  }
  get encoding() {
    return (
      lf("THREE.Texture: Property .encoding has been replaced by .colorSpace."),
      this.colorSpace === Dn ? ko : RS
    );
  }
  set encoding(e) {
    lf("THREE.Texture: Property .encoding has been replaced by .colorSpace."),
      (this.colorSpace = e === ko ? Dn : Qi);
  }
}
An.DEFAULT_IMAGE = null;
An.DEFAULT_MAPPING = kg;
An.DEFAULT_ANISOTROPY = 1;
class Bt {
  constructor(e = 0, t = 0, i = 0, r = 1) {
    (Bt.prototype.isVector4 = !0),
      (this.x = e),
      (this.y = t),
      (this.z = i),
      (this.w = r);
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, t, i, r) {
    return (this.x = e), (this.y = t), (this.z = i), (this.w = r), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), (this.w = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setW(e) {
    return (this.w = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      case 3:
        this.w = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return (
      (this.x = e.x),
      (this.y = e.y),
      (this.z = e.z),
      (this.w = e.w !== void 0 ? e.w : 1),
      this
    );
  }
  add(e) {
    return (
      (this.x += e.x), (this.y += e.y), (this.z += e.z), (this.w += e.w), this
    );
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), (this.w += e), this;
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x),
      (this.y = e.y + t.y),
      (this.z = e.z + t.z),
      (this.w = e.w + t.w),
      this
    );
  }
  addScaledVector(e, t) {
    return (
      (this.x += e.x * t),
      (this.y += e.y * t),
      (this.z += e.z * t),
      (this.w += e.w * t),
      this
    );
  }
  sub(e) {
    return (
      (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), (this.w -= e.w), this
    );
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this;
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x),
      (this.y = e.y - t.y),
      (this.z = e.z - t.z),
      (this.w = e.w - t.w),
      this
    );
  }
  multiply(e) {
    return (
      (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), (this.w *= e.w), this
    );
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this;
  }
  applyMatrix4(e) {
    const t = this.x,
      i = this.y,
      r = this.z,
      s = this.w,
      o = e.elements;
    return (
      (this.x = o[0] * t + o[4] * i + o[8] * r + o[12] * s),
      (this.y = o[1] * t + o[5] * i + o[9] * r + o[13] * s),
      (this.z = o[2] * t + o[6] * i + o[10] * r + o[14] * s),
      (this.w = o[3] * t + o[7] * i + o[11] * r + o[15] * s),
      this
    );
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const t = Math.sqrt(1 - e.w * e.w);
    return (
      t < 1e-4
        ? ((this.x = 1), (this.y = 0), (this.z = 0))
        : ((this.x = e.x / t), (this.y = e.y / t), (this.z = e.z / t)),
      this
    );
  }
  setAxisAngleFromRotationMatrix(e) {
    let t, i, r, s;
    const u = e.elements,
      f = u[0],
      h = u[4],
      d = u[8],
      p = u[1],
      m = u[5],
      y = u[9],
      w = u[2],
      S = u[6],
      v = u[10];
    if (
      Math.abs(h - p) < 0.01 &&
      Math.abs(d - w) < 0.01 &&
      Math.abs(y - S) < 0.01
    ) {
      if (
        Math.abs(h + p) < 0.1 &&
        Math.abs(d + w) < 0.1 &&
        Math.abs(y + S) < 0.1 &&
        Math.abs(f + m + v - 3) < 0.1
      )
        return this.set(1, 0, 0, 0), this;
      t = Math.PI;
      const _ = (f + 1) / 2,
        T = (m + 1) / 2,
        P = (v + 1) / 2,
        b = (h + p) / 4,
        L = (d + w) / 4,
        N = (y + S) / 4;
      return (
        _ > T && _ > P
          ? _ < 0.01
            ? ((i = 0), (r = 0.707106781), (s = 0.707106781))
            : ((i = Math.sqrt(_)), (r = b / i), (s = L / i))
          : T > P
          ? T < 0.01
            ? ((i = 0.707106781), (r = 0), (s = 0.707106781))
            : ((r = Math.sqrt(T)), (i = b / r), (s = N / r))
          : P < 0.01
          ? ((i = 0.707106781), (r = 0.707106781), (s = 0))
          : ((s = Math.sqrt(P)), (i = L / s), (r = N / s)),
        this.set(i, r, s, t),
        this
      );
    }
    let M = Math.sqrt(
      (S - y) * (S - y) + (d - w) * (d - w) + (p - h) * (p - h)
    );
    return (
      Math.abs(M) < 0.001 && (M = 1),
      (this.x = (S - y) / M),
      (this.y = (d - w) / M),
      (this.z = (p - h) / M),
      (this.w = Math.acos((f + m + v - 1) / 2)),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      (this.w = Math.min(this.w, e.w)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      (this.w = Math.max(this.w, e.w)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      (this.z = Math.max(e.z, Math.min(t.z, this.z))),
      (this.w = Math.max(e.w, Math.min(t.w, this.w))),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      (this.z = Math.max(e, Math.min(t, this.z))),
      (this.w = Math.max(e, Math.min(t, this.w))),
      this
    );
  }
  clampLength(e, t) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(
      Math.max(e, Math.min(t, i))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      (this.w = Math.floor(this.w)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      (this.w = Math.ceil(this.w)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      (this.w = Math.round(this.w)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      (this.w = Math.trunc(this.w)),
      this
    );
  }
  negate() {
    return (
      (this.x = -this.x),
      (this.y = -this.y),
      (this.z = -this.z),
      (this.w = -this.w),
      this
    );
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return (
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  length() {
    return Math.sqrt(
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  manhattanLength() {
    return (
      Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    );
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      (this.w += (e.w - this.w) * t),
      this
    );
  }
  lerpVectors(e, t, i) {
    return (
      (this.x = e.x + (t.x - e.x) * i),
      (this.y = e.y + (t.y - e.y) * i),
      (this.z = e.z + (t.z - e.z) * i),
      (this.w = e.w + (t.w - e.w) * i),
      this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, t = 0) {
    return (
      (this.x = e[t]),
      (this.y = e[t + 1]),
      (this.z = e[t + 2]),
      (this.w = e[t + 3]),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this.x),
      (e[t + 1] = this.y),
      (e[t + 2] = this.z),
      (e[t + 3] = this.w),
      e
    );
  }
  fromBufferAttribute(e, t) {
    return (
      (this.x = e.getX(t)),
      (this.y = e.getY(t)),
      (this.z = e.getZ(t)),
      (this.w = e.getW(t)),
      this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      (this.w = Math.random()),
      this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class TL extends Zs {
  constructor(e = 1, t = 1, i = {}) {
    super(),
      (this.isRenderTarget = !0),
      (this.width = e),
      (this.height = t),
      (this.depth = 1),
      (this.scissor = new Bt(0, 0, e, t)),
      (this.scissorTest = !1),
      (this.viewport = new Bt(0, 0, e, t));
    const r = { width: e, height: t, depth: 1 };
    i.encoding !== void 0 &&
      (lf(
        "THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."
      ),
      (i.colorSpace = i.encoding === ko ? Dn : Qi)),
      (i = Object.assign(
        {
          generateMipmaps: !1,
          internalFormat: null,
          minFilter: wn,
          depthBuffer: !0,
          stencilBuffer: !1,
          depthTexture: null,
          samples: 0,
        },
        i
      )),
      (this.texture = new An(
        r,
        i.mapping,
        i.wrapS,
        i.wrapT,
        i.magFilter,
        i.minFilter,
        i.format,
        i.type,
        i.anisotropy,
        i.colorSpace
      )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.flipY = !1),
      (this.texture.generateMipmaps = i.generateMipmaps),
      (this.texture.internalFormat = i.internalFormat),
      (this.depthBuffer = i.depthBuffer),
      (this.stencilBuffer = i.stencilBuffer),
      (this.depthTexture = i.depthTexture),
      (this.samples = i.samples);
  }
  setSize(e, t, i = 1) {
    (this.width !== e || this.height !== t || this.depth !== i) &&
      ((this.width = e),
      (this.height = t),
      (this.depth = i),
      (this.texture.image.width = e),
      (this.texture.image.height = t),
      (this.texture.image.depth = i),
      this.dispose()),
      this.viewport.set(0, 0, e, t),
      this.scissor.set(0, 0, e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.width = e.width),
      (this.height = e.height),
      (this.depth = e.depth),
      this.scissor.copy(e.scissor),
      (this.scissorTest = e.scissorTest),
      this.viewport.copy(e.viewport),
      (this.texture = e.texture.clone()),
      (this.texture.isRenderTargetTexture = !0);
    const t = Object.assign({}, e.texture.image);
    return (
      (this.texture.source = new Ua(t)),
      (this.depthBuffer = e.depthBuffer),
      (this.stencilBuffer = e.stencilBuffer),
      e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
      (this.samples = e.samples),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class Vr extends TL {
  constructor(e = 1, t = 1, i = {}) {
    super(e, t, i), (this.isWebGLRenderTarget = !0);
  }
}
class Vg extends An {
  constructor(e = null, t = 1, i = 1, r = 1) {
    super(null),
      (this.isDataArrayTexture = !0),
      (this.image = { data: e, width: t, height: i, depth: r }),
      (this.magFilter = Sn),
      (this.minFilter = Sn),
      (this.wrapR = fi),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
class G6 extends Vr {
  constructor(e = 1, t = 1, i = 1, r = {}) {
    super(e, t, r),
      (this.isWebGLArrayRenderTarget = !0),
      (this.depth = i),
      (this.texture = new Vg(null, e, t, i)),
      (this.texture.isRenderTargetTexture = !0);
  }
}
class DS extends An {
  constructor(e = null, t = 1, i = 1, r = 1) {
    super(null),
      (this.isData3DTexture = !0),
      (this.image = { data: e, width: t, height: i, depth: r }),
      (this.magFilter = Sn),
      (this.minFilter = Sn),
      (this.wrapR = fi),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
class W6 extends Vr {
  constructor(e = 1, t = 1, i = 1, r = {}) {
    super(e, t, r),
      (this.isWebGL3DRenderTarget = !0),
      (this.depth = i),
      (this.texture = new DS(null, e, t, i)),
      (this.texture.isRenderTargetTexture = !0);
  }
}
class j6 extends Vr {
  constructor(e = 1, t = 1, i = 1, r = {}) {
    super(e, t, r), (this.isWebGLMultipleRenderTargets = !0);
    const s = this.texture;
    this.texture = [];
    for (let o = 0; o < i; o++)
      (this.texture[o] = s.clone()),
        (this.texture[o].isRenderTargetTexture = !0);
  }
  setSize(e, t, i = 1) {
    if (this.width !== e || this.height !== t || this.depth !== i) {
      (this.width = e), (this.height = t), (this.depth = i);
      for (let r = 0, s = this.texture.length; r < s; r++)
        (this.texture[r].image.width = e),
          (this.texture[r].image.height = t),
          (this.texture[r].image.depth = i);
      this.dispose();
    }
    this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
  }
  copy(e) {
    this.dispose(),
      (this.width = e.width),
      (this.height = e.height),
      (this.depth = e.depth),
      this.scissor.copy(e.scissor),
      (this.scissorTest = e.scissorTest),
      this.viewport.copy(e.viewport),
      (this.depthBuffer = e.depthBuffer),
      (this.stencilBuffer = e.stencilBuffer),
      e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
      (this.texture.length = 0);
    for (let t = 0, i = e.texture.length; t < i; t++)
      (this.texture[t] = e.texture[t].clone()),
        (this.texture[t].isRenderTargetTexture = !0);
    return this;
  }
}
class hi {
  constructor(e = 0, t = 0, i = 0, r = 1) {
    (this.isQuaternion = !0),
      (this._x = e),
      (this._y = t),
      (this._z = i),
      (this._w = r);
  }
  static slerpFlat(e, t, i, r, s, o, a) {
    let u = i[r + 0],
      f = i[r + 1],
      h = i[r + 2],
      d = i[r + 3];
    const p = s[o + 0],
      m = s[o + 1],
      y = s[o + 2],
      w = s[o + 3];
    if (a === 0) {
      (e[t + 0] = u), (e[t + 1] = f), (e[t + 2] = h), (e[t + 3] = d);
      return;
    }
    if (a === 1) {
      (e[t + 0] = p), (e[t + 1] = m), (e[t + 2] = y), (e[t + 3] = w);
      return;
    }
    if (d !== w || u !== p || f !== m || h !== y) {
      let S = 1 - a;
      const v = u * p + f * m + h * y + d * w,
        M = v >= 0 ? 1 : -1,
        _ = 1 - v * v;
      if (_ > Number.EPSILON) {
        const P = Math.sqrt(_),
          b = Math.atan2(P, v * M);
        (S = Math.sin(S * b) / P), (a = Math.sin(a * b) / P);
      }
      const T = a * M;
      if (
        ((u = u * S + p * T),
        (f = f * S + m * T),
        (h = h * S + y * T),
        (d = d * S + w * T),
        S === 1 - a)
      ) {
        const P = 1 / Math.sqrt(u * u + f * f + h * h + d * d);
        (u *= P), (f *= P), (h *= P), (d *= P);
      }
    }
    (e[t] = u), (e[t + 1] = f), (e[t + 2] = h), (e[t + 3] = d);
  }
  static multiplyQuaternionsFlat(e, t, i, r, s, o) {
    const a = i[r],
      u = i[r + 1],
      f = i[r + 2],
      h = i[r + 3],
      d = s[o],
      p = s[o + 1],
      m = s[o + 2],
      y = s[o + 3];
    return (
      (e[t] = a * y + h * d + u * m - f * p),
      (e[t + 1] = u * y + h * p + f * d - a * m),
      (e[t + 2] = f * y + h * m + a * p - u * d),
      (e[t + 3] = h * y - a * d - u * p - f * m),
      e
    );
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    (this._w = e), this._onChangeCallback();
  }
  set(e, t, i, r) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = i),
      (this._w = r),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return (
      (this._x = e.x),
      (this._y = e.y),
      (this._z = e.z),
      (this._w = e.w),
      this._onChangeCallback(),
      this
    );
  }
  setFromEuler(e, t = !0) {
    const i = e._x,
      r = e._y,
      s = e._z,
      o = e._order,
      a = Math.cos,
      u = Math.sin,
      f = a(i / 2),
      h = a(r / 2),
      d = a(s / 2),
      p = u(i / 2),
      m = u(r / 2),
      y = u(s / 2);
    switch (o) {
      case "XYZ":
        (this._x = p * h * d + f * m * y),
          (this._y = f * m * d - p * h * y),
          (this._z = f * h * y + p * m * d),
          (this._w = f * h * d - p * m * y);
        break;
      case "YXZ":
        (this._x = p * h * d + f * m * y),
          (this._y = f * m * d - p * h * y),
          (this._z = f * h * y - p * m * d),
          (this._w = f * h * d + p * m * y);
        break;
      case "ZXY":
        (this._x = p * h * d - f * m * y),
          (this._y = f * m * d + p * h * y),
          (this._z = f * h * y + p * m * d),
          (this._w = f * h * d - p * m * y);
        break;
      case "ZYX":
        (this._x = p * h * d - f * m * y),
          (this._y = f * m * d + p * h * y),
          (this._z = f * h * y - p * m * d),
          (this._w = f * h * d + p * m * y);
        break;
      case "YZX":
        (this._x = p * h * d + f * m * y),
          (this._y = f * m * d + p * h * y),
          (this._z = f * h * y - p * m * d),
          (this._w = f * h * d - p * m * y);
        break;
      case "XZY":
        (this._x = p * h * d - f * m * y),
          (this._y = f * m * d - p * h * y),
          (this._z = f * h * y + p * m * d),
          (this._w = f * h * d + p * m * y);
        break;
      default:
        console.warn(
          "THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o
        );
    }
    return t === !0 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, t) {
    const i = t / 2,
      r = Math.sin(i);
    return (
      (this._x = e.x * r),
      (this._y = e.y * r),
      (this._z = e.z * r),
      (this._w = Math.cos(i)),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e) {
    const t = e.elements,
      i = t[0],
      r = t[4],
      s = t[8],
      o = t[1],
      a = t[5],
      u = t[9],
      f = t[2],
      h = t[6],
      d = t[10],
      p = i + a + d;
    if (p > 0) {
      const m = 0.5 / Math.sqrt(p + 1);
      (this._w = 0.25 / m),
        (this._x = (h - u) * m),
        (this._y = (s - f) * m),
        (this._z = (o - r) * m);
    } else if (i > a && i > d) {
      const m = 2 * Math.sqrt(1 + i - a - d);
      (this._w = (h - u) / m),
        (this._x = 0.25 * m),
        (this._y = (r + o) / m),
        (this._z = (s + f) / m);
    } else if (a > d) {
      const m = 2 * Math.sqrt(1 + a - i - d);
      (this._w = (s - f) / m),
        (this._x = (r + o) / m),
        (this._y = 0.25 * m),
        (this._z = (u + h) / m);
    } else {
      const m = 2 * Math.sqrt(1 + d - i - a);
      (this._w = (o - r) / m),
        (this._x = (s + f) / m),
        (this._y = (u + h) / m),
        (this._z = 0.25 * m);
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, t) {
    let i = e.dot(t) + 1;
    return (
      i < Number.EPSILON
        ? ((i = 0),
          Math.abs(e.x) > Math.abs(e.z)
            ? ((this._x = -e.y), (this._y = e.x), (this._z = 0), (this._w = i))
            : ((this._x = 0), (this._y = -e.z), (this._z = e.y), (this._w = i)))
        : ((this._x = e.y * t.z - e.z * t.y),
          (this._y = e.z * t.x - e.x * t.z),
          (this._z = e.x * t.y - e.y * t.x),
          (this._w = i)),
      this.normalize()
    );
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(vn(this.dot(e), -1, 1)));
  }
  rotateTowards(e, t) {
    const i = this.angleTo(e);
    if (i === 0) return this;
    const r = Math.min(1, t / i);
    return this.slerp(e, r), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return (
      (this._x *= -1),
      (this._y *= -1),
      (this._z *= -1),
      this._onChangeCallback(),
      this
    );
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return (
      this._x * this._x +
      this._y * this._y +
      this._z * this._z +
      this._w * this._w
    );
  }
  length() {
    return Math.sqrt(
      this._x * this._x +
        this._y * this._y +
        this._z * this._z +
        this._w * this._w
    );
  }
  normalize() {
    let e = this.length();
    return (
      e === 0
        ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
        : ((e = 1 / e),
          (this._x = this._x * e),
          (this._y = this._y * e),
          (this._z = this._z * e),
          (this._w = this._w * e)),
      this._onChangeCallback(),
      this
    );
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, t) {
    const i = e._x,
      r = e._y,
      s = e._z,
      o = e._w,
      a = t._x,
      u = t._y,
      f = t._z,
      h = t._w;
    return (
      (this._x = i * h + o * a + r * f - s * u),
      (this._y = r * h + o * u + s * a - i * f),
      (this._z = s * h + o * f + i * u - r * a),
      (this._w = o * h - i * a - r * u - s * f),
      this._onChangeCallback(),
      this
    );
  }
  slerp(e, t) {
    if (t === 0) return this;
    if (t === 1) return this.copy(e);
    const i = this._x,
      r = this._y,
      s = this._z,
      o = this._w;
    let a = o * e._w + i * e._x + r * e._y + s * e._z;
    if (
      (a < 0
        ? ((this._w = -e._w),
          (this._x = -e._x),
          (this._y = -e._y),
          (this._z = -e._z),
          (a = -a))
        : this.copy(e),
      a >= 1)
    )
      return (this._w = o), (this._x = i), (this._y = r), (this._z = s), this;
    const u = 1 - a * a;
    if (u <= Number.EPSILON) {
      const m = 1 - t;
      return (
        (this._w = m * o + t * this._w),
        (this._x = m * i + t * this._x),
        (this._y = m * r + t * this._y),
        (this._z = m * s + t * this._z),
        this.normalize(),
        this
      );
    }
    const f = Math.sqrt(u),
      h = Math.atan2(f, a),
      d = Math.sin((1 - t) * h) / f,
      p = Math.sin(t * h) / f;
    return (
      (this._w = o * d + this._w * p),
      (this._x = i * d + this._x * p),
      (this._y = r * d + this._y * p),
      (this._z = s * d + this._z * p),
      this._onChangeCallback(),
      this
    );
  }
  slerpQuaternions(e, t, i) {
    return this.copy(e).slerp(t, i);
  }
  random() {
    const e = Math.random(),
      t = Math.sqrt(1 - e),
      i = Math.sqrt(e),
      r = 2 * Math.PI * Math.random(),
      s = 2 * Math.PI * Math.random();
    return this.set(
      t * Math.cos(r),
      i * Math.sin(s),
      i * Math.cos(s),
      t * Math.sin(r)
    );
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._w === this._w
    );
  }
  fromArray(e, t = 0) {
    return (
      (this._x = e[t]),
      (this._y = e[t + 1]),
      (this._z = e[t + 2]),
      (this._w = e[t + 3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._w),
      e
    );
  }
  fromBufferAttribute(e, t) {
    return (
      (this._x = e.getX(t)),
      (this._y = e.getY(t)),
      (this._z = e.getZ(t)),
      (this._w = e.getW(t)),
      this._onChangeCallback(),
      this
    );
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class U {
  constructor(e = 0, t = 0, i = 0) {
    (U.prototype.isVector3 = !0), (this.x = e), (this.y = t), (this.z = i);
  }
  set(e, t, i) {
    return (
      i === void 0 && (i = this.z),
      (this.x = e),
      (this.y = t),
      (this.z = i),
      this
    );
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), (this.z += e.z), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), this;
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x), (this.y = e.y + t.y), (this.z = e.z + t.z), this
    );
  }
  addScaledVector(e, t) {
    return (this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), this;
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x), (this.y = e.y - t.y), (this.z = e.z - t.z), this
    );
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), this;
  }
  multiplyVectors(e, t) {
    return (
      (this.x = e.x * t.x), (this.y = e.y * t.y), (this.z = e.z * t.z), this
    );
  }
  applyEuler(e) {
    return this.applyQuaternion(C2.setFromEuler(e));
  }
  applyAxisAngle(e, t) {
    return this.applyQuaternion(C2.setFromAxisAngle(e, t));
  }
  applyMatrix3(e) {
    const t = this.x,
      i = this.y,
      r = this.z,
      s = e.elements;
    return (
      (this.x = s[0] * t + s[3] * i + s[6] * r),
      (this.y = s[1] * t + s[4] * i + s[7] * r),
      (this.z = s[2] * t + s[5] * i + s[8] * r),
      this
    );
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const t = this.x,
      i = this.y,
      r = this.z,
      s = e.elements,
      o = 1 / (s[3] * t + s[7] * i + s[11] * r + s[15]);
    return (
      (this.x = (s[0] * t + s[4] * i + s[8] * r + s[12]) * o),
      (this.y = (s[1] * t + s[5] * i + s[9] * r + s[13]) * o),
      (this.z = (s[2] * t + s[6] * i + s[10] * r + s[14]) * o),
      this
    );
  }
  applyQuaternion(e) {
    const t = this.x,
      i = this.y,
      r = this.z,
      s = e.x,
      o = e.y,
      a = e.z,
      u = e.w,
      f = 2 * (o * r - a * i),
      h = 2 * (a * t - s * r),
      d = 2 * (s * i - o * t);
    return (
      (this.x = t + u * f + o * d - a * h),
      (this.y = i + u * h + a * f - s * d),
      (this.z = r + u * d + s * h - o * f),
      this
    );
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(
      e.projectionMatrix
    );
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(
      e.matrixWorld
    );
  }
  transformDirection(e) {
    const t = this.x,
      i = this.y,
      r = this.z,
      s = e.elements;
    return (
      (this.x = s[0] * t + s[4] * i + s[8] * r),
      (this.y = s[1] * t + s[5] * i + s[9] * r),
      (this.z = s[2] * t + s[6] * i + s[10] * r),
      this.normalize()
    );
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      (this.z = Math.max(e.z, Math.min(t.z, this.z))),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      (this.z = Math.max(e, Math.min(t, this.z))),
      this
    );
  }
  clampLength(e, t) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(
      Math.max(e, Math.min(t, i))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      this
    );
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      this
    );
  }
  lerpVectors(e, t, i) {
    return (
      (this.x = e.x + (t.x - e.x) * i),
      (this.y = e.y + (t.y - e.y) * i),
      (this.z = e.z + (t.z - e.z) * i),
      this
    );
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, t) {
    const i = e.x,
      r = e.y,
      s = e.z,
      o = t.x,
      a = t.y,
      u = t.z;
    return (
      (this.x = r * u - s * a),
      (this.y = s * o - i * u),
      (this.z = i * a - r * o),
      this
    );
  }
  projectOnVector(e) {
    const t = e.lengthSq();
    if (t === 0) return this.set(0, 0, 0);
    const i = e.dot(this) / t;
    return this.copy(e).multiplyScalar(i);
  }
  projectOnPlane(e) {
    return ly.copy(this).projectOnVector(e), this.sub(ly);
  }
  reflect(e) {
    return this.sub(ly.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const i = this.dot(e) / t;
    return Math.acos(vn(i, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      i = this.y - e.y,
      r = this.z - e.z;
    return t * t + i * i + r * r;
  }
  manhattanDistanceTo(e) {
    return (
      Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    );
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, t, i) {
    const r = Math.sin(t) * e;
    return (
      (this.x = r * Math.sin(i)),
      (this.y = Math.cos(t) * e),
      (this.z = r * Math.cos(i)),
      this
    );
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, t, i) {
    return (
      (this.x = e * Math.sin(t)), (this.y = i), (this.z = e * Math.cos(t)), this
    );
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return (this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this;
  }
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(),
      i = this.setFromMatrixColumn(e, 1).length(),
      r = this.setFromMatrixColumn(e, 2).length();
    return (this.x = t), (this.y = i), (this.z = r), this;
  }
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, t * 4);
  }
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, t * 3);
  }
  setFromEuler(e) {
    return (this.x = e._x), (this.y = e._y), (this.z = e._z), this;
  }
  setFromColor(e) {
    return (this.x = e.r), (this.y = e.g), (this.z = e.b), this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, t = 0) {
    return (this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), e;
  }
  fromBufferAttribute(e, t) {
    return (
      (this.x = e.getX(t)), (this.y = e.getY(t)), (this.z = e.getZ(t)), this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      this
    );
  }
  randomDirection() {
    const e = (Math.random() - 0.5) * 2,
      t = Math.random() * Math.PI * 2,
      i = Math.sqrt(1 - e ** 2);
    return (
      (this.x = i * Math.cos(t)), (this.y = i * Math.sin(t)), (this.z = e), this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const ly = new U(),
  C2 = new hi();
class Ai {
  constructor(
    e = new U(1 / 0, 1 / 0, 1 / 0),
    t = new U(-1 / 0, -1 / 0, -1 / 0)
  ) {
    (this.isBox3 = !0), (this.min = e), (this.max = t);
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let t = 0, i = e.length; t < i; t += 3)
      this.expandByPoint(Cr.fromArray(e, t));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let t = 0, i = e.count; t < i; t++)
      this.expandByPoint(Cr.fromBufferAttribute(e, t));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, i = e.length; t < i; t++) this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const i = Cr.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
  }
  setFromObject(e, t = !1) {
    return this.makeEmpty(), this.expandByObject(e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = this.min.z = 1 / 0),
      (this.max.x = this.max.y = this.max.z = -1 / 0),
      this
    );
  }
  isEmpty() {
    return (
      this.max.x < this.min.x ||
      this.max.y < this.min.y ||
      this.max.z < this.min.z
    );
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, t = !1) {
    e.updateWorldMatrix(!1, !1);
    const i = e.geometry;
    if (i !== void 0) {
      const s = i.getAttribute("position");
      if (t === !0 && s !== void 0 && e.isInstancedMesh !== !0)
        for (let o = 0, a = s.count; o < a; o++)
          e.isMesh === !0
            ? e.getVertexPosition(o, Cr)
            : Cr.fromBufferAttribute(s, o),
            Cr.applyMatrix4(e.matrixWorld),
            this.expandByPoint(Cr);
      else
        e.boundingBox !== void 0
          ? (e.boundingBox === null && e.computeBoundingBox(),
            $d.copy(e.boundingBox))
          : (i.boundingBox === null && i.computeBoundingBox(),
            $d.copy(i.boundingBox)),
          $d.applyMatrix4(e.matrixWorld),
          this.union($d);
    }
    const r = e.children;
    for (let s = 0, o = r.length; s < o; s++) this.expandByObject(r[s], t);
    return this;
  }
  containsPoint(e) {
    return !(
      e.x < this.min.x ||
      e.x > this.max.x ||
      e.y < this.min.y ||
      e.y > this.max.y ||
      e.z < this.min.z ||
      e.z > this.max.z
    );
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y &&
      this.min.z <= e.min.z &&
      e.max.z <= this.max.z
    );
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return !(
      e.max.x < this.min.x ||
      e.min.x > this.max.x ||
      e.max.y < this.min.y ||
      e.min.y > this.max.y ||
      e.max.z < this.min.z ||
      e.min.z > this.max.z
    );
  }
  intersectsSphere(e) {
    return (
      this.clampPoint(e.center, Cr),
      Cr.distanceToSquared(e.center) <= e.radius * e.radius
    );
  }
  intersectsPlane(e) {
    let t, i;
    return (
      e.normal.x > 0
        ? ((t = e.normal.x * this.min.x), (i = e.normal.x * this.max.x))
        : ((t = e.normal.x * this.max.x), (i = e.normal.x * this.min.x)),
      e.normal.y > 0
        ? ((t += e.normal.y * this.min.y), (i += e.normal.y * this.max.y))
        : ((t += e.normal.y * this.max.y), (i += e.normal.y * this.min.y)),
      e.normal.z > 0
        ? ((t += e.normal.z * this.min.z), (i += e.normal.z * this.max.z))
        : ((t += e.normal.z * this.max.z), (i += e.normal.z * this.min.z)),
      t <= -e.constant && i >= -e.constant
    );
  }
  intersectsTriangle(e) {
    if (this.isEmpty()) return !1;
    this.getCenter(Ac),
      Jd.subVectors(this.max, Ac),
      bl.subVectors(e.a, Ac),
      Cl.subVectors(e.b, Ac),
      Pl.subVectors(e.c, Ac),
      lo.subVectors(Cl, bl),
      uo.subVectors(Pl, Cl),
      fa.subVectors(bl, Pl);
    let t = [
      0,
      -lo.z,
      lo.y,
      0,
      -uo.z,
      uo.y,
      0,
      -fa.z,
      fa.y,
      lo.z,
      0,
      -lo.x,
      uo.z,
      0,
      -uo.x,
      fa.z,
      0,
      -fa.x,
      -lo.y,
      lo.x,
      0,
      -uo.y,
      uo.x,
      0,
      -fa.y,
      fa.x,
      0,
    ];
    return !uy(t, bl, Cl, Pl, Jd) ||
      ((t = [1, 0, 0, 0, 1, 0, 0, 0, 1]), !uy(t, bl, Cl, Pl, Jd))
      ? !1
      : (ep.crossVectors(lo, uo),
        (t = [ep.x, ep.y, ep.z]),
        uy(t, bl, Cl, Pl, Jd));
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, Cr).distanceTo(e);
  }
  getBoundingSphere(e) {
    return (
      this.isEmpty()
        ? e.makeEmpty()
        : (this.getCenter(e.center),
          (e.radius = this.getSize(Cr).length() * 0.5)),
      e
    );
  }
  intersect(e) {
    return (
      this.min.max(e.min),
      this.max.min(e.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty()
      ? this
      : (Ss[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        Ss[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        Ss[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        Ss[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        Ss[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        Ss[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        Ss[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        Ss[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints(Ss),
        this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const Ss = [
    new U(),
    new U(),
    new U(),
    new U(),
    new U(),
    new U(),
    new U(),
    new U(),
  ],
  Cr = new U(),
  $d = new Ai(),
  bl = new U(),
  Cl = new U(),
  Pl = new U(),
  lo = new U(),
  uo = new U(),
  fa = new U(),
  Ac = new U(),
  Jd = new U(),
  ep = new U(),
  ha = new U();
function uy(n, e, t, i, r) {
  for (let s = 0, o = n.length - 3; s <= o; s += 3) {
    ha.fromArray(n, s);
    const a =
        r.x * Math.abs(ha.x) + r.y * Math.abs(ha.y) + r.z * Math.abs(ha.z),
      u = e.dot(ha),
      f = t.dot(ha),
      h = i.dot(ha);
    if (Math.max(-Math.max(u, f, h), Math.min(u, f, h)) > a) return !1;
  }
  return !0;
}
const X6 = new Ai(),
  bc = new U(),
  cy = new U();
let di = class {
  constructor(e = new U(), t = -1) {
    (this.isSphere = !0), (this.center = e), (this.radius = t);
  }
  set(e, t) {
    return this.center.copy(e), (this.radius = t), this;
  }
  setFromPoints(e, t) {
    const i = this.center;
    t !== void 0 ? i.copy(t) : X6.setFromPoints(e).getCenter(i);
    let r = 0;
    for (let s = 0, o = e.length; s < o; s++)
      r = Math.max(r, i.distanceToSquared(e[s]));
    return (this.radius = Math.sqrt(r)), this;
  }
  copy(e) {
    return this.center.copy(e.center), (this.radius = e.radius), this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), (this.radius = -1), this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, t) {
    const i = this.center.distanceToSquared(e);
    return (
      t.copy(e),
      i > this.radius * this.radius &&
        (t.sub(this.center).normalize(),
        t.multiplyScalar(this.radius).add(this.center)),
      t
    );
  }
  getBoundingBox(e) {
    return this.isEmpty()
      ? (e.makeEmpty(), e)
      : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return (
      this.center.applyMatrix4(e),
      (this.radius = this.radius * e.getMaxScaleOnAxis()),
      this
    );
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty()) return this.center.copy(e), (this.radius = 0), this;
    bc.subVectors(e, this.center);
    const t = bc.lengthSq();
    if (t > this.radius * this.radius) {
      const i = Math.sqrt(t),
        r = (i - this.radius) * 0.5;
      this.center.addScaledVector(bc, r / i), (this.radius += r);
    }
    return this;
  }
  union(e) {
    return e.isEmpty()
      ? this
      : this.isEmpty()
      ? (this.copy(e), this)
      : (this.center.equals(e.center) === !0
          ? (this.radius = Math.max(this.radius, e.radius))
          : (cy.subVectors(e.center, this.center).setLength(e.radius),
            this.expandByPoint(bc.copy(e.center).add(cy)),
            this.expandByPoint(bc.copy(e.center).sub(cy))),
        this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
const Ms = new U(),
  fy = new U(),
  tp = new U(),
  co = new U(),
  hy = new U(),
  np = new U(),
  dy = new U();
class rl {
  constructor(e = new U(), t = new U(0, 0, -1)) {
    (this.origin = e), (this.direction = t);
  }
  set(e, t) {
    return this.origin.copy(e), this.direction.copy(t), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, t) {
    return t.copy(this.origin).addScaledVector(this.direction, e);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, Ms)), this;
  }
  closestPointToPoint(e, t) {
    t.subVectors(e, this.origin);
    const i = t.dot(this.direction);
    return i < 0
      ? t.copy(this.origin)
      : t.copy(this.origin).addScaledVector(this.direction, i);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const t = Ms.subVectors(e, this.origin).dot(this.direction);
    return t < 0
      ? this.origin.distanceToSquared(e)
      : (Ms.copy(this.origin).addScaledVector(this.direction, t),
        Ms.distanceToSquared(e));
  }
  distanceSqToSegment(e, t, i, r) {
    fy.copy(e).add(t).multiplyScalar(0.5),
      tp.copy(t).sub(e).normalize(),
      co.copy(this.origin).sub(fy);
    const s = e.distanceTo(t) * 0.5,
      o = -this.direction.dot(tp),
      a = co.dot(this.direction),
      u = -co.dot(tp),
      f = co.lengthSq(),
      h = Math.abs(1 - o * o);
    let d, p, m, y;
    if (h > 0)
      if (((d = o * u - a), (p = o * a - u), (y = s * h), d >= 0))
        if (p >= -y)
          if (p <= y) {
            const w = 1 / h;
            (d *= w),
              (p *= w),
              (m = d * (d + o * p + 2 * a) + p * (o * d + p + 2 * u) + f);
          } else
            (p = s),
              (d = Math.max(0, -(o * p + a))),
              (m = -d * d + p * (p + 2 * u) + f);
        else
          (p = -s),
            (d = Math.max(0, -(o * p + a))),
            (m = -d * d + p * (p + 2 * u) + f);
      else
        p <= -y
          ? ((d = Math.max(0, -(-o * s + a))),
            (p = d > 0 ? -s : Math.min(Math.max(-s, -u), s)),
            (m = -d * d + p * (p + 2 * u) + f))
          : p <= y
          ? ((d = 0),
            (p = Math.min(Math.max(-s, -u), s)),
            (m = p * (p + 2 * u) + f))
          : ((d = Math.max(0, -(o * s + a))),
            (p = d > 0 ? s : Math.min(Math.max(-s, -u), s)),
            (m = -d * d + p * (p + 2 * u) + f));
    else
      (p = o > 0 ? -s : s),
        (d = Math.max(0, -(o * p + a))),
        (m = -d * d + p * (p + 2 * u) + f);
    return (
      i && i.copy(this.origin).addScaledVector(this.direction, d),
      r && r.copy(fy).addScaledVector(tp, p),
      m
    );
  }
  intersectSphere(e, t) {
    Ms.subVectors(e.center, this.origin);
    const i = Ms.dot(this.direction),
      r = Ms.dot(Ms) - i * i,
      s = e.radius * e.radius;
    if (r > s) return null;
    const o = Math.sqrt(s - r),
      a = i - o,
      u = i + o;
    return u < 0 ? null : a < 0 ? this.at(u, t) : this.at(a, t);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const t = e.normal.dot(this.direction);
    if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const i = -(this.origin.dot(e.normal) + e.constant) / t;
    return i >= 0 ? i : null;
  }
  intersectPlane(e, t) {
    const i = this.distanceToPlane(e);
    return i === null ? null : this.at(i, t);
  }
  intersectsPlane(e) {
    const t = e.distanceToPoint(this.origin);
    return t === 0 || e.normal.dot(this.direction) * t < 0;
  }
  intersectBox(e, t) {
    let i, r, s, o, a, u;
    const f = 1 / this.direction.x,
      h = 1 / this.direction.y,
      d = 1 / this.direction.z,
      p = this.origin;
    return (
      f >= 0
        ? ((i = (e.min.x - p.x) * f), (r = (e.max.x - p.x) * f))
        : ((i = (e.max.x - p.x) * f), (r = (e.min.x - p.x) * f)),
      h >= 0
        ? ((s = (e.min.y - p.y) * h), (o = (e.max.y - p.y) * h))
        : ((s = (e.max.y - p.y) * h), (o = (e.min.y - p.y) * h)),
      i > o ||
      s > r ||
      ((s > i || isNaN(i)) && (i = s),
      (o < r || isNaN(r)) && (r = o),
      d >= 0
        ? ((a = (e.min.z - p.z) * d), (u = (e.max.z - p.z) * d))
        : ((a = (e.max.z - p.z) * d), (u = (e.min.z - p.z) * d)),
      i > u || a > r) ||
      ((a > i || i !== i) && (i = a), (u < r || r !== r) && (r = u), r < 0)
        ? null
        : this.at(i >= 0 ? i : r, t)
    );
  }
  intersectsBox(e) {
    return this.intersectBox(e, Ms) !== null;
  }
  intersectTriangle(e, t, i, r, s) {
    hy.subVectors(t, e), np.subVectors(i, e), dy.crossVectors(hy, np);
    let o = this.direction.dot(dy),
      a;
    if (o > 0) {
      if (r) return null;
      a = 1;
    } else if (o < 0) (a = -1), (o = -o);
    else return null;
    co.subVectors(this.origin, e);
    const u = a * this.direction.dot(np.crossVectors(co, np));
    if (u < 0) return null;
    const f = a * this.direction.dot(hy.cross(co));
    if (f < 0 || u + f > o) return null;
    const h = -a * co.dot(dy);
    return h < 0 ? null : this.at(h / o, s);
  }
  applyMatrix4(e) {
    return (
      this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
    );
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class dt {
  constructor(e, t, i, r, s, o, a, u, f, h, d, p, m, y, w, S) {
    (dt.prototype.isMatrix4 = !0),
      (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
      e !== void 0 && this.set(e, t, i, r, s, o, a, u, f, h, d, p, m, y, w, S);
  }
  set(e, t, i, r, s, o, a, u, f, h, d, p, m, y, w, S) {
    const v = this.elements;
    return (
      (v[0] = e),
      (v[4] = t),
      (v[8] = i),
      (v[12] = r),
      (v[1] = s),
      (v[5] = o),
      (v[9] = a),
      (v[13] = u),
      (v[2] = f),
      (v[6] = h),
      (v[10] = d),
      (v[14] = p),
      (v[3] = m),
      (v[7] = y),
      (v[11] = w),
      (v[15] = S),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  clone() {
    return new dt().fromArray(this.elements);
  }
  copy(e) {
    const t = this.elements,
      i = e.elements;
    return (
      (t[0] = i[0]),
      (t[1] = i[1]),
      (t[2] = i[2]),
      (t[3] = i[3]),
      (t[4] = i[4]),
      (t[5] = i[5]),
      (t[6] = i[6]),
      (t[7] = i[7]),
      (t[8] = i[8]),
      (t[9] = i[9]),
      (t[10] = i[10]),
      (t[11] = i[11]),
      (t[12] = i[12]),
      (t[13] = i[13]),
      (t[14] = i[14]),
      (t[15] = i[15]),
      this
    );
  }
  copyPosition(e) {
    const t = this.elements,
      i = e.elements;
    return (t[12] = i[12]), (t[13] = i[13]), (t[14] = i[14]), this;
  }
  setFromMatrix3(e) {
    const t = e.elements;
    return (
      this.set(
        t[0],
        t[3],
        t[6],
        0,
        t[1],
        t[4],
        t[7],
        0,
        t[2],
        t[5],
        t[8],
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractBasis(e, t, i) {
    return (
      e.setFromMatrixColumn(this, 0),
      t.setFromMatrixColumn(this, 1),
      i.setFromMatrixColumn(this, 2),
      this
    );
  }
  makeBasis(e, t, i) {
    return (
      this.set(
        e.x,
        t.x,
        i.x,
        0,
        e.y,
        t.y,
        i.y,
        0,
        e.z,
        t.z,
        i.z,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractRotation(e) {
    const t = this.elements,
      i = e.elements,
      r = 1 / Rl.setFromMatrixColumn(e, 0).length(),
      s = 1 / Rl.setFromMatrixColumn(e, 1).length(),
      o = 1 / Rl.setFromMatrixColumn(e, 2).length();
    return (
      (t[0] = i[0] * r),
      (t[1] = i[1] * r),
      (t[2] = i[2] * r),
      (t[3] = 0),
      (t[4] = i[4] * s),
      (t[5] = i[5] * s),
      (t[6] = i[6] * s),
      (t[7] = 0),
      (t[8] = i[8] * o),
      (t[9] = i[9] * o),
      (t[10] = i[10] * o),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    );
  }
  makeRotationFromEuler(e) {
    const t = this.elements,
      i = e.x,
      r = e.y,
      s = e.z,
      o = Math.cos(i),
      a = Math.sin(i),
      u = Math.cos(r),
      f = Math.sin(r),
      h = Math.cos(s),
      d = Math.sin(s);
    if (e.order === "XYZ") {
      const p = o * h,
        m = o * d,
        y = a * h,
        w = a * d;
      (t[0] = u * h),
        (t[4] = -u * d),
        (t[8] = f),
        (t[1] = m + y * f),
        (t[5] = p - w * f),
        (t[9] = -a * u),
        (t[2] = w - p * f),
        (t[6] = y + m * f),
        (t[10] = o * u);
    } else if (e.order === "YXZ") {
      const p = u * h,
        m = u * d,
        y = f * h,
        w = f * d;
      (t[0] = p + w * a),
        (t[4] = y * a - m),
        (t[8] = o * f),
        (t[1] = o * d),
        (t[5] = o * h),
        (t[9] = -a),
        (t[2] = m * a - y),
        (t[6] = w + p * a),
        (t[10] = o * u);
    } else if (e.order === "ZXY") {
      const p = u * h,
        m = u * d,
        y = f * h,
        w = f * d;
      (t[0] = p - w * a),
        (t[4] = -o * d),
        (t[8] = y + m * a),
        (t[1] = m + y * a),
        (t[5] = o * h),
        (t[9] = w - p * a),
        (t[2] = -o * f),
        (t[6] = a),
        (t[10] = o * u);
    } else if (e.order === "ZYX") {
      const p = o * h,
        m = o * d,
        y = a * h,
        w = a * d;
      (t[0] = u * h),
        (t[4] = y * f - m),
        (t[8] = p * f + w),
        (t[1] = u * d),
        (t[5] = w * f + p),
        (t[9] = m * f - y),
        (t[2] = -f),
        (t[6] = a * u),
        (t[10] = o * u);
    } else if (e.order === "YZX") {
      const p = o * u,
        m = o * f,
        y = a * u,
        w = a * f;
      (t[0] = u * h),
        (t[4] = w - p * d),
        (t[8] = y * d + m),
        (t[1] = d),
        (t[5] = o * h),
        (t[9] = -a * h),
        (t[2] = -f * h),
        (t[6] = m * d + y),
        (t[10] = p - w * d);
    } else if (e.order === "XZY") {
      const p = o * u,
        m = o * f,
        y = a * u,
        w = a * f;
      (t[0] = u * h),
        (t[4] = -d),
        (t[8] = f * h),
        (t[1] = p * d + w),
        (t[5] = o * h),
        (t[9] = m * d - y),
        (t[2] = y * d - m),
        (t[6] = a * h),
        (t[10] = w * d + p);
    }
    return (
      (t[3] = 0),
      (t[7] = 0),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    );
  }
  makeRotationFromQuaternion(e) {
    return this.compose(Y6, e, q6);
  }
  lookAt(e, t, i) {
    const r = this.elements;
    return (
      qi.subVectors(e, t),
      qi.lengthSq() === 0 && (qi.z = 1),
      qi.normalize(),
      fo.crossVectors(i, qi),
      fo.lengthSq() === 0 &&
        (Math.abs(i.z) === 1 ? (qi.x += 1e-4) : (qi.z += 1e-4),
        qi.normalize(),
        fo.crossVectors(i, qi)),
      fo.normalize(),
      ip.crossVectors(qi, fo),
      (r[0] = fo.x),
      (r[4] = ip.x),
      (r[8] = qi.x),
      (r[1] = fo.y),
      (r[5] = ip.y),
      (r[9] = qi.y),
      (r[2] = fo.z),
      (r[6] = ip.z),
      (r[10] = qi.z),
      this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const i = e.elements,
      r = t.elements,
      s = this.elements,
      o = i[0],
      a = i[4],
      u = i[8],
      f = i[12],
      h = i[1],
      d = i[5],
      p = i[9],
      m = i[13],
      y = i[2],
      w = i[6],
      S = i[10],
      v = i[14],
      M = i[3],
      _ = i[7],
      T = i[11],
      P = i[15],
      b = r[0],
      L = r[4],
      N = r[8],
      C = r[12],
      R = r[1],
      B = r[5],
      Z = r[9],
      ae = r[13],
      V = r[2],
      Q = r[6],
      $ = r[10],
      ce = r[14],
      k = r[3],
      G = r[7],
      W = r[11],
      Y = r[15];
    return (
      (s[0] = o * b + a * R + u * V + f * k),
      (s[4] = o * L + a * B + u * Q + f * G),
      (s[8] = o * N + a * Z + u * $ + f * W),
      (s[12] = o * C + a * ae + u * ce + f * Y),
      (s[1] = h * b + d * R + p * V + m * k),
      (s[5] = h * L + d * B + p * Q + m * G),
      (s[9] = h * N + d * Z + p * $ + m * W),
      (s[13] = h * C + d * ae + p * ce + m * Y),
      (s[2] = y * b + w * R + S * V + v * k),
      (s[6] = y * L + w * B + S * Q + v * G),
      (s[10] = y * N + w * Z + S * $ + v * W),
      (s[14] = y * C + w * ae + S * ce + v * Y),
      (s[3] = M * b + _ * R + T * V + P * k),
      (s[7] = M * L + _ * B + T * Q + P * G),
      (s[11] = M * N + _ * Z + T * $ + P * W),
      (s[15] = M * C + _ * ae + T * ce + P * Y),
      this
    );
  }
  multiplyScalar(e) {
    const t = this.elements;
    return (
      (t[0] *= e),
      (t[4] *= e),
      (t[8] *= e),
      (t[12] *= e),
      (t[1] *= e),
      (t[5] *= e),
      (t[9] *= e),
      (t[13] *= e),
      (t[2] *= e),
      (t[6] *= e),
      (t[10] *= e),
      (t[14] *= e),
      (t[3] *= e),
      (t[7] *= e),
      (t[11] *= e),
      (t[15] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      i = e[4],
      r = e[8],
      s = e[12],
      o = e[1],
      a = e[5],
      u = e[9],
      f = e[13],
      h = e[2],
      d = e[6],
      p = e[10],
      m = e[14],
      y = e[3],
      w = e[7],
      S = e[11],
      v = e[15];
    return (
      y *
        (+s * u * d -
          r * f * d -
          s * a * p +
          i * f * p +
          r * a * m -
          i * u * m) +
      w *
        (+t * u * m -
          t * f * p +
          s * o * p -
          r * o * m +
          r * f * h -
          s * u * h) +
      S *
        (+t * f * d -
          t * a * m -
          s * o * d +
          i * o * m +
          s * a * h -
          i * f * h) +
      v *
        (-r * a * h - t * u * d + t * a * p + r * o * d - i * o * p + i * u * h)
    );
  }
  transpose() {
    const e = this.elements;
    let t;
    return (
      (t = e[1]),
      (e[1] = e[4]),
      (e[4] = t),
      (t = e[2]),
      (e[2] = e[8]),
      (e[8] = t),
      (t = e[6]),
      (e[6] = e[9]),
      (e[9] = t),
      (t = e[3]),
      (e[3] = e[12]),
      (e[12] = t),
      (t = e[7]),
      (e[7] = e[13]),
      (e[13] = t),
      (t = e[11]),
      (e[11] = e[14]),
      (e[14] = t),
      this
    );
  }
  setPosition(e, t, i) {
    const r = this.elements;
    return (
      e.isVector3
        ? ((r[12] = e.x), (r[13] = e.y), (r[14] = e.z))
        : ((r[12] = e), (r[13] = t), (r[14] = i)),
      this
    );
  }
  invert() {
    const e = this.elements,
      t = e[0],
      i = e[1],
      r = e[2],
      s = e[3],
      o = e[4],
      a = e[5],
      u = e[6],
      f = e[7],
      h = e[8],
      d = e[9],
      p = e[10],
      m = e[11],
      y = e[12],
      w = e[13],
      S = e[14],
      v = e[15],
      M = d * S * f - w * p * f + w * u * m - a * S * m - d * u * v + a * p * v,
      _ = y * p * f - h * S * f - y * u * m + o * S * m + h * u * v - o * p * v,
      T = h * w * f - y * d * f + y * a * m - o * w * m - h * a * v + o * d * v,
      P = y * d * u - h * w * u - y * a * p + o * w * p + h * a * S - o * d * S,
      b = t * M + i * _ + r * T + s * P;
    if (b === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const L = 1 / b;
    return (
      (e[0] = M * L),
      (e[1] =
        (w * p * s -
          d * S * s -
          w * r * m +
          i * S * m +
          d * r * v -
          i * p * v) *
        L),
      (e[2] =
        (a * S * s -
          w * u * s +
          w * r * f -
          i * S * f -
          a * r * v +
          i * u * v) *
        L),
      (e[3] =
        (d * u * s -
          a * p * s -
          d * r * f +
          i * p * f +
          a * r * m -
          i * u * m) *
        L),
      (e[4] = _ * L),
      (e[5] =
        (h * S * s -
          y * p * s +
          y * r * m -
          t * S * m -
          h * r * v +
          t * p * v) *
        L),
      (e[6] =
        (y * u * s -
          o * S * s -
          y * r * f +
          t * S * f +
          o * r * v -
          t * u * v) *
        L),
      (e[7] =
        (o * p * s -
          h * u * s +
          h * r * f -
          t * p * f -
          o * r * m +
          t * u * m) *
        L),
      (e[8] = T * L),
      (e[9] =
        (y * d * s -
          h * w * s -
          y * i * m +
          t * w * m +
          h * i * v -
          t * d * v) *
        L),
      (e[10] =
        (o * w * s -
          y * a * s +
          y * i * f -
          t * w * f -
          o * i * v +
          t * a * v) *
        L),
      (e[11] =
        (h * a * s -
          o * d * s -
          h * i * f +
          t * d * f +
          o * i * m -
          t * a * m) *
        L),
      (e[12] = P * L),
      (e[13] =
        (h * w * r -
          y * d * r +
          y * i * p -
          t * w * p -
          h * i * S +
          t * d * S) *
        L),
      (e[14] =
        (y * a * r -
          o * w * r -
          y * i * u +
          t * w * u +
          o * i * S -
          t * a * S) *
        L),
      (e[15] =
        (o * d * r -
          h * a * r +
          h * i * u -
          t * d * u -
          o * i * p +
          t * a * p) *
        L),
      this
    );
  }
  scale(e) {
    const t = this.elements,
      i = e.x,
      r = e.y,
      s = e.z;
    return (
      (t[0] *= i),
      (t[4] *= r),
      (t[8] *= s),
      (t[1] *= i),
      (t[5] *= r),
      (t[9] *= s),
      (t[2] *= i),
      (t[6] *= r),
      (t[10] *= s),
      (t[3] *= i),
      (t[7] *= r),
      (t[11] *= s),
      this
    );
  }
  getMaxScaleOnAxis() {
    const e = this.elements,
      t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
      i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
      r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, i, r));
  }
  makeTranslation(e, t, i) {
    return (
      e.isVector3
        ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1)
        : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1),
      this
    );
  }
  makeRotationX(e) {
    const t = Math.cos(e),
      i = Math.sin(e);
    return this.set(1, 0, 0, 0, 0, t, -i, 0, 0, i, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationY(e) {
    const t = Math.cos(e),
      i = Math.sin(e);
    return this.set(t, 0, i, 0, 0, 1, 0, 0, -i, 0, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationZ(e) {
    const t = Math.cos(e),
      i = Math.sin(e);
    return this.set(t, -i, 0, 0, i, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  makeRotationAxis(e, t) {
    const i = Math.cos(t),
      r = Math.sin(t),
      s = 1 - i,
      o = e.x,
      a = e.y,
      u = e.z,
      f = s * o,
      h = s * a;
    return (
      this.set(
        f * o + i,
        f * a - r * u,
        f * u + r * a,
        0,
        f * a + r * u,
        h * a + i,
        h * u - r * o,
        0,
        f * u - r * a,
        h * u + r * o,
        s * u * u + i,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  makeScale(e, t, i) {
    return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this;
  }
  makeShear(e, t, i, r, s, o) {
    return this.set(1, i, s, 0, e, 1, o, 0, t, r, 1, 0, 0, 0, 0, 1), this;
  }
  compose(e, t, i) {
    const r = this.elements,
      s = t._x,
      o = t._y,
      a = t._z,
      u = t._w,
      f = s + s,
      h = o + o,
      d = a + a,
      p = s * f,
      m = s * h,
      y = s * d,
      w = o * h,
      S = o * d,
      v = a * d,
      M = u * f,
      _ = u * h,
      T = u * d,
      P = i.x,
      b = i.y,
      L = i.z;
    return (
      (r[0] = (1 - (w + v)) * P),
      (r[1] = (m + T) * P),
      (r[2] = (y - _) * P),
      (r[3] = 0),
      (r[4] = (m - T) * b),
      (r[5] = (1 - (p + v)) * b),
      (r[6] = (S + M) * b),
      (r[7] = 0),
      (r[8] = (y + _) * L),
      (r[9] = (S - M) * L),
      (r[10] = (1 - (p + w)) * L),
      (r[11] = 0),
      (r[12] = e.x),
      (r[13] = e.y),
      (r[14] = e.z),
      (r[15] = 1),
      this
    );
  }
  decompose(e, t, i) {
    const r = this.elements;
    let s = Rl.set(r[0], r[1], r[2]).length();
    const o = Rl.set(r[4], r[5], r[6]).length(),
      a = Rl.set(r[8], r[9], r[10]).length();
    this.determinant() < 0 && (s = -s),
      (e.x = r[12]),
      (e.y = r[13]),
      (e.z = r[14]),
      Pr.copy(this);
    const f = 1 / s,
      h = 1 / o,
      d = 1 / a;
    return (
      (Pr.elements[0] *= f),
      (Pr.elements[1] *= f),
      (Pr.elements[2] *= f),
      (Pr.elements[4] *= h),
      (Pr.elements[5] *= h),
      (Pr.elements[6] *= h),
      (Pr.elements[8] *= d),
      (Pr.elements[9] *= d),
      (Pr.elements[10] *= d),
      t.setFromRotationMatrix(Pr),
      (i.x = s),
      (i.y = o),
      (i.z = a),
      this
    );
  }
  makePerspective(e, t, i, r, s, o, a = kr) {
    const u = this.elements,
      f = (2 * s) / (t - e),
      h = (2 * s) / (i - r),
      d = (t + e) / (t - e),
      p = (i + r) / (i - r);
    let m, y;
    if (a === kr) (m = -(o + s) / (o - s)), (y = (-2 * o * s) / (o - s));
    else if (a === Uu) (m = -o / (o - s)), (y = (-o * s) / (o - s));
    else
      throw new Error(
        "THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a
      );
    return (
      (u[0] = f),
      (u[4] = 0),
      (u[8] = d),
      (u[12] = 0),
      (u[1] = 0),
      (u[5] = h),
      (u[9] = p),
      (u[13] = 0),
      (u[2] = 0),
      (u[6] = 0),
      (u[10] = m),
      (u[14] = y),
      (u[3] = 0),
      (u[7] = 0),
      (u[11] = -1),
      (u[15] = 0),
      this
    );
  }
  makeOrthographic(e, t, i, r, s, o, a = kr) {
    const u = this.elements,
      f = 1 / (t - e),
      h = 1 / (i - r),
      d = 1 / (o - s),
      p = (t + e) * f,
      m = (i + r) * h;
    let y, w;
    if (a === kr) (y = (o + s) * d), (w = -2 * d);
    else if (a === Uu) (y = s * d), (w = -1 * d);
    else
      throw new Error(
        "THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a
      );
    return (
      (u[0] = 2 * f),
      (u[4] = 0),
      (u[8] = 0),
      (u[12] = -p),
      (u[1] = 0),
      (u[5] = 2 * h),
      (u[9] = 0),
      (u[13] = -m),
      (u[2] = 0),
      (u[6] = 0),
      (u[10] = w),
      (u[14] = -y),
      (u[3] = 0),
      (u[7] = 0),
      (u[11] = 0),
      (u[15] = 1),
      this
    );
  }
  equals(e) {
    const t = this.elements,
      i = e.elements;
    for (let r = 0; r < 16; r++) if (t[r] !== i[r]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let i = 0; i < 16; i++) this.elements[i] = e[i + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const i = this.elements;
    return (
      (e[t] = i[0]),
      (e[t + 1] = i[1]),
      (e[t + 2] = i[2]),
      (e[t + 3] = i[3]),
      (e[t + 4] = i[4]),
      (e[t + 5] = i[5]),
      (e[t + 6] = i[6]),
      (e[t + 7] = i[7]),
      (e[t + 8] = i[8]),
      (e[t + 9] = i[9]),
      (e[t + 10] = i[10]),
      (e[t + 11] = i[11]),
      (e[t + 12] = i[12]),
      (e[t + 13] = i[13]),
      (e[t + 14] = i[14]),
      (e[t + 15] = i[15]),
      e
    );
  }
}
const Rl = new U(),
  Pr = new dt(),
  Y6 = new U(0, 0, 0),
  q6 = new U(1, 1, 1),
  fo = new U(),
  ip = new U(),
  qi = new U(),
  P2 = new dt(),
  R2 = new hi();
class yh {
  constructor(e = 0, t = 0, i = 0, r = yh.DEFAULT_ORDER) {
    (this.isEuler = !0),
      (this._x = e),
      (this._y = t),
      (this._z = i),
      (this._order = r);
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    (this._order = e), this._onChangeCallback();
  }
  set(e, t, i, r = this._order) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = i),
      (this._order = r),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return (
      (this._x = e._x),
      (this._y = e._y),
      (this._z = e._z),
      (this._order = e._order),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e, t = this._order, i = !0) {
    const r = e.elements,
      s = r[0],
      o = r[4],
      a = r[8],
      u = r[1],
      f = r[5],
      h = r[9],
      d = r[2],
      p = r[6],
      m = r[10];
    switch (t) {
      case "XYZ":
        (this._y = Math.asin(vn(a, -1, 1))),
          Math.abs(a) < 0.9999999
            ? ((this._x = Math.atan2(-h, m)), (this._z = Math.atan2(-o, s)))
            : ((this._x = Math.atan2(p, f)), (this._z = 0));
        break;
      case "YXZ":
        (this._x = Math.asin(-vn(h, -1, 1))),
          Math.abs(h) < 0.9999999
            ? ((this._y = Math.atan2(a, m)), (this._z = Math.atan2(u, f)))
            : ((this._y = Math.atan2(-d, s)), (this._z = 0));
        break;
      case "ZXY":
        (this._x = Math.asin(vn(p, -1, 1))),
          Math.abs(p) < 0.9999999
            ? ((this._y = Math.atan2(-d, m)), (this._z = Math.atan2(-o, f)))
            : ((this._y = 0), (this._z = Math.atan2(u, s)));
        break;
      case "ZYX":
        (this._y = Math.asin(-vn(d, -1, 1))),
          Math.abs(d) < 0.9999999
            ? ((this._x = Math.atan2(p, m)), (this._z = Math.atan2(u, s)))
            : ((this._x = 0), (this._z = Math.atan2(-o, f)));
        break;
      case "YZX":
        (this._z = Math.asin(vn(u, -1, 1))),
          Math.abs(u) < 0.9999999
            ? ((this._x = Math.atan2(-h, f)), (this._y = Math.atan2(-d, s)))
            : ((this._x = 0), (this._y = Math.atan2(a, m)));
        break;
      case "XZY":
        (this._z = Math.asin(-vn(o, -1, 1))),
          Math.abs(o) < 0.9999999
            ? ((this._x = Math.atan2(p, f)), (this._y = Math.atan2(a, s)))
            : ((this._x = Math.atan2(-h, m)), (this._y = 0));
        break;
      default:
        console.warn(
          "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
            t
        );
    }
    return (this._order = t), i === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, t, i) {
    return (
      P2.makeRotationFromQuaternion(e), this.setFromRotationMatrix(P2, t, i)
    );
  }
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t);
  }
  reorder(e) {
    return R2.setFromEuler(this), this.setFromQuaternion(R2, e);
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._order === this._order
    );
  }
  fromArray(e) {
    return (
      (this._x = e[0]),
      (this._y = e[1]),
      (this._z = e[2]),
      e[3] !== void 0 && (this._order = e[3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._order),
      e
    );
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
yh.DEFAULT_ORDER = "XYZ";
class Ga {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = ((1 << e) | 0) >>> 0;
  }
  enable(e) {
    this.mask |= (1 << e) | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= (1 << e) | 0;
  }
  disable(e) {
    this.mask &= ~((1 << e) | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & ((1 << e) | 0)) !== 0;
  }
}
let Z6 = 0;
const L2 = new U(),
  Ll = new hi(),
  ws = new dt(),
  rp = new U(),
  Cc = new U(),
  K6 = new U(),
  Q6 = new hi(),
  I2 = new U(1, 0, 0),
  N2 = new U(0, 1, 0),
  D2 = new U(0, 0, 1),
  $6 = { type: "added" },
  J6 = { type: "removed" };
class Ft extends Zs {
  constructor() {
    super(),
      (this.isObject3D = !0),
      Object.defineProperty(this, "id", { value: Z6++ }),
      (this.uuid = er()),
      (this.name = ""),
      (this.type = "Object3D"),
      (this.parent = null),
      (this.children = []),
      (this.up = Ft.DEFAULT_UP.clone());
    const e = new U(),
      t = new yh(),
      i = new hi(),
      r = new U(1, 1, 1);
    function s() {
      i.setFromEuler(t, !1);
    }
    function o() {
      t.setFromQuaternion(i, void 0, !1);
    }
    t._onChange(s),
      i._onChange(o),
      Object.defineProperties(this, {
        position: { configurable: !0, enumerable: !0, value: e },
        rotation: { configurable: !0, enumerable: !0, value: t },
        quaternion: { configurable: !0, enumerable: !0, value: i },
        scale: { configurable: !0, enumerable: !0, value: r },
        modelViewMatrix: { value: new dt() },
        normalMatrix: { value: new Et() },
      }),
      (this.matrix = new dt()),
      (this.matrixWorld = new dt()),
      (this.matrixAutoUpdate = Ft.DEFAULT_MATRIX_AUTO_UPDATE),
      (this.matrixWorldAutoUpdate = Ft.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
      (this.matrixWorldNeedsUpdate = !1),
      (this.layers = new Ga()),
      (this.visible = !0),
      (this.castShadow = !1),
      (this.receiveShadow = !1),
      (this.frustumCulled = !0),
      (this.renderOrder = 0),
      (this.animations = []),
      (this.userData = {});
  }
  onBeforeShadow() {}
  onAfterShadow() {}
  onBeforeRender() {}
  onAfterRender() {}
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      this.matrix.premultiply(e),
      this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, t) {
    return Ll.setFromAxisAngle(e, t), this.quaternion.multiply(Ll), this;
  }
  rotateOnWorldAxis(e, t) {
    return Ll.setFromAxisAngle(e, t), this.quaternion.premultiply(Ll), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(I2, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(N2, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(D2, e);
  }
  translateOnAxis(e, t) {
    return (
      L2.copy(e).applyQuaternion(this.quaternion),
      this.position.add(L2.multiplyScalar(t)),
      this
    );
  }
  translateX(e) {
    return this.translateOnAxis(I2, e);
  }
  translateY(e) {
    return this.translateOnAxis(N2, e);
  }
  translateZ(e) {
    return this.translateOnAxis(D2, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      e.applyMatrix4(ws.copy(this.matrixWorld).invert())
    );
  }
  lookAt(e, t, i) {
    e.isVector3 ? rp.copy(e) : rp.set(e, t, i);
    const r = this.parent;
    this.updateWorldMatrix(!0, !1),
      Cc.setFromMatrixPosition(this.matrixWorld),
      this.isCamera || this.isLight
        ? ws.lookAt(Cc, rp, this.up)
        : ws.lookAt(rp, Cc, this.up),
      this.quaternion.setFromRotationMatrix(ws),
      r &&
        (ws.extractRotation(r.matrixWorld),
        Ll.setFromRotationMatrix(ws),
        this.quaternion.premultiply(Ll.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
      return this;
    }
    return e === this
      ? (console.error(
          "THREE.Object3D.add: object can't be added as a child of itself.",
          e
        ),
        this)
      : (e && e.isObject3D
          ? (e.parent !== null && e.parent.remove(e),
            (e.parent = this),
            this.children.push(e),
            e.dispatchEvent($6))
          : console.error(
              "THREE.Object3D.add: object not an instance of THREE.Object3D.",
              e
            ),
        this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) this.remove(arguments[i]);
      return this;
    }
    const t = this.children.indexOf(e);
    return (
      t !== -1 &&
        ((e.parent = null), this.children.splice(t, 1), e.dispatchEvent(J6)),
      this
    );
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      ws.copy(this.matrixWorld).invert(),
      e.parent !== null &&
        (e.parent.updateWorldMatrix(!0, !1), ws.multiply(e.parent.matrixWorld)),
      e.applyMatrix4(ws),
      this.add(e),
      e.updateWorldMatrix(!1, !0),
      this
    );
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, t) {
    if (this[e] === t) return this;
    for (let i = 0, r = this.children.length; i < r; i++) {
      const o = this.children[i].getObjectByProperty(e, t);
      if (o !== void 0) return o;
    }
  }
  getObjectsByProperty(e, t, i = []) {
    this[e] === t && i.push(this);
    const r = this.children;
    for (let s = 0, o = r.length; s < o; s++)
      r[s].getObjectsByProperty(e, t, i);
    return i;
  }
  getWorldPosition(e) {
    return (
      this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
    );
  }
  getWorldQuaternion(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Cc, e, K6), e
    );
  }
  getWorldScale(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Cc, Q6, e), e
    );
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  raycast() {}
  traverse(e) {
    e(this);
    const t = this.children;
    for (let i = 0, r = t.length; i < r; i++) t[i].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1) return;
    e(this);
    const t = this.children;
    for (let i = 0, r = t.length; i < r; i++) t[i].traverseVisible(e);
  }
  traverseAncestors(e) {
    const t = this.parent;
    t !== null && (e(t), t.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale),
      (this.matrixWorldNeedsUpdate = !0);
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      (this.matrixWorldNeedsUpdate || e) &&
        (this.parent === null
          ? this.matrixWorld.copy(this.matrix)
          : this.matrixWorld.multiplyMatrices(
              this.parent.matrixWorld,
              this.matrix
            ),
        (this.matrixWorldNeedsUpdate = !1),
        (e = !0));
    const t = this.children;
    for (let i = 0, r = t.length; i < r; i++) {
      const s = t[i];
      (s.matrixWorldAutoUpdate === !0 || e === !0) && s.updateMatrixWorld(e);
    }
  }
  updateWorldMatrix(e, t) {
    const i = this.parent;
    if (
      (e === !0 &&
        i !== null &&
        i.matrixWorldAutoUpdate === !0 &&
        i.updateWorldMatrix(!0, !1),
      this.matrixAutoUpdate && this.updateMatrix(),
      this.parent === null
        ? this.matrixWorld.copy(this.matrix)
        : this.matrixWorld.multiplyMatrices(
            this.parent.matrixWorld,
            this.matrix
          ),
      t === !0)
    ) {
      const r = this.children;
      for (let s = 0, o = r.length; s < o; s++) {
        const a = r[s];
        a.matrixWorldAutoUpdate === !0 && a.updateWorldMatrix(!1, !0);
      }
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string",
      i = {};
    t &&
      ((e = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {},
      }),
      (i.metadata = {
        version: 4.6,
        type: "Object",
        generator: "Object3D.toJSON",
      }));
    const r = {};
    (r.uuid = this.uuid),
      (r.type = this.type),
      this.name !== "" && (r.name = this.name),
      this.castShadow === !0 && (r.castShadow = !0),
      this.receiveShadow === !0 && (r.receiveShadow = !0),
      this.visible === !1 && (r.visible = !1),
      this.frustumCulled === !1 && (r.frustumCulled = !1),
      this.renderOrder !== 0 && (r.renderOrder = this.renderOrder),
      Object.keys(this.userData).length > 0 && (r.userData = this.userData),
      (r.layers = this.layers.mask),
      (r.matrix = this.matrix.toArray()),
      (r.up = this.up.toArray()),
      this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1),
      this.isInstancedMesh &&
        ((r.type = "InstancedMesh"),
        (r.count = this.count),
        (r.instanceMatrix = this.instanceMatrix.toJSON()),
        this.instanceColor !== null &&
          (r.instanceColor = this.instanceColor.toJSON())),
      this.isBatchedMesh &&
        ((r.type = "BatchedMesh"),
        (r.perObjectFrustumCulled = this.perObjectFrustumCulled),
        (r.sortObjects = this.sortObjects),
        (r.drawRanges = this._drawRanges),
        (r.reservedRanges = this._reservedRanges),
        (r.visibility = this._visibility),
        (r.active = this._active),
        (r.bounds = this._bounds.map((a) => ({
          boxInitialized: a.boxInitialized,
          boxMin: a.box.min.toArray(),
          boxMax: a.box.max.toArray(),
          sphereInitialized: a.sphereInitialized,
          sphereRadius: a.sphere.radius,
          sphereCenter: a.sphere.center.toArray(),
        }))),
        (r.maxGeometryCount = this._maxGeometryCount),
        (r.maxVertexCount = this._maxVertexCount),
        (r.maxIndexCount = this._maxIndexCount),
        (r.geometryInitialized = this._geometryInitialized),
        (r.geometryCount = this._geometryCount),
        (r.matricesTexture = this._matricesTexture.toJSON(e)),
        this.boundingSphere !== null &&
          (r.boundingSphere = {
            center: r.boundingSphere.center.toArray(),
            radius: r.boundingSphere.radius,
          }),
        this.boundingBox !== null &&
          (r.boundingBox = {
            min: r.boundingBox.min.toArray(),
            max: r.boundingBox.max.toArray(),
          }));
    function s(a, u) {
      return a[u.uuid] === void 0 && (a[u.uuid] = u.toJSON(e)), u.uuid;
    }
    if (this.isScene)
      this.background &&
        (this.background.isColor
          ? (r.background = this.background.toJSON())
          : this.background.isTexture &&
            (r.background = this.background.toJSON(e).uuid)),
        this.environment &&
          this.environment.isTexture &&
          this.environment.isRenderTargetTexture !== !0 &&
          (r.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      r.geometry = s(e.geometries, this.geometry);
      const a = this.geometry.parameters;
      if (a !== void 0 && a.shapes !== void 0) {
        const u = a.shapes;
        if (Array.isArray(u))
          for (let f = 0, h = u.length; f < h; f++) {
            const d = u[f];
            s(e.shapes, d);
          }
        else s(e.shapes, u);
      }
    }
    if (
      (this.isSkinnedMesh &&
        ((r.bindMode = this.bindMode),
        (r.bindMatrix = this.bindMatrix.toArray()),
        this.skeleton !== void 0 &&
          (s(e.skeletons, this.skeleton), (r.skeleton = this.skeleton.uuid))),
      this.material !== void 0)
    )
      if (Array.isArray(this.material)) {
        const a = [];
        for (let u = 0, f = this.material.length; u < f; u++)
          a.push(s(e.materials, this.material[u]));
        r.material = a;
      } else r.material = s(e.materials, this.material);
    if (this.children.length > 0) {
      r.children = [];
      for (let a = 0; a < this.children.length; a++)
        r.children.push(this.children[a].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      r.animations = [];
      for (let a = 0; a < this.animations.length; a++) {
        const u = this.animations[a];
        r.animations.push(s(e.animations, u));
      }
    }
    if (t) {
      const a = o(e.geometries),
        u = o(e.materials),
        f = o(e.textures),
        h = o(e.images),
        d = o(e.shapes),
        p = o(e.skeletons),
        m = o(e.animations),
        y = o(e.nodes);
      a.length > 0 && (i.geometries = a),
        u.length > 0 && (i.materials = u),
        f.length > 0 && (i.textures = f),
        h.length > 0 && (i.images = h),
        d.length > 0 && (i.shapes = d),
        p.length > 0 && (i.skeletons = p),
        m.length > 0 && (i.animations = m),
        y.length > 0 && (i.nodes = y);
    }
    return (i.object = r), i;
    function o(a) {
      const u = [];
      for (const f in a) {
        const h = a[f];
        delete h.metadata, u.push(h);
      }
      return u;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, t = !0) {
    if (
      ((this.name = e.name),
      this.up.copy(e.up),
      this.position.copy(e.position),
      (this.rotation.order = e.rotation.order),
      this.quaternion.copy(e.quaternion),
      this.scale.copy(e.scale),
      this.matrix.copy(e.matrix),
      this.matrixWorld.copy(e.matrixWorld),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      (this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate),
      (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
      (this.layers.mask = e.layers.mask),
      (this.visible = e.visible),
      (this.castShadow = e.castShadow),
      (this.receiveShadow = e.receiveShadow),
      (this.frustumCulled = e.frustumCulled),
      (this.renderOrder = e.renderOrder),
      (this.animations = e.animations.slice()),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      t === !0)
    )
      for (let i = 0; i < e.children.length; i++) {
        const r = e.children[i];
        this.add(r.clone());
      }
    return this;
  }
}
Ft.DEFAULT_UP = new U(0, 1, 0);
Ft.DEFAULT_MATRIX_AUTO_UPDATE = !0;
Ft.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const Rr = new U(),
  Es = new U(),
  py = new U(),
  Ts = new U(),
  Il = new U(),
  Nl = new U(),
  O2 = new U(),
  my = new U(),
  gy = new U(),
  vy = new U();
let sp = !1;
class Oi {
  constructor(e = new U(), t = new U(), i = new U()) {
    (this.a = e), (this.b = t), (this.c = i);
  }
  static getNormal(e, t, i, r) {
    r.subVectors(i, t), Rr.subVectors(e, t), r.cross(Rr);
    const s = r.lengthSq();
    return s > 0 ? r.multiplyScalar(1 / Math.sqrt(s)) : r.set(0, 0, 0);
  }
  static getBarycoord(e, t, i, r, s) {
    Rr.subVectors(r, t), Es.subVectors(i, t), py.subVectors(e, t);
    const o = Rr.dot(Rr),
      a = Rr.dot(Es),
      u = Rr.dot(py),
      f = Es.dot(Es),
      h = Es.dot(py),
      d = o * f - a * a;
    if (d === 0) return s.set(0, 0, 0), null;
    const p = 1 / d,
      m = (f * u - a * h) * p,
      y = (o * h - a * u) * p;
    return s.set(1 - m - y, y, m);
  }
  static containsPoint(e, t, i, r) {
    return this.getBarycoord(e, t, i, r, Ts) === null
      ? !1
      : Ts.x >= 0 && Ts.y >= 0 && Ts.x + Ts.y <= 1;
  }
  static getUV(e, t, i, r, s, o, a, u) {
    return (
      sp === !1 &&
        (console.warn(
          "THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."
        ),
        (sp = !0)),
      this.getInterpolation(e, t, i, r, s, o, a, u)
    );
  }
  static getInterpolation(e, t, i, r, s, o, a, u) {
    return this.getBarycoord(e, t, i, r, Ts) === null
      ? ((u.x = 0),
        (u.y = 0),
        "z" in u && (u.z = 0),
        "w" in u && (u.w = 0),
        null)
      : (u.setScalar(0),
        u.addScaledVector(s, Ts.x),
        u.addScaledVector(o, Ts.y),
        u.addScaledVector(a, Ts.z),
        u);
  }
  static isFrontFacing(e, t, i, r) {
    return Rr.subVectors(i, t), Es.subVectors(e, t), Rr.cross(Es).dot(r) < 0;
  }
  set(e, t, i) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(i), this;
  }
  setFromPointsAndIndices(e, t, i, r) {
    return this.a.copy(e[t]), this.b.copy(e[i]), this.c.copy(e[r]), this;
  }
  setFromAttributeAndIndices(e, t, i, r) {
    return (
      this.a.fromBufferAttribute(e, t),
      this.b.fromBufferAttribute(e, i),
      this.c.fromBufferAttribute(e, r),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return (
      Rr.subVectors(this.c, this.b),
      Es.subVectors(this.a, this.b),
      Rr.cross(Es).length() * 0.5
    );
  }
  getMidpoint(e) {
    return e
      .addVectors(this.a, this.b)
      .add(this.c)
      .multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return Oi.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, t) {
    return Oi.getBarycoord(e, this.a, this.b, this.c, t);
  }
  getUV(e, t, i, r, s) {
    return (
      sp === !1 &&
        (console.warn(
          "THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."
        ),
        (sp = !0)),
      Oi.getInterpolation(e, this.a, this.b, this.c, t, i, r, s)
    );
  }
  getInterpolation(e, t, i, r, s) {
    return Oi.getInterpolation(e, this.a, this.b, this.c, t, i, r, s);
  }
  containsPoint(e) {
    return Oi.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return Oi.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, t) {
    const i = this.a,
      r = this.b,
      s = this.c;
    let o, a;
    Il.subVectors(r, i), Nl.subVectors(s, i), my.subVectors(e, i);
    const u = Il.dot(my),
      f = Nl.dot(my);
    if (u <= 0 && f <= 0) return t.copy(i);
    gy.subVectors(e, r);
    const h = Il.dot(gy),
      d = Nl.dot(gy);
    if (h >= 0 && d <= h) return t.copy(r);
    const p = u * d - h * f;
    if (p <= 0 && u >= 0 && h <= 0)
      return (o = u / (u - h)), t.copy(i).addScaledVector(Il, o);
    vy.subVectors(e, s);
    const m = Il.dot(vy),
      y = Nl.dot(vy);
    if (y >= 0 && m <= y) return t.copy(s);
    const w = m * f - u * y;
    if (w <= 0 && f >= 0 && y <= 0)
      return (a = f / (f - y)), t.copy(i).addScaledVector(Nl, a);
    const S = h * y - m * d;
    if (S <= 0 && d - h >= 0 && m - y >= 0)
      return (
        O2.subVectors(s, r),
        (a = (d - h) / (d - h + (m - y))),
        t.copy(r).addScaledVector(O2, a)
      );
    const v = 1 / (S + w + p);
    return (
      (o = w * v),
      (a = p * v),
      t.copy(i).addScaledVector(Il, o).addScaledVector(Nl, a)
    );
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
const AL = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074,
  },
  ho = { h: 0, s: 0, l: 0 },
  op = { h: 0, s: 0, l: 0 };
function yy(n, e, t) {
  return (
    t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6
      ? n + (e - n) * 6 * t
      : t < 1 / 2
      ? e
      : t < 2 / 3
      ? n + (e - n) * 6 * (2 / 3 - t)
      : n
  );
}
class Be {
  constructor(e, t, i) {
    return (
      (this.isColor = !0),
      (this.r = 1),
      (this.g = 1),
      (this.b = 1),
      this.set(e, t, i)
    );
  }
  set(e, t, i) {
    if (t === void 0 && i === void 0) {
      const r = e;
      r && r.isColor
        ? this.copy(r)
        : typeof r == "number"
        ? this.setHex(r)
        : typeof r == "string" && this.setStyle(r);
    } else this.setRGB(e, t, i);
    return this;
  }
  setScalar(e) {
    return (this.r = e), (this.g = e), (this.b = e), this;
  }
  setHex(e, t = Dn) {
    return (
      (e = Math.floor(e)),
      (this.r = ((e >> 16) & 255) / 255),
      (this.g = ((e >> 8) & 255) / 255),
      (this.b = (e & 255) / 255),
      zt.toWorkingColorSpace(this, t),
      this
    );
  }
  setRGB(e, t, i, r = zt.workingColorSpace) {
    return (
      (this.r = e),
      (this.g = t),
      (this.b = i),
      zt.toWorkingColorSpace(this, r),
      this
    );
  }
  setHSL(e, t, i, r = zt.workingColorSpace) {
    if (((e = IS(e, 1)), (t = vn(t, 0, 1)), (i = vn(i, 0, 1)), t === 0))
      this.r = this.g = this.b = i;
    else {
      const s = i <= 0.5 ? i * (1 + t) : i + t - i * t,
        o = 2 * i - s;
      (this.r = yy(o, s, e + 1 / 3)),
        (this.g = yy(o, s, e)),
        (this.b = yy(o, s, e - 1 / 3));
    }
    return zt.toWorkingColorSpace(this, r), this;
  }
  setStyle(e, t = Dn) {
    function i(s) {
      s !== void 0 &&
        parseFloat(s) < 1 &&
        console.warn(
          "THREE.Color: Alpha component of " + e + " will be ignored."
        );
    }
    let r;
    if ((r = /^(\w+)\(([^\)]*)\)/.exec(e))) {
      let s;
      const o = r[1],
        a = r[2];
      switch (o) {
        case "rgb":
        case "rgba":
          if (
            (s =
              /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                a
              ))
          )
            return (
              i(s[4]),
              this.setRGB(
                Math.min(255, parseInt(s[1], 10)) / 255,
                Math.min(255, parseInt(s[2], 10)) / 255,
                Math.min(255, parseInt(s[3], 10)) / 255,
                t
              )
            );
          if (
            (s =
              /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                a
              ))
          )
            return (
              i(s[4]),
              this.setRGB(
                Math.min(100, parseInt(s[1], 10)) / 100,
                Math.min(100, parseInt(s[2], 10)) / 100,
                Math.min(100, parseInt(s[3], 10)) / 100,
                t
              )
            );
          break;
        case "hsl":
        case "hsla":
          if (
            (s =
              /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                a
              ))
          )
            return (
              i(s[4]),
              this.setHSL(
                parseFloat(s[1]) / 360,
                parseFloat(s[2]) / 100,
                parseFloat(s[3]) / 100,
                t
              )
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e);
      }
    } else if ((r = /^\#([A-Fa-f\d]+)$/.exec(e))) {
      const s = r[1],
        o = s.length;
      if (o === 3)
        return this.setRGB(
          parseInt(s.charAt(0), 16) / 15,
          parseInt(s.charAt(1), 16) / 15,
          parseInt(s.charAt(2), 16) / 15,
          t
        );
      if (o === 6) return this.setHex(parseInt(s, 16), t);
      console.warn("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0) return this.setColorName(e, t);
    return this;
  }
  setColorName(e, t = Dn) {
    const i = AL[e.toLowerCase()];
    return (
      i !== void 0
        ? this.setHex(i, t)
        : console.warn("THREE.Color: Unknown color " + e),
      this
    );
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
  }
  copySRGBToLinear(e) {
    return (this.r = Tu(e.r)), (this.g = Tu(e.g)), (this.b = Tu(e.b)), this;
  }
  copyLinearToSRGB(e) {
    return (this.r = oy(e.r)), (this.g = oy(e.g)), (this.b = oy(e.b)), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = Dn) {
    return (
      zt.fromWorkingColorSpace(ai.copy(this), e),
      Math.round(vn(ai.r * 255, 0, 255)) * 65536 +
        Math.round(vn(ai.g * 255, 0, 255)) * 256 +
        Math.round(vn(ai.b * 255, 0, 255))
    );
  }
  getHexString(e = Dn) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, t = zt.workingColorSpace) {
    zt.fromWorkingColorSpace(ai.copy(this), t);
    const i = ai.r,
      r = ai.g,
      s = ai.b,
      o = Math.max(i, r, s),
      a = Math.min(i, r, s);
    let u, f;
    const h = (a + o) / 2;
    if (a === o) (u = 0), (f = 0);
    else {
      const d = o - a;
      switch (((f = h <= 0.5 ? d / (o + a) : d / (2 - o - a)), o)) {
        case i:
          u = (r - s) / d + (r < s ? 6 : 0);
          break;
        case r:
          u = (s - i) / d + 2;
          break;
        case s:
          u = (i - r) / d + 4;
          break;
      }
      u /= 6;
    }
    return (e.h = u), (e.s = f), (e.l = h), e;
  }
  getRGB(e, t = zt.workingColorSpace) {
    return (
      zt.fromWorkingColorSpace(ai.copy(this), t),
      (e.r = ai.r),
      (e.g = ai.g),
      (e.b = ai.b),
      e
    );
  }
  getStyle(e = Dn) {
    zt.fromWorkingColorSpace(ai.copy(this), e);
    const t = ai.r,
      i = ai.g,
      r = ai.b;
    return e !== Dn
      ? `color(${e} ${t.toFixed(3)} ${i.toFixed(3)} ${r.toFixed(3)})`
      : `rgb(${Math.round(t * 255)},${Math.round(i * 255)},${Math.round(
          r * 255
        )})`;
  }
  offsetHSL(e, t, i) {
    return this.getHSL(ho), this.setHSL(ho.h + e, ho.s + t, ho.l + i);
  }
  add(e) {
    return (this.r += e.r), (this.g += e.g), (this.b += e.b), this;
  }
  addColors(e, t) {
    return (
      (this.r = e.r + t.r), (this.g = e.g + t.g), (this.b = e.b + t.b), this
    );
  }
  addScalar(e) {
    return (this.r += e), (this.g += e), (this.b += e), this;
  }
  sub(e) {
    return (
      (this.r = Math.max(0, this.r - e.r)),
      (this.g = Math.max(0, this.g - e.g)),
      (this.b = Math.max(0, this.b - e.b)),
      this
    );
  }
  multiply(e) {
    return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this;
  }
  multiplyScalar(e) {
    return (this.r *= e), (this.g *= e), (this.b *= e), this;
  }
  lerp(e, t) {
    return (
      (this.r += (e.r - this.r) * t),
      (this.g += (e.g - this.g) * t),
      (this.b += (e.b - this.b) * t),
      this
    );
  }
  lerpColors(e, t, i) {
    return (
      (this.r = e.r + (t.r - e.r) * i),
      (this.g = e.g + (t.g - e.g) * i),
      (this.b = e.b + (t.b - e.b) * i),
      this
    );
  }
  lerpHSL(e, t) {
    this.getHSL(ho), e.getHSL(op);
    const i = af(ho.h, op.h, t),
      r = af(ho.s, op.s, t),
      s = af(ho.l, op.l, t);
    return this.setHSL(i, r, s), this;
  }
  setFromVector3(e) {
    return (this.r = e.x), (this.g = e.y), (this.b = e.z), this;
  }
  applyMatrix3(e) {
    const t = this.r,
      i = this.g,
      r = this.b,
      s = e.elements;
    return (
      (this.r = s[0] * t + s[3] * i + s[6] * r),
      (this.g = s[1] * t + s[4] * i + s[7] * r),
      (this.b = s[2] * t + s[5] * i + s[8] * r),
      this
    );
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, t = 0) {
    return (this.r = e[t]), (this.g = e[t + 1]), (this.b = e[t + 2]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.r), (e[t + 1] = this.g), (e[t + 2] = this.b), e;
  }
  fromBufferAttribute(e, t) {
    return (
      (this.r = e.getX(t)), (this.g = e.getY(t)), (this.b = e.getZ(t)), this
    );
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const ai = new Be();
Be.NAMES = AL;
let eV = 0;
class gi extends Zs {
  constructor() {
    super(),
      (this.isMaterial = !0),
      Object.defineProperty(this, "id", { value: eV++ }),
      (this.uuid = er()),
      (this.name = ""),
      (this.type = "Material"),
      (this.blending = Va),
      (this.side = js),
      (this.vertexColors = !1),
      (this.opacity = 1),
      (this.transparent = !1),
      (this.alphaHash = !1),
      (this.blendSrc = Qm),
      (this.blendDst = $m),
      (this.blendEquation = wo),
      (this.blendSrcAlpha = null),
      (this.blendDstAlpha = null),
      (this.blendEquationAlpha = null),
      (this.blendColor = new Be(0, 0, 0)),
      (this.blendAlpha = 0),
      (this.depthFunc = Lf),
      (this.depthTest = !0),
      (this.depthWrite = !0),
      (this.stencilWriteMask = 255),
      (this.stencilFunc = O_),
      (this.stencilRef = 0),
      (this.stencilFuncMask = 255),
      (this.stencilFail = ba),
      (this.stencilZFail = ba),
      (this.stencilZPass = ba),
      (this.stencilWrite = !1),
      (this.clippingPlanes = null),
      (this.clipIntersection = !1),
      (this.clipShadows = !1),
      (this.shadowSide = null),
      (this.colorWrite = !0),
      (this.precision = null),
      (this.polygonOffset = !1),
      (this.polygonOffsetFactor = 0),
      (this.polygonOffsetUnits = 0),
      (this.dithering = !1),
      (this.alphaToCoverage = !1),
      (this.premultipliedAlpha = !1),
      (this.forceSinglePass = !1),
      (this.visible = !0),
      (this.toneMapped = !0),
      (this.userData = {}),
      (this.version = 0),
      (this._alphaTest = 0);
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, (this._alphaTest = e);
  }
  onBuild() {}
  onBeforeRender() {}
  onBeforeCompile() {}
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const t in e) {
        const i = e[t];
        if (i === void 0) {
          console.warn(
            `THREE.Material: parameter '${t}' has value of undefined.`
          );
          continue;
        }
        const r = this[t];
        if (r === void 0) {
          console.warn(
            `THREE.Material: '${t}' is not a property of THREE.${this.type}.`
          );
          continue;
        }
        r && r.isColor
          ? r.set(i)
          : r && r.isVector3 && i && i.isVector3
          ? r.copy(i)
          : (this[t] = i);
      }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    t && (e = { textures: {}, images: {} });
    const i = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON",
      },
    };
    (i.uuid = this.uuid),
      (i.type = this.type),
      this.name !== "" && (i.name = this.name),
      this.color && this.color.isColor && (i.color = this.color.getHex()),
      this.roughness !== void 0 && (i.roughness = this.roughness),
      this.metalness !== void 0 && (i.metalness = this.metalness),
      this.sheen !== void 0 && (i.sheen = this.sheen),
      this.sheenColor &&
        this.sheenColor.isColor &&
        (i.sheenColor = this.sheenColor.getHex()),
      this.sheenRoughness !== void 0 &&
        (i.sheenRoughness = this.sheenRoughness),
      this.emissive &&
        this.emissive.isColor &&
        (i.emissive = this.emissive.getHex()),
      this.emissiveIntensity &&
        this.emissiveIntensity !== 1 &&
        (i.emissiveIntensity = this.emissiveIntensity),
      this.specular &&
        this.specular.isColor &&
        (i.specular = this.specular.getHex()),
      this.specularIntensity !== void 0 &&
        (i.specularIntensity = this.specularIntensity),
      this.specularColor &&
        this.specularColor.isColor &&
        (i.specularColor = this.specularColor.getHex()),
      this.shininess !== void 0 && (i.shininess = this.shininess),
      this.clearcoat !== void 0 && (i.clearcoat = this.clearcoat),
      this.clearcoatRoughness !== void 0 &&
        (i.clearcoatRoughness = this.clearcoatRoughness),
      this.clearcoatMap &&
        this.clearcoatMap.isTexture &&
        (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
      this.clearcoatRoughnessMap &&
        this.clearcoatRoughnessMap.isTexture &&
        (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
      this.clearcoatNormalMap &&
        this.clearcoatNormalMap.isTexture &&
        ((i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid),
        (i.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
      this.iridescence !== void 0 && (i.iridescence = this.iridescence),
      this.iridescenceIOR !== void 0 &&
        (i.iridescenceIOR = this.iridescenceIOR),
      this.iridescenceThicknessRange !== void 0 &&
        (i.iridescenceThicknessRange = this.iridescenceThicknessRange),
      this.iridescenceMap &&
        this.iridescenceMap.isTexture &&
        (i.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
      this.iridescenceThicknessMap &&
        this.iridescenceThicknessMap.isTexture &&
        (i.iridescenceThicknessMap =
          this.iridescenceThicknessMap.toJSON(e).uuid),
      this.anisotropy !== void 0 && (i.anisotropy = this.anisotropy),
      this.anisotropyRotation !== void 0 &&
        (i.anisotropyRotation = this.anisotropyRotation),
      this.anisotropyMap &&
        this.anisotropyMap.isTexture &&
        (i.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
      this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid),
      this.matcap &&
        this.matcap.isTexture &&
        (i.matcap = this.matcap.toJSON(e).uuid),
      this.alphaMap &&
        this.alphaMap.isTexture &&
        (i.alphaMap = this.alphaMap.toJSON(e).uuid),
      this.lightMap &&
        this.lightMap.isTexture &&
        ((i.lightMap = this.lightMap.toJSON(e).uuid),
        (i.lightMapIntensity = this.lightMapIntensity)),
      this.aoMap &&
        this.aoMap.isTexture &&
        ((i.aoMap = this.aoMap.toJSON(e).uuid),
        (i.aoMapIntensity = this.aoMapIntensity)),
      this.bumpMap &&
        this.bumpMap.isTexture &&
        ((i.bumpMap = this.bumpMap.toJSON(e).uuid),
        (i.bumpScale = this.bumpScale)),
      this.normalMap &&
        this.normalMap.isTexture &&
        ((i.normalMap = this.normalMap.toJSON(e).uuid),
        (i.normalMapType = this.normalMapType),
        (i.normalScale = this.normalScale.toArray())),
      this.displacementMap &&
        this.displacementMap.isTexture &&
        ((i.displacementMap = this.displacementMap.toJSON(e).uuid),
        (i.displacementScale = this.displacementScale),
        (i.displacementBias = this.displacementBias)),
      this.roughnessMap &&
        this.roughnessMap.isTexture &&
        (i.roughnessMap = this.roughnessMap.toJSON(e).uuid),
      this.metalnessMap &&
        this.metalnessMap.isTexture &&
        (i.metalnessMap = this.metalnessMap.toJSON(e).uuid),
      this.emissiveMap &&
        this.emissiveMap.isTexture &&
        (i.emissiveMap = this.emissiveMap.toJSON(e).uuid),
      this.specularMap &&
        this.specularMap.isTexture &&
        (i.specularMap = this.specularMap.toJSON(e).uuid),
      this.specularIntensityMap &&
        this.specularIntensityMap.isTexture &&
        (i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
      this.specularColorMap &&
        this.specularColorMap.isTexture &&
        (i.specularColorMap = this.specularColorMap.toJSON(e).uuid),
      this.envMap &&
        this.envMap.isTexture &&
        ((i.envMap = this.envMap.toJSON(e).uuid),
        this.combine !== void 0 && (i.combine = this.combine)),
      this.envMapIntensity !== void 0 &&
        (i.envMapIntensity = this.envMapIntensity),
      this.reflectivity !== void 0 && (i.reflectivity = this.reflectivity),
      this.refractionRatio !== void 0 &&
        (i.refractionRatio = this.refractionRatio),
      this.gradientMap &&
        this.gradientMap.isTexture &&
        (i.gradientMap = this.gradientMap.toJSON(e).uuid),
      this.transmission !== void 0 && (i.transmission = this.transmission),
      this.transmissionMap &&
        this.transmissionMap.isTexture &&
        (i.transmissionMap = this.transmissionMap.toJSON(e).uuid),
      this.thickness !== void 0 && (i.thickness = this.thickness),
      this.thicknessMap &&
        this.thicknessMap.isTexture &&
        (i.thicknessMap = this.thicknessMap.toJSON(e).uuid),
      this.attenuationDistance !== void 0 &&
        this.attenuationDistance !== 1 / 0 &&
        (i.attenuationDistance = this.attenuationDistance),
      this.attenuationColor !== void 0 &&
        (i.attenuationColor = this.attenuationColor.getHex()),
      this.size !== void 0 && (i.size = this.size),
      this.shadowSide !== null && (i.shadowSide = this.shadowSide),
      this.sizeAttenuation !== void 0 &&
        (i.sizeAttenuation = this.sizeAttenuation),
      this.blending !== Va && (i.blending = this.blending),
      this.side !== js && (i.side = this.side),
      this.vertexColors === !0 && (i.vertexColors = !0),
      this.opacity < 1 && (i.opacity = this.opacity),
      this.transparent === !0 && (i.transparent = !0),
      this.blendSrc !== Qm && (i.blendSrc = this.blendSrc),
      this.blendDst !== $m && (i.blendDst = this.blendDst),
      this.blendEquation !== wo && (i.blendEquation = this.blendEquation),
      this.blendSrcAlpha !== null && (i.blendSrcAlpha = this.blendSrcAlpha),
      this.blendDstAlpha !== null && (i.blendDstAlpha = this.blendDstAlpha),
      this.blendEquationAlpha !== null &&
        (i.blendEquationAlpha = this.blendEquationAlpha),
      this.blendColor &&
        this.blendColor.isColor &&
        (i.blendColor = this.blendColor.getHex()),
      this.blendAlpha !== 0 && (i.blendAlpha = this.blendAlpha),
      this.depthFunc !== Lf && (i.depthFunc = this.depthFunc),
      this.depthTest === !1 && (i.depthTest = this.depthTest),
      this.depthWrite === !1 && (i.depthWrite = this.depthWrite),
      this.colorWrite === !1 && (i.colorWrite = this.colorWrite),
      this.stencilWriteMask !== 255 &&
        (i.stencilWriteMask = this.stencilWriteMask),
      this.stencilFunc !== O_ && (i.stencilFunc = this.stencilFunc),
      this.stencilRef !== 0 && (i.stencilRef = this.stencilRef),
      this.stencilFuncMask !== 255 &&
        (i.stencilFuncMask = this.stencilFuncMask),
      this.stencilFail !== ba && (i.stencilFail = this.stencilFail),
      this.stencilZFail !== ba && (i.stencilZFail = this.stencilZFail),
      this.stencilZPass !== ba && (i.stencilZPass = this.stencilZPass),
      this.stencilWrite === !0 && (i.stencilWrite = this.stencilWrite),
      this.rotation !== void 0 &&
        this.rotation !== 0 &&
        (i.rotation = this.rotation),
      this.polygonOffset === !0 && (i.polygonOffset = !0),
      this.polygonOffsetFactor !== 0 &&
        (i.polygonOffsetFactor = this.polygonOffsetFactor),
      this.polygonOffsetUnits !== 0 &&
        (i.polygonOffsetUnits = this.polygonOffsetUnits),
      this.linewidth !== void 0 &&
        this.linewidth !== 1 &&
        (i.linewidth = this.linewidth),
      this.dashSize !== void 0 && (i.dashSize = this.dashSize),
      this.gapSize !== void 0 && (i.gapSize = this.gapSize),
      this.scale !== void 0 && (i.scale = this.scale),
      this.dithering === !0 && (i.dithering = !0),
      this.alphaTest > 0 && (i.alphaTest = this.alphaTest),
      this.alphaHash === !0 && (i.alphaHash = !0),
      this.alphaToCoverage === !0 && (i.alphaToCoverage = !0),
      this.premultipliedAlpha === !0 && (i.premultipliedAlpha = !0),
      this.forceSinglePass === !0 && (i.forceSinglePass = !0),
      this.wireframe === !0 && (i.wireframe = !0),
      this.wireframeLinewidth > 1 &&
        (i.wireframeLinewidth = this.wireframeLinewidth),
      this.wireframeLinecap !== "round" &&
        (i.wireframeLinecap = this.wireframeLinecap),
      this.wireframeLinejoin !== "round" &&
        (i.wireframeLinejoin = this.wireframeLinejoin),
      this.flatShading === !0 && (i.flatShading = !0),
      this.visible === !1 && (i.visible = !1),
      this.toneMapped === !1 && (i.toneMapped = !1),
      this.fog === !1 && (i.fog = !1),
      Object.keys(this.userData).length > 0 && (i.userData = this.userData);
    function r(s) {
      const o = [];
      for (const a in s) {
        const u = s[a];
        delete u.metadata, o.push(u);
      }
      return o;
    }
    if (t) {
      const s = r(e.textures),
        o = r(e.images);
      s.length > 0 && (i.textures = s), o.length > 0 && (i.images = o);
    }
    return i;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.name = e.name),
      (this.blending = e.blending),
      (this.side = e.side),
      (this.vertexColors = e.vertexColors),
      (this.opacity = e.opacity),
      (this.transparent = e.transparent),
      (this.blendSrc = e.blendSrc),
      (this.blendDst = e.blendDst),
      (this.blendEquation = e.blendEquation),
      (this.blendSrcAlpha = e.blendSrcAlpha),
      (this.blendDstAlpha = e.blendDstAlpha),
      (this.blendEquationAlpha = e.blendEquationAlpha),
      this.blendColor.copy(e.blendColor),
      (this.blendAlpha = e.blendAlpha),
      (this.depthFunc = e.depthFunc),
      (this.depthTest = e.depthTest),
      (this.depthWrite = e.depthWrite),
      (this.stencilWriteMask = e.stencilWriteMask),
      (this.stencilFunc = e.stencilFunc),
      (this.stencilRef = e.stencilRef),
      (this.stencilFuncMask = e.stencilFuncMask),
      (this.stencilFail = e.stencilFail),
      (this.stencilZFail = e.stencilZFail),
      (this.stencilZPass = e.stencilZPass),
      (this.stencilWrite = e.stencilWrite);
    const t = e.clippingPlanes;
    let i = null;
    if (t !== null) {
      const r = t.length;
      i = new Array(r);
      for (let s = 0; s !== r; ++s) i[s] = t[s].clone();
    }
    return (
      (this.clippingPlanes = i),
      (this.clipIntersection = e.clipIntersection),
      (this.clipShadows = e.clipShadows),
      (this.shadowSide = e.shadowSide),
      (this.colorWrite = e.colorWrite),
      (this.precision = e.precision),
      (this.polygonOffset = e.polygonOffset),
      (this.polygonOffsetFactor = e.polygonOffsetFactor),
      (this.polygonOffsetUnits = e.polygonOffsetUnits),
      (this.dithering = e.dithering),
      (this.alphaTest = e.alphaTest),
      (this.alphaHash = e.alphaHash),
      (this.alphaToCoverage = e.alphaToCoverage),
      (this.premultipliedAlpha = e.premultipliedAlpha),
      (this.forceSinglePass = e.forceSinglePass),
      (this.visible = e.visible),
      (this.toneMapped = e.toneMapped),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
}
class Qo extends gi {
  constructor(e) {
    super(),
      (this.isMeshBasicMaterial = !0),
      (this.type = "MeshBasicMaterial"),
      (this.color = new Be(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = gh),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const Rs = tV();
function tV() {
  const n = new ArrayBuffer(4),
    e = new Float32Array(n),
    t = new Uint32Array(n),
    i = new Uint32Array(512),
    r = new Uint32Array(512);
  for (let u = 0; u < 256; ++u) {
    const f = u - 127;
    f < -27
      ? ((i[u] = 0), (i[u | 256] = 32768), (r[u] = 24), (r[u | 256] = 24))
      : f < -14
      ? ((i[u] = 1024 >> (-f - 14)),
        (i[u | 256] = (1024 >> (-f - 14)) | 32768),
        (r[u] = -f - 1),
        (r[u | 256] = -f - 1))
      : f <= 15
      ? ((i[u] = (f + 15) << 10),
        (i[u | 256] = ((f + 15) << 10) | 32768),
        (r[u] = 13),
        (r[u | 256] = 13))
      : f < 128
      ? ((i[u] = 31744), (i[u | 256] = 64512), (r[u] = 24), (r[u | 256] = 24))
      : ((i[u] = 31744), (i[u | 256] = 64512), (r[u] = 13), (r[u | 256] = 13));
  }
  const s = new Uint32Array(2048),
    o = new Uint32Array(64),
    a = new Uint32Array(64);
  for (let u = 1; u < 1024; ++u) {
    let f = u << 13,
      h = 0;
    for (; !(f & 8388608); ) (f <<= 1), (h -= 8388608);
    (f &= -8388609), (h += 947912704), (s[u] = f | h);
  }
  for (let u = 1024; u < 2048; ++u) s[u] = 939524096 + ((u - 1024) << 13);
  for (let u = 1; u < 31; ++u) o[u] = u << 23;
  (o[31] = 1199570944), (o[32] = 2147483648);
  for (let u = 33; u < 63; ++u) o[u] = 2147483648 + ((u - 32) << 23);
  o[63] = 3347054592;
  for (let u = 1; u < 64; ++u) u !== 32 && (a[u] = 1024);
  return {
    floatView: e,
    uint32View: t,
    baseTable: i,
    shiftTable: r,
    mantissaTable: s,
    exponentTable: o,
    offsetTable: a,
  };
}
function Ni(n) {
  Math.abs(n) > 65504 &&
    console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),
    (n = vn(n, -65504, 65504)),
    (Rs.floatView[0] = n);
  const e = Rs.uint32View[0],
    t = (e >> 23) & 511;
  return Rs.baseTable[t] + ((e & 8388607) >> Rs.shiftTable[t]);
}
function Wc(n) {
  const e = n >> 10;
  return (
    (Rs.uint32View[0] =
      Rs.mantissaTable[Rs.offsetTable[e] + (n & 1023)] + Rs.exponentTable[e]),
    Rs.floatView[0]
  );
}
const nV = { toHalfFloat: Ni, fromHalfFloat: Wc },
  Pn = new U(),
  ap = new de();
class Ht {
  constructor(e, t, i = !1) {
    if (Array.isArray(e))
      throw new TypeError(
        "THREE.BufferAttribute: array should be a Typed Array."
      );
    (this.isBufferAttribute = !0),
      (this.name = ""),
      (this.array = e),
      (this.itemSize = t),
      (this.count = e !== void 0 ? e.length / t : 0),
      (this.normalized = i),
      (this.usage = Hf),
      (this._updateRange = { offset: 0, count: -1 }),
      (this.updateRanges = []),
      (this.gpuType = Ur),
      (this.version = 0);
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  get updateRange() {
    return (
      console.warn(
        "THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."
      ),
      this._updateRange
    );
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.array = new e.array.constructor(e.array)),
      (this.itemSize = e.itemSize),
      (this.count = e.count),
      (this.normalized = e.normalized),
      (this.usage = e.usage),
      (this.gpuType = e.gpuType),
      this
    );
  }
  copyAt(e, t, i) {
    (e *= this.itemSize), (i *= t.itemSize);
    for (let r = 0, s = this.itemSize; r < s; r++)
      this.array[e + r] = t.array[i + r];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let t = 0, i = this.count; t < i; t++)
        ap.fromBufferAttribute(this, t),
          ap.applyMatrix3(e),
          this.setXY(t, ap.x, ap.y);
    else if (this.itemSize === 3)
      for (let t = 0, i = this.count; t < i; t++)
        Pn.fromBufferAttribute(this, t),
          Pn.applyMatrix3(e),
          this.setXYZ(t, Pn.x, Pn.y, Pn.z);
    return this;
  }
  applyMatrix4(e) {
    for (let t = 0, i = this.count; t < i; t++)
      Pn.fromBufferAttribute(this, t),
        Pn.applyMatrix4(e),
        this.setXYZ(t, Pn.x, Pn.y, Pn.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, i = this.count; t < i; t++)
      Pn.fromBufferAttribute(this, t),
        Pn.applyNormalMatrix(e),
        this.setXYZ(t, Pn.x, Pn.y, Pn.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, i = this.count; t < i; t++)
      Pn.fromBufferAttribute(this, t),
        Pn.transformDirection(e),
        this.setXYZ(t, Pn.x, Pn.y, Pn.z);
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  getComponent(e, t) {
    let i = this.array[e * this.itemSize + t];
    return this.normalized && (i = Ui(i, this.array)), i;
  }
  setComponent(e, t, i) {
    return (
      this.normalized && (i = Mt(i, this.array)),
      (this.array[e * this.itemSize + t] = i),
      this
    );
  }
  getX(e) {
    let t = this.array[e * this.itemSize];
    return this.normalized && (t = Ui(t, this.array)), t;
  }
  setX(e, t) {
    return (
      this.normalized && (t = Mt(t, this.array)),
      (this.array[e * this.itemSize] = t),
      this
    );
  }
  getY(e) {
    let t = this.array[e * this.itemSize + 1];
    return this.normalized && (t = Ui(t, this.array)), t;
  }
  setY(e, t) {
    return (
      this.normalized && (t = Mt(t, this.array)),
      (this.array[e * this.itemSize + 1] = t),
      this
    );
  }
  getZ(e) {
    let t = this.array[e * this.itemSize + 2];
    return this.normalized && (t = Ui(t, this.array)), t;
  }
  setZ(e, t) {
    return (
      this.normalized && (t = Mt(t, this.array)),
      (this.array[e * this.itemSize + 2] = t),
      this
    );
  }
  getW(e) {
    let t = this.array[e * this.itemSize + 3];
    return this.normalized && (t = Ui(t, this.array)), t;
  }
  setW(e, t) {
    return (
      this.normalized && (t = Mt(t, this.array)),
      (this.array[e * this.itemSize + 3] = t),
      this
    );
  }
  setXY(e, t, i) {
    return (
      (e *= this.itemSize),
      this.normalized && ((t = Mt(t, this.array)), (i = Mt(i, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = i),
      this
    );
  }
  setXYZ(e, t, i, r) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = Mt(t, this.array)),
        (i = Mt(i, this.array)),
        (r = Mt(r, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = i),
      (this.array[e + 2] = r),
      this
    );
  }
  setXYZW(e, t, i, r, s) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = Mt(t, this.array)),
        (i = Mt(i, this.array)),
        (r = Mt(r, this.array)),
        (s = Mt(s, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = i),
      (this.array[e + 2] = r),
      (this.array[e + 3] = s),
      this
    );
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized,
    };
    return (
      this.name !== "" && (e.name = this.name),
      this.usage !== Hf && (e.usage = this.usage),
      e
    );
  }
}
class iV extends Ht {
  constructor(e, t, i) {
    super(new Int8Array(e), t, i);
  }
}
class rV extends Ht {
  constructor(e, t, i) {
    super(new Uint8Array(e), t, i);
  }
}
class sV extends Ht {
  constructor(e, t, i) {
    super(new Uint8ClampedArray(e), t, i);
  }
}
class oV extends Ht {
  constructor(e, t, i) {
    super(new Int16Array(e), t, i);
  }
}
class OS extends Ht {
  constructor(e, t, i) {
    super(new Uint16Array(e), t, i);
  }
}
class aV extends Ht {
  constructor(e, t, i) {
    super(new Int32Array(e), t, i);
  }
}
class US extends Ht {
  constructor(e, t, i) {
    super(new Uint32Array(e), t, i);
  }
}
class lV extends Ht {
  constructor(e, t, i) {
    super(new Uint16Array(e), t, i), (this.isFloat16BufferAttribute = !0);
  }
  getX(e) {
    let t = Wc(this.array[e * this.itemSize]);
    return this.normalized && (t = Ui(t, this.array)), t;
  }
  setX(e, t) {
    return (
      this.normalized && (t = Mt(t, this.array)),
      (this.array[e * this.itemSize] = Ni(t)),
      this
    );
  }
  getY(e) {
    let t = Wc(this.array[e * this.itemSize + 1]);
    return this.normalized && (t = Ui(t, this.array)), t;
  }
  setY(e, t) {
    return (
      this.normalized && (t = Mt(t, this.array)),
      (this.array[e * this.itemSize + 1] = Ni(t)),
      this
    );
  }
  getZ(e) {
    let t = Wc(this.array[e * this.itemSize + 2]);
    return this.normalized && (t = Ui(t, this.array)), t;
  }
  setZ(e, t) {
    return (
      this.normalized && (t = Mt(t, this.array)),
      (this.array[e * this.itemSize + 2] = Ni(t)),
      this
    );
  }
  getW(e) {
    let t = Wc(this.array[e * this.itemSize + 3]);
    return this.normalized && (t = Ui(t, this.array)), t;
  }
  setW(e, t) {
    return (
      this.normalized && (t = Mt(t, this.array)),
      (this.array[e * this.itemSize + 3] = Ni(t)),
      this
    );
  }
  setXY(e, t, i) {
    return (
      (e *= this.itemSize),
      this.normalized && ((t = Mt(t, this.array)), (i = Mt(i, this.array))),
      (this.array[e + 0] = Ni(t)),
      (this.array[e + 1] = Ni(i)),
      this
    );
  }
  setXYZ(e, t, i, r) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = Mt(t, this.array)),
        (i = Mt(i, this.array)),
        (r = Mt(r, this.array))),
      (this.array[e + 0] = Ni(t)),
      (this.array[e + 1] = Ni(i)),
      (this.array[e + 2] = Ni(r)),
      this
    );
  }
  setXYZW(e, t, i, r, s) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = Mt(t, this.array)),
        (i = Mt(i, this.array)),
        (r = Mt(r, this.array)),
        (s = Mt(s, this.array))),
      (this.array[e + 0] = Ni(t)),
      (this.array[e + 1] = Ni(i)),
      (this.array[e + 2] = Ni(r)),
      (this.array[e + 3] = Ni(s)),
      this
    );
  }
}
class Ze extends Ht {
  constructor(e, t, i) {
    super(new Float32Array(e), t, i);
  }
}
class uV extends Ht {
  constructor(e, t, i) {
    super(new Float64Array(e), t, i);
  }
}
let cV = 0;
const vr = new dt(),
  xy = new Ft(),
  Dl = new U(),
  Zi = new Ai(),
  Pc = new Ai(),
  Wn = new U();
class Tt extends Zs {
  constructor() {
    super(),
      (this.isBufferGeometry = !0),
      Object.defineProperty(this, "id", { value: cV++ }),
      (this.uuid = er()),
      (this.name = ""),
      (this.type = "BufferGeometry"),
      (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.morphTargetsRelative = !1),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.drawRange = { start: 0, count: 1 / 0 }),
      (this.userData = {});
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return (
      Array.isArray(e)
        ? (this.index = new (wL(e) ? US : OS)(e, 1))
        : (this.index = e),
      this
    );
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, t) {
    return (this.attributes[e] = t), this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, t, i = 0) {
    this.groups.push({ start: e, count: t, materialIndex: i });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, t) {
    (this.drawRange.start = e), (this.drawRange.count = t);
  }
  applyMatrix4(e) {
    const t = this.attributes.position;
    t !== void 0 && (t.applyMatrix4(e), (t.needsUpdate = !0));
    const i = this.attributes.normal;
    if (i !== void 0) {
      const s = new Et().getNormalMatrix(e);
      i.applyNormalMatrix(s), (i.needsUpdate = !0);
    }
    const r = this.attributes.tangent;
    return (
      r !== void 0 && (r.transformDirection(e), (r.needsUpdate = !0)),
      this.boundingBox !== null && this.computeBoundingBox(),
      this.boundingSphere !== null && this.computeBoundingSphere(),
      this
    );
  }
  applyQuaternion(e) {
    return vr.makeRotationFromQuaternion(e), this.applyMatrix4(vr), this;
  }
  rotateX(e) {
    return vr.makeRotationX(e), this.applyMatrix4(vr), this;
  }
  rotateY(e) {
    return vr.makeRotationY(e), this.applyMatrix4(vr), this;
  }
  rotateZ(e) {
    return vr.makeRotationZ(e), this.applyMatrix4(vr), this;
  }
  translate(e, t, i) {
    return vr.makeTranslation(e, t, i), this.applyMatrix4(vr), this;
  }
  scale(e, t, i) {
    return vr.makeScale(e, t, i), this.applyMatrix4(vr), this;
  }
  lookAt(e) {
    return xy.lookAt(e), xy.updateMatrix(), this.applyMatrix4(xy.matrix), this;
  }
  center() {
    return (
      this.computeBoundingBox(),
      this.boundingBox.getCenter(Dl).negate(),
      this.translate(Dl.x, Dl.y, Dl.z),
      this
    );
  }
  setFromPoints(e) {
    const t = [];
    for (let i = 0, r = e.length; i < r; i++) {
      const s = e[i];
      t.push(s.x, s.y, s.z || 0);
    }
    return this.setAttribute("position", new Ze(t, 3)), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Ai());
    const e = this.attributes.position,
      t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
        this
      ),
        this.boundingBox.set(
          new U(-1 / 0, -1 / 0, -1 / 0),
          new U(1 / 0, 1 / 0, 1 / 0)
        );
      return;
    }
    if (e !== void 0) {
      if ((this.boundingBox.setFromBufferAttribute(e), t))
        for (let i = 0, r = t.length; i < r; i++) {
          const s = t[i];
          Zi.setFromBufferAttribute(s),
            this.morphTargetsRelative
              ? (Wn.addVectors(this.boundingBox.min, Zi.min),
                this.boundingBox.expandByPoint(Wn),
                Wn.addVectors(this.boundingBox.max, Zi.max),
                this.boundingBox.expandByPoint(Wn))
              : (this.boundingBox.expandByPoint(Zi.min),
                this.boundingBox.expandByPoint(Zi.max));
        }
    } else this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) ||
      isNaN(this.boundingBox.min.y) ||
      isNaN(this.boundingBox.min.z)) &&
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
        this
      );
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new di());
    const e = this.attributes.position,
      t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error(
        'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
        this
      ),
        this.boundingSphere.set(new U(), 1 / 0);
      return;
    }
    if (e) {
      const i = this.boundingSphere.center;
      if ((Zi.setFromBufferAttribute(e), t))
        for (let s = 0, o = t.length; s < o; s++) {
          const a = t[s];
          Pc.setFromBufferAttribute(a),
            this.morphTargetsRelative
              ? (Wn.addVectors(Zi.min, Pc.min),
                Zi.expandByPoint(Wn),
                Wn.addVectors(Zi.max, Pc.max),
                Zi.expandByPoint(Wn))
              : (Zi.expandByPoint(Pc.min), Zi.expandByPoint(Pc.max));
        }
      Zi.getCenter(i);
      let r = 0;
      for (let s = 0, o = e.count; s < o; s++)
        Wn.fromBufferAttribute(e, s),
          (r = Math.max(r, i.distanceToSquared(Wn)));
      if (t)
        for (let s = 0, o = t.length; s < o; s++) {
          const a = t[s],
            u = this.morphTargetsRelative;
          for (let f = 0, h = a.count; f < h; f++)
            Wn.fromBufferAttribute(a, f),
              u && (Dl.fromBufferAttribute(e, f), Wn.add(Dl)),
              (r = Math.max(r, i.distanceToSquared(Wn)));
        }
      (this.boundingSphere.radius = Math.sqrt(r)),
        isNaN(this.boundingSphere.radius) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
            this
          );
    }
  }
  computeTangents() {
    const e = this.index,
      t = this.attributes;
    if (
      e === null ||
      t.position === void 0 ||
      t.normal === void 0 ||
      t.uv === void 0
    ) {
      console.error(
        "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
      );
      return;
    }
    const i = e.array,
      r = t.position.array,
      s = t.normal.array,
      o = t.uv.array,
      a = r.length / 3;
    this.hasAttribute("tangent") === !1 &&
      this.setAttribute("tangent", new Ht(new Float32Array(4 * a), 4));
    const u = this.getAttribute("tangent").array,
      f = [],
      h = [];
    for (let R = 0; R < a; R++) (f[R] = new U()), (h[R] = new U());
    const d = new U(),
      p = new U(),
      m = new U(),
      y = new de(),
      w = new de(),
      S = new de(),
      v = new U(),
      M = new U();
    function _(R, B, Z) {
      d.fromArray(r, R * 3),
        p.fromArray(r, B * 3),
        m.fromArray(r, Z * 3),
        y.fromArray(o, R * 2),
        w.fromArray(o, B * 2),
        S.fromArray(o, Z * 2),
        p.sub(d),
        m.sub(d),
        w.sub(y),
        S.sub(y);
      const ae = 1 / (w.x * S.y - S.x * w.y);
      isFinite(ae) &&
        (v
          .copy(p)
          .multiplyScalar(S.y)
          .addScaledVector(m, -w.y)
          .multiplyScalar(ae),
        M.copy(m)
          .multiplyScalar(w.x)
          .addScaledVector(p, -S.x)
          .multiplyScalar(ae),
        f[R].add(v),
        f[B].add(v),
        f[Z].add(v),
        h[R].add(M),
        h[B].add(M),
        h[Z].add(M));
    }
    let T = this.groups;
    T.length === 0 && (T = [{ start: 0, count: i.length }]);
    for (let R = 0, B = T.length; R < B; ++R) {
      const Z = T[R],
        ae = Z.start,
        V = Z.count;
      for (let Q = ae, $ = ae + V; Q < $; Q += 3)
        _(i[Q + 0], i[Q + 1], i[Q + 2]);
    }
    const P = new U(),
      b = new U(),
      L = new U(),
      N = new U();
    function C(R) {
      L.fromArray(s, R * 3), N.copy(L);
      const B = f[R];
      P.copy(B),
        P.sub(L.multiplyScalar(L.dot(B))).normalize(),
        b.crossVectors(N, B);
      const ae = b.dot(h[R]) < 0 ? -1 : 1;
      (u[R * 4] = P.x),
        (u[R * 4 + 1] = P.y),
        (u[R * 4 + 2] = P.z),
        (u[R * 4 + 3] = ae);
    }
    for (let R = 0, B = T.length; R < B; ++R) {
      const Z = T[R],
        ae = Z.start,
        V = Z.count;
      for (let Q = ae, $ = ae + V; Q < $; Q += 3)
        C(i[Q + 0]), C(i[Q + 1]), C(i[Q + 2]);
    }
  }
  computeVertexNormals() {
    const e = this.index,
      t = this.getAttribute("position");
    if (t !== void 0) {
      let i = this.getAttribute("normal");
      if (i === void 0)
        (i = new Ht(new Float32Array(t.count * 3), 3)),
          this.setAttribute("normal", i);
      else for (let p = 0, m = i.count; p < m; p++) i.setXYZ(p, 0, 0, 0);
      const r = new U(),
        s = new U(),
        o = new U(),
        a = new U(),
        u = new U(),
        f = new U(),
        h = new U(),
        d = new U();
      if (e)
        for (let p = 0, m = e.count; p < m; p += 3) {
          const y = e.getX(p + 0),
            w = e.getX(p + 1),
            S = e.getX(p + 2);
          r.fromBufferAttribute(t, y),
            s.fromBufferAttribute(t, w),
            o.fromBufferAttribute(t, S),
            h.subVectors(o, s),
            d.subVectors(r, s),
            h.cross(d),
            a.fromBufferAttribute(i, y),
            u.fromBufferAttribute(i, w),
            f.fromBufferAttribute(i, S),
            a.add(h),
            u.add(h),
            f.add(h),
            i.setXYZ(y, a.x, a.y, a.z),
            i.setXYZ(w, u.x, u.y, u.z),
            i.setXYZ(S, f.x, f.y, f.z);
        }
      else
        for (let p = 0, m = t.count; p < m; p += 3)
          r.fromBufferAttribute(t, p + 0),
            s.fromBufferAttribute(t, p + 1),
            o.fromBufferAttribute(t, p + 2),
            h.subVectors(o, s),
            d.subVectors(r, s),
            h.cross(d),
            i.setXYZ(p + 0, h.x, h.y, h.z),
            i.setXYZ(p + 1, h.x, h.y, h.z),
            i.setXYZ(p + 2, h.x, h.y, h.z);
      this.normalizeNormals(), (i.needsUpdate = !0);
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let t = 0, i = e.count; t < i; t++)
      Wn.fromBufferAttribute(e, t),
        Wn.normalize(),
        e.setXYZ(t, Wn.x, Wn.y, Wn.z);
  }
  toNonIndexed() {
    function e(a, u) {
      const f = a.array,
        h = a.itemSize,
        d = a.normalized,
        p = new f.constructor(u.length * h);
      let m = 0,
        y = 0;
      for (let w = 0, S = u.length; w < S; w++) {
        a.isInterleavedBufferAttribute
          ? (m = u[w] * a.data.stride + a.offset)
          : (m = u[w] * h);
        for (let v = 0; v < h; v++) p[y++] = f[m++];
      }
      return new Ht(p, h, d);
    }
    if (this.index === null)
      return (
        console.warn(
          "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
        ),
        this
      );
    const t = new Tt(),
      i = this.index.array,
      r = this.attributes;
    for (const a in r) {
      const u = r[a],
        f = e(u, i);
      t.setAttribute(a, f);
    }
    const s = this.morphAttributes;
    for (const a in s) {
      const u = [],
        f = s[a];
      for (let h = 0, d = f.length; h < d; h++) {
        const p = f[h],
          m = e(p, i);
        u.push(m);
      }
      t.morphAttributes[a] = u;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    const o = this.groups;
    for (let a = 0, u = o.length; a < u; a++) {
      const f = o[a];
      t.addGroup(f.start, f.count, f.materialIndex);
    }
    return t;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON",
      },
    };
    if (
      ((e.uuid = this.uuid),
      (e.type = this.type),
      this.name !== "" && (e.name = this.name),
      Object.keys(this.userData).length > 0 && (e.userData = this.userData),
      this.parameters !== void 0)
    ) {
      const u = this.parameters;
      for (const f in u) u[f] !== void 0 && (e[f] = u[f]);
      return e;
    }
    e.data = { attributes: {} };
    const t = this.index;
    t !== null &&
      (e.data.index = {
        type: t.array.constructor.name,
        array: Array.prototype.slice.call(t.array),
      });
    const i = this.attributes;
    for (const u in i) {
      const f = i[u];
      e.data.attributes[u] = f.toJSON(e.data);
    }
    const r = {};
    let s = !1;
    for (const u in this.morphAttributes) {
      const f = this.morphAttributes[u],
        h = [];
      for (let d = 0, p = f.length; d < p; d++) {
        const m = f[d];
        h.push(m.toJSON(e.data));
      }
      h.length > 0 && ((r[u] = h), (s = !0));
    }
    s &&
      ((e.data.morphAttributes = r),
      (e.data.morphTargetsRelative = this.morphTargetsRelative));
    const o = this.groups;
    o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
    const a = this.boundingSphere;
    return (
      a !== null &&
        (e.data.boundingSphere = {
          center: a.center.toArray(),
          radius: a.radius,
        }),
      e
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    const t = {};
    this.name = e.name;
    const i = e.index;
    i !== null && this.setIndex(i.clone(t));
    const r = e.attributes;
    for (const f in r) {
      const h = r[f];
      this.setAttribute(f, h.clone(t));
    }
    const s = e.morphAttributes;
    for (const f in s) {
      const h = [],
        d = s[f];
      for (let p = 0, m = d.length; p < m; p++) h.push(d[p].clone(t));
      this.morphAttributes[f] = h;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const o = e.groups;
    for (let f = 0, h = o.length; f < h; f++) {
      const d = o[f];
      this.addGroup(d.start, d.count, d.materialIndex);
    }
    const a = e.boundingBox;
    a !== null && (this.boundingBox = a.clone());
    const u = e.boundingSphere;
    return (
      u !== null && (this.boundingSphere = u.clone()),
      (this.drawRange.start = e.drawRange.start),
      (this.drawRange.count = e.drawRange.count),
      (this.userData = e.userData),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const U2 = new dt(),
  da = new rl(),
  lp = new di(),
  k2 = new U(),
  Ol = new U(),
  Ul = new U(),
  kl = new U(),
  _y = new U(),
  up = new U(),
  cp = new de(),
  fp = new de(),
  hp = new de(),
  F2 = new U(),
  z2 = new U(),
  B2 = new U(),
  dp = new U(),
  pp = new U();
class Un extends Ft {
  constructor(e = new Tt(), t = new Qo()) {
    super(),
      (this.isMesh = !0),
      (this.type = "Mesh"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.morphTargetInfluences !== void 0 &&
        (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
      e.morphTargetDictionary !== void 0 &&
        (this.morphTargetDictionary = Object.assign(
          {},
          e.morphTargetDictionary
        )),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      i = Object.keys(t);
    if (i.length > 0) {
      const r = t[i[0]];
      if (r !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let s = 0, o = r.length; s < o; s++) {
          const a = r[s].name || String(s);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[a] = s);
        }
      }
    }
  }
  getVertexPosition(e, t) {
    const i = this.geometry,
      r = i.attributes.position,
      s = i.morphAttributes.position,
      o = i.morphTargetsRelative;
    t.fromBufferAttribute(r, e);
    const a = this.morphTargetInfluences;
    if (s && a) {
      up.set(0, 0, 0);
      for (let u = 0, f = s.length; u < f; u++) {
        const h = a[u],
          d = s[u];
        h !== 0 &&
          (_y.fromBufferAttribute(d, e),
          o ? up.addScaledVector(_y, h) : up.addScaledVector(_y.sub(t), h));
      }
      t.add(up);
    }
    return t;
  }
  raycast(e, t) {
    const i = this.geometry,
      r = this.material,
      s = this.matrixWorld;
    r !== void 0 &&
      (i.boundingSphere === null && i.computeBoundingSphere(),
      lp.copy(i.boundingSphere),
      lp.applyMatrix4(s),
      da.copy(e.ray).recast(e.near),
      !(
        lp.containsPoint(da.origin) === !1 &&
        (da.intersectSphere(lp, k2) === null ||
          da.origin.distanceToSquared(k2) > (e.far - e.near) ** 2)
      ) &&
        (U2.copy(s).invert(),
        da.copy(e.ray).applyMatrix4(U2),
        !(i.boundingBox !== null && da.intersectsBox(i.boundingBox) === !1) &&
          this._computeIntersections(e, t, da)));
  }
  _computeIntersections(e, t, i) {
    let r;
    const s = this.geometry,
      o = this.material,
      a = s.index,
      u = s.attributes.position,
      f = s.attributes.uv,
      h = s.attributes.uv1,
      d = s.attributes.normal,
      p = s.groups,
      m = s.drawRange;
    if (a !== null)
      if (Array.isArray(o))
        for (let y = 0, w = p.length; y < w; y++) {
          const S = p[y],
            v = o[S.materialIndex],
            M = Math.max(S.start, m.start),
            _ = Math.min(
              a.count,
              Math.min(S.start + S.count, m.start + m.count)
            );
          for (let T = M, P = _; T < P; T += 3) {
            const b = a.getX(T),
              L = a.getX(T + 1),
              N = a.getX(T + 2);
            (r = mp(this, v, e, i, f, h, d, b, L, N)),
              r &&
                ((r.faceIndex = Math.floor(T / 3)),
                (r.face.materialIndex = S.materialIndex),
                t.push(r));
          }
        }
      else {
        const y = Math.max(0, m.start),
          w = Math.min(a.count, m.start + m.count);
        for (let S = y, v = w; S < v; S += 3) {
          const M = a.getX(S),
            _ = a.getX(S + 1),
            T = a.getX(S + 2);
          (r = mp(this, o, e, i, f, h, d, M, _, T)),
            r && ((r.faceIndex = Math.floor(S / 3)), t.push(r));
        }
      }
    else if (u !== void 0)
      if (Array.isArray(o))
        for (let y = 0, w = p.length; y < w; y++) {
          const S = p[y],
            v = o[S.materialIndex],
            M = Math.max(S.start, m.start),
            _ = Math.min(
              u.count,
              Math.min(S.start + S.count, m.start + m.count)
            );
          for (let T = M, P = _; T < P; T += 3) {
            const b = T,
              L = T + 1,
              N = T + 2;
            (r = mp(this, v, e, i, f, h, d, b, L, N)),
              r &&
                ((r.faceIndex = Math.floor(T / 3)),
                (r.face.materialIndex = S.materialIndex),
                t.push(r));
          }
        }
      else {
        const y = Math.max(0, m.start),
          w = Math.min(u.count, m.start + m.count);
        for (let S = y, v = w; S < v; S += 3) {
          const M = S,
            _ = S + 1,
            T = S + 2;
          (r = mp(this, o, e, i, f, h, d, M, _, T)),
            r && ((r.faceIndex = Math.floor(S / 3)), t.push(r));
        }
      }
  }
}
function fV(n, e, t, i, r, s, o, a) {
  let u;
  if (
    (e.side === Ti
      ? (u = i.intersectTriangle(o, s, r, !0, a))
      : (u = i.intersectTriangle(r, s, o, e.side === js, a)),
    u === null)
  )
    return null;
  pp.copy(a), pp.applyMatrix4(n.matrixWorld);
  const f = t.ray.origin.distanceTo(pp);
  return f < t.near || f > t.far
    ? null
    : { distance: f, point: pp.clone(), object: n };
}
function mp(n, e, t, i, r, s, o, a, u, f) {
  n.getVertexPosition(a, Ol),
    n.getVertexPosition(u, Ul),
    n.getVertexPosition(f, kl);
  const h = fV(n, e, t, i, Ol, Ul, kl, dp);
  if (h) {
    r &&
      (cp.fromBufferAttribute(r, a),
      fp.fromBufferAttribute(r, u),
      hp.fromBufferAttribute(r, f),
      (h.uv = Oi.getInterpolation(dp, Ol, Ul, kl, cp, fp, hp, new de()))),
      s &&
        (cp.fromBufferAttribute(s, a),
        fp.fromBufferAttribute(s, u),
        hp.fromBufferAttribute(s, f),
        (h.uv1 = Oi.getInterpolation(dp, Ol, Ul, kl, cp, fp, hp, new de())),
        (h.uv2 = h.uv1)),
      o &&
        (F2.fromBufferAttribute(o, a),
        z2.fromBufferAttribute(o, u),
        B2.fromBufferAttribute(o, f),
        (h.normal = Oi.getInterpolation(dp, Ol, Ul, kl, F2, z2, B2, new U())),
        h.normal.dot(i.direction) > 0 && h.normal.multiplyScalar(-1));
    const d = { a, b: u, c: f, normal: new U(), materialIndex: 0 };
    Oi.getNormal(Ol, Ul, kl, d.normal), (h.face = d);
  }
  return h;
}
class sl extends Tt {
  constructor(e = 1, t = 1, i = 1, r = 1, s = 1, o = 1) {
    super(),
      (this.type = "BoxGeometry"),
      (this.parameters = {
        width: e,
        height: t,
        depth: i,
        widthSegments: r,
        heightSegments: s,
        depthSegments: o,
      });
    const a = this;
    (r = Math.floor(r)), (s = Math.floor(s)), (o = Math.floor(o));
    const u = [],
      f = [],
      h = [],
      d = [];
    let p = 0,
      m = 0;
    y("z", "y", "x", -1, -1, i, t, e, o, s, 0),
      y("z", "y", "x", 1, -1, i, t, -e, o, s, 1),
      y("x", "z", "y", 1, 1, e, i, t, r, o, 2),
      y("x", "z", "y", 1, -1, e, i, -t, r, o, 3),
      y("x", "y", "z", 1, -1, e, t, i, r, s, 4),
      y("x", "y", "z", -1, -1, e, t, -i, r, s, 5),
      this.setIndex(u),
      this.setAttribute("position", new Ze(f, 3)),
      this.setAttribute("normal", new Ze(h, 3)),
      this.setAttribute("uv", new Ze(d, 2));
    function y(w, S, v, M, _, T, P, b, L, N, C) {
      const R = T / L,
        B = P / N,
        Z = T / 2,
        ae = P / 2,
        V = b / 2,
        Q = L + 1,
        $ = N + 1;
      let ce = 0,
        k = 0;
      const G = new U();
      for (let W = 0; W < $; W++) {
        const Y = W * B - ae;
        for (let ie = 0; ie < Q; ie++) {
          const J = ie * R - Z;
          (G[w] = J * M),
            (G[S] = Y * _),
            (G[v] = V),
            f.push(G.x, G.y, G.z),
            (G[w] = 0),
            (G[S] = 0),
            (G[v] = b > 0 ? 1 : -1),
            h.push(G.x, G.y, G.z),
            d.push(ie / L),
            d.push(1 - W / N),
            (ce += 1);
        }
      }
      for (let W = 0; W < N; W++)
        for (let Y = 0; Y < L; Y++) {
          const ie = p + Y + Q * W,
            J = p + Y + Q * (W + 1),
            he = p + (Y + 1) + Q * (W + 1),
            Ee = p + (Y + 1) + Q * W;
          u.push(ie, J, Ee), u.push(J, he, Ee), (k += 6);
        }
      a.addGroup(m, k, C), (m += k), (p += ce);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new sl(
      e.width,
      e.height,
      e.depth,
      e.widthSegments,
      e.heightSegments,
      e.depthSegments
    );
  }
}
function Fu(n) {
  const e = {};
  for (const t in n) {
    e[t] = {};
    for (const i in n[t]) {
      const r = n[t][i];
      r &&
      (r.isColor ||
        r.isMatrix3 ||
        r.isMatrix4 ||
        r.isVector2 ||
        r.isVector3 ||
        r.isVector4 ||
        r.isTexture ||
        r.isQuaternion)
        ? r.isRenderTargetTexture
          ? (console.warn(
              "UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."
            ),
            (e[t][i] = null))
          : (e[t][i] = r.clone())
        : Array.isArray(r)
        ? (e[t][i] = r.slice())
        : (e[t][i] = r);
    }
  }
  return e;
}
function _i(n) {
  const e = {};
  for (let t = 0; t < n.length; t++) {
    const i = Fu(n[t]);
    for (const r in i) e[r] = i[r];
  }
  return e;
}
function hV(n) {
  const e = [];
  for (let t = 0; t < n.length; t++) e.push(n[t].clone());
  return e;
}
function bL(n) {
  return n.getRenderTarget() === null
    ? n.outputColorSpace
    : zt.workingColorSpace;
}
const CL = { clone: Fu, merge: _i };
var dV = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
  pV = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class Hr extends gi {
  constructor(e) {
    super(),
      (this.isShaderMaterial = !0),
      (this.type = "ShaderMaterial"),
      (this.defines = {}),
      (this.uniforms = {}),
      (this.uniformsGroups = []),
      (this.vertexShader = dV),
      (this.fragmentShader = pV),
      (this.linewidth = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.lights = !1),
      (this.clipping = !1),
      (this.forceSinglePass = !0),
      (this.extensions = {
        derivatives: !1,
        fragDepth: !1,
        drawBuffers: !1,
        shaderTextureLOD: !1,
        clipCullDistance: !1,
      }),
      (this.defaultAttributeValues = {
        color: [1, 1, 1],
        uv: [0, 0],
        uv1: [0, 0],
      }),
      (this.index0AttributeName = void 0),
      (this.uniformsNeedUpdate = !1),
      (this.glslVersion = null),
      e !== void 0 && this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.fragmentShader = e.fragmentShader),
      (this.vertexShader = e.vertexShader),
      (this.uniforms = Fu(e.uniforms)),
      (this.uniformsGroups = hV(e.uniformsGroups)),
      (this.defines = Object.assign({}, e.defines)),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.fog = e.fog),
      (this.lights = e.lights),
      (this.clipping = e.clipping),
      (this.extensions = Object.assign({}, e.extensions)),
      (this.glslVersion = e.glslVersion),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    (t.glslVersion = this.glslVersion), (t.uniforms = {});
    for (const r in this.uniforms) {
      const o = this.uniforms[r].value;
      o && o.isTexture
        ? (t.uniforms[r] = { type: "t", value: o.toJSON(e).uuid })
        : o && o.isColor
        ? (t.uniforms[r] = { type: "c", value: o.getHex() })
        : o && o.isVector2
        ? (t.uniforms[r] = { type: "v2", value: o.toArray() })
        : o && o.isVector3
        ? (t.uniforms[r] = { type: "v3", value: o.toArray() })
        : o && o.isVector4
        ? (t.uniforms[r] = { type: "v4", value: o.toArray() })
        : o && o.isMatrix3
        ? (t.uniforms[r] = { type: "m3", value: o.toArray() })
        : o && o.isMatrix4
        ? (t.uniforms[r] = { type: "m4", value: o.toArray() })
        : (t.uniforms[r] = { value: o });
    }
    Object.keys(this.defines).length > 0 && (t.defines = this.defines),
      (t.vertexShader = this.vertexShader),
      (t.fragmentShader = this.fragmentShader),
      (t.lights = this.lights),
      (t.clipping = this.clipping);
    const i = {};
    for (const r in this.extensions) this.extensions[r] === !0 && (i[r] = !0);
    return Object.keys(i).length > 0 && (t.extensions = i), t;
  }
}
class xh extends Ft {
  constructor() {
    super(),
      (this.isCamera = !0),
      (this.type = "Camera"),
      (this.matrixWorldInverse = new dt()),
      (this.projectionMatrix = new dt()),
      (this.projectionMatrixInverse = new dt()),
      (this.coordinateSystem = kr);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.matrixWorldInverse.copy(e.matrixWorldInverse),
      this.projectionMatrix.copy(e.projectionMatrix),
      this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
      (this.coordinateSystem = e.coordinateSystem),
      this
    );
  }
  getWorldDirection(e) {
    return super.getWorldDirection(e).negate();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class En extends xh {
  constructor(e = 50, t = 1, i = 0.1, r = 2e3) {
    super(),
      (this.isPerspectiveCamera = !0),
      (this.type = "PerspectiveCamera"),
      (this.fov = e),
      (this.zoom = 1),
      (this.near = i),
      (this.far = r),
      (this.focus = 10),
      (this.aspect = t),
      (this.view = null),
      (this.filmGauge = 35),
      (this.filmOffset = 0),
      this.updateProjectionMatrix();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.fov = e.fov),
      (this.zoom = e.zoom),
      (this.near = e.near),
      (this.far = e.far),
      (this.focus = e.focus),
      (this.aspect = e.aspect),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      (this.filmGauge = e.filmGauge),
      (this.filmOffset = e.filmOffset),
      this
    );
  }
  setFocalLength(e) {
    const t = (0.5 * this.getFilmHeight()) / e;
    (this.fov = ku * 2 * Math.atan(t)), this.updateProjectionMatrix();
  }
  getFocalLength() {
    const e = Math.tan(Ha * 0.5 * this.fov);
    return (0.5 * this.getFilmHeight()) / e;
  }
  getEffectiveFOV() {
    return ku * 2 * Math.atan(Math.tan(Ha * 0.5 * this.fov) / this.zoom);
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  setViewOffset(e, t, i, r, s, o) {
    (this.aspect = e / t),
      this.view === null &&
        (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1,
        }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = i),
      (this.view.offsetY = r),
      (this.view.width = s),
      (this.view.height = o),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let t = (e * Math.tan(Ha * 0.5 * this.fov)) / this.zoom,
      i = 2 * t,
      r = this.aspect * i,
      s = -0.5 * r;
    const o = this.view;
    if (this.view !== null && this.view.enabled) {
      const u = o.fullWidth,
        f = o.fullHeight;
      (s += (o.offsetX * r) / u),
        (t -= (o.offsetY * i) / f),
        (r *= o.width / u),
        (i *= o.height / f);
    }
    const a = this.filmOffset;
    a !== 0 && (s += (e * a) / this.getFilmWidth()),
      this.projectionMatrix.makePerspective(
        s,
        s + r,
        t,
        t - i,
        e,
        this.far,
        this.coordinateSystem
      ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.fov = this.fov),
      (t.object.zoom = this.zoom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      (t.object.focus = this.focus),
      (t.object.aspect = this.aspect),
      this.view !== null && (t.object.view = Object.assign({}, this.view)),
      (t.object.filmGauge = this.filmGauge),
      (t.object.filmOffset = this.filmOffset),
      t
    );
  }
}
const Fl = -90,
  zl = 1;
class PL extends Ft {
  constructor(e, t, i) {
    super(),
      (this.type = "CubeCamera"),
      (this.renderTarget = i),
      (this.coordinateSystem = null),
      (this.activeMipmapLevel = 0);
    const r = new En(Fl, zl, e, t);
    (r.layers = this.layers), this.add(r);
    const s = new En(Fl, zl, e, t);
    (s.layers = this.layers), this.add(s);
    const o = new En(Fl, zl, e, t);
    (o.layers = this.layers), this.add(o);
    const a = new En(Fl, zl, e, t);
    (a.layers = this.layers), this.add(a);
    const u = new En(Fl, zl, e, t);
    (u.layers = this.layers), this.add(u);
    const f = new En(Fl, zl, e, t);
    (f.layers = this.layers), this.add(f);
  }
  updateCoordinateSystem() {
    const e = this.coordinateSystem,
      t = this.children.concat(),
      [i, r, s, o, a, u] = t;
    for (const f of t) this.remove(f);
    if (e === kr)
      i.up.set(0, 1, 0),
        i.lookAt(1, 0, 0),
        r.up.set(0, 1, 0),
        r.lookAt(-1, 0, 0),
        s.up.set(0, 0, -1),
        s.lookAt(0, 1, 0),
        o.up.set(0, 0, 1),
        o.lookAt(0, -1, 0),
        a.up.set(0, 1, 0),
        a.lookAt(0, 0, 1),
        u.up.set(0, 1, 0),
        u.lookAt(0, 0, -1);
    else if (e === Uu)
      i.up.set(0, -1, 0),
        i.lookAt(-1, 0, 0),
        r.up.set(0, -1, 0),
        r.lookAt(1, 0, 0),
        s.up.set(0, 0, 1),
        s.lookAt(0, 1, 0),
        o.up.set(0, 0, -1),
        o.lookAt(0, -1, 0),
        a.up.set(0, -1, 0),
        a.lookAt(0, 0, 1),
        u.up.set(0, -1, 0),
        u.lookAt(0, 0, -1);
    else
      throw new Error(
        "THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " +
          e
      );
    for (const f of t) this.add(f), f.updateMatrixWorld();
  }
  update(e, t) {
    this.parent === null && this.updateMatrixWorld();
    const { renderTarget: i, activeMipmapLevel: r } = this;
    this.coordinateSystem !== e.coordinateSystem &&
      ((this.coordinateSystem = e.coordinateSystem),
      this.updateCoordinateSystem());
    const [s, o, a, u, f, h] = this.children,
      d = e.getRenderTarget(),
      p = e.getActiveCubeFace(),
      m = e.getActiveMipmapLevel(),
      y = e.xr.enabled;
    e.xr.enabled = !1;
    const w = i.texture.generateMipmaps;
    (i.texture.generateMipmaps = !1),
      e.setRenderTarget(i, 0, r),
      e.render(t, s),
      e.setRenderTarget(i, 1, r),
      e.render(t, o),
      e.setRenderTarget(i, 2, r),
      e.render(t, a),
      e.setRenderTarget(i, 3, r),
      e.render(t, u),
      e.setRenderTarget(i, 4, r),
      e.render(t, f),
      (i.texture.generateMipmaps = w),
      e.setRenderTarget(i, 5, r),
      e.render(t, h),
      e.setRenderTarget(d, p, m),
      (e.xr.enabled = y),
      (i.texture.needsPMREMUpdate = !0);
  }
}
class _h extends An {
  constructor(e, t, i, r, s, o, a, u, f, h) {
    (e = e !== void 0 ? e : []),
      (t = t !== void 0 ? t : Xs),
      super(e, t, i, r, s, o, a, u, f, h),
      (this.isCubeTexture = !0),
      (this.flipY = !1);
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class RL extends Vr {
  constructor(e = 1, t = {}) {
    super(e, e, t), (this.isWebGLCubeRenderTarget = !0);
    const i = { width: e, height: e, depth: 1 },
      r = [i, i, i, i, i, i];
    t.encoding !== void 0 &&
      (lf(
        "THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."
      ),
      (t.colorSpace = t.encoding === ko ? Dn : Qi)),
      (this.texture = new _h(
        r,
        t.mapping,
        t.wrapS,
        t.wrapT,
        t.magFilter,
        t.minFilter,
        t.format,
        t.type,
        t.anisotropy,
        t.colorSpace
      )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.generateMipmaps =
        t.generateMipmaps !== void 0 ? t.generateMipmaps : !1),
      (this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : wn);
  }
  fromEquirectangularTexture(e, t) {
    (this.texture.type = t.type),
      (this.texture.colorSpace = t.colorSpace),
      (this.texture.generateMipmaps = t.generateMipmaps),
      (this.texture.minFilter = t.minFilter),
      (this.texture.magFilter = t.magFilter);
    const i = {
        uniforms: { tEquirect: { value: null } },
        vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
        fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`,
      },
      r = new sl(5, 5, 5),
      s = new Hr({
        name: "CubemapFromEquirect",
        uniforms: Fu(i.uniforms),
        vertexShader: i.vertexShader,
        fragmentShader: i.fragmentShader,
        side: Ti,
        blending: zs,
      });
    s.uniforms.tEquirect.value = t;
    const o = new Un(r, s),
      a = t.minFilter;
    return (
      t.minFilter === Wo && (t.minFilter = wn),
      new PL(1, 10, this).update(e, o),
      (t.minFilter = a),
      o.geometry.dispose(),
      o.material.dispose(),
      this
    );
  }
  clear(e, t, i, r) {
    const s = e.getRenderTarget();
    for (let o = 0; o < 6; o++) e.setRenderTarget(this, o), e.clear(t, i, r);
    e.setRenderTarget(s);
  }
}
const Sy = new U(),
  mV = new U(),
  gV = new Et();
class Ps {
  constructor(e = new U(1, 0, 0), t = 0) {
    (this.isPlane = !0), (this.normal = e), (this.constant = t);
  }
  set(e, t) {
    return this.normal.copy(e), (this.constant = t), this;
  }
  setComponents(e, t, i, r) {
    return this.normal.set(e, t, i), (this.constant = r), this;
  }
  setFromNormalAndCoplanarPoint(e, t) {
    return this.normal.copy(e), (this.constant = -t.dot(this.normal)), this;
  }
  setFromCoplanarPoints(e, t, i) {
    const r = Sy.subVectors(i, t).cross(mV.subVectors(e, t)).normalize();
    return this.setFromNormalAndCoplanarPoint(r, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), (this.constant = e.constant), this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), (this.constant *= e), this;
  }
  negate() {
    return (this.constant *= -1), this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, t) {
    return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  intersectLine(e, t) {
    const i = e.delta(Sy),
      r = this.normal.dot(i);
    if (r === 0)
      return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
    const s = -(e.start.dot(this.normal) + this.constant) / r;
    return s < 0 || s > 1 ? null : t.copy(e.start).addScaledVector(i, s);
  }
  intersectsLine(e) {
    const t = this.distanceToPoint(e.start),
      i = this.distanceToPoint(e.end);
    return (t < 0 && i > 0) || (i < 0 && t > 0);
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, t) {
    const i = t || gV.getNormalMatrix(e),
      r = this.coplanarPoint(Sy).applyMatrix4(e),
      s = this.normal.applyMatrix3(i).normalize();
    return (this.constant = -r.dot(s)), this;
  }
  translate(e) {
    return (this.constant -= e.dot(this.normal)), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const pa = new di(),
  gp = new U();
class Sh {
  constructor(
    e = new Ps(),
    t = new Ps(),
    i = new Ps(),
    r = new Ps(),
    s = new Ps(),
    o = new Ps()
  ) {
    this.planes = [e, t, i, r, s, o];
  }
  set(e, t, i, r, s, o) {
    const a = this.planes;
    return (
      a[0].copy(e),
      a[1].copy(t),
      a[2].copy(i),
      a[3].copy(r),
      a[4].copy(s),
      a[5].copy(o),
      this
    );
  }
  copy(e) {
    const t = this.planes;
    for (let i = 0; i < 6; i++) t[i].copy(e.planes[i]);
    return this;
  }
  setFromProjectionMatrix(e, t = kr) {
    const i = this.planes,
      r = e.elements,
      s = r[0],
      o = r[1],
      a = r[2],
      u = r[3],
      f = r[4],
      h = r[5],
      d = r[6],
      p = r[7],
      m = r[8],
      y = r[9],
      w = r[10],
      S = r[11],
      v = r[12],
      M = r[13],
      _ = r[14],
      T = r[15];
    if (
      (i[0].setComponents(u - s, p - f, S - m, T - v).normalize(),
      i[1].setComponents(u + s, p + f, S + m, T + v).normalize(),
      i[2].setComponents(u + o, p + h, S + y, T + M).normalize(),
      i[3].setComponents(u - o, p - h, S - y, T - M).normalize(),
      i[4].setComponents(u - a, p - d, S - w, T - _).normalize(),
      t === kr)
    )
      i[5].setComponents(u + a, p + d, S + w, T + _).normalize();
    else if (t === Uu) i[5].setComponents(a, d, w, _).normalize();
    else
      throw new Error(
        "THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " +
          t
      );
    return this;
  }
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      e.boundingSphere === null && e.computeBoundingSphere(),
        pa.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
    else {
      const t = e.geometry;
      t.boundingSphere === null && t.computeBoundingSphere(),
        pa.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
    }
    return this.intersectsSphere(pa);
  }
  intersectsSprite(e) {
    return (
      pa.center.set(0, 0, 0),
      (pa.radius = 0.7071067811865476),
      pa.applyMatrix4(e.matrixWorld),
      this.intersectsSphere(pa)
    );
  }
  intersectsSphere(e) {
    const t = this.planes,
      i = e.center,
      r = -e.radius;
    for (let s = 0; s < 6; s++) if (t[s].distanceToPoint(i) < r) return !1;
    return !0;
  }
  intersectsBox(e) {
    const t = this.planes;
    for (let i = 0; i < 6; i++) {
      const r = t[i];
      if (
        ((gp.x = r.normal.x > 0 ? e.max.x : e.min.x),
        (gp.y = r.normal.y > 0 ? e.max.y : e.min.y),
        (gp.z = r.normal.z > 0 ? e.max.z : e.min.z),
        r.distanceToPoint(gp) < 0)
      )
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const t = this.planes;
    for (let i = 0; i < 6; i++) if (t[i].distanceToPoint(e) < 0) return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function LL() {
  let n = null,
    e = !1,
    t = null,
    i = null;
  function r(s, o) {
    t(s, o), (i = n.requestAnimationFrame(r));
  }
  return {
    start: function () {
      e !== !0 && t !== null && ((i = n.requestAnimationFrame(r)), (e = !0));
    },
    stop: function () {
      n.cancelAnimationFrame(i), (e = !1);
    },
    setAnimationLoop: function (s) {
      t = s;
    },
    setContext: function (s) {
      n = s;
    },
  };
}
function vV(n, e) {
  const t = e.isWebGL2,
    i = new WeakMap();
  function r(f, h) {
    const d = f.array,
      p = f.usage,
      m = d.byteLength,
      y = n.createBuffer();
    n.bindBuffer(h, y), n.bufferData(h, d, p), f.onUploadCallback();
    let w;
    if (d instanceof Float32Array) w = n.FLOAT;
    else if (d instanceof Uint16Array)
      if (f.isFloat16BufferAttribute)
        if (t) w = n.HALF_FLOAT;
        else
          throw new Error(
            "THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."
          );
      else w = n.UNSIGNED_SHORT;
    else if (d instanceof Int16Array) w = n.SHORT;
    else if (d instanceof Uint32Array) w = n.UNSIGNED_INT;
    else if (d instanceof Int32Array) w = n.INT;
    else if (d instanceof Int8Array) w = n.BYTE;
    else if (d instanceof Uint8Array) w = n.UNSIGNED_BYTE;
    else if (d instanceof Uint8ClampedArray) w = n.UNSIGNED_BYTE;
    else
      throw new Error(
        "THREE.WebGLAttributes: Unsupported buffer data format: " + d
      );
    return {
      buffer: y,
      type: w,
      bytesPerElement: d.BYTES_PER_ELEMENT,
      version: f.version,
      size: m,
    };
  }
  function s(f, h, d) {
    const p = h.array,
      m = h._updateRange,
      y = h.updateRanges;
    if (
      (n.bindBuffer(d, f),
      m.count === -1 && y.length === 0 && n.bufferSubData(d, 0, p),
      y.length !== 0)
    ) {
      for (let w = 0, S = y.length; w < S; w++) {
        const v = y[w];
        t
          ? n.bufferSubData(
              d,
              v.start * p.BYTES_PER_ELEMENT,
              p,
              v.start,
              v.count
            )
          : n.bufferSubData(
              d,
              v.start * p.BYTES_PER_ELEMENT,
              p.subarray(v.start, v.start + v.count)
            );
      }
      h.clearUpdateRanges();
    }
    m.count !== -1 &&
      (t
        ? n.bufferSubData(
            d,
            m.offset * p.BYTES_PER_ELEMENT,
            p,
            m.offset,
            m.count
          )
        : n.bufferSubData(
            d,
            m.offset * p.BYTES_PER_ELEMENT,
            p.subarray(m.offset, m.offset + m.count)
          ),
      (m.count = -1)),
      h.onUploadCallback();
  }
  function o(f) {
    return f.isInterleavedBufferAttribute && (f = f.data), i.get(f);
  }
  function a(f) {
    f.isInterleavedBufferAttribute && (f = f.data);
    const h = i.get(f);
    h && (n.deleteBuffer(h.buffer), i.delete(f));
  }
  function u(f, h) {
    if (f.isGLBufferAttribute) {
      const p = i.get(f);
      (!p || p.version < f.version) &&
        i.set(f, {
          buffer: f.buffer,
          type: f.type,
          bytesPerElement: f.elementSize,
          version: f.version,
        });
      return;
    }
    f.isInterleavedBufferAttribute && (f = f.data);
    const d = i.get(f);
    if (d === void 0) i.set(f, r(f, h));
    else if (d.version < f.version) {
      if (d.size !== f.array.byteLength)
        throw new Error(
          "THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported."
        );
      s(d.buffer, f, h), (d.version = f.version);
    }
  }
  return { get: o, remove: a, update: u };
}
class Mh extends Tt {
  constructor(e = 1, t = 1, i = 1, r = 1) {
    super(),
      (this.type = "PlaneGeometry"),
      (this.parameters = {
        width: e,
        height: t,
        widthSegments: i,
        heightSegments: r,
      });
    const s = e / 2,
      o = t / 2,
      a = Math.floor(i),
      u = Math.floor(r),
      f = a + 1,
      h = u + 1,
      d = e / a,
      p = t / u,
      m = [],
      y = [],
      w = [],
      S = [];
    for (let v = 0; v < h; v++) {
      const M = v * p - o;
      for (let _ = 0; _ < f; _++) {
        const T = _ * d - s;
        y.push(T, -M, 0), w.push(0, 0, 1), S.push(_ / a), S.push(1 - v / u);
      }
    }
    for (let v = 0; v < u; v++)
      for (let M = 0; M < a; M++) {
        const _ = M + f * v,
          T = M + f * (v + 1),
          P = M + 1 + f * (v + 1),
          b = M + 1 + f * v;
        m.push(_, T, b), m.push(T, P, b);
      }
    this.setIndex(m),
      this.setAttribute("position", new Ze(y, 3)),
      this.setAttribute("normal", new Ze(w, 3)),
      this.setAttribute("uv", new Ze(S, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Mh(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
var yV = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,
  xV = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,
  _V = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,
  SV = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  MV = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,
  wV = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
  EV = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
  TV = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
  AV = `#ifdef USE_BATCHING
	attribute float batchId;
	uniform highp sampler2D batchingTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,
  bV = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( batchId );
#endif`,
  CV = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,
  PV = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
  RV = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,
  LV = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
  IV = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
  NV = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,
  DV = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
  OV = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
  UV = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
  kV = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
  FV = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
  zV = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,
  BV = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,
  VV = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,
  HV = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
  GV = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
  WV = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
  jV = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,
  XV = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
  YV = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
  qV = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
  ZV = `
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return sRGBTransferOETF( value );
}`,
  KV = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
  QV = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
  $V = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
  JV = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
  e8 = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
  t8 = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
  n8 = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
  i8 = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
  r8 = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
  s8 = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
  o8 = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,
  a8 = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
  l8 = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
  u8 = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
  c8 = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
  f8 = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,
  h8 = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
  d8 = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
  p8 = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
  m8 = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
  g8 = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,
  v8 = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
  y8 = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
  x8 = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
  _8 = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,
  S8 = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
  M8 = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  w8 = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,
  E8 = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,
  T8 = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
  A8 = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
  b8 = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
  C8 = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  P8 = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
  R8 = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
  L8 = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
  I8 = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,
  N8 = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,
  D8 = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,
  O8 = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,
  U8 = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
  k8 = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  F8 = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  z8 = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
  B8 = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,
  V8 = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,
  H8 = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,
  G8 = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,
  W8 = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
  j8 = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
  X8 = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,
  Y8 = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
  q8 = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
  Z8 = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
  K8 = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
  Q8 = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
  $8 = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
  J8 = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,
  eH = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
  tH = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
  nH = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
  iH = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
  rH = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,
  sH = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
  oH = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
  aH = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
  lH = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
  uH = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
  cH = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color *= toneMappingExposure;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	return color;
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
  fH = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,
  hH = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,
  dH = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  pH = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  mH = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,
  gH = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const vH = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
  yH = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  xH = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  _H = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  SH = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  MH = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  wH = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
  EH = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,
  TH = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
  AH = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
  bH = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
  CH = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  PH = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  RH = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  LH = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
  IH = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  NH = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  DH = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  OH = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
  UH = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  kH = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
  FH = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
  zH = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  BH = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  VH = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
  HH = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  GH = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  WH = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  jH = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
  XH = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  YH = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  qH = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  ZH = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  KH = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  St = {
    alphahash_fragment: yV,
    alphahash_pars_fragment: xV,
    alphamap_fragment: _V,
    alphamap_pars_fragment: SV,
    alphatest_fragment: MV,
    alphatest_pars_fragment: wV,
    aomap_fragment: EV,
    aomap_pars_fragment: TV,
    batching_pars_vertex: AV,
    batching_vertex: bV,
    begin_vertex: CV,
    beginnormal_vertex: PV,
    bsdfs: RV,
    iridescence_fragment: LV,
    bumpmap_pars_fragment: IV,
    clipping_planes_fragment: NV,
    clipping_planes_pars_fragment: DV,
    clipping_planes_pars_vertex: OV,
    clipping_planes_vertex: UV,
    color_fragment: kV,
    color_pars_fragment: FV,
    color_pars_vertex: zV,
    color_vertex: BV,
    common: VV,
    cube_uv_reflection_fragment: HV,
    defaultnormal_vertex: GV,
    displacementmap_pars_vertex: WV,
    displacementmap_vertex: jV,
    emissivemap_fragment: XV,
    emissivemap_pars_fragment: YV,
    colorspace_fragment: qV,
    colorspace_pars_fragment: ZV,
    envmap_fragment: KV,
    envmap_common_pars_fragment: QV,
    envmap_pars_fragment: $V,
    envmap_pars_vertex: JV,
    envmap_physical_pars_fragment: f8,
    envmap_vertex: e8,
    fog_vertex: t8,
    fog_pars_vertex: n8,
    fog_fragment: i8,
    fog_pars_fragment: r8,
    gradientmap_pars_fragment: s8,
    lightmap_fragment: o8,
    lightmap_pars_fragment: a8,
    lights_lambert_fragment: l8,
    lights_lambert_pars_fragment: u8,
    lights_pars_begin: c8,
    lights_toon_fragment: h8,
    lights_toon_pars_fragment: d8,
    lights_phong_fragment: p8,
    lights_phong_pars_fragment: m8,
    lights_physical_fragment: g8,
    lights_physical_pars_fragment: v8,
    lights_fragment_begin: y8,
    lights_fragment_maps: x8,
    lights_fragment_end: _8,
    logdepthbuf_fragment: S8,
    logdepthbuf_pars_fragment: M8,
    logdepthbuf_pars_vertex: w8,
    logdepthbuf_vertex: E8,
    map_fragment: T8,
    map_pars_fragment: A8,
    map_particle_fragment: b8,
    map_particle_pars_fragment: C8,
    metalnessmap_fragment: P8,
    metalnessmap_pars_fragment: R8,
    morphcolor_vertex: L8,
    morphnormal_vertex: I8,
    morphtarget_pars_vertex: N8,
    morphtarget_vertex: D8,
    normal_fragment_begin: O8,
    normal_fragment_maps: U8,
    normal_pars_fragment: k8,
    normal_pars_vertex: F8,
    normal_vertex: z8,
    normalmap_pars_fragment: B8,
    clearcoat_normal_fragment_begin: V8,
    clearcoat_normal_fragment_maps: H8,
    clearcoat_pars_fragment: G8,
    iridescence_pars_fragment: W8,
    opaque_fragment: j8,
    packing: X8,
    premultiplied_alpha_fragment: Y8,
    project_vertex: q8,
    dithering_fragment: Z8,
    dithering_pars_fragment: K8,
    roughnessmap_fragment: Q8,
    roughnessmap_pars_fragment: $8,
    shadowmap_pars_fragment: J8,
    shadowmap_pars_vertex: eH,
    shadowmap_vertex: tH,
    shadowmask_pars_fragment: nH,
    skinbase_vertex: iH,
    skinning_pars_vertex: rH,
    skinning_vertex: sH,
    skinnormal_vertex: oH,
    specularmap_fragment: aH,
    specularmap_pars_fragment: lH,
    tonemapping_fragment: uH,
    tonemapping_pars_fragment: cH,
    transmission_fragment: fH,
    transmission_pars_fragment: hH,
    uv_pars_fragment: dH,
    uv_pars_vertex: pH,
    uv_vertex: mH,
    worldpos_vertex: gH,
    background_vert: vH,
    background_frag: yH,
    backgroundCube_vert: xH,
    backgroundCube_frag: _H,
    cube_vert: SH,
    cube_frag: MH,
    depth_vert: wH,
    depth_frag: EH,
    distanceRGBA_vert: TH,
    distanceRGBA_frag: AH,
    equirect_vert: bH,
    equirect_frag: CH,
    linedashed_vert: PH,
    linedashed_frag: RH,
    meshbasic_vert: LH,
    meshbasic_frag: IH,
    meshlambert_vert: NH,
    meshlambert_frag: DH,
    meshmatcap_vert: OH,
    meshmatcap_frag: UH,
    meshnormal_vert: kH,
    meshnormal_frag: FH,
    meshphong_vert: zH,
    meshphong_frag: BH,
    meshphysical_vert: VH,
    meshphysical_frag: HH,
    meshtoon_vert: GH,
    meshtoon_frag: WH,
    points_vert: jH,
    points_frag: XH,
    shadow_vert: YH,
    shadow_frag: qH,
    sprite_vert: ZH,
    sprite_frag: KH,
  },
  Re = {
    common: {
      diffuse: { value: new Be(16777215) },
      opacity: { value: 1 },
      map: { value: null },
      mapTransform: { value: new Et() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new Et() },
      alphaTest: { value: 0 },
    },
    specularmap: {
      specularMap: { value: null },
      specularMapTransform: { value: new Et() },
    },
    envmap: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      reflectivity: { value: 1 },
      ior: { value: 1.5 },
      refractionRatio: { value: 0.98 },
    },
    aomap: {
      aoMap: { value: null },
      aoMapIntensity: { value: 1 },
      aoMapTransform: { value: new Et() },
    },
    lightmap: {
      lightMap: { value: null },
      lightMapIntensity: { value: 1 },
      lightMapTransform: { value: new Et() },
    },
    bumpmap: {
      bumpMap: { value: null },
      bumpMapTransform: { value: new Et() },
      bumpScale: { value: 1 },
    },
    normalmap: {
      normalMap: { value: null },
      normalMapTransform: { value: new Et() },
      normalScale: { value: new de(1, 1) },
    },
    displacementmap: {
      displacementMap: { value: null },
      displacementMapTransform: { value: new Et() },
      displacementScale: { value: 1 },
      displacementBias: { value: 0 },
    },
    emissivemap: {
      emissiveMap: { value: null },
      emissiveMapTransform: { value: new Et() },
    },
    metalnessmap: {
      metalnessMap: { value: null },
      metalnessMapTransform: { value: new Et() },
    },
    roughnessmap: {
      roughnessMap: { value: null },
      roughnessMapTransform: { value: new Et() },
    },
    gradientmap: { gradientMap: { value: null } },
    fog: {
      fogDensity: { value: 25e-5 },
      fogNear: { value: 1 },
      fogFar: { value: 2e3 },
      fogColor: { value: new Be(16777215) },
    },
    lights: {
      ambientLightColor: { value: [] },
      lightProbe: { value: [] },
      directionalLights: {
        value: [],
        properties: { direction: {}, color: {} },
      },
      directionalLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      directionalShadowMap: { value: [] },
      directionalShadowMatrix: { value: [] },
      spotLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {},
        },
      },
      spotLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      spotLightMap: { value: [] },
      spotShadowMap: { value: [] },
      spotLightMatrix: { value: [] },
      pointLights: {
        value: [],
        properties: { color: {}, position: {}, decay: {}, distance: {} },
      },
      pointLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {},
        },
      },
      pointShadowMap: { value: [] },
      pointShadowMatrix: { value: [] },
      hemisphereLights: {
        value: [],
        properties: { direction: {}, skyColor: {}, groundColor: {} },
      },
      rectAreaLights: {
        value: [],
        properties: { color: {}, position: {}, width: {}, height: {} },
      },
      ltc_1: { value: null },
      ltc_2: { value: null },
    },
    points: {
      diffuse: { value: new Be(16777215) },
      opacity: { value: 1 },
      size: { value: 1 },
      scale: { value: 1 },
      map: { value: null },
      alphaMap: { value: null },
      alphaMapTransform: { value: new Et() },
      alphaTest: { value: 0 },
      uvTransform: { value: new Et() },
    },
    sprite: {
      diffuse: { value: new Be(16777215) },
      opacity: { value: 1 },
      center: { value: new de(0.5, 0.5) },
      rotation: { value: 0 },
      map: { value: null },
      mapTransform: { value: new Et() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new Et() },
      alphaTest: { value: 0 },
    },
  },
  Or = {
    basic: {
      uniforms: _i([
        Re.common,
        Re.specularmap,
        Re.envmap,
        Re.aomap,
        Re.lightmap,
        Re.fog,
      ]),
      vertexShader: St.meshbasic_vert,
      fragmentShader: St.meshbasic_frag,
    },
    lambert: {
      uniforms: _i([
        Re.common,
        Re.specularmap,
        Re.envmap,
        Re.aomap,
        Re.lightmap,
        Re.emissivemap,
        Re.bumpmap,
        Re.normalmap,
        Re.displacementmap,
        Re.fog,
        Re.lights,
        { emissive: { value: new Be(0) } },
      ]),
      vertexShader: St.meshlambert_vert,
      fragmentShader: St.meshlambert_frag,
    },
    phong: {
      uniforms: _i([
        Re.common,
        Re.specularmap,
        Re.envmap,
        Re.aomap,
        Re.lightmap,
        Re.emissivemap,
        Re.bumpmap,
        Re.normalmap,
        Re.displacementmap,
        Re.fog,
        Re.lights,
        {
          emissive: { value: new Be(0) },
          specular: { value: new Be(1118481) },
          shininess: { value: 30 },
        },
      ]),
      vertexShader: St.meshphong_vert,
      fragmentShader: St.meshphong_frag,
    },
    standard: {
      uniforms: _i([
        Re.common,
        Re.envmap,
        Re.aomap,
        Re.lightmap,
        Re.emissivemap,
        Re.bumpmap,
        Re.normalmap,
        Re.displacementmap,
        Re.roughnessmap,
        Re.metalnessmap,
        Re.fog,
        Re.lights,
        {
          emissive: { value: new Be(0) },
          roughness: { value: 1 },
          metalness: { value: 0 },
          envMapIntensity: { value: 1 },
        },
      ]),
      vertexShader: St.meshphysical_vert,
      fragmentShader: St.meshphysical_frag,
    },
    toon: {
      uniforms: _i([
        Re.common,
        Re.aomap,
        Re.lightmap,
        Re.emissivemap,
        Re.bumpmap,
        Re.normalmap,
        Re.displacementmap,
        Re.gradientmap,
        Re.fog,
        Re.lights,
        { emissive: { value: new Be(0) } },
      ]),
      vertexShader: St.meshtoon_vert,
      fragmentShader: St.meshtoon_frag,
    },
    matcap: {
      uniforms: _i([
        Re.common,
        Re.bumpmap,
        Re.normalmap,
        Re.displacementmap,
        Re.fog,
        { matcap: { value: null } },
      ]),
      vertexShader: St.meshmatcap_vert,
      fragmentShader: St.meshmatcap_frag,
    },
    points: {
      uniforms: _i([Re.points, Re.fog]),
      vertexShader: St.points_vert,
      fragmentShader: St.points_frag,
    },
    dashed: {
      uniforms: _i([
        Re.common,
        Re.fog,
        {
          scale: { value: 1 },
          dashSize: { value: 1 },
          totalSize: { value: 2 },
        },
      ]),
      vertexShader: St.linedashed_vert,
      fragmentShader: St.linedashed_frag,
    },
    depth: {
      uniforms: _i([Re.common, Re.displacementmap]),
      vertexShader: St.depth_vert,
      fragmentShader: St.depth_frag,
    },
    normal: {
      uniforms: _i([
        Re.common,
        Re.bumpmap,
        Re.normalmap,
        Re.displacementmap,
        { opacity: { value: 1 } },
      ]),
      vertexShader: St.meshnormal_vert,
      fragmentShader: St.meshnormal_frag,
    },
    sprite: {
      uniforms: _i([Re.sprite, Re.fog]),
      vertexShader: St.sprite_vert,
      fragmentShader: St.sprite_frag,
    },
    background: {
      uniforms: {
        uvTransform: { value: new Et() },
        t2D: { value: null },
        backgroundIntensity: { value: 1 },
      },
      vertexShader: St.background_vert,
      fragmentShader: St.background_frag,
    },
    backgroundCube: {
      uniforms: {
        envMap: { value: null },
        flipEnvMap: { value: -1 },
        backgroundBlurriness: { value: 0 },
        backgroundIntensity: { value: 1 },
      },
      vertexShader: St.backgroundCube_vert,
      fragmentShader: St.backgroundCube_frag,
    },
    cube: {
      uniforms: {
        tCube: { value: null },
        tFlip: { value: -1 },
        opacity: { value: 1 },
      },
      vertexShader: St.cube_vert,
      fragmentShader: St.cube_frag,
    },
    equirect: {
      uniforms: { tEquirect: { value: null } },
      vertexShader: St.equirect_vert,
      fragmentShader: St.equirect_frag,
    },
    distanceRGBA: {
      uniforms: _i([
        Re.common,
        Re.displacementmap,
        {
          referencePosition: { value: new U() },
          nearDistance: { value: 1 },
          farDistance: { value: 1e3 },
        },
      ]),
      vertexShader: St.distanceRGBA_vert,
      fragmentShader: St.distanceRGBA_frag,
    },
    shadow: {
      uniforms: _i([
        Re.lights,
        Re.fog,
        { color: { value: new Be(0) }, opacity: { value: 1 } },
      ]),
      vertexShader: St.shadow_vert,
      fragmentShader: St.shadow_frag,
    },
  };
Or.physical = {
  uniforms: _i([
    Or.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: new Et() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: new Et() },
      clearcoatNormalScale: { value: new de(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: new Et() },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: new Et() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: new Et() },
      sheen: { value: 0 },
      sheenColor: { value: new Be(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: new Et() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: new Et() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: new Et() },
      transmissionSamplerSize: { value: new de() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: new Et() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: new Be(0) },
      specularColor: { value: new Be(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: new Et() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: new Et() },
      anisotropyVector: { value: new de() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: new Et() },
    },
  ]),
  vertexShader: St.meshphysical_vert,
  fragmentShader: St.meshphysical_frag,
};
const vp = { r: 0, b: 0, g: 0 };
function QH(n, e, t, i, r, s, o) {
  const a = new Be(0);
  let u = s === !0 ? 0 : 1,
    f,
    h,
    d = null,
    p = 0,
    m = null;
  function y(S, v) {
    let M = !1,
      _ = v.isScene === !0 ? v.background : null;
    _ && _.isTexture && (_ = (v.backgroundBlurriness > 0 ? t : e).get(_)),
      _ === null ? w(a, u) : _ && _.isColor && (w(_, 1), (M = !0));
    const T = n.xr.getEnvironmentBlendMode();
    T === "additive"
      ? i.buffers.color.setClear(0, 0, 0, 1, o)
      : T === "alpha-blend" && i.buffers.color.setClear(0, 0, 0, 0, o),
      (n.autoClear || M) &&
        n.clear(n.autoClearColor, n.autoClearDepth, n.autoClearStencil),
      _ && (_.isCubeTexture || _.mapping === ju)
        ? (h === void 0 &&
            ((h = new Un(
              new sl(1, 1, 1),
              new Hr({
                name: "BackgroundCubeMaterial",
                uniforms: Fu(Or.backgroundCube.uniforms),
                vertexShader: Or.backgroundCube.vertexShader,
                fragmentShader: Or.backgroundCube.fragmentShader,
                side: Ti,
                depthTest: !1,
                depthWrite: !1,
                fog: !1,
              })
            )),
            h.geometry.deleteAttribute("normal"),
            h.geometry.deleteAttribute("uv"),
            (h.onBeforeRender = function (P, b, L) {
              this.matrixWorld.copyPosition(L.matrixWorld);
            }),
            Object.defineProperty(h.material, "envMap", {
              get: function () {
                return this.uniforms.envMap.value;
              },
            }),
            r.update(h)),
          (h.material.uniforms.envMap.value = _),
          (h.material.uniforms.flipEnvMap.value =
            _.isCubeTexture && _.isRenderTargetTexture === !1 ? -1 : 1),
          (h.material.uniforms.backgroundBlurriness.value =
            v.backgroundBlurriness),
          (h.material.uniforms.backgroundIntensity.value =
            v.backgroundIntensity),
          (h.material.toneMapped = zt.getTransfer(_.colorSpace) !== jt),
          (d !== _ || p !== _.version || m !== n.toneMapping) &&
            ((h.material.needsUpdate = !0),
            (d = _),
            (p = _.version),
            (m = n.toneMapping)),
          h.layers.enableAll(),
          S.unshift(h, h.geometry, h.material, 0, 0, null))
        : _ &&
          _.isTexture &&
          (f === void 0 &&
            ((f = new Un(
              new Mh(2, 2),
              new Hr({
                name: "BackgroundMaterial",
                uniforms: Fu(Or.background.uniforms),
                vertexShader: Or.background.vertexShader,
                fragmentShader: Or.background.fragmentShader,
                side: js,
                depthTest: !1,
                depthWrite: !1,
                fog: !1,
              })
            )),
            f.geometry.deleteAttribute("normal"),
            Object.defineProperty(f.material, "map", {
              get: function () {
                return this.uniforms.t2D.value;
              },
            }),
            r.update(f)),
          (f.material.uniforms.t2D.value = _),
          (f.material.uniforms.backgroundIntensity.value =
            v.backgroundIntensity),
          (f.material.toneMapped = zt.getTransfer(_.colorSpace) !== jt),
          _.matrixAutoUpdate === !0 && _.updateMatrix(),
          f.material.uniforms.uvTransform.value.copy(_.matrix),
          (d !== _ || p !== _.version || m !== n.toneMapping) &&
            ((f.material.needsUpdate = !0),
            (d = _),
            (p = _.version),
            (m = n.toneMapping)),
          f.layers.enableAll(),
          S.unshift(f, f.geometry, f.material, 0, 0, null));
  }
  function w(S, v) {
    S.getRGB(vp, bL(n)), i.buffers.color.setClear(vp.r, vp.g, vp.b, v, o);
  }
  return {
    getClearColor: function () {
      return a;
    },
    setClearColor: function (S, v = 1) {
      a.set(S), (u = v), w(a, u);
    },
    getClearAlpha: function () {
      return u;
    },
    setClearAlpha: function (S) {
      (u = S), w(a, u);
    },
    render: y,
  };
}
function $H(n, e, t, i) {
  const r = n.getParameter(n.MAX_VERTEX_ATTRIBS),
    s = i.isWebGL2 ? null : e.get("OES_vertex_array_object"),
    o = i.isWebGL2 || s !== null,
    a = {},
    u = S(null);
  let f = u,
    h = !1;
  function d(V, Q, $, ce, k) {
    let G = !1;
    if (o) {
      const W = w(ce, $, Q);
      f !== W && ((f = W), m(f.object)),
        (G = v(V, ce, $, k)),
        G && M(V, ce, $, k);
    } else {
      const W = Q.wireframe === !0;
      (f.geometry !== ce.id || f.program !== $.id || f.wireframe !== W) &&
        ((f.geometry = ce.id), (f.program = $.id), (f.wireframe = W), (G = !0));
    }
    k !== null && t.update(k, n.ELEMENT_ARRAY_BUFFER),
      (G || h) &&
        ((h = !1),
        N(V, Q, $, ce),
        k !== null && n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, t.get(k).buffer));
  }
  function p() {
    return i.isWebGL2 ? n.createVertexArray() : s.createVertexArrayOES();
  }
  function m(V) {
    return i.isWebGL2 ? n.bindVertexArray(V) : s.bindVertexArrayOES(V);
  }
  function y(V) {
    return i.isWebGL2 ? n.deleteVertexArray(V) : s.deleteVertexArrayOES(V);
  }
  function w(V, Q, $) {
    const ce = $.wireframe === !0;
    let k = a[V.id];
    k === void 0 && ((k = {}), (a[V.id] = k));
    let G = k[Q.id];
    G === void 0 && ((G = {}), (k[Q.id] = G));
    let W = G[ce];
    return W === void 0 && ((W = S(p())), (G[ce] = W)), W;
  }
  function S(V) {
    const Q = [],
      $ = [],
      ce = [];
    for (let k = 0; k < r; k++) (Q[k] = 0), ($[k] = 0), (ce[k] = 0);
    return {
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: Q,
      enabledAttributes: $,
      attributeDivisors: ce,
      object: V,
      attributes: {},
      index: null,
    };
  }
  function v(V, Q, $, ce) {
    const k = f.attributes,
      G = Q.attributes;
    let W = 0;
    const Y = $.getAttributes();
    for (const ie in Y)
      if (Y[ie].location >= 0) {
        const he = k[ie];
        let Ee = G[ie];
        if (
          (Ee === void 0 &&
            (ie === "instanceMatrix" &&
              V.instanceMatrix &&
              (Ee = V.instanceMatrix),
            ie === "instanceColor" &&
              V.instanceColor &&
              (Ee = V.instanceColor)),
          he === void 0 || he.attribute !== Ee || (Ee && he.data !== Ee.data))
        )
          return !0;
        W++;
      }
    return f.attributesNum !== W || f.index !== ce;
  }
  function M(V, Q, $, ce) {
    const k = {},
      G = Q.attributes;
    let W = 0;
    const Y = $.getAttributes();
    for (const ie in Y)
      if (Y[ie].location >= 0) {
        let he = G[ie];
        he === void 0 &&
          (ie === "instanceMatrix" &&
            V.instanceMatrix &&
            (he = V.instanceMatrix),
          ie === "instanceColor" && V.instanceColor && (he = V.instanceColor));
        const Ee = {};
        (Ee.attribute = he),
          he && he.data && (Ee.data = he.data),
          (k[ie] = Ee),
          W++;
      }
    (f.attributes = k), (f.attributesNum = W), (f.index = ce);
  }
  function _() {
    const V = f.newAttributes;
    for (let Q = 0, $ = V.length; Q < $; Q++) V[Q] = 0;
  }
  function T(V) {
    P(V, 0);
  }
  function P(V, Q) {
    const $ = f.newAttributes,
      ce = f.enabledAttributes,
      k = f.attributeDivisors;
    ($[V] = 1),
      ce[V] === 0 && (n.enableVertexAttribArray(V), (ce[V] = 1)),
      k[V] !== Q &&
        ((i.isWebGL2 ? n : e.get("ANGLE_instanced_arrays"))[
          i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
        ](V, Q),
        (k[V] = Q));
  }
  function b() {
    const V = f.newAttributes,
      Q = f.enabledAttributes;
    for (let $ = 0, ce = Q.length; $ < ce; $++)
      Q[$] !== V[$] && (n.disableVertexAttribArray($), (Q[$] = 0));
  }
  function L(V, Q, $, ce, k, G, W) {
    W === !0
      ? n.vertexAttribIPointer(V, Q, $, k, G)
      : n.vertexAttribPointer(V, Q, $, ce, k, G);
  }
  function N(V, Q, $, ce) {
    if (
      i.isWebGL2 === !1 &&
      (V.isInstancedMesh || ce.isInstancedBufferGeometry) &&
      e.get("ANGLE_instanced_arrays") === null
    )
      return;
    _();
    const k = ce.attributes,
      G = $.getAttributes(),
      W = Q.defaultAttributeValues;
    for (const Y in G) {
      const ie = G[Y];
      if (ie.location >= 0) {
        let J = k[Y];
        if (
          (J === void 0 &&
            (Y === "instanceMatrix" &&
              V.instanceMatrix &&
              (J = V.instanceMatrix),
            Y === "instanceColor" && V.instanceColor && (J = V.instanceColor)),
          J !== void 0)
        ) {
          const he = J.normalized,
            Ee = J.itemSize,
            be = t.get(J);
          if (be === void 0) continue;
          const Pe = be.buffer,
            it = be.type,
            rt = be.bytesPerElement,
            Ve =
              i.isWebGL2 === !0 &&
              (it === n.INT || it === n.UNSIGNED_INT || J.gpuType === MS);
          if (J.isInterleavedBufferAttribute) {
            const We = J.data,
              H = We.stride,
              Me = J.offset;
            if (We.isInstancedInterleavedBuffer) {
              for (let pe = 0; pe < ie.locationSize; pe++)
                P(ie.location + pe, We.meshPerAttribute);
              V.isInstancedMesh !== !0 &&
                ce._maxInstanceCount === void 0 &&
                (ce._maxInstanceCount = We.meshPerAttribute * We.count);
            } else
              for (let pe = 0; pe < ie.locationSize; pe++) T(ie.location + pe);
            n.bindBuffer(n.ARRAY_BUFFER, Pe);
            for (let pe = 0; pe < ie.locationSize; pe++)
              L(
                ie.location + pe,
                Ee / ie.locationSize,
                it,
                he,
                H * rt,
                (Me + (Ee / ie.locationSize) * pe) * rt,
                Ve
              );
          } else {
            if (J.isInstancedBufferAttribute) {
              for (let We = 0; We < ie.locationSize; We++)
                P(ie.location + We, J.meshPerAttribute);
              V.isInstancedMesh !== !0 &&
                ce._maxInstanceCount === void 0 &&
                (ce._maxInstanceCount = J.meshPerAttribute * J.count);
            } else
              for (let We = 0; We < ie.locationSize; We++) T(ie.location + We);
            n.bindBuffer(n.ARRAY_BUFFER, Pe);
            for (let We = 0; We < ie.locationSize; We++)
              L(
                ie.location + We,
                Ee / ie.locationSize,
                it,
                he,
                Ee * rt,
                (Ee / ie.locationSize) * We * rt,
                Ve
              );
          }
        } else if (W !== void 0) {
          const he = W[Y];
          if (he !== void 0)
            switch (he.length) {
              case 2:
                n.vertexAttrib2fv(ie.location, he);
                break;
              case 3:
                n.vertexAttrib3fv(ie.location, he);
                break;
              case 4:
                n.vertexAttrib4fv(ie.location, he);
                break;
              default:
                n.vertexAttrib1fv(ie.location, he);
            }
        }
      }
    }
    b();
  }
  function C() {
    Z();
    for (const V in a) {
      const Q = a[V];
      for (const $ in Q) {
        const ce = Q[$];
        for (const k in ce) y(ce[k].object), delete ce[k];
        delete Q[$];
      }
      delete a[V];
    }
  }
  function R(V) {
    if (a[V.id] === void 0) return;
    const Q = a[V.id];
    for (const $ in Q) {
      const ce = Q[$];
      for (const k in ce) y(ce[k].object), delete ce[k];
      delete Q[$];
    }
    delete a[V.id];
  }
  function B(V) {
    for (const Q in a) {
      const $ = a[Q];
      if ($[V.id] === void 0) continue;
      const ce = $[V.id];
      for (const k in ce) y(ce[k].object), delete ce[k];
      delete $[V.id];
    }
  }
  function Z() {
    ae(), (h = !0), f !== u && ((f = u), m(f.object));
  }
  function ae() {
    (u.geometry = null), (u.program = null), (u.wireframe = !1);
  }
  return {
    setup: d,
    reset: Z,
    resetDefaultState: ae,
    dispose: C,
    releaseStatesOfGeometry: R,
    releaseStatesOfProgram: B,
    initAttributes: _,
    enableAttribute: T,
    disableUnusedAttributes: b,
  };
}
function JH(n, e, t, i) {
  const r = i.isWebGL2;
  let s;
  function o(h) {
    s = h;
  }
  function a(h, d) {
    n.drawArrays(s, h, d), t.update(d, s, 1);
  }
  function u(h, d, p) {
    if (p === 0) return;
    let m, y;
    if (r) (m = n), (y = "drawArraysInstanced");
    else if (
      ((m = e.get("ANGLE_instanced_arrays")),
      (y = "drawArraysInstancedANGLE"),
      m === null)
    ) {
      console.error(
        "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
      );
      return;
    }
    m[y](s, h, d, p), t.update(d, s, p);
  }
  function f(h, d, p) {
    if (p === 0) return;
    const m = e.get("WEBGL_multi_draw");
    if (m === null) for (let y = 0; y < p; y++) this.render(h[y], d[y]);
    else {
      m.multiDrawArraysWEBGL(s, h, 0, d, 0, p);
      let y = 0;
      for (let w = 0; w < p; w++) y += d[w];
      t.update(y, s, 1);
    }
  }
  (this.setMode = o),
    (this.render = a),
    (this.renderInstances = u),
    (this.renderMultiDraw = f);
}
function eG(n, e, t) {
  let i;
  function r() {
    if (i !== void 0) return i;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const L = e.get("EXT_texture_filter_anisotropic");
      i = n.getParameter(L.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else i = 0;
    return i;
  }
  function s(L) {
    if (L === "highp") {
      if (
        n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.HIGH_FLOAT).precision >
          0 &&
        n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.HIGH_FLOAT).precision >
          0
      )
        return "highp";
      L = "mediump";
    }
    return L === "mediump" &&
      n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.MEDIUM_FLOAT).precision >
        0 &&
      n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.MEDIUM_FLOAT).precision >
        0
      ? "mediump"
      : "lowp";
  }
  const o =
    typeof WebGL2RenderingContext < "u" &&
    n.constructor.name === "WebGL2RenderingContext";
  let a = t.precision !== void 0 ? t.precision : "highp";
  const u = s(a);
  u !== a &&
    (console.warn(
      "THREE.WebGLRenderer:",
      a,
      "not supported, using",
      u,
      "instead."
    ),
    (a = u));
  const f = o || e.has("WEBGL_draw_buffers"),
    h = t.logarithmicDepthBuffer === !0,
    d = n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS),
    p = n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
    m = n.getParameter(n.MAX_TEXTURE_SIZE),
    y = n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE),
    w = n.getParameter(n.MAX_VERTEX_ATTRIBS),
    S = n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS),
    v = n.getParameter(n.MAX_VARYING_VECTORS),
    M = n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS),
    _ = p > 0,
    T = o || e.has("OES_texture_float"),
    P = _ && T,
    b = o ? n.getParameter(n.MAX_SAMPLES) : 0;
  return {
    isWebGL2: o,
    drawBuffers: f,
    getMaxAnisotropy: r,
    getMaxPrecision: s,
    precision: a,
    logarithmicDepthBuffer: h,
    maxTextures: d,
    maxVertexTextures: p,
    maxTextureSize: m,
    maxCubemapSize: y,
    maxAttributes: w,
    maxVertexUniforms: S,
    maxVaryings: v,
    maxFragmentUniforms: M,
    vertexTextures: _,
    floatFragmentTextures: T,
    floatVertexTextures: P,
    maxSamples: b,
  };
}
function tG(n) {
  const e = this;
  let t = null,
    i = 0,
    r = !1,
    s = !1;
  const o = new Ps(),
    a = new Et(),
    u = { value: null, needsUpdate: !1 };
  (this.uniform = u),
    (this.numPlanes = 0),
    (this.numIntersection = 0),
    (this.init = function (d, p) {
      const m = d.length !== 0 || p || i !== 0 || r;
      return (r = p), (i = d.length), m;
    }),
    (this.beginShadows = function () {
      (s = !0), h(null);
    }),
    (this.endShadows = function () {
      s = !1;
    }),
    (this.setGlobalState = function (d, p) {
      t = h(d, p, 0);
    }),
    (this.setState = function (d, p, m) {
      const y = d.clippingPlanes,
        w = d.clipIntersection,
        S = d.clipShadows,
        v = n.get(d);
      if (!r || y === null || y.length === 0 || (s && !S)) s ? h(null) : f();
      else {
        const M = s ? 0 : i,
          _ = M * 4;
        let T = v.clippingState || null;
        (u.value = T), (T = h(y, p, _, m));
        for (let P = 0; P !== _; ++P) T[P] = t[P];
        (v.clippingState = T),
          (this.numIntersection = w ? this.numPlanes : 0),
          (this.numPlanes += M);
      }
    });
  function f() {
    u.value !== t && ((u.value = t), (u.needsUpdate = i > 0)),
      (e.numPlanes = i),
      (e.numIntersection = 0);
  }
  function h(d, p, m, y) {
    const w = d !== null ? d.length : 0;
    let S = null;
    if (w !== 0) {
      if (((S = u.value), y !== !0 || S === null)) {
        const v = m + w * 4,
          M = p.matrixWorldInverse;
        a.getNormalMatrix(M),
          (S === null || S.length < v) && (S = new Float32Array(v));
        for (let _ = 0, T = m; _ !== w; ++_, T += 4)
          o.copy(d[_]).applyMatrix4(M, a),
            o.normal.toArray(S, T),
            (S[T + 3] = o.constant);
      }
      (u.value = S), (u.needsUpdate = !0);
    }
    return (e.numPlanes = w), (e.numIntersection = 0), S;
  }
}
function nG(n) {
  let e = new WeakMap();
  function t(o, a) {
    return a === If ? (o.mapping = Xs) : a === Nf && (o.mapping = Go), o;
  }
  function i(o) {
    if (o && o.isTexture) {
      const a = o.mapping;
      if (a === If || a === Nf)
        if (e.has(o)) {
          const u = e.get(o).texture;
          return t(u, o.mapping);
        } else {
          const u = o.image;
          if (u && u.height > 0) {
            const f = new RL(u.height / 2);
            return (
              f.fromEquirectangularTexture(n, o),
              e.set(o, f),
              o.addEventListener("dispose", r),
              t(f.texture, o.mapping)
            );
          } else return null;
        }
    }
    return o;
  }
  function r(o) {
    const a = o.target;
    a.removeEventListener("dispose", r);
    const u = e.get(a);
    u !== void 0 && (e.delete(a), u.dispose());
  }
  function s() {
    e = new WeakMap();
  }
  return { get: i, dispose: s };
}
class Fo extends xh {
  constructor(e = -1, t = 1, i = 1, r = -1, s = 0.1, o = 2e3) {
    super(),
      (this.isOrthographicCamera = !0),
      (this.type = "OrthographicCamera"),
      (this.zoom = 1),
      (this.view = null),
      (this.left = e),
      (this.right = t),
      (this.top = i),
      (this.bottom = r),
      (this.near = s),
      (this.far = o),
      this.updateProjectionMatrix();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.left = e.left),
      (this.right = e.right),
      (this.top = e.top),
      (this.bottom = e.bottom),
      (this.near = e.near),
      (this.far = e.far),
      (this.zoom = e.zoom),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      this
    );
  }
  setViewOffset(e, t, i, r, s, o) {
    this.view === null &&
      (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1,
      }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = i),
      (this.view.offsetY = r),
      (this.view.width = s),
      (this.view.height = o),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom),
      t = (this.top - this.bottom) / (2 * this.zoom),
      i = (this.right + this.left) / 2,
      r = (this.top + this.bottom) / 2;
    let s = i - e,
      o = i + e,
      a = r + t,
      u = r - t;
    if (this.view !== null && this.view.enabled) {
      const f = (this.right - this.left) / this.view.fullWidth / this.zoom,
        h = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      (s += f * this.view.offsetX),
        (o = s + f * this.view.width),
        (a -= h * this.view.offsetY),
        (u = a - h * this.view.height);
    }
    this.projectionMatrix.makeOrthographic(
      s,
      o,
      a,
      u,
      this.near,
      this.far,
      this.coordinateSystem
    ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.zoom = this.zoom),
      (t.object.left = this.left),
      (t.object.right = this.right),
      (t.object.top = this.top),
      (t.object.bottom = this.bottom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      this.view !== null && (t.object.view = Object.assign({}, this.view)),
      t
    );
  }
}
const pu = 4,
  V2 = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
  Pa = 20,
  My = new Fo(),
  H2 = new Be();
let wy = null,
  Ey = 0,
  Ty = 0;
const Ca = (1 + Math.sqrt(5)) / 2,
  Bl = 1 / Ca,
  G2 = [
    new U(1, 1, 1),
    new U(-1, 1, 1),
    new U(1, 1, -1),
    new U(-1, 1, -1),
    new U(0, Ca, Bl),
    new U(0, Ca, -Bl),
    new U(Bl, 0, Ca),
    new U(-Bl, 0, Ca),
    new U(Ca, Bl, 0),
    new U(-Ca, Bl, 0),
  ];
class F_ {
  constructor(e) {
    (this._renderer = e),
      (this._pingPongRenderTarget = null),
      (this._lodMax = 0),
      (this._cubeSize = 0),
      (this._lodPlanes = []),
      (this._sizeLods = []),
      (this._sigmas = []),
      (this._blurMaterial = null),
      (this._cubemapMaterial = null),
      (this._equirectMaterial = null),
      this._compileMaterial(this._blurMaterial);
  }
  fromScene(e, t = 0, i = 0.1, r = 100) {
    (wy = this._renderer.getRenderTarget()),
      (Ey = this._renderer.getActiveCubeFace()),
      (Ty = this._renderer.getActiveMipmapLevel()),
      this._setSize(256);
    const s = this._allocateTargets();
    return (
      (s.depthBuffer = !0),
      this._sceneToCubeUV(e, i, r, s),
      t > 0 && this._blur(s, 0, 0, t),
      this._applyPMREM(s),
      this._cleanup(s),
      s
    );
  }
  fromEquirectangular(e, t = null) {
    return this._fromTexture(e, t);
  }
  fromCubemap(e, t = null) {
    return this._fromTexture(e, t);
  }
  compileCubemapShader() {
    this._cubemapMaterial === null &&
      ((this._cubemapMaterial = X2()),
      this._compileMaterial(this._cubemapMaterial));
  }
  compileEquirectangularShader() {
    this._equirectMaterial === null &&
      ((this._equirectMaterial = j2()),
      this._compileMaterial(this._equirectMaterial));
  }
  dispose() {
    this._dispose(),
      this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
      this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  _setSize(e) {
    (this._lodMax = Math.floor(Math.log2(e))),
      (this._cubeSize = Math.pow(2, this._lodMax));
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(),
      this._pingPongRenderTarget !== null &&
        this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(wy, Ey, Ty),
      (e.scissorTest = !1),
      yp(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, t) {
    e.mapping === Xs || e.mapping === Go
      ? this._setSize(
          e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width
        )
      : this._setSize(e.image.width / 4),
      (wy = this._renderer.getRenderTarget()),
      (Ey = this._renderer.getActiveCubeFace()),
      (Ty = this._renderer.getActiveMipmapLevel());
    const i = t || this._allocateTargets();
    return (
      this._textureToCubeUV(e, i), this._applyPMREM(i), this._cleanup(i), i
    );
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112),
      t = 4 * this._cubeSize,
      i = {
        magFilter: wn,
        minFilter: wn,
        generateMipmaps: !1,
        type: Ou,
        format: wi,
        colorSpace: hs,
        depthBuffer: !1,
      },
      r = W2(e, t, i);
    if (
      this._pingPongRenderTarget === null ||
      this._pingPongRenderTarget.width !== e ||
      this._pingPongRenderTarget.height !== t
    ) {
      this._pingPongRenderTarget !== null && this._dispose(),
        (this._pingPongRenderTarget = W2(e, t, i));
      const { _lodMax: s } = this;
      ({
        sizeLods: this._sizeLods,
        lodPlanes: this._lodPlanes,
        sigmas: this._sigmas,
      } = iG(s)),
        (this._blurMaterial = rG(s, e, t));
    }
    return r;
  }
  _compileMaterial(e) {
    const t = new Un(this._lodPlanes[0], e);
    this._renderer.compile(t, My);
  }
  _sceneToCubeUV(e, t, i, r) {
    const a = new En(90, 1, t, i),
      u = [1, -1, 1, 1, 1, 1],
      f = [1, 1, 1, -1, -1, -1],
      h = this._renderer,
      d = h.autoClear,
      p = h.toneMapping;
    h.getClearColor(H2), (h.toneMapping = us), (h.autoClear = !1);
    const m = new Qo({
        name: "PMREM.Background",
        side: Ti,
        depthWrite: !1,
        depthTest: !1,
      }),
      y = new Un(new sl(), m);
    let w = !1;
    const S = e.background;
    S
      ? S.isColor && (m.color.copy(S), (e.background = null), (w = !0))
      : (m.color.copy(H2), (w = !0));
    for (let v = 0; v < 6; v++) {
      const M = v % 3;
      M === 0
        ? (a.up.set(0, u[v], 0), a.lookAt(f[v], 0, 0))
        : M === 1
        ? (a.up.set(0, 0, u[v]), a.lookAt(0, f[v], 0))
        : (a.up.set(0, u[v], 0), a.lookAt(0, 0, f[v]));
      const _ = this._cubeSize;
      yp(r, M * _, v > 2 ? _ : 0, _, _),
        h.setRenderTarget(r),
        w && h.render(y, a),
        h.render(e, a);
    }
    y.geometry.dispose(),
      y.material.dispose(),
      (h.toneMapping = p),
      (h.autoClear = d),
      (e.background = S);
  }
  _textureToCubeUV(e, t) {
    const i = this._renderer,
      r = e.mapping === Xs || e.mapping === Go;
    r
      ? (this._cubemapMaterial === null && (this._cubemapMaterial = X2()),
        (this._cubemapMaterial.uniforms.flipEnvMap.value =
          e.isRenderTargetTexture === !1 ? -1 : 1))
      : this._equirectMaterial === null && (this._equirectMaterial = j2());
    const s = r ? this._cubemapMaterial : this._equirectMaterial,
      o = new Un(this._lodPlanes[0], s),
      a = s.uniforms;
    a.envMap.value = e;
    const u = this._cubeSize;
    yp(t, 0, 0, 3 * u, 2 * u), i.setRenderTarget(t), i.render(o, My);
  }
  _applyPMREM(e) {
    const t = this._renderer,
      i = t.autoClear;
    t.autoClear = !1;
    for (let r = 1; r < this._lodPlanes.length; r++) {
      const s = Math.sqrt(
          this._sigmas[r] * this._sigmas[r] -
            this._sigmas[r - 1] * this._sigmas[r - 1]
        ),
        o = G2[(r - 1) % G2.length];
      this._blur(e, r - 1, r, s, o);
    }
    t.autoClear = i;
  }
  _blur(e, t, i, r, s) {
    const o = this._pingPongRenderTarget;
    this._halfBlur(e, o, t, i, r, "latitudinal", s),
      this._halfBlur(o, e, i, i, r, "longitudinal", s);
  }
  _halfBlur(e, t, i, r, s, o, a) {
    const u = this._renderer,
      f = this._blurMaterial;
    o !== "latitudinal" &&
      o !== "longitudinal" &&
      console.error(
        "blur direction must be either latitudinal or longitudinal!"
      );
    const h = 3,
      d = new Un(this._lodPlanes[r], f),
      p = f.uniforms,
      m = this._sizeLods[i] - 1,
      y = isFinite(s) ? Math.PI / (2 * m) : (2 * Math.PI) / (2 * Pa - 1),
      w = s / y,
      S = isFinite(s) ? 1 + Math.floor(h * w) : Pa;
    S > Pa &&
      console.warn(
        `sigmaRadians, ${s}, is too large and will clip, as it requested ${S} samples when the maximum is set to ${Pa}`
      );
    const v = [];
    let M = 0;
    for (let L = 0; L < Pa; ++L) {
      const N = L / w,
        C = Math.exp((-N * N) / 2);
      v.push(C), L === 0 ? (M += C) : L < S && (M += 2 * C);
    }
    for (let L = 0; L < v.length; L++) v[L] = v[L] / M;
    (p.envMap.value = e.texture),
      (p.samples.value = S),
      (p.weights.value = v),
      (p.latitudinal.value = o === "latitudinal"),
      a && (p.poleAxis.value = a);
    const { _lodMax: _ } = this;
    (p.dTheta.value = y), (p.mipInt.value = _ - i);
    const T = this._sizeLods[r],
      P = 3 * T * (r > _ - pu ? r - _ + pu : 0),
      b = 4 * (this._cubeSize - T);
    yp(t, P, b, 3 * T, 2 * T), u.setRenderTarget(t), u.render(d, My);
  }
}
function iG(n) {
  const e = [],
    t = [],
    i = [];
  let r = n;
  const s = n - pu + 1 + V2.length;
  for (let o = 0; o < s; o++) {
    const a = Math.pow(2, r);
    t.push(a);
    let u = 1 / a;
    o > n - pu ? (u = V2[o - n + pu - 1]) : o === 0 && (u = 0), i.push(u);
    const f = 1 / (a - 2),
      h = -f,
      d = 1 + f,
      p = [h, h, d, h, d, d, h, h, d, d, h, d],
      m = 6,
      y = 6,
      w = 3,
      S = 2,
      v = 1,
      M = new Float32Array(w * y * m),
      _ = new Float32Array(S * y * m),
      T = new Float32Array(v * y * m);
    for (let b = 0; b < m; b++) {
      const L = ((b % 3) * 2) / 3 - 1,
        N = b > 2 ? 0 : -1,
        C = [
          L,
          N,
          0,
          L + 2 / 3,
          N,
          0,
          L + 2 / 3,
          N + 1,
          0,
          L,
          N,
          0,
          L + 2 / 3,
          N + 1,
          0,
          L,
          N + 1,
          0,
        ];
      M.set(C, w * y * b), _.set(p, S * y * b);
      const R = [b, b, b, b, b, b];
      T.set(R, v * y * b);
    }
    const P = new Tt();
    P.setAttribute("position", new Ht(M, w)),
      P.setAttribute("uv", new Ht(_, S)),
      P.setAttribute("faceIndex", new Ht(T, v)),
      e.push(P),
      r > pu && r--;
  }
  return { lodPlanes: e, sizeLods: t, sigmas: i };
}
function W2(n, e, t) {
  const i = new Vr(n, e, t);
  return (
    (i.texture.mapping = ju),
    (i.texture.name = "PMREM.cubeUv"),
    (i.scissorTest = !0),
    i
  );
}
function yp(n, e, t, i, r) {
  n.viewport.set(e, t, i, r), n.scissor.set(e, t, i, r);
}
function rG(n, e, t) {
  const i = new Float32Array(Pa),
    r = new U(0, 1, 0);
  return new Hr({
    name: "SphericalGaussianBlur",
    defines: {
      n: Pa,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / t,
      CUBEUV_MAX_MIP: `${n}.0`,
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: i },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: r },
    },
    vertexShader: kS(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
    blending: zs,
    depthTest: !1,
    depthWrite: !1,
  });
}
function j2() {
  return new Hr({
    name: "EquirectangularToCubeUV",
    uniforms: { envMap: { value: null } },
    vertexShader: kS(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
    blending: zs,
    depthTest: !1,
    depthWrite: !1,
  });
}
function X2() {
  return new Hr({
    name: "CubemapToCubeUV",
    uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
    vertexShader: kS(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
    blending: zs,
    depthTest: !1,
    depthWrite: !1,
  });
}
function kS() {
  return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function sG(n) {
  let e = new WeakMap(),
    t = null;
  function i(a) {
    if (a && a.isTexture) {
      const u = a.mapping,
        f = u === If || u === Nf,
        h = u === Xs || u === Go;
      if (f || h)
        if (a.isRenderTargetTexture && a.needsPMREMUpdate === !0) {
          a.needsPMREMUpdate = !1;
          let d = e.get(a);
          return (
            t === null && (t = new F_(n)),
            (d = f ? t.fromEquirectangular(a, d) : t.fromCubemap(a, d)),
            e.set(a, d),
            d.texture
          );
        } else {
          if (e.has(a)) return e.get(a).texture;
          {
            const d = a.image;
            if ((f && d && d.height > 0) || (h && d && r(d))) {
              t === null && (t = new F_(n));
              const p = f ? t.fromEquirectangular(a) : t.fromCubemap(a);
              return e.set(a, p), a.addEventListener("dispose", s), p.texture;
            } else return null;
          }
        }
    }
    return a;
  }
  function r(a) {
    let u = 0;
    const f = 6;
    for (let h = 0; h < f; h++) a[h] !== void 0 && u++;
    return u === f;
  }
  function s(a) {
    const u = a.target;
    u.removeEventListener("dispose", s);
    const f = e.get(u);
    f !== void 0 && (e.delete(u), f.dispose());
  }
  function o() {
    (e = new WeakMap()), t !== null && (t.dispose(), (t = null));
  }
  return { get: i, dispose: o };
}
function oG(n) {
  const e = {};
  function t(i) {
    if (e[i] !== void 0) return e[i];
    let r;
    switch (i) {
      case "WEBGL_depth_texture":
        r =
          n.getExtension("WEBGL_depth_texture") ||
          n.getExtension("MOZ_WEBGL_depth_texture") ||
          n.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        r =
          n.getExtension("EXT_texture_filter_anisotropic") ||
          n.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
          n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        r =
          n.getExtension("WEBGL_compressed_texture_s3tc") ||
          n.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
          n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        r =
          n.getExtension("WEBGL_compressed_texture_pvrtc") ||
          n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        r = n.getExtension(i);
    }
    return (e[i] = r), r;
  }
  return {
    has: function (i) {
      return t(i) !== null;
    },
    init: function (i) {
      i.isWebGL2
        ? (t("EXT_color_buffer_float"), t("WEBGL_clip_cull_distance"))
        : (t("WEBGL_depth_texture"),
          t("OES_texture_float"),
          t("OES_texture_half_float"),
          t("OES_texture_half_float_linear"),
          t("OES_standard_derivatives"),
          t("OES_element_index_uint"),
          t("OES_vertex_array_object"),
          t("ANGLE_instanced_arrays")),
        t("OES_texture_float_linear"),
        t("EXT_color_buffer_half_float"),
        t("WEBGL_multisampled_render_to_texture");
    },
    get: function (i) {
      const r = t(i);
      return (
        r === null &&
          console.warn(
            "THREE.WebGLRenderer: " + i + " extension not supported."
          ),
        r
      );
    },
  };
}
function aG(n, e, t, i) {
  const r = {},
    s = new WeakMap();
  function o(d) {
    const p = d.target;
    p.index !== null && e.remove(p.index);
    for (const y in p.attributes) e.remove(p.attributes[y]);
    for (const y in p.morphAttributes) {
      const w = p.morphAttributes[y];
      for (let S = 0, v = w.length; S < v; S++) e.remove(w[S]);
    }
    p.removeEventListener("dispose", o), delete r[p.id];
    const m = s.get(p);
    m && (e.remove(m), s.delete(p)),
      i.releaseStatesOfGeometry(p),
      p.isInstancedBufferGeometry === !0 && delete p._maxInstanceCount,
      t.memory.geometries--;
  }
  function a(d, p) {
    return (
      r[p.id] === !0 ||
        (p.addEventListener("dispose", o),
        (r[p.id] = !0),
        t.memory.geometries++),
      p
    );
  }
  function u(d) {
    const p = d.attributes;
    for (const y in p) e.update(p[y], n.ARRAY_BUFFER);
    const m = d.morphAttributes;
    for (const y in m) {
      const w = m[y];
      for (let S = 0, v = w.length; S < v; S++) e.update(w[S], n.ARRAY_BUFFER);
    }
  }
  function f(d) {
    const p = [],
      m = d.index,
      y = d.attributes.position;
    let w = 0;
    if (m !== null) {
      const M = m.array;
      w = m.version;
      for (let _ = 0, T = M.length; _ < T; _ += 3) {
        const P = M[_ + 0],
          b = M[_ + 1],
          L = M[_ + 2];
        p.push(P, b, b, L, L, P);
      }
    } else if (y !== void 0) {
      const M = y.array;
      w = y.version;
      for (let _ = 0, T = M.length / 3 - 1; _ < T; _ += 3) {
        const P = _ + 0,
          b = _ + 1,
          L = _ + 2;
        p.push(P, b, b, L, L, P);
      }
    } else return;
    const S = new (wL(p) ? US : OS)(p, 1);
    S.version = w;
    const v = s.get(d);
    v && e.remove(v), s.set(d, S);
  }
  function h(d) {
    const p = s.get(d);
    if (p) {
      const m = d.index;
      m !== null && p.version < m.version && f(d);
    } else f(d);
    return s.get(d);
  }
  return { get: a, update: u, getWireframeAttribute: h };
}
function lG(n, e, t, i) {
  const r = i.isWebGL2;
  let s;
  function o(m) {
    s = m;
  }
  let a, u;
  function f(m) {
    (a = m.type), (u = m.bytesPerElement);
  }
  function h(m, y) {
    n.drawElements(s, y, a, m * u), t.update(y, s, 1);
  }
  function d(m, y, w) {
    if (w === 0) return;
    let S, v;
    if (r) (S = n), (v = "drawElementsInstanced");
    else if (
      ((S = e.get("ANGLE_instanced_arrays")),
      (v = "drawElementsInstancedANGLE"),
      S === null)
    ) {
      console.error(
        "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
      );
      return;
    }
    S[v](s, y, a, m * u, w), t.update(y, s, w);
  }
  function p(m, y, w) {
    if (w === 0) return;
    const S = e.get("WEBGL_multi_draw");
    if (S === null) for (let v = 0; v < w; v++) this.render(m[v] / u, y[v]);
    else {
      S.multiDrawElementsWEBGL(s, y, 0, a, m, 0, w);
      let v = 0;
      for (let M = 0; M < w; M++) v += y[M];
      t.update(v, s, 1);
    }
  }
  (this.setMode = o),
    (this.setIndex = f),
    (this.render = h),
    (this.renderInstances = d),
    (this.renderMultiDraw = p);
}
function uG(n) {
  const e = { geometries: 0, textures: 0 },
    t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
  function i(s, o, a) {
    switch ((t.calls++, o)) {
      case n.TRIANGLES:
        t.triangles += a * (s / 3);
        break;
      case n.LINES:
        t.lines += a * (s / 2);
        break;
      case n.LINE_STRIP:
        t.lines += a * (s - 1);
        break;
      case n.LINE_LOOP:
        t.lines += a * s;
        break;
      case n.POINTS:
        t.points += a * s;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", o);
        break;
    }
  }
  function r() {
    (t.calls = 0), (t.triangles = 0), (t.points = 0), (t.lines = 0);
  }
  return {
    memory: e,
    render: t,
    programs: null,
    autoReset: !0,
    reset: r,
    update: i,
  };
}
function cG(n, e) {
  return n[0] - e[0];
}
function fG(n, e) {
  return Math.abs(e[1]) - Math.abs(n[1]);
}
function hG(n, e, t) {
  const i = {},
    r = new Float32Array(8),
    s = new WeakMap(),
    o = new Bt(),
    a = [];
  for (let f = 0; f < 8; f++) a[f] = [f, 0];
  function u(f, h, d) {
    const p = f.morphTargetInfluences;
    if (e.isWebGL2 === !0) {
      const y =
          h.morphAttributes.position ||
          h.morphAttributes.normal ||
          h.morphAttributes.color,
        w = y !== void 0 ? y.length : 0;
      let S = s.get(h);
      if (S === void 0 || S.count !== w) {
        let Q = function () {
          ae.dispose(), s.delete(h), h.removeEventListener("dispose", Q);
        };
        var m = Q;
        S !== void 0 && S.texture.dispose();
        const _ = h.morphAttributes.position !== void 0,
          T = h.morphAttributes.normal !== void 0,
          P = h.morphAttributes.color !== void 0,
          b = h.morphAttributes.position || [],
          L = h.morphAttributes.normal || [],
          N = h.morphAttributes.color || [];
        let C = 0;
        _ === !0 && (C = 1), T === !0 && (C = 2), P === !0 && (C = 3);
        let R = h.attributes.position.count * C,
          B = 1;
        R > e.maxTextureSize &&
          ((B = Math.ceil(R / e.maxTextureSize)), (R = e.maxTextureSize));
        const Z = new Float32Array(R * B * 4 * w),
          ae = new Vg(Z, R, B, w);
        (ae.type = Ur), (ae.needsUpdate = !0);
        const V = C * 4;
        for (let $ = 0; $ < w; $++) {
          const ce = b[$],
            k = L[$],
            G = N[$],
            W = R * B * 4 * $;
          for (let Y = 0; Y < ce.count; Y++) {
            const ie = Y * V;
            _ === !0 &&
              (o.fromBufferAttribute(ce, Y),
              (Z[W + ie + 0] = o.x),
              (Z[W + ie + 1] = o.y),
              (Z[W + ie + 2] = o.z),
              (Z[W + ie + 3] = 0)),
              T === !0 &&
                (o.fromBufferAttribute(k, Y),
                (Z[W + ie + 4] = o.x),
                (Z[W + ie + 5] = o.y),
                (Z[W + ie + 6] = o.z),
                (Z[W + ie + 7] = 0)),
              P === !0 &&
                (o.fromBufferAttribute(G, Y),
                (Z[W + ie + 8] = o.x),
                (Z[W + ie + 9] = o.y),
                (Z[W + ie + 10] = o.z),
                (Z[W + ie + 11] = G.itemSize === 4 ? o.w : 1));
          }
        }
        (S = { count: w, texture: ae, size: new de(R, B) }),
          s.set(h, S),
          h.addEventListener("dispose", Q);
      }
      let v = 0;
      for (let _ = 0; _ < p.length; _++) v += p[_];
      const M = h.morphTargetsRelative ? 1 : 1 - v;
      d.getUniforms().setValue(n, "morphTargetBaseInfluence", M),
        d.getUniforms().setValue(n, "morphTargetInfluences", p),
        d.getUniforms().setValue(n, "morphTargetsTexture", S.texture, t),
        d.getUniforms().setValue(n, "morphTargetsTextureSize", S.size);
    } else {
      const y = p === void 0 ? 0 : p.length;
      let w = i[h.id];
      if (w === void 0 || w.length !== y) {
        w = [];
        for (let T = 0; T < y; T++) w[T] = [T, 0];
        i[h.id] = w;
      }
      for (let T = 0; T < y; T++) {
        const P = w[T];
        (P[0] = T), (P[1] = p[T]);
      }
      w.sort(fG);
      for (let T = 0; T < 8; T++)
        T < y && w[T][1]
          ? ((a[T][0] = w[T][0]), (a[T][1] = w[T][1]))
          : ((a[T][0] = Number.MAX_SAFE_INTEGER), (a[T][1] = 0));
      a.sort(cG);
      const S = h.morphAttributes.position,
        v = h.morphAttributes.normal;
      let M = 0;
      for (let T = 0; T < 8; T++) {
        const P = a[T],
          b = P[0],
          L = P[1];
        b !== Number.MAX_SAFE_INTEGER && L
          ? (S &&
              h.getAttribute("morphTarget" + T) !== S[b] &&
              h.setAttribute("morphTarget" + T, S[b]),
            v &&
              h.getAttribute("morphNormal" + T) !== v[b] &&
              h.setAttribute("morphNormal" + T, v[b]),
            (r[T] = L),
            (M += L))
          : (S &&
              h.hasAttribute("morphTarget" + T) === !0 &&
              h.deleteAttribute("morphTarget" + T),
            v &&
              h.hasAttribute("morphNormal" + T) === !0 &&
              h.deleteAttribute("morphNormal" + T),
            (r[T] = 0));
      }
      const _ = h.morphTargetsRelative ? 1 : 1 - M;
      d.getUniforms().setValue(n, "morphTargetBaseInfluence", _),
        d.getUniforms().setValue(n, "morphTargetInfluences", r);
    }
  }
  return { update: u };
}
function dG(n, e, t, i) {
  let r = new WeakMap();
  function s(u) {
    const f = i.render.frame,
      h = u.geometry,
      d = e.get(u, h);
    if (
      (r.get(d) !== f && (e.update(d), r.set(d, f)),
      u.isInstancedMesh &&
        (u.hasEventListener("dispose", a) === !1 &&
          u.addEventListener("dispose", a),
        r.get(u) !== f &&
          (t.update(u.instanceMatrix, n.ARRAY_BUFFER),
          u.instanceColor !== null && t.update(u.instanceColor, n.ARRAY_BUFFER),
          r.set(u, f))),
      u.isSkinnedMesh)
    ) {
      const p = u.skeleton;
      r.get(p) !== f && (p.update(), r.set(p, f));
    }
    return d;
  }
  function o() {
    r = new WeakMap();
  }
  function a(u) {
    const f = u.target;
    f.removeEventListener("dispose", a),
      t.remove(f.instanceMatrix),
      f.instanceColor !== null && t.remove(f.instanceColor);
  }
  return { update: s, dispose: o };
}
class FS extends An {
  constructor(e, t, i, r, s, o, a, u, f, h) {
    if (((h = h !== void 0 ? h : Uo), h !== Uo && h !== Qa))
      throw new Error(
        "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
      );
    i === void 0 && h === Uo && (i = Ds),
      i === void 0 && h === Qa && (i = Oo),
      super(null, r, s, o, a, u, h, i, f),
      (this.isDepthTexture = !0),
      (this.image = { width: e, height: t }),
      (this.magFilter = a !== void 0 ? a : Sn),
      (this.minFilter = u !== void 0 ? u : Sn),
      (this.flipY = !1),
      (this.generateMipmaps = !1),
      (this.compareFunction = null);
  }
  copy(e) {
    return super.copy(e), (this.compareFunction = e.compareFunction), this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      this.compareFunction !== null &&
        (t.compareFunction = this.compareFunction),
      t
    );
  }
}
const IL = new An(),
  NL = new FS(1, 1);
NL.compareFunction = LS;
const DL = new Vg(),
  OL = new DS(),
  UL = new _h(),
  Y2 = [],
  q2 = [],
  Z2 = new Float32Array(16),
  K2 = new Float32Array(9),
  Q2 = new Float32Array(4);
function Xu(n, e, t) {
  const i = n[0];
  if (i <= 0 || i > 0) return n;
  const r = e * t;
  let s = Y2[r];
  if ((s === void 0 && ((s = new Float32Array(r)), (Y2[r] = s)), e !== 0)) {
    i.toArray(s, 0);
    for (let o = 1, a = 0; o !== e; ++o) (a += t), n[o].toArray(s, a);
  }
  return s;
}
function kn(n, e) {
  if (n.length !== e.length) return !1;
  for (let t = 0, i = n.length; t < i; t++) if (n[t] !== e[t]) return !1;
  return !0;
}
function Fn(n, e) {
  for (let t = 0, i = e.length; t < i; t++) n[t] = e[t];
}
function Hg(n, e) {
  let t = q2[e];
  t === void 0 && ((t = new Int32Array(e)), (q2[e] = t));
  for (let i = 0; i !== e; ++i) t[i] = n.allocateTextureUnit();
  return t;
}
function pG(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1f(this.addr, e), (t[0] = e));
}
function mG(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (n.uniform2f(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (kn(t, e)) return;
    n.uniform2fv(this.addr, e), Fn(t, e);
  }
}
function gG(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (n.uniform3f(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else if (e.r !== void 0)
    (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) &&
      (n.uniform3f(this.addr, e.r, e.g, e.b),
      (t[0] = e.r),
      (t[1] = e.g),
      (t[2] = e.b));
  else {
    if (kn(t, e)) return;
    n.uniform3fv(this.addr, e), Fn(t, e);
  }
}
function vG(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (n.uniform4f(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (kn(t, e)) return;
    n.uniform4fv(this.addr, e), Fn(t, e);
  }
}
function yG(n, e) {
  const t = this.cache,
    i = e.elements;
  if (i === void 0) {
    if (kn(t, e)) return;
    n.uniformMatrix2fv(this.addr, !1, e), Fn(t, e);
  } else {
    if (kn(t, i)) return;
    Q2.set(i), n.uniformMatrix2fv(this.addr, !1, Q2), Fn(t, i);
  }
}
function xG(n, e) {
  const t = this.cache,
    i = e.elements;
  if (i === void 0) {
    if (kn(t, e)) return;
    n.uniformMatrix3fv(this.addr, !1, e), Fn(t, e);
  } else {
    if (kn(t, i)) return;
    K2.set(i), n.uniformMatrix3fv(this.addr, !1, K2), Fn(t, i);
  }
}
function _G(n, e) {
  const t = this.cache,
    i = e.elements;
  if (i === void 0) {
    if (kn(t, e)) return;
    n.uniformMatrix4fv(this.addr, !1, e), Fn(t, e);
  } else {
    if (kn(t, i)) return;
    Z2.set(i), n.uniformMatrix4fv(this.addr, !1, Z2), Fn(t, i);
  }
}
function SG(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1i(this.addr, e), (t[0] = e));
}
function MG(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (n.uniform2i(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (kn(t, e)) return;
    n.uniform2iv(this.addr, e), Fn(t, e);
  }
}
function wG(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (n.uniform3i(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else {
    if (kn(t, e)) return;
    n.uniform3iv(this.addr, e), Fn(t, e);
  }
}
function EG(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (n.uniform4i(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (kn(t, e)) return;
    n.uniform4iv(this.addr, e), Fn(t, e);
  }
}
function TG(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1ui(this.addr, e), (t[0] = e));
}
function AG(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (n.uniform2ui(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (kn(t, e)) return;
    n.uniform2uiv(this.addr, e), Fn(t, e);
  }
}
function bG(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (n.uniform3ui(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else {
    if (kn(t, e)) return;
    n.uniform3uiv(this.addr, e), Fn(t, e);
  }
}
function CG(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (n.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (kn(t, e)) return;
    n.uniform4uiv(this.addr, e), Fn(t, e);
  }
}
function PG(n, e, t) {
  const i = this.cache,
    r = t.allocateTextureUnit();
  i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r));
  const s = this.type === n.SAMPLER_2D_SHADOW ? NL : IL;
  t.setTexture2D(e || s, r);
}
function RG(n, e, t) {
  const i = this.cache,
    r = t.allocateTextureUnit();
  i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r)),
    t.setTexture3D(e || OL, r);
}
function LG(n, e, t) {
  const i = this.cache,
    r = t.allocateTextureUnit();
  i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r)),
    t.setTextureCube(e || UL, r);
}
function IG(n, e, t) {
  const i = this.cache,
    r = t.allocateTextureUnit();
  i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r)),
    t.setTexture2DArray(e || DL, r);
}
function NG(n) {
  switch (n) {
    case 5126:
      return pG;
    case 35664:
      return mG;
    case 35665:
      return gG;
    case 35666:
      return vG;
    case 35674:
      return yG;
    case 35675:
      return xG;
    case 35676:
      return _G;
    case 5124:
    case 35670:
      return SG;
    case 35667:
    case 35671:
      return MG;
    case 35668:
    case 35672:
      return wG;
    case 35669:
    case 35673:
      return EG;
    case 5125:
      return TG;
    case 36294:
      return AG;
    case 36295:
      return bG;
    case 36296:
      return CG;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return PG;
    case 35679:
    case 36299:
    case 36307:
      return RG;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return LG;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return IG;
  }
}
function DG(n, e) {
  n.uniform1fv(this.addr, e);
}
function OG(n, e) {
  const t = Xu(e, this.size, 2);
  n.uniform2fv(this.addr, t);
}
function UG(n, e) {
  const t = Xu(e, this.size, 3);
  n.uniform3fv(this.addr, t);
}
function kG(n, e) {
  const t = Xu(e, this.size, 4);
  n.uniform4fv(this.addr, t);
}
function FG(n, e) {
  const t = Xu(e, this.size, 4);
  n.uniformMatrix2fv(this.addr, !1, t);
}
function zG(n, e) {
  const t = Xu(e, this.size, 9);
  n.uniformMatrix3fv(this.addr, !1, t);
}
function BG(n, e) {
  const t = Xu(e, this.size, 16);
  n.uniformMatrix4fv(this.addr, !1, t);
}
function VG(n, e) {
  n.uniform1iv(this.addr, e);
}
function HG(n, e) {
  n.uniform2iv(this.addr, e);
}
function GG(n, e) {
  n.uniform3iv(this.addr, e);
}
function WG(n, e) {
  n.uniform4iv(this.addr, e);
}
function jG(n, e) {
  n.uniform1uiv(this.addr, e);
}
function XG(n, e) {
  n.uniform2uiv(this.addr, e);
}
function YG(n, e) {
  n.uniform3uiv(this.addr, e);
}
function qG(n, e) {
  n.uniform4uiv(this.addr, e);
}
function ZG(n, e, t) {
  const i = this.cache,
    r = e.length,
    s = Hg(t, r);
  kn(i, s) || (n.uniform1iv(this.addr, s), Fn(i, s));
  for (let o = 0; o !== r; ++o) t.setTexture2D(e[o] || IL, s[o]);
}
function KG(n, e, t) {
  const i = this.cache,
    r = e.length,
    s = Hg(t, r);
  kn(i, s) || (n.uniform1iv(this.addr, s), Fn(i, s));
  for (let o = 0; o !== r; ++o) t.setTexture3D(e[o] || OL, s[o]);
}
function QG(n, e, t) {
  const i = this.cache,
    r = e.length,
    s = Hg(t, r);
  kn(i, s) || (n.uniform1iv(this.addr, s), Fn(i, s));
  for (let o = 0; o !== r; ++o) t.setTextureCube(e[o] || UL, s[o]);
}
function $G(n, e, t) {
  const i = this.cache,
    r = e.length,
    s = Hg(t, r);
  kn(i, s) || (n.uniform1iv(this.addr, s), Fn(i, s));
  for (let o = 0; o !== r; ++o) t.setTexture2DArray(e[o] || DL, s[o]);
}
function JG(n) {
  switch (n) {
    case 5126:
      return DG;
    case 35664:
      return OG;
    case 35665:
      return UG;
    case 35666:
      return kG;
    case 35674:
      return FG;
    case 35675:
      return zG;
    case 35676:
      return BG;
    case 5124:
    case 35670:
      return VG;
    case 35667:
    case 35671:
      return HG;
    case 35668:
    case 35672:
      return GG;
    case 35669:
    case 35673:
      return WG;
    case 5125:
      return jG;
    case 36294:
      return XG;
    case 36295:
      return YG;
    case 36296:
      return qG;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return ZG;
    case 35679:
    case 36299:
    case 36307:
      return KG;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return QG;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return $G;
  }
}
class e9 {
  constructor(e, t, i) {
    (this.id = e),
      (this.addr = i),
      (this.cache = []),
      (this.type = t.type),
      (this.setValue = NG(t.type));
  }
}
class t9 {
  constructor(e, t, i) {
    (this.id = e),
      (this.addr = i),
      (this.cache = []),
      (this.type = t.type),
      (this.size = t.size),
      (this.setValue = JG(t.type));
  }
}
class n9 {
  constructor(e) {
    (this.id = e), (this.seq = []), (this.map = {});
  }
  setValue(e, t, i) {
    const r = this.seq;
    for (let s = 0, o = r.length; s !== o; ++s) {
      const a = r[s];
      a.setValue(e, t[a.id], i);
    }
  }
}
const Ay = /(\w+)(\])?(\[|\.)?/g;
function $2(n, e) {
  n.seq.push(e), (n.map[e.id] = e);
}
function i9(n, e, t) {
  const i = n.name,
    r = i.length;
  for (Ay.lastIndex = 0; ; ) {
    const s = Ay.exec(i),
      o = Ay.lastIndex;
    let a = s[1];
    const u = s[2] === "]",
      f = s[3];
    if ((u && (a = a | 0), f === void 0 || (f === "[" && o + 2 === r))) {
      $2(t, f === void 0 ? new e9(a, n, e) : new t9(a, n, e));
      break;
    } else {
      let d = t.map[a];
      d === void 0 && ((d = new n9(a)), $2(t, d)), (t = d);
    }
  }
}
class dm {
  constructor(e, t) {
    (this.seq = []), (this.map = {});
    const i = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
    for (let r = 0; r < i; ++r) {
      const s = e.getActiveUniform(t, r),
        o = e.getUniformLocation(t, s.name);
      i9(s, o, this);
    }
  }
  setValue(e, t, i, r) {
    const s = this.map[t];
    s !== void 0 && s.setValue(e, i, r);
  }
  setOptional(e, t, i) {
    const r = t[i];
    r !== void 0 && this.setValue(e, i, r);
  }
  static upload(e, t, i, r) {
    for (let s = 0, o = t.length; s !== o; ++s) {
      const a = t[s],
        u = i[a.id];
      u.needsUpdate !== !1 && a.setValue(e, u.value, r);
    }
  }
  static seqWithValue(e, t) {
    const i = [];
    for (let r = 0, s = e.length; r !== s; ++r) {
      const o = e[r];
      o.id in t && i.push(o);
    }
    return i;
  }
}
function J2(n, e, t) {
  const i = n.createShader(e);
  return n.shaderSource(i, t), n.compileShader(i), i;
}
const r9 = 37297;
let s9 = 0;
function o9(n, e) {
  const t = n.split(`
`),
    i = [],
    r = Math.max(e - 6, 0),
    s = Math.min(e + 6, t.length);
  for (let o = r; o < s; o++) {
    const a = o + 1;
    i.push(`${a === e ? ">" : " "} ${a}: ${t[o]}`);
  }
  return i.join(`
`);
}
function a9(n) {
  const e = zt.getPrimaries(zt.workingColorSpace),
    t = zt.getPrimaries(n);
  let i;
  switch (
    (e === t
      ? (i = "")
      : e === Vf && t === Bf
      ? (i = "LinearDisplayP3ToLinearSRGB")
      : e === Bf && t === Vf && (i = "LinearSRGBToLinearDisplayP3"),
    n)
  ) {
    case hs:
    case vh:
      return [i, "LinearTransferOETF"];
    case Dn:
    case Bg:
      return [i, "sRGBTransferOETF"];
    default:
      return (
        console.warn("THREE.WebGLProgram: Unsupported color space:", n),
        [i, "LinearTransferOETF"]
      );
  }
}
function eA(n, e, t) {
  const i = n.getShaderParameter(e, n.COMPILE_STATUS),
    r = n.getShaderInfoLog(e).trim();
  if (i && r === "") return "";
  const s = /ERROR: 0:(\d+)/.exec(r);
  if (s) {
    const o = parseInt(s[1]);
    return (
      t.toUpperCase() +
      `

` +
      r +
      `

` +
      o9(n.getShaderSource(e), o)
    );
  } else return r;
}
function l9(n, e) {
  const t = a9(e);
  return `vec4 ${n}( vec4 value ) { return ${t[0]}( ${t[1]}( value ) ); }`;
}
function u9(n, e) {
  let t;
  switch (e) {
    case ZR:
      t = "Linear";
      break;
    case KR:
      t = "Reinhard";
      break;
    case QR:
      t = "OptimizedCineon";
      break;
    case _S:
      t = "ACESFilmic";
      break;
    case JR:
      t = "AgX";
      break;
    case $R:
      t = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
        (t = "Linear");
  }
  return (
    "vec3 " + n + "( vec3 color ) { return " + t + "ToneMapping( color ); }"
  );
}
function c9(n) {
  return [
    n.extensionDerivatives ||
    n.envMapCubeUVHeight ||
    n.bumpMap ||
    n.normalMapTangentSpace ||
    n.clearcoatNormalMap ||
    n.flatShading ||
    n.shaderID === "physical"
      ? "#extension GL_OES_standard_derivatives : enable"
      : "",
    (n.extensionFragDepth || n.logarithmicDepthBuffer) &&
    n.rendererExtensionFragDepth
      ? "#extension GL_EXT_frag_depth : enable"
      : "",
    n.extensionDrawBuffers && n.rendererExtensionDrawBuffers
      ? "#extension GL_EXT_draw_buffers : require"
      : "",
    (n.extensionShaderTextureLOD || n.envMap || n.transmission) &&
    n.rendererExtensionShaderTextureLod
      ? "#extension GL_EXT_shader_texture_lod : enable"
      : "",
  ].filter(mu).join(`
`);
}
function f9(n) {
  return [
    n.extensionClipCullDistance
      ? "#extension GL_ANGLE_clip_cull_distance : require"
      : "",
  ].filter(mu).join(`
`);
}
function h9(n) {
  const e = [];
  for (const t in n) {
    const i = n[t];
    i !== !1 && e.push("#define " + t + " " + i);
  }
  return e.join(`
`);
}
function d9(n, e) {
  const t = {},
    i = n.getProgramParameter(e, n.ACTIVE_ATTRIBUTES);
  for (let r = 0; r < i; r++) {
    const s = n.getActiveAttrib(e, r),
      o = s.name;
    let a = 1;
    s.type === n.FLOAT_MAT2 && (a = 2),
      s.type === n.FLOAT_MAT3 && (a = 3),
      s.type === n.FLOAT_MAT4 && (a = 4),
      (t[o] = {
        type: s.type,
        location: n.getAttribLocation(e, o),
        locationSize: a,
      });
  }
  return t;
}
function mu(n) {
  return n !== "";
}
function tA(n, e) {
  const t =
    e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return n
    .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
    .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
    .replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps)
    .replace(/NUM_SPOT_LIGHT_COORDS/g, t)
    .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
    .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
    .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
    .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
    .replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps)
    .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
    .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function nA(n, e) {
  return n
    .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
    .replace(
      /UNION_CLIPPING_PLANES/g,
      e.numClippingPlanes - e.numClipIntersection
    );
}
const p9 = /^[ \t]*#include +<([\w\d./]+)>/gm;
function z_(n) {
  return n.replace(p9, g9);
}
const m9 = new Map([
  ["encodings_fragment", "colorspace_fragment"],
  ["encodings_pars_fragment", "colorspace_pars_fragment"],
  ["output_fragment", "opaque_fragment"],
]);
function g9(n, e) {
  let t = St[e];
  if (t === void 0) {
    const i = m9.get(e);
    if (i !== void 0)
      (t = St[i]),
        console.warn(
          'THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',
          e,
          i
        );
    else throw new Error("Can not resolve #include <" + e + ">");
  }
  return z_(t);
}
const v9 =
  /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function iA(n) {
  return n.replace(v9, y9);
}
function y9(n, e, t, i) {
  let r = "";
  for (let s = parseInt(e); s < parseInt(t); s++)
    r += i
      .replace(/\[\s*i\s*\]/g, "[ " + s + " ]")
      .replace(/UNROLLED_LOOP_INDEX/g, s);
  return r;
}
function rA(n) {
  let e =
    "precision " +
    n.precision +
    ` float;
precision ` +
    n.precision +
    " int;";
  return (
    n.precision === "highp"
      ? (e += `
#define HIGH_PRECISION`)
      : n.precision === "mediump"
      ? (e += `
#define MEDIUM_PRECISION`)
      : n.precision === "lowp" &&
        (e += `
#define LOW_PRECISION`),
    e
  );
}
function x9(n) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return (
    n.shadowMapType === Ug
      ? (e = "SHADOWMAP_TYPE_PCF")
      : n.shadowMapType === sf
      ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
      : n.shadowMapType === Ir && (e = "SHADOWMAP_TYPE_VSM"),
    e
  );
}
function _9(n) {
  let e = "ENVMAP_TYPE_CUBE";
  if (n.envMap)
    switch (n.envMapMode) {
      case Xs:
      case Go:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case ju:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function S9(n) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (n.envMap)
    switch (n.envMapMode) {
      case Go:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function M9(n) {
  let e = "ENVMAP_BLENDING_NONE";
  if (n.envMap)
    switch (n.combine) {
      case gh:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case YR:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case qR:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function w9(n) {
  const e = n.envMapCubeUVHeight;
  if (e === null) return null;
  const t = Math.log2(e) - 2,
    i = 1 / e;
  return {
    texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
    texelHeight: i,
    maxMip: t,
  };
}
function E9(n, e, t, i) {
  const r = n.getContext(),
    s = t.defines;
  let o = t.vertexShader,
    a = t.fragmentShader;
  const u = x9(t),
    f = _9(t),
    h = S9(t),
    d = M9(t),
    p = w9(t),
    m = t.isWebGL2 ? "" : c9(t),
    y = f9(t),
    w = h9(s),
    S = r.createProgram();
  let v,
    M,
    _ = t.glslVersion
      ? "#version " +
        t.glslVersion +
        `
`
      : "";
  t.isRawShaderMaterial
    ? ((v = [
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        w,
      ].filter(mu).join(`
`)),
      v.length > 0 &&
        (v += `
`),
      (M = [
        m,
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        w,
      ].filter(mu).join(`
`)),
      M.length > 0 &&
        (M += `
`))
    : ((v = [
        rA(t),
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        w,
        t.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
        t.batching ? "#define USE_BATCHING" : "",
        t.instancing ? "#define USE_INSTANCING" : "",
        t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
        t.useFog && t.fog ? "#define USE_FOG" : "",
        t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
        t.map ? "#define USE_MAP" : "",
        t.envMap ? "#define USE_ENVMAP" : "",
        t.envMap ? "#define " + h : "",
        t.lightMap ? "#define USE_LIGHTMAP" : "",
        t.aoMap ? "#define USE_AOMAP" : "",
        t.bumpMap ? "#define USE_BUMPMAP" : "",
        t.normalMap ? "#define USE_NORMALMAP" : "",
        t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
        t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        t.anisotropy ? "#define USE_ANISOTROPY" : "",
        t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        t.specularMap ? "#define USE_SPECULARMAP" : "",
        t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        t.metalnessMap ? "#define USE_METALNESSMAP" : "",
        t.alphaMap ? "#define USE_ALPHAMAP" : "",
        t.alphaHash ? "#define USE_ALPHAHASH" : "",
        t.transmission ? "#define USE_TRANSMISSION" : "",
        t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        t.mapUv ? "#define MAP_UV " + t.mapUv : "",
        t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "",
        t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "",
        t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "",
        t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "",
        t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "",
        t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "",
        t.displacementMapUv
          ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv
          : "",
        t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "",
        t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "",
        t.anisotropyMapUv
          ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv
          : "",
        t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "",
        t.clearcoatNormalMapUv
          ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv
          : "",
        t.clearcoatRoughnessMapUv
          ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv
          : "",
        t.iridescenceMapUv
          ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv
          : "",
        t.iridescenceThicknessMapUv
          ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv
          : "",
        t.sheenColorMapUv
          ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv
          : "",
        t.sheenRoughnessMapUv
          ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv
          : "",
        t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "",
        t.specularColorMapUv
          ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv
          : "",
        t.specularIntensityMapUv
          ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv
          : "",
        t.transmissionMapUv
          ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv
          : "",
        t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "",
        t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
        t.vertexColors ? "#define USE_COLOR" : "",
        t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        t.vertexUv1s ? "#define USE_UV1" : "",
        t.vertexUv2s ? "#define USE_UV2" : "",
        t.vertexUv3s ? "#define USE_UV3" : "",
        t.pointsUvs ? "#define USE_POINTS_UV" : "",
        t.flatShading ? "#define FLAT_SHADED" : "",
        t.skinning ? "#define USE_SKINNING" : "",
        t.morphTargets ? "#define USE_MORPHTARGETS" : "",
        t.morphNormals && t.flatShading === !1
          ? "#define USE_MORPHNORMALS"
          : "",
        t.morphColors && t.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
        t.morphTargetsCount > 0 && t.isWebGL2
          ? "#define MORPHTARGETS_TEXTURE"
          : "",
        t.morphTargetsCount > 0 && t.isWebGL2
          ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride
          : "",
        t.morphTargetsCount > 0 && t.isWebGL2
          ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount
          : "",
        t.doubleSided ? "#define DOUBLE_SIDED" : "",
        t.flipSided ? "#define FLIP_SIDED" : "",
        t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        t.shadowMapEnabled ? "#define " + u : "",
        t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
        t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
        t.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
        t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        t.logarithmicDepthBuffer && t.rendererExtensionFragDepth
          ? "#define USE_LOGDEPTHBUF_EXT"
          : "",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat4 projectionMatrix;",
        "uniform mat4 viewMatrix;",
        "uniform mat3 normalMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        "#ifdef USE_INSTANCING",
        "	attribute mat4 instanceMatrix;",
        "#endif",
        "#ifdef USE_INSTANCING_COLOR",
        "	attribute vec3 instanceColor;",
        "#endif",
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "attribute vec2 uv;",
        "#ifdef USE_UV1",
        "	attribute vec2 uv1;",
        "#endif",
        "#ifdef USE_UV2",
        "	attribute vec2 uv2;",
        "#endif",
        "#ifdef USE_UV3",
        "	attribute vec2 uv3;",
        "#endif",
        "#ifdef USE_TANGENT",
        "	attribute vec4 tangent;",
        "#endif",
        "#if defined( USE_COLOR_ALPHA )",
        "	attribute vec4 color;",
        "#elif defined( USE_COLOR )",
        "	attribute vec3 color;",
        "#endif",
        "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
        "	attribute vec3 morphTarget0;",
        "	attribute vec3 morphTarget1;",
        "	attribute vec3 morphTarget2;",
        "	attribute vec3 morphTarget3;",
        "	#ifdef USE_MORPHNORMALS",
        "		attribute vec3 morphNormal0;",
        "		attribute vec3 morphNormal1;",
        "		attribute vec3 morphNormal2;",
        "		attribute vec3 morphNormal3;",
        "	#else",
        "		attribute vec3 morphTarget4;",
        "		attribute vec3 morphTarget5;",
        "		attribute vec3 morphTarget6;",
        "		attribute vec3 morphTarget7;",
        "	#endif",
        "#endif",
        "#ifdef USE_SKINNING",
        "	attribute vec4 skinIndex;",
        "	attribute vec4 skinWeight;",
        "#endif",
        `
`,
      ].filter(mu).join(`
`)),
      (M = [
        m,
        rA(t),
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        w,
        t.useFog && t.fog ? "#define USE_FOG" : "",
        t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
        t.map ? "#define USE_MAP" : "",
        t.matcap ? "#define USE_MATCAP" : "",
        t.envMap ? "#define USE_ENVMAP" : "",
        t.envMap ? "#define " + f : "",
        t.envMap ? "#define " + h : "",
        t.envMap ? "#define " + d : "",
        p ? "#define CUBEUV_TEXEL_WIDTH " + p.texelWidth : "",
        p ? "#define CUBEUV_TEXEL_HEIGHT " + p.texelHeight : "",
        p ? "#define CUBEUV_MAX_MIP " + p.maxMip + ".0" : "",
        t.lightMap ? "#define USE_LIGHTMAP" : "",
        t.aoMap ? "#define USE_AOMAP" : "",
        t.bumpMap ? "#define USE_BUMPMAP" : "",
        t.normalMap ? "#define USE_NORMALMAP" : "",
        t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        t.anisotropy ? "#define USE_ANISOTROPY" : "",
        t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        t.clearcoat ? "#define USE_CLEARCOAT" : "",
        t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        t.iridescence ? "#define USE_IRIDESCENCE" : "",
        t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        t.specularMap ? "#define USE_SPECULARMAP" : "",
        t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        t.metalnessMap ? "#define USE_METALNESSMAP" : "",
        t.alphaMap ? "#define USE_ALPHAMAP" : "",
        t.alphaTest ? "#define USE_ALPHATEST" : "",
        t.alphaHash ? "#define USE_ALPHAHASH" : "",
        t.sheen ? "#define USE_SHEEN" : "",
        t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        t.transmission ? "#define USE_TRANSMISSION" : "",
        t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
        t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "",
        t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        t.vertexUv1s ? "#define USE_UV1" : "",
        t.vertexUv2s ? "#define USE_UV2" : "",
        t.vertexUv3s ? "#define USE_UV3" : "",
        t.pointsUvs ? "#define USE_POINTS_UV" : "",
        t.gradientMap ? "#define USE_GRADIENTMAP" : "",
        t.flatShading ? "#define FLAT_SHADED" : "",
        t.doubleSided ? "#define DOUBLE_SIDED" : "",
        t.flipSided ? "#define FLIP_SIDED" : "",
        t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        t.shadowMapEnabled ? "#define " + u : "",
        t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
        t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
        t.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
        t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
        t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        t.logarithmicDepthBuffer && t.rendererExtensionFragDepth
          ? "#define USE_LOGDEPTHBUF_EXT"
          : "",
        "uniform mat4 viewMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        t.toneMapping !== us ? "#define TONE_MAPPING" : "",
        t.toneMapping !== us ? St.tonemapping_pars_fragment : "",
        t.toneMapping !== us ? u9("toneMapping", t.toneMapping) : "",
        t.dithering ? "#define DITHERING" : "",
        t.opaque ? "#define OPAQUE" : "",
        St.colorspace_pars_fragment,
        l9("linearToOutputTexel", t.outputColorSpace),
        t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
        `
`,
      ].filter(mu).join(`
`))),
    (o = z_(o)),
    (o = tA(o, t)),
    (o = nA(o, t)),
    (a = z_(a)),
    (a = tA(a, t)),
    (a = nA(a, t)),
    (o = iA(o)),
    (a = iA(a)),
    t.isWebGL2 &&
      t.isRawShaderMaterial !== !0 &&
      ((_ = `#version 300 es
`),
      (v =
        [
          y,
          "precision mediump sampler2DArray;",
          "#define attribute in",
          "#define varying out",
          "#define texture2D texture",
        ].join(`
`) +
        `
` +
        v),
      (M =
        [
          "precision mediump sampler2DArray;",
          "#define varying in",
          t.glslVersion === U_
            ? ""
            : "layout(location = 0) out highp vec4 pc_fragColor;",
          t.glslVersion === U_ ? "" : "#define gl_FragColor pc_fragColor",
          "#define gl_FragDepthEXT gl_FragDepth",
          "#define texture2D texture",
          "#define textureCube texture",
          "#define texture2DProj textureProj",
          "#define texture2DLodEXT textureLod",
          "#define texture2DProjLodEXT textureProjLod",
          "#define textureCubeLodEXT textureLod",
          "#define texture2DGradEXT textureGrad",
          "#define texture2DProjGradEXT textureProjGrad",
          "#define textureCubeGradEXT textureGrad",
        ].join(`
`) +
        `
` +
        M));
  const T = _ + v + o,
    P = _ + M + a,
    b = J2(r, r.VERTEX_SHADER, T),
    L = J2(r, r.FRAGMENT_SHADER, P);
  r.attachShader(S, b),
    r.attachShader(S, L),
    t.index0AttributeName !== void 0
      ? r.bindAttribLocation(S, 0, t.index0AttributeName)
      : t.morphTargets === !0 && r.bindAttribLocation(S, 0, "position"),
    r.linkProgram(S);
  function N(Z) {
    if (n.debug.checkShaderErrors) {
      const ae = r.getProgramInfoLog(S).trim(),
        V = r.getShaderInfoLog(b).trim(),
        Q = r.getShaderInfoLog(L).trim();
      let $ = !0,
        ce = !0;
      if (r.getProgramParameter(S, r.LINK_STATUS) === !1)
        if ((($ = !1), typeof n.debug.onShaderError == "function"))
          n.debug.onShaderError(r, S, b, L);
        else {
          const k = eA(r, b, "vertex"),
            G = eA(r, L, "fragment");
          console.error(
            "THREE.WebGLProgram: Shader Error " +
              r.getError() +
              " - VALIDATE_STATUS " +
              r.getProgramParameter(S, r.VALIDATE_STATUS) +
              `

Program Info Log: ` +
              ae +
              `
` +
              k +
              `
` +
              G
          );
        }
      else
        ae !== ""
          ? console.warn("THREE.WebGLProgram: Program Info Log:", ae)
          : (V === "" || Q === "") && (ce = !1);
      ce &&
        (Z.diagnostics = {
          runnable: $,
          programLog: ae,
          vertexShader: { log: V, prefix: v },
          fragmentShader: { log: Q, prefix: M },
        });
    }
    r.deleteShader(b), r.deleteShader(L), (C = new dm(r, S)), (R = d9(r, S));
  }
  let C;
  this.getUniforms = function () {
    return C === void 0 && N(this), C;
  };
  let R;
  this.getAttributes = function () {
    return R === void 0 && N(this), R;
  };
  let B = t.rendererExtensionParallelShaderCompile === !1;
  return (
    (this.isReady = function () {
      return B === !1 && (B = r.getProgramParameter(S, r9)), B;
    }),
    (this.destroy = function () {
      i.releaseStatesOfProgram(this),
        r.deleteProgram(S),
        (this.program = void 0);
    }),
    (this.type = t.shaderType),
    (this.name = t.shaderName),
    (this.id = s9++),
    (this.cacheKey = e),
    (this.usedTimes = 1),
    (this.program = S),
    (this.vertexShader = b),
    (this.fragmentShader = L),
    this
  );
}
let T9 = 0;
class A9 {
  constructor() {
    (this.shaderCache = new Map()), (this.materialCache = new Map());
  }
  update(e) {
    const t = e.vertexShader,
      i = e.fragmentShader,
      r = this._getShaderStage(t),
      s = this._getShaderStage(i),
      o = this._getShaderCacheForMaterial(e);
    return (
      o.has(r) === !1 && (o.add(r), r.usedTimes++),
      o.has(s) === !1 && (o.add(s), s.usedTimes++),
      this
    );
  }
  remove(e) {
    const t = this.materialCache.get(e);
    for (const i of t)
      i.usedTimes--, i.usedTimes === 0 && this.shaderCache.delete(i.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const t = this.materialCache;
    let i = t.get(e);
    return i === void 0 && ((i = new Set()), t.set(e, i)), i;
  }
  _getShaderStage(e) {
    const t = this.shaderCache;
    let i = t.get(e);
    return i === void 0 && ((i = new b9(e)), t.set(e, i)), i;
  }
}
class b9 {
  constructor(e) {
    (this.id = T9++), (this.code = e), (this.usedTimes = 0);
  }
}
function C9(n, e, t, i, r, s, o) {
  const a = new Ga(),
    u = new A9(),
    f = [],
    h = r.isWebGL2,
    d = r.logarithmicDepthBuffer,
    p = r.vertexTextures;
  let m = r.precision;
  const y = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite",
  };
  function w(C) {
    return C === 0 ? "uv" : `uv${C}`;
  }
  function S(C, R, B, Z, ae) {
    const V = Z.fog,
      Q = ae.geometry,
      $ = C.isMeshStandardMaterial ? Z.environment : null,
      ce = (C.isMeshStandardMaterial ? t : e).get(C.envMap || $),
      k = ce && ce.mapping === ju ? ce.image.height : null,
      G = y[C.type];
    C.precision !== null &&
      ((m = r.getMaxPrecision(C.precision)),
      m !== C.precision &&
        console.warn(
          "THREE.WebGLProgram.getParameters:",
          C.precision,
          "not supported, using",
          m,
          "instead."
        ));
    const W =
        Q.morphAttributes.position ||
        Q.morphAttributes.normal ||
        Q.morphAttributes.color,
      Y = W !== void 0 ? W.length : 0;
    let ie = 0;
    Q.morphAttributes.position !== void 0 && (ie = 1),
      Q.morphAttributes.normal !== void 0 && (ie = 2),
      Q.morphAttributes.color !== void 0 && (ie = 3);
    let J, he, Ee, be;
    if (G) {
      const Jt = Or[G];
      (J = Jt.vertexShader), (he = Jt.fragmentShader);
    } else
      (J = C.vertexShader),
        (he = C.fragmentShader),
        u.update(C),
        (Ee = u.getVertexShaderID(C)),
        (be = u.getFragmentShaderID(C));
    const Pe = n.getRenderTarget(),
      it = ae.isInstancedMesh === !0,
      rt = ae.isBatchedMesh === !0,
      Ve = !!C.map,
      We = !!C.matcap,
      H = !!ce,
      Me = !!C.aoMap,
      pe = !!C.lightMap,
      Te = !!C.bumpMap,
      me = !!C.normalMap,
      Ke = !!C.displacementMap,
      Ne = !!C.emissiveMap,
      D = !!C.metalnessMap,
      I = !!C.roughnessMap,
      te = C.anisotropy > 0,
      xe = C.clearcoat > 0,
      ye = C.iridescence > 0,
      ge = C.sheen > 0,
      Ye = C.transmission > 0,
      Le = te && !!C.anisotropyMap,
      Fe = xe && !!C.clearcoatMap,
      tt = xe && !!C.clearcoatNormalMap,
      mt = xe && !!C.clearcoatRoughnessMap,
      _e = ye && !!C.iridescenceMap,
      Rt = ye && !!C.iridescenceThicknessMap,
      _t = ge && !!C.sheenColorMap,
      ht = ge && !!C.sheenRoughnessMap,
      et = !!C.specularMap,
      He = !!C.specularColorMap,
      j = !!C.specularIntensityMap,
      ve = Ye && !!C.transmissionMap,
      ke = Ye && !!C.thicknessMap,
      Oe = !!C.gradientMap,
      Se = !!C.alphaMap,
      X = C.alphaTest > 0,
      Ce = !!C.alphaHash,
      Ie = !!C.extensions,
      st = !!Q.attributes.uv1,
      qe = !!Q.attributes.uv2,
      Ct = !!Q.attributes.uv3;
    let Lt = us;
    return (
      C.toneMapped &&
        (Pe === null || Pe.isXRRenderTarget === !0) &&
        (Lt = n.toneMapping),
      {
        isWebGL2: h,
        shaderID: G,
        shaderType: C.type,
        shaderName: C.name,
        vertexShader: J,
        fragmentShader: he,
        defines: C.defines,
        customVertexShaderID: Ee,
        customFragmentShaderID: be,
        isRawShaderMaterial: C.isRawShaderMaterial === !0,
        glslVersion: C.glslVersion,
        precision: m,
        batching: rt,
        instancing: it,
        instancingColor: it && ae.instanceColor !== null,
        supportsVertexTextures: p,
        outputColorSpace:
          Pe === null
            ? n.outputColorSpace
            : Pe.isXRRenderTarget === !0
            ? Pe.texture.colorSpace
            : hs,
        map: Ve,
        matcap: We,
        envMap: H,
        envMapMode: H && ce.mapping,
        envMapCubeUVHeight: k,
        aoMap: Me,
        lightMap: pe,
        bumpMap: Te,
        normalMap: me,
        displacementMap: p && Ke,
        emissiveMap: Ne,
        normalMapObjectSpace: me && C.normalMapType === pL,
        normalMapTangentSpace: me && C.normalMapType === Ko,
        metalnessMap: D,
        roughnessMap: I,
        anisotropy: te,
        anisotropyMap: Le,
        clearcoat: xe,
        clearcoatMap: Fe,
        clearcoatNormalMap: tt,
        clearcoatRoughnessMap: mt,
        iridescence: ye,
        iridescenceMap: _e,
        iridescenceThicknessMap: Rt,
        sheen: ge,
        sheenColorMap: _t,
        sheenRoughnessMap: ht,
        specularMap: et,
        specularColorMap: He,
        specularIntensityMap: j,
        transmission: Ye,
        transmissionMap: ve,
        thicknessMap: ke,
        gradientMap: Oe,
        opaque: C.transparent === !1 && C.blending === Va,
        alphaMap: Se,
        alphaTest: X,
        alphaHash: Ce,
        combine: C.combine,
        mapUv: Ve && w(C.map.channel),
        aoMapUv: Me && w(C.aoMap.channel),
        lightMapUv: pe && w(C.lightMap.channel),
        bumpMapUv: Te && w(C.bumpMap.channel),
        normalMapUv: me && w(C.normalMap.channel),
        displacementMapUv: Ke && w(C.displacementMap.channel),
        emissiveMapUv: Ne && w(C.emissiveMap.channel),
        metalnessMapUv: D && w(C.metalnessMap.channel),
        roughnessMapUv: I && w(C.roughnessMap.channel),
        anisotropyMapUv: Le && w(C.anisotropyMap.channel),
        clearcoatMapUv: Fe && w(C.clearcoatMap.channel),
        clearcoatNormalMapUv: tt && w(C.clearcoatNormalMap.channel),
        clearcoatRoughnessMapUv: mt && w(C.clearcoatRoughnessMap.channel),
        iridescenceMapUv: _e && w(C.iridescenceMap.channel),
        iridescenceThicknessMapUv: Rt && w(C.iridescenceThicknessMap.channel),
        sheenColorMapUv: _t && w(C.sheenColorMap.channel),
        sheenRoughnessMapUv: ht && w(C.sheenRoughnessMap.channel),
        specularMapUv: et && w(C.specularMap.channel),
        specularColorMapUv: He && w(C.specularColorMap.channel),
        specularIntensityMapUv: j && w(C.specularIntensityMap.channel),
        transmissionMapUv: ve && w(C.transmissionMap.channel),
        thicknessMapUv: ke && w(C.thicknessMap.channel),
        alphaMapUv: Se && w(C.alphaMap.channel),
        vertexTangents: !!Q.attributes.tangent && (me || te),
        vertexColors: C.vertexColors,
        vertexAlphas:
          C.vertexColors === !0 &&
          !!Q.attributes.color &&
          Q.attributes.color.itemSize === 4,
        vertexUv1s: st,
        vertexUv2s: qe,
        vertexUv3s: Ct,
        pointsUvs: ae.isPoints === !0 && !!Q.attributes.uv && (Ve || Se),
        fog: !!V,
        useFog: C.fog === !0,
        fogExp2: V && V.isFogExp2,
        flatShading: C.flatShading === !0,
        sizeAttenuation: C.sizeAttenuation === !0,
        logarithmicDepthBuffer: d,
        skinning: ae.isSkinnedMesh === !0,
        morphTargets: Q.morphAttributes.position !== void 0,
        morphNormals: Q.morphAttributes.normal !== void 0,
        morphColors: Q.morphAttributes.color !== void 0,
        morphTargetsCount: Y,
        morphTextureStride: ie,
        numDirLights: R.directional.length,
        numPointLights: R.point.length,
        numSpotLights: R.spot.length,
        numSpotLightMaps: R.spotLightMap.length,
        numRectAreaLights: R.rectArea.length,
        numHemiLights: R.hemi.length,
        numDirLightShadows: R.directionalShadowMap.length,
        numPointLightShadows: R.pointShadowMap.length,
        numSpotLightShadows: R.spotShadowMap.length,
        numSpotLightShadowsWithMaps: R.numSpotLightShadowsWithMaps,
        numLightProbes: R.numLightProbes,
        numClippingPlanes: o.numPlanes,
        numClipIntersection: o.numIntersection,
        dithering: C.dithering,
        shadowMapEnabled: n.shadowMap.enabled && B.length > 0,
        shadowMapType: n.shadowMap.type,
        toneMapping: Lt,
        useLegacyLights: n._useLegacyLights,
        decodeVideoTexture:
          Ve &&
          C.map.isVideoTexture === !0 &&
          zt.getTransfer(C.map.colorSpace) === jt,
        premultipliedAlpha: C.premultipliedAlpha,
        doubleSided: C.side === rs,
        flipSided: C.side === Ti,
        useDepthPacking: C.depthPacking >= 0,
        depthPacking: C.depthPacking || 0,
        index0AttributeName: C.index0AttributeName,
        extensionDerivatives: Ie && C.extensions.derivatives === !0,
        extensionFragDepth: Ie && C.extensions.fragDepth === !0,
        extensionDrawBuffers: Ie && C.extensions.drawBuffers === !0,
        extensionShaderTextureLOD: Ie && C.extensions.shaderTextureLOD === !0,
        extensionClipCullDistance:
          Ie &&
          C.extensions.clipCullDistance &&
          i.has("WEBGL_clip_cull_distance"),
        rendererExtensionFragDepth: h || i.has("EXT_frag_depth"),
        rendererExtensionDrawBuffers: h || i.has("WEBGL_draw_buffers"),
        rendererExtensionShaderTextureLod: h || i.has("EXT_shader_texture_lod"),
        rendererExtensionParallelShaderCompile: i.has(
          "KHR_parallel_shader_compile"
        ),
        customProgramCacheKey: C.customProgramCacheKey(),
      }
    );
  }
  function v(C) {
    const R = [];
    if (
      (C.shaderID
        ? R.push(C.shaderID)
        : (R.push(C.customVertexShaderID), R.push(C.customFragmentShaderID)),
      C.defines !== void 0)
    )
      for (const B in C.defines) R.push(B), R.push(C.defines[B]);
    return (
      C.isRawShaderMaterial === !1 &&
        (M(R, C), _(R, C), R.push(n.outputColorSpace)),
      R.push(C.customProgramCacheKey),
      R.join()
    );
  }
  function M(C, R) {
    C.push(R.precision),
      C.push(R.outputColorSpace),
      C.push(R.envMapMode),
      C.push(R.envMapCubeUVHeight),
      C.push(R.mapUv),
      C.push(R.alphaMapUv),
      C.push(R.lightMapUv),
      C.push(R.aoMapUv),
      C.push(R.bumpMapUv),
      C.push(R.normalMapUv),
      C.push(R.displacementMapUv),
      C.push(R.emissiveMapUv),
      C.push(R.metalnessMapUv),
      C.push(R.roughnessMapUv),
      C.push(R.anisotropyMapUv),
      C.push(R.clearcoatMapUv),
      C.push(R.clearcoatNormalMapUv),
      C.push(R.clearcoatRoughnessMapUv),
      C.push(R.iridescenceMapUv),
      C.push(R.iridescenceThicknessMapUv),
      C.push(R.sheenColorMapUv),
      C.push(R.sheenRoughnessMapUv),
      C.push(R.specularMapUv),
      C.push(R.specularColorMapUv),
      C.push(R.specularIntensityMapUv),
      C.push(R.transmissionMapUv),
      C.push(R.thicknessMapUv),
      C.push(R.combine),
      C.push(R.fogExp2),
      C.push(R.sizeAttenuation),
      C.push(R.morphTargetsCount),
      C.push(R.morphAttributeCount),
      C.push(R.numDirLights),
      C.push(R.numPointLights),
      C.push(R.numSpotLights),
      C.push(R.numSpotLightMaps),
      C.push(R.numHemiLights),
      C.push(R.numRectAreaLights),
      C.push(R.numDirLightShadows),
      C.push(R.numPointLightShadows),
      C.push(R.numSpotLightShadows),
      C.push(R.numSpotLightShadowsWithMaps),
      C.push(R.numLightProbes),
      C.push(R.shadowMapType),
      C.push(R.toneMapping),
      C.push(R.numClippingPlanes),
      C.push(R.numClipIntersection),
      C.push(R.depthPacking);
  }
  function _(C, R) {
    a.disableAll(),
      R.isWebGL2 && a.enable(0),
      R.supportsVertexTextures && a.enable(1),
      R.instancing && a.enable(2),
      R.instancingColor && a.enable(3),
      R.matcap && a.enable(4),
      R.envMap && a.enable(5),
      R.normalMapObjectSpace && a.enable(6),
      R.normalMapTangentSpace && a.enable(7),
      R.clearcoat && a.enable(8),
      R.iridescence && a.enable(9),
      R.alphaTest && a.enable(10),
      R.vertexColors && a.enable(11),
      R.vertexAlphas && a.enable(12),
      R.vertexUv1s && a.enable(13),
      R.vertexUv2s && a.enable(14),
      R.vertexUv3s && a.enable(15),
      R.vertexTangents && a.enable(16),
      R.anisotropy && a.enable(17),
      R.alphaHash && a.enable(18),
      R.batching && a.enable(19),
      C.push(a.mask),
      a.disableAll(),
      R.fog && a.enable(0),
      R.useFog && a.enable(1),
      R.flatShading && a.enable(2),
      R.logarithmicDepthBuffer && a.enable(3),
      R.skinning && a.enable(4),
      R.morphTargets && a.enable(5),
      R.morphNormals && a.enable(6),
      R.morphColors && a.enable(7),
      R.premultipliedAlpha && a.enable(8),
      R.shadowMapEnabled && a.enable(9),
      R.useLegacyLights && a.enable(10),
      R.doubleSided && a.enable(11),
      R.flipSided && a.enable(12),
      R.useDepthPacking && a.enable(13),
      R.dithering && a.enable(14),
      R.transmission && a.enable(15),
      R.sheen && a.enable(16),
      R.opaque && a.enable(17),
      R.pointsUvs && a.enable(18),
      R.decodeVideoTexture && a.enable(19),
      C.push(a.mask);
  }
  function T(C) {
    const R = y[C.type];
    let B;
    if (R) {
      const Z = Or[R];
      B = CL.clone(Z.uniforms);
    } else B = C.uniforms;
    return B;
  }
  function P(C, R) {
    let B;
    for (let Z = 0, ae = f.length; Z < ae; Z++) {
      const V = f[Z];
      if (V.cacheKey === R) {
        (B = V), ++B.usedTimes;
        break;
      }
    }
    return B === void 0 && ((B = new E9(n, R, C, s)), f.push(B)), B;
  }
  function b(C) {
    if (--C.usedTimes === 0) {
      const R = f.indexOf(C);
      (f[R] = f[f.length - 1]), f.pop(), C.destroy();
    }
  }
  function L(C) {
    u.remove(C);
  }
  function N() {
    u.dispose();
  }
  return {
    getParameters: S,
    getProgramCacheKey: v,
    getUniforms: T,
    acquireProgram: P,
    releaseProgram: b,
    releaseShaderCache: L,
    programs: f,
    dispose: N,
  };
}
function P9() {
  let n = new WeakMap();
  function e(s) {
    let o = n.get(s);
    return o === void 0 && ((o = {}), n.set(s, o)), o;
  }
  function t(s) {
    n.delete(s);
  }
  function i(s, o, a) {
    n.get(s)[o] = a;
  }
  function r() {
    n = new WeakMap();
  }
  return { get: e, remove: t, update: i, dispose: r };
}
function R9(n, e) {
  return n.groupOrder !== e.groupOrder
    ? n.groupOrder - e.groupOrder
    : n.renderOrder !== e.renderOrder
    ? n.renderOrder - e.renderOrder
    : n.material.id !== e.material.id
    ? n.material.id - e.material.id
    : n.z !== e.z
    ? n.z - e.z
    : n.id - e.id;
}
function sA(n, e) {
  return n.groupOrder !== e.groupOrder
    ? n.groupOrder - e.groupOrder
    : n.renderOrder !== e.renderOrder
    ? n.renderOrder - e.renderOrder
    : n.z !== e.z
    ? e.z - n.z
    : n.id - e.id;
}
function oA() {
  const n = [];
  let e = 0;
  const t = [],
    i = [],
    r = [];
  function s() {
    (e = 0), (t.length = 0), (i.length = 0), (r.length = 0);
  }
  function o(d, p, m, y, w, S) {
    let v = n[e];
    return (
      v === void 0
        ? ((v = {
            id: d.id,
            object: d,
            geometry: p,
            material: m,
            groupOrder: y,
            renderOrder: d.renderOrder,
            z: w,
            group: S,
          }),
          (n[e] = v))
        : ((v.id = d.id),
          (v.object = d),
          (v.geometry = p),
          (v.material = m),
          (v.groupOrder = y),
          (v.renderOrder = d.renderOrder),
          (v.z = w),
          (v.group = S)),
      e++,
      v
    );
  }
  function a(d, p, m, y, w, S) {
    const v = o(d, p, m, y, w, S);
    m.transmission > 0
      ? i.push(v)
      : m.transparent === !0
      ? r.push(v)
      : t.push(v);
  }
  function u(d, p, m, y, w, S) {
    const v = o(d, p, m, y, w, S);
    m.transmission > 0
      ? i.unshift(v)
      : m.transparent === !0
      ? r.unshift(v)
      : t.unshift(v);
  }
  function f(d, p) {
    t.length > 1 && t.sort(d || R9),
      i.length > 1 && i.sort(p || sA),
      r.length > 1 && r.sort(p || sA);
  }
  function h() {
    for (let d = e, p = n.length; d < p; d++) {
      const m = n[d];
      if (m.id === null) break;
      (m.id = null),
        (m.object = null),
        (m.geometry = null),
        (m.material = null),
        (m.group = null);
    }
  }
  return {
    opaque: t,
    transmissive: i,
    transparent: r,
    init: s,
    push: a,
    unshift: u,
    finish: h,
    sort: f,
  };
}
function L9() {
  let n = new WeakMap();
  function e(i, r) {
    const s = n.get(i);
    let o;
    return (
      s === void 0
        ? ((o = new oA()), n.set(i, [o]))
        : r >= s.length
        ? ((o = new oA()), s.push(o))
        : (o = s[r]),
      o
    );
  }
  function t() {
    n = new WeakMap();
  }
  return { get: e, dispose: t };
}
function I9() {
  const n = {};
  return {
    get: function (e) {
      if (n[e.id] !== void 0) return n[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = { direction: new U(), color: new Be() };
          break;
        case "SpotLight":
          t = {
            position: new U(),
            direction: new U(),
            color: new Be(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0,
          };
          break;
        case "PointLight":
          t = { position: new U(), color: new Be(), distance: 0, decay: 0 };
          break;
        case "HemisphereLight":
          t = { direction: new U(), skyColor: new Be(), groundColor: new Be() };
          break;
        case "RectAreaLight":
          t = {
            color: new Be(),
            position: new U(),
            halfWidth: new U(),
            halfHeight: new U(),
          };
          break;
      }
      return (n[e.id] = t), t;
    },
  };
}
function N9() {
  const n = {};
  return {
    get: function (e) {
      if (n[e.id] !== void 0) return n[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new de(),
          };
          break;
        case "SpotLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new de(),
          };
          break;
        case "PointLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new de(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3,
          };
          break;
      }
      return (n[e.id] = t), t;
    },
  };
}
let D9 = 0;
function O9(n, e) {
  return (
    (e.castShadow ? 2 : 0) -
    (n.castShadow ? 2 : 0) +
    (e.map ? 1 : 0) -
    (n.map ? 1 : 0)
  );
}
function U9(n, e) {
  const t = new I9(),
    i = N9(),
    r = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1,
        numSpotMaps: -1,
        numLightProbes: -1,
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotLightMap: [],
      spotShadow: [],
      spotShadowMap: [],
      spotLightMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: [],
      numSpotLightShadowsWithMaps: 0,
      numLightProbes: 0,
    };
  for (let h = 0; h < 9; h++) r.probe.push(new U());
  const s = new U(),
    o = new dt(),
    a = new dt();
  function u(h, d) {
    let p = 0,
      m = 0,
      y = 0;
    for (let Z = 0; Z < 9; Z++) r.probe[Z].set(0, 0, 0);
    let w = 0,
      S = 0,
      v = 0,
      M = 0,
      _ = 0,
      T = 0,
      P = 0,
      b = 0,
      L = 0,
      N = 0,
      C = 0;
    h.sort(O9);
    const R = d === !0 ? Math.PI : 1;
    for (let Z = 0, ae = h.length; Z < ae; Z++) {
      const V = h[Z],
        Q = V.color,
        $ = V.intensity,
        ce = V.distance,
        k = V.shadow && V.shadow.map ? V.shadow.map.texture : null;
      if (V.isAmbientLight)
        (p += Q.r * $ * R), (m += Q.g * $ * R), (y += Q.b * $ * R);
      else if (V.isLightProbe) {
        for (let G = 0; G < 9; G++)
          r.probe[G].addScaledVector(V.sh.coefficients[G], $);
        C++;
      } else if (V.isDirectionalLight) {
        const G = t.get(V);
        if (
          (G.color.copy(V.color).multiplyScalar(V.intensity * R), V.castShadow)
        ) {
          const W = V.shadow,
            Y = i.get(V);
          (Y.shadowBias = W.bias),
            (Y.shadowNormalBias = W.normalBias),
            (Y.shadowRadius = W.radius),
            (Y.shadowMapSize = W.mapSize),
            (r.directionalShadow[w] = Y),
            (r.directionalShadowMap[w] = k),
            (r.directionalShadowMatrix[w] = V.shadow.matrix),
            T++;
        }
        (r.directional[w] = G), w++;
      } else if (V.isSpotLight) {
        const G = t.get(V);
        G.position.setFromMatrixPosition(V.matrixWorld),
          G.color.copy(Q).multiplyScalar($ * R),
          (G.distance = ce),
          (G.coneCos = Math.cos(V.angle)),
          (G.penumbraCos = Math.cos(V.angle * (1 - V.penumbra))),
          (G.decay = V.decay),
          (r.spot[v] = G);
        const W = V.shadow;
        if (
          (V.map &&
            ((r.spotLightMap[L] = V.map),
            L++,
            W.updateMatrices(V),
            V.castShadow && N++),
          (r.spotLightMatrix[v] = W.matrix),
          V.castShadow)
        ) {
          const Y = i.get(V);
          (Y.shadowBias = W.bias),
            (Y.shadowNormalBias = W.normalBias),
            (Y.shadowRadius = W.radius),
            (Y.shadowMapSize = W.mapSize),
            (r.spotShadow[v] = Y),
            (r.spotShadowMap[v] = k),
            b++;
        }
        v++;
      } else if (V.isRectAreaLight) {
        const G = t.get(V);
        G.color.copy(Q).multiplyScalar($),
          G.halfWidth.set(V.width * 0.5, 0, 0),
          G.halfHeight.set(0, V.height * 0.5, 0),
          (r.rectArea[M] = G),
          M++;
      } else if (V.isPointLight) {
        const G = t.get(V);
        if (
          (G.color.copy(V.color).multiplyScalar(V.intensity * R),
          (G.distance = V.distance),
          (G.decay = V.decay),
          V.castShadow)
        ) {
          const W = V.shadow,
            Y = i.get(V);
          (Y.shadowBias = W.bias),
            (Y.shadowNormalBias = W.normalBias),
            (Y.shadowRadius = W.radius),
            (Y.shadowMapSize = W.mapSize),
            (Y.shadowCameraNear = W.camera.near),
            (Y.shadowCameraFar = W.camera.far),
            (r.pointShadow[S] = Y),
            (r.pointShadowMap[S] = k),
            (r.pointShadowMatrix[S] = V.shadow.matrix),
            P++;
        }
        (r.point[S] = G), S++;
      } else if (V.isHemisphereLight) {
        const G = t.get(V);
        G.skyColor.copy(V.color).multiplyScalar($ * R),
          G.groundColor.copy(V.groundColor).multiplyScalar($ * R),
          (r.hemi[_] = G),
          _++;
      }
    }
    M > 0 &&
      (e.isWebGL2
        ? n.has("OES_texture_float_linear") === !0
          ? ((r.rectAreaLTC1 = Re.LTC_FLOAT_1),
            (r.rectAreaLTC2 = Re.LTC_FLOAT_2))
          : ((r.rectAreaLTC1 = Re.LTC_HALF_1), (r.rectAreaLTC2 = Re.LTC_HALF_2))
        : n.has("OES_texture_float_linear") === !0
        ? ((r.rectAreaLTC1 = Re.LTC_FLOAT_1), (r.rectAreaLTC2 = Re.LTC_FLOAT_2))
        : n.has("OES_texture_half_float_linear") === !0
        ? ((r.rectAreaLTC1 = Re.LTC_HALF_1), (r.rectAreaLTC2 = Re.LTC_HALF_2))
        : console.error(
            "THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions."
          )),
      (r.ambient[0] = p),
      (r.ambient[1] = m),
      (r.ambient[2] = y);
    const B = r.hash;
    (B.directionalLength !== w ||
      B.pointLength !== S ||
      B.spotLength !== v ||
      B.rectAreaLength !== M ||
      B.hemiLength !== _ ||
      B.numDirectionalShadows !== T ||
      B.numPointShadows !== P ||
      B.numSpotShadows !== b ||
      B.numSpotMaps !== L ||
      B.numLightProbes !== C) &&
      ((r.directional.length = w),
      (r.spot.length = v),
      (r.rectArea.length = M),
      (r.point.length = S),
      (r.hemi.length = _),
      (r.directionalShadow.length = T),
      (r.directionalShadowMap.length = T),
      (r.pointShadow.length = P),
      (r.pointShadowMap.length = P),
      (r.spotShadow.length = b),
      (r.spotShadowMap.length = b),
      (r.directionalShadowMatrix.length = T),
      (r.pointShadowMatrix.length = P),
      (r.spotLightMatrix.length = b + L - N),
      (r.spotLightMap.length = L),
      (r.numSpotLightShadowsWithMaps = N),
      (r.numLightProbes = C),
      (B.directionalLength = w),
      (B.pointLength = S),
      (B.spotLength = v),
      (B.rectAreaLength = M),
      (B.hemiLength = _),
      (B.numDirectionalShadows = T),
      (B.numPointShadows = P),
      (B.numSpotShadows = b),
      (B.numSpotMaps = L),
      (B.numLightProbes = C),
      (r.version = D9++));
  }
  function f(h, d) {
    let p = 0,
      m = 0,
      y = 0,
      w = 0,
      S = 0;
    const v = d.matrixWorldInverse;
    for (let M = 0, _ = h.length; M < _; M++) {
      const T = h[M];
      if (T.isDirectionalLight) {
        const P = r.directional[p];
        P.direction.setFromMatrixPosition(T.matrixWorld),
          s.setFromMatrixPosition(T.target.matrixWorld),
          P.direction.sub(s),
          P.direction.transformDirection(v),
          p++;
      } else if (T.isSpotLight) {
        const P = r.spot[y];
        P.position.setFromMatrixPosition(T.matrixWorld),
          P.position.applyMatrix4(v),
          P.direction.setFromMatrixPosition(T.matrixWorld),
          s.setFromMatrixPosition(T.target.matrixWorld),
          P.direction.sub(s),
          P.direction.transformDirection(v),
          y++;
      } else if (T.isRectAreaLight) {
        const P = r.rectArea[w];
        P.position.setFromMatrixPosition(T.matrixWorld),
          P.position.applyMatrix4(v),
          a.identity(),
          o.copy(T.matrixWorld),
          o.premultiply(v),
          a.extractRotation(o),
          P.halfWidth.set(T.width * 0.5, 0, 0),
          P.halfHeight.set(0, T.height * 0.5, 0),
          P.halfWidth.applyMatrix4(a),
          P.halfHeight.applyMatrix4(a),
          w++;
      } else if (T.isPointLight) {
        const P = r.point[m];
        P.position.setFromMatrixPosition(T.matrixWorld),
          P.position.applyMatrix4(v),
          m++;
      } else if (T.isHemisphereLight) {
        const P = r.hemi[S];
        P.direction.setFromMatrixPosition(T.matrixWorld),
          P.direction.transformDirection(v),
          S++;
      }
    }
  }
  return { setup: u, setupView: f, state: r };
}
function aA(n, e) {
  const t = new U9(n, e),
    i = [],
    r = [];
  function s() {
    (i.length = 0), (r.length = 0);
  }
  function o(d) {
    i.push(d);
  }
  function a(d) {
    r.push(d);
  }
  function u(d) {
    t.setup(i, d);
  }
  function f(d) {
    t.setupView(i, d);
  }
  return {
    init: s,
    state: { lightsArray: i, shadowsArray: r, lights: t },
    setupLights: u,
    setupLightsView: f,
    pushLight: o,
    pushShadow: a,
  };
}
function k9(n, e) {
  let t = new WeakMap();
  function i(s, o = 0) {
    const a = t.get(s);
    let u;
    return (
      a === void 0
        ? ((u = new aA(n, e)), t.set(s, [u]))
        : o >= a.length
        ? ((u = new aA(n, e)), a.push(u))
        : (u = a[o]),
      u
    );
  }
  function r() {
    t = new WeakMap();
  }
  return { get: i, dispose: r };
}
class zS extends gi {
  constructor(e) {
    super(),
      (this.isMeshDepthMaterial = !0),
      (this.type = "MeshDepthMaterial"),
      (this.depthPacking = hL),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.depthPacking = e.depthPacking),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      this
    );
  }
}
class BS extends gi {
  constructor(e) {
    super(),
      (this.isMeshDistanceMaterial = !0),
      (this.type = "MeshDistanceMaterial"),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      this
    );
  }
}
const F9 = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
  z9 = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function B9(n, e, t) {
  let i = new Sh();
  const r = new de(),
    s = new de(),
    o = new Bt(),
    a = new zS({ depthPacking: dL }),
    u = new BS(),
    f = {},
    h = t.maxTextureSize,
    d = { [js]: Ti, [Ti]: js, [rs]: rs },
    p = new Hr({
      defines: { VSM_SAMPLES: 8 },
      uniforms: {
        shadow_pass: { value: null },
        resolution: { value: new de() },
        radius: { value: 4 },
      },
      vertexShader: F9,
      fragmentShader: z9,
    }),
    m = p.clone();
  m.defines.HORIZONTAL_PASS = 1;
  const y = new Tt();
  y.setAttribute(
    "position",
    new Ht(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
  );
  const w = new Un(y, p),
    S = this;
  (this.enabled = !1),
    (this.autoUpdate = !0),
    (this.needsUpdate = !1),
    (this.type = Ug);
  let v = this.type;
  this.render = function (b, L, N) {
    if (
      S.enabled === !1 ||
      (S.autoUpdate === !1 && S.needsUpdate === !1) ||
      b.length === 0
    )
      return;
    const C = n.getRenderTarget(),
      R = n.getActiveCubeFace(),
      B = n.getActiveMipmapLevel(),
      Z = n.state;
    Z.setBlending(zs),
      Z.buffers.color.setClear(1, 1, 1, 1),
      Z.buffers.depth.setTest(!0),
      Z.setScissorTest(!1);
    const ae = v !== Ir && this.type === Ir,
      V = v === Ir && this.type !== Ir;
    for (let Q = 0, $ = b.length; Q < $; Q++) {
      const ce = b[Q],
        k = ce.shadow;
      if (k === void 0) {
        console.warn("THREE.WebGLShadowMap:", ce, "has no shadow.");
        continue;
      }
      if (k.autoUpdate === !1 && k.needsUpdate === !1) continue;
      r.copy(k.mapSize);
      const G = k.getFrameExtents();
      if (
        (r.multiply(G),
        s.copy(k.mapSize),
        (r.x > h || r.y > h) &&
          (r.x > h &&
            ((s.x = Math.floor(h / G.x)),
            (r.x = s.x * G.x),
            (k.mapSize.x = s.x)),
          r.y > h &&
            ((s.y = Math.floor(h / G.y)),
            (r.y = s.y * G.y),
            (k.mapSize.y = s.y))),
        k.map === null || ae === !0 || V === !0)
      ) {
        const Y = this.type !== Ir ? { minFilter: Sn, magFilter: Sn } : {};
        k.map !== null && k.map.dispose(),
          (k.map = new Vr(r.x, r.y, Y)),
          (k.map.texture.name = ce.name + ".shadowMap"),
          k.camera.updateProjectionMatrix();
      }
      n.setRenderTarget(k.map), n.clear();
      const W = k.getViewportCount();
      for (let Y = 0; Y < W; Y++) {
        const ie = k.getViewport(Y);
        o.set(s.x * ie.x, s.y * ie.y, s.x * ie.z, s.y * ie.w),
          Z.viewport(o),
          k.updateMatrices(ce, Y),
          (i = k.getFrustum()),
          T(L, N, k.camera, ce, this.type);
      }
      k.isPointLightShadow !== !0 && this.type === Ir && M(k, N),
        (k.needsUpdate = !1);
    }
    (v = this.type), (S.needsUpdate = !1), n.setRenderTarget(C, R, B);
  };
  function M(b, L) {
    const N = e.update(w);
    p.defines.VSM_SAMPLES !== b.blurSamples &&
      ((p.defines.VSM_SAMPLES = b.blurSamples),
      (m.defines.VSM_SAMPLES = b.blurSamples),
      (p.needsUpdate = !0),
      (m.needsUpdate = !0)),
      b.mapPass === null && (b.mapPass = new Vr(r.x, r.y)),
      (p.uniforms.shadow_pass.value = b.map.texture),
      (p.uniforms.resolution.value = b.mapSize),
      (p.uniforms.radius.value = b.radius),
      n.setRenderTarget(b.mapPass),
      n.clear(),
      n.renderBufferDirect(L, null, N, p, w, null),
      (m.uniforms.shadow_pass.value = b.mapPass.texture),
      (m.uniforms.resolution.value = b.mapSize),
      (m.uniforms.radius.value = b.radius),
      n.setRenderTarget(b.map),
      n.clear(),
      n.renderBufferDirect(L, null, N, m, w, null);
  }
  function _(b, L, N, C) {
    let R = null;
    const B =
      N.isPointLight === !0 ? b.customDistanceMaterial : b.customDepthMaterial;
    if (B !== void 0) R = B;
    else if (
      ((R = N.isPointLight === !0 ? u : a),
      (n.localClippingEnabled &&
        L.clipShadows === !0 &&
        Array.isArray(L.clippingPlanes) &&
        L.clippingPlanes.length !== 0) ||
        (L.displacementMap && L.displacementScale !== 0) ||
        (L.alphaMap && L.alphaTest > 0) ||
        (L.map && L.alphaTest > 0))
    ) {
      const Z = R.uuid,
        ae = L.uuid;
      let V = f[Z];
      V === void 0 && ((V = {}), (f[Z] = V));
      let Q = V[ae];
      Q === void 0 &&
        ((Q = R.clone()), (V[ae] = Q), L.addEventListener("dispose", P)),
        (R = Q);
    }
    if (
      ((R.visible = L.visible),
      (R.wireframe = L.wireframe),
      C === Ir
        ? (R.side = L.shadowSide !== null ? L.shadowSide : L.side)
        : (R.side = L.shadowSide !== null ? L.shadowSide : d[L.side]),
      (R.alphaMap = L.alphaMap),
      (R.alphaTest = L.alphaTest),
      (R.map = L.map),
      (R.clipShadows = L.clipShadows),
      (R.clippingPlanes = L.clippingPlanes),
      (R.clipIntersection = L.clipIntersection),
      (R.displacementMap = L.displacementMap),
      (R.displacementScale = L.displacementScale),
      (R.displacementBias = L.displacementBias),
      (R.wireframeLinewidth = L.wireframeLinewidth),
      (R.linewidth = L.linewidth),
      N.isPointLight === !0 && R.isMeshDistanceMaterial === !0)
    ) {
      const Z = n.properties.get(R);
      Z.light = N;
    }
    return R;
  }
  function T(b, L, N, C, R) {
    if (b.visible === !1) return;
    if (
      b.layers.test(L.layers) &&
      (b.isMesh || b.isLine || b.isPoints) &&
      (b.castShadow || (b.receiveShadow && R === Ir)) &&
      (!b.frustumCulled || i.intersectsObject(b))
    ) {
      b.modelViewMatrix.multiplyMatrices(N.matrixWorldInverse, b.matrixWorld);
      const ae = e.update(b),
        V = b.material;
      if (Array.isArray(V)) {
        const Q = ae.groups;
        for (let $ = 0, ce = Q.length; $ < ce; $++) {
          const k = Q[$],
            G = V[k.materialIndex];
          if (G && G.visible) {
            const W = _(b, G, C, R);
            b.onBeforeShadow(n, b, L, N, ae, W, k),
              n.renderBufferDirect(N, null, ae, W, b, k),
              b.onAfterShadow(n, b, L, N, ae, W, k);
          }
        }
      } else if (V.visible) {
        const Q = _(b, V, C, R);
        b.onBeforeShadow(n, b, L, N, ae, Q, null),
          n.renderBufferDirect(N, null, ae, Q, b, null),
          b.onAfterShadow(n, b, L, N, ae, Q, null);
      }
    }
    const Z = b.children;
    for (let ae = 0, V = Z.length; ae < V; ae++) T(Z[ae], L, N, C, R);
  }
  function P(b) {
    b.target.removeEventListener("dispose", P);
    for (const N in f) {
      const C = f[N],
        R = b.target.uuid;
      R in C && (C[R].dispose(), delete C[R]);
    }
  }
}
function V9(n, e, t) {
  const i = t.isWebGL2;
  function r() {
    let X = !1;
    const Ce = new Bt();
    let Ie = null;
    const st = new Bt(0, 0, 0, 0);
    return {
      setMask: function (qe) {
        Ie !== qe && !X && (n.colorMask(qe, qe, qe, qe), (Ie = qe));
      },
      setLocked: function (qe) {
        X = qe;
      },
      setClear: function (qe, Ct, Lt, Gt, Jt) {
        Jt === !0 && ((qe *= Gt), (Ct *= Gt), (Lt *= Gt)),
          Ce.set(qe, Ct, Lt, Gt),
          st.equals(Ce) === !1 && (n.clearColor(qe, Ct, Lt, Gt), st.copy(Ce));
      },
      reset: function () {
        (X = !1), (Ie = null), st.set(-1, 0, 0, 0);
      },
    };
  }
  function s() {
    let X = !1,
      Ce = null,
      Ie = null,
      st = null;
    return {
      setTest: function (qe) {
        qe ? rt(n.DEPTH_TEST) : Ve(n.DEPTH_TEST);
      },
      setMask: function (qe) {
        Ce !== qe && !X && (n.depthMask(qe), (Ce = qe));
      },
      setFunc: function (qe) {
        if (Ie !== qe) {
          switch (qe) {
            case BR:
              n.depthFunc(n.NEVER);
              break;
            case VR:
              n.depthFunc(n.ALWAYS);
              break;
            case HR:
              n.depthFunc(n.LESS);
              break;
            case Lf:
              n.depthFunc(n.LEQUAL);
              break;
            case GR:
              n.depthFunc(n.EQUAL);
              break;
            case WR:
              n.depthFunc(n.GEQUAL);
              break;
            case jR:
              n.depthFunc(n.GREATER);
              break;
            case XR:
              n.depthFunc(n.NOTEQUAL);
              break;
            default:
              n.depthFunc(n.LEQUAL);
          }
          Ie = qe;
        }
      },
      setLocked: function (qe) {
        X = qe;
      },
      setClear: function (qe) {
        st !== qe && (n.clearDepth(qe), (st = qe));
      },
      reset: function () {
        (X = !1), (Ce = null), (Ie = null), (st = null);
      },
    };
  }
  function o() {
    let X = !1,
      Ce = null,
      Ie = null,
      st = null,
      qe = null,
      Ct = null,
      Lt = null,
      Gt = null,
      Jt = null;
    return {
      setTest: function (It) {
        X || (It ? rt(n.STENCIL_TEST) : Ve(n.STENCIL_TEST));
      },
      setMask: function (It) {
        Ce !== It && !X && (n.stencilMask(It), (Ce = It));
      },
      setFunc: function (It, Yn, sr) {
        (Ie !== It || st !== Yn || qe !== sr) &&
          (n.stencilFunc(It, Yn, sr), (Ie = It), (st = Yn), (qe = sr));
      },
      setOp: function (It, Yn, sr) {
        (Ct !== It || Lt !== Yn || Gt !== sr) &&
          (n.stencilOp(It, Yn, sr), (Ct = It), (Lt = Yn), (Gt = sr));
      },
      setLocked: function (It) {
        X = It;
      },
      setClear: function (It) {
        Jt !== It && (n.clearStencil(It), (Jt = It));
      },
      reset: function () {
        (X = !1),
          (Ce = null),
          (Ie = null),
          (st = null),
          (qe = null),
          (Ct = null),
          (Lt = null),
          (Gt = null),
          (Jt = null);
      },
    };
  }
  const a = new r(),
    u = new s(),
    f = new o(),
    h = new WeakMap(),
    d = new WeakMap();
  let p = {},
    m = {},
    y = new WeakMap(),
    w = [],
    S = null,
    v = !1,
    M = null,
    _ = null,
    T = null,
    P = null,
    b = null,
    L = null,
    N = null,
    C = new Be(0, 0, 0),
    R = 0,
    B = !1,
    Z = null,
    ae = null,
    V = null,
    Q = null,
    $ = null;
  const ce = n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let k = !1,
    G = 0;
  const W = n.getParameter(n.VERSION);
  W.indexOf("WebGL") !== -1
    ? ((G = parseFloat(/^WebGL (\d)/.exec(W)[1])), (k = G >= 1))
    : W.indexOf("OpenGL ES") !== -1 &&
      ((G = parseFloat(/^OpenGL ES (\d)/.exec(W)[1])), (k = G >= 2));
  let Y = null,
    ie = {};
  const J = n.getParameter(n.SCISSOR_BOX),
    he = n.getParameter(n.VIEWPORT),
    Ee = new Bt().fromArray(J),
    be = new Bt().fromArray(he);
  function Pe(X, Ce, Ie, st) {
    const qe = new Uint8Array(4),
      Ct = n.createTexture();
    n.bindTexture(X, Ct),
      n.texParameteri(X, n.TEXTURE_MIN_FILTER, n.NEAREST),
      n.texParameteri(X, n.TEXTURE_MAG_FILTER, n.NEAREST);
    for (let Lt = 0; Lt < Ie; Lt++)
      i && (X === n.TEXTURE_3D || X === n.TEXTURE_2D_ARRAY)
        ? n.texImage3D(Ce, 0, n.RGBA, 1, 1, st, 0, n.RGBA, n.UNSIGNED_BYTE, qe)
        : n.texImage2D(
            Ce + Lt,
            0,
            n.RGBA,
            1,
            1,
            0,
            n.RGBA,
            n.UNSIGNED_BYTE,
            qe
          );
    return Ct;
  }
  const it = {};
  (it[n.TEXTURE_2D] = Pe(n.TEXTURE_2D, n.TEXTURE_2D, 1)),
    (it[n.TEXTURE_CUBE_MAP] = Pe(
      n.TEXTURE_CUBE_MAP,
      n.TEXTURE_CUBE_MAP_POSITIVE_X,
      6
    )),
    i &&
      ((it[n.TEXTURE_2D_ARRAY] = Pe(
        n.TEXTURE_2D_ARRAY,
        n.TEXTURE_2D_ARRAY,
        1,
        1
      )),
      (it[n.TEXTURE_3D] = Pe(n.TEXTURE_3D, n.TEXTURE_3D, 1, 1))),
    a.setClear(0, 0, 0, 1),
    u.setClear(1),
    f.setClear(0),
    rt(n.DEPTH_TEST),
    u.setFunc(Lf),
    Ne(!1),
    D(r_),
    rt(n.CULL_FACE),
    me(zs);
  function rt(X) {
    p[X] !== !0 && (n.enable(X), (p[X] = !0));
  }
  function Ve(X) {
    p[X] !== !1 && (n.disable(X), (p[X] = !1));
  }
  function We(X, Ce) {
    return m[X] !== Ce
      ? (n.bindFramebuffer(X, Ce),
        (m[X] = Ce),
        i &&
          (X === n.DRAW_FRAMEBUFFER && (m[n.FRAMEBUFFER] = Ce),
          X === n.FRAMEBUFFER && (m[n.DRAW_FRAMEBUFFER] = Ce)),
        !0)
      : !1;
  }
  function H(X, Ce) {
    let Ie = w,
      st = !1;
    if (X)
      if (
        ((Ie = y.get(Ce)),
        Ie === void 0 && ((Ie = []), y.set(Ce, Ie)),
        X.isWebGLMultipleRenderTargets)
      ) {
        const qe = X.texture;
        if (Ie.length !== qe.length || Ie[0] !== n.COLOR_ATTACHMENT0) {
          for (let Ct = 0, Lt = qe.length; Ct < Lt; Ct++)
            Ie[Ct] = n.COLOR_ATTACHMENT0 + Ct;
          (Ie.length = qe.length), (st = !0);
        }
      } else
        Ie[0] !== n.COLOR_ATTACHMENT0 &&
          ((Ie[0] = n.COLOR_ATTACHMENT0), (st = !0));
    else Ie[0] !== n.BACK && ((Ie[0] = n.BACK), (st = !0));
    st &&
      (t.isWebGL2
        ? n.drawBuffers(Ie)
        : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(Ie));
  }
  function Me(X) {
    return S !== X ? (n.useProgram(X), (S = X), !0) : !1;
  }
  const pe = {
    [wo]: n.FUNC_ADD,
    [TR]: n.FUNC_SUBTRACT,
    [AR]: n.FUNC_REVERSE_SUBTRACT,
  };
  if (i) (pe[a_] = n.MIN), (pe[l_] = n.MAX);
  else {
    const X = e.get("EXT_blend_minmax");
    X !== null && ((pe[a_] = X.MIN_EXT), (pe[l_] = X.MAX_EXT));
  }
  const Te = {
    [bR]: n.ZERO,
    [CR]: n.ONE,
    [PR]: n.SRC_COLOR,
    [Qm]: n.SRC_ALPHA,
    [OR]: n.SRC_ALPHA_SATURATE,
    [NR]: n.DST_COLOR,
    [LR]: n.DST_ALPHA,
    [RR]: n.ONE_MINUS_SRC_COLOR,
    [$m]: n.ONE_MINUS_SRC_ALPHA,
    [DR]: n.ONE_MINUS_DST_COLOR,
    [IR]: n.ONE_MINUS_DST_ALPHA,
    [UR]: n.CONSTANT_COLOR,
    [kR]: n.ONE_MINUS_CONSTANT_COLOR,
    [FR]: n.CONSTANT_ALPHA,
    [zR]: n.ONE_MINUS_CONSTANT_ALPHA,
  };
  function me(X, Ce, Ie, st, qe, Ct, Lt, Gt, Jt, It) {
    if (X === zs) {
      v === !0 && (Ve(n.BLEND), (v = !1));
      return;
    }
    if ((v === !1 && (rt(n.BLEND), (v = !0)), X !== ER)) {
      if (X !== M || It !== B) {
        if (
          ((_ !== wo || b !== wo) &&
            (n.blendEquation(n.FUNC_ADD), (_ = wo), (b = wo)),
          It)
        )
          switch (X) {
            case Va:
              n.blendFuncSeparate(
                n.ONE,
                n.ONE_MINUS_SRC_ALPHA,
                n.ONE,
                n.ONE_MINUS_SRC_ALPHA
              );
              break;
            case Km:
              n.blendFunc(n.ONE, n.ONE);
              break;
            case s_:
              n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
              break;
            case o_:
              n.blendFuncSeparate(n.ZERO, n.SRC_COLOR, n.ZERO, n.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", X);
              break;
          }
        else
          switch (X) {
            case Va:
              n.blendFuncSeparate(
                n.SRC_ALPHA,
                n.ONE_MINUS_SRC_ALPHA,
                n.ONE,
                n.ONE_MINUS_SRC_ALPHA
              );
              break;
            case Km:
              n.blendFunc(n.SRC_ALPHA, n.ONE);
              break;
            case s_:
              n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
              break;
            case o_:
              n.blendFunc(n.ZERO, n.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", X);
              break;
          }
        (T = null),
          (P = null),
          (L = null),
          (N = null),
          C.set(0, 0, 0),
          (R = 0),
          (M = X),
          (B = It);
      }
      return;
    }
    (qe = qe || Ce),
      (Ct = Ct || Ie),
      (Lt = Lt || st),
      (Ce !== _ || qe !== b) &&
        (n.blendEquationSeparate(pe[Ce], pe[qe]), (_ = Ce), (b = qe)),
      (Ie !== T || st !== P || Ct !== L || Lt !== N) &&
        (n.blendFuncSeparate(Te[Ie], Te[st], Te[Ct], Te[Lt]),
        (T = Ie),
        (P = st),
        (L = Ct),
        (N = Lt)),
      (Gt.equals(C) === !1 || Jt !== R) &&
        (n.blendColor(Gt.r, Gt.g, Gt.b, Jt), C.copy(Gt), (R = Jt)),
      (M = X),
      (B = !1);
  }
  function Ke(X, Ce) {
    X.side === rs ? Ve(n.CULL_FACE) : rt(n.CULL_FACE);
    let Ie = X.side === Ti;
    Ce && (Ie = !Ie),
      Ne(Ie),
      X.blending === Va && X.transparent === !1
        ? me(zs)
        : me(
            X.blending,
            X.blendEquation,
            X.blendSrc,
            X.blendDst,
            X.blendEquationAlpha,
            X.blendSrcAlpha,
            X.blendDstAlpha,
            X.blendColor,
            X.blendAlpha,
            X.premultipliedAlpha
          ),
      u.setFunc(X.depthFunc),
      u.setTest(X.depthTest),
      u.setMask(X.depthWrite),
      a.setMask(X.colorWrite);
    const st = X.stencilWrite;
    f.setTest(st),
      st &&
        (f.setMask(X.stencilWriteMask),
        f.setFunc(X.stencilFunc, X.stencilRef, X.stencilFuncMask),
        f.setOp(X.stencilFail, X.stencilZFail, X.stencilZPass)),
      te(X.polygonOffset, X.polygonOffsetFactor, X.polygonOffsetUnits),
      X.alphaToCoverage === !0
        ? rt(n.SAMPLE_ALPHA_TO_COVERAGE)
        : Ve(n.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function Ne(X) {
    Z !== X && (X ? n.frontFace(n.CW) : n.frontFace(n.CCW), (Z = X));
  }
  function D(X) {
    X !== SR
      ? (rt(n.CULL_FACE),
        X !== ae &&
          (X === r_
            ? n.cullFace(n.BACK)
            : X === MR
            ? n.cullFace(n.FRONT)
            : n.cullFace(n.FRONT_AND_BACK)))
      : Ve(n.CULL_FACE),
      (ae = X);
  }
  function I(X) {
    X !== V && (k && n.lineWidth(X), (V = X));
  }
  function te(X, Ce, Ie) {
    X
      ? (rt(n.POLYGON_OFFSET_FILL),
        (Q !== Ce || $ !== Ie) && (n.polygonOffset(Ce, Ie), (Q = Ce), ($ = Ie)))
      : Ve(n.POLYGON_OFFSET_FILL);
  }
  function xe(X) {
    X ? rt(n.SCISSOR_TEST) : Ve(n.SCISSOR_TEST);
  }
  function ye(X) {
    X === void 0 && (X = n.TEXTURE0 + ce - 1),
      Y !== X && (n.activeTexture(X), (Y = X));
  }
  function ge(X, Ce, Ie) {
    Ie === void 0 && (Y === null ? (Ie = n.TEXTURE0 + ce - 1) : (Ie = Y));
    let st = ie[Ie];
    st === void 0 && ((st = { type: void 0, texture: void 0 }), (ie[Ie] = st)),
      (st.type !== X || st.texture !== Ce) &&
        (Y !== Ie && (n.activeTexture(Ie), (Y = Ie)),
        n.bindTexture(X, Ce || it[X]),
        (st.type = X),
        (st.texture = Ce));
  }
  function Ye() {
    const X = ie[Y];
    X !== void 0 &&
      X.type !== void 0 &&
      (n.bindTexture(X.type, null), (X.type = void 0), (X.texture = void 0));
  }
  function Le() {
    try {
      n.compressedTexImage2D.apply(n, arguments);
    } catch (X) {
      console.error("THREE.WebGLState:", X);
    }
  }
  function Fe() {
    try {
      n.compressedTexImage3D.apply(n, arguments);
    } catch (X) {
      console.error("THREE.WebGLState:", X);
    }
  }
  function tt() {
    try {
      n.texSubImage2D.apply(n, arguments);
    } catch (X) {
      console.error("THREE.WebGLState:", X);
    }
  }
  function mt() {
    try {
      n.texSubImage3D.apply(n, arguments);
    } catch (X) {
      console.error("THREE.WebGLState:", X);
    }
  }
  function _e() {
    try {
      n.compressedTexSubImage2D.apply(n, arguments);
    } catch (X) {
      console.error("THREE.WebGLState:", X);
    }
  }
  function Rt() {
    try {
      n.compressedTexSubImage3D.apply(n, arguments);
    } catch (X) {
      console.error("THREE.WebGLState:", X);
    }
  }
  function _t() {
    try {
      n.texStorage2D.apply(n, arguments);
    } catch (X) {
      console.error("THREE.WebGLState:", X);
    }
  }
  function ht() {
    try {
      n.texStorage3D.apply(n, arguments);
    } catch (X) {
      console.error("THREE.WebGLState:", X);
    }
  }
  function et() {
    try {
      n.texImage2D.apply(n, arguments);
    } catch (X) {
      console.error("THREE.WebGLState:", X);
    }
  }
  function He() {
    try {
      n.texImage3D.apply(n, arguments);
    } catch (X) {
      console.error("THREE.WebGLState:", X);
    }
  }
  function j(X) {
    Ee.equals(X) === !1 && (n.scissor(X.x, X.y, X.z, X.w), Ee.copy(X));
  }
  function ve(X) {
    be.equals(X) === !1 && (n.viewport(X.x, X.y, X.z, X.w), be.copy(X));
  }
  function ke(X, Ce) {
    let Ie = d.get(Ce);
    Ie === void 0 && ((Ie = new WeakMap()), d.set(Ce, Ie));
    let st = Ie.get(X);
    st === void 0 && ((st = n.getUniformBlockIndex(Ce, X.name)), Ie.set(X, st));
  }
  function Oe(X, Ce) {
    const st = d.get(Ce).get(X);
    h.get(Ce) !== st &&
      (n.uniformBlockBinding(Ce, st, X.__bindingPointIndex), h.set(Ce, st));
  }
  function Se() {
    n.disable(n.BLEND),
      n.disable(n.CULL_FACE),
      n.disable(n.DEPTH_TEST),
      n.disable(n.POLYGON_OFFSET_FILL),
      n.disable(n.SCISSOR_TEST),
      n.disable(n.STENCIL_TEST),
      n.disable(n.SAMPLE_ALPHA_TO_COVERAGE),
      n.blendEquation(n.FUNC_ADD),
      n.blendFunc(n.ONE, n.ZERO),
      n.blendFuncSeparate(n.ONE, n.ZERO, n.ONE, n.ZERO),
      n.blendColor(0, 0, 0, 0),
      n.colorMask(!0, !0, !0, !0),
      n.clearColor(0, 0, 0, 0),
      n.depthMask(!0),
      n.depthFunc(n.LESS),
      n.clearDepth(1),
      n.stencilMask(4294967295),
      n.stencilFunc(n.ALWAYS, 0, 4294967295),
      n.stencilOp(n.KEEP, n.KEEP, n.KEEP),
      n.clearStencil(0),
      n.cullFace(n.BACK),
      n.frontFace(n.CCW),
      n.polygonOffset(0, 0),
      n.activeTexture(n.TEXTURE0),
      n.bindFramebuffer(n.FRAMEBUFFER, null),
      i === !0 &&
        (n.bindFramebuffer(n.DRAW_FRAMEBUFFER, null),
        n.bindFramebuffer(n.READ_FRAMEBUFFER, null)),
      n.useProgram(null),
      n.lineWidth(1),
      n.scissor(0, 0, n.canvas.width, n.canvas.height),
      n.viewport(0, 0, n.canvas.width, n.canvas.height),
      (p = {}),
      (Y = null),
      (ie = {}),
      (m = {}),
      (y = new WeakMap()),
      (w = []),
      (S = null),
      (v = !1),
      (M = null),
      (_ = null),
      (T = null),
      (P = null),
      (b = null),
      (L = null),
      (N = null),
      (C = new Be(0, 0, 0)),
      (R = 0),
      (B = !1),
      (Z = null),
      (ae = null),
      (V = null),
      (Q = null),
      ($ = null),
      Ee.set(0, 0, n.canvas.width, n.canvas.height),
      be.set(0, 0, n.canvas.width, n.canvas.height),
      a.reset(),
      u.reset(),
      f.reset();
  }
  return {
    buffers: { color: a, depth: u, stencil: f },
    enable: rt,
    disable: Ve,
    bindFramebuffer: We,
    drawBuffers: H,
    useProgram: Me,
    setBlending: me,
    setMaterial: Ke,
    setFlipSided: Ne,
    setCullFace: D,
    setLineWidth: I,
    setPolygonOffset: te,
    setScissorTest: xe,
    activeTexture: ye,
    bindTexture: ge,
    unbindTexture: Ye,
    compressedTexImage2D: Le,
    compressedTexImage3D: Fe,
    texImage2D: et,
    texImage3D: He,
    updateUBOMapping: ke,
    uniformBlockBinding: Oe,
    texStorage2D: _t,
    texStorage3D: ht,
    texSubImage2D: tt,
    texSubImage3D: mt,
    compressedTexSubImage2D: _e,
    compressedTexSubImage3D: Rt,
    scissor: j,
    viewport: ve,
    reset: Se,
  };
}
function H9(n, e, t, i, r, s, o) {
  const a = r.isWebGL2,
    u = e.has("WEBGL_multisampled_render_to_texture")
      ? e.get("WEBGL_multisampled_render_to_texture")
      : null,
    f =
      typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent),
    h = new WeakMap();
  let d;
  const p = new WeakMap();
  let m = !1;
  try {
    m =
      typeof OffscreenCanvas < "u" &&
      new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {}
  function y(D, I) {
    return m ? new OffscreenCanvas(D, I) : Gf("canvas");
  }
  function w(D, I, te, xe) {
    let ye = 1;
    if (
      ((D.width > xe || D.height > xe) &&
        (ye = xe / Math.max(D.width, D.height)),
      ye < 1 || I === !0)
    )
      if (
        (typeof HTMLImageElement < "u" && D instanceof HTMLImageElement) ||
        (typeof HTMLCanvasElement < "u" && D instanceof HTMLCanvasElement) ||
        (typeof ImageBitmap < "u" && D instanceof ImageBitmap)
      ) {
        const ge = I ? tg : Math.floor,
          Ye = ge(ye * D.width),
          Le = ge(ye * D.height);
        d === void 0 && (d = y(Ye, Le));
        const Fe = te ? y(Ye, Le) : d;
        return (
          (Fe.width = Ye),
          (Fe.height = Le),
          Fe.getContext("2d").drawImage(D, 0, 0, Ye, Le),
          console.warn(
            "THREE.WebGLRenderer: Texture has been resized from (" +
              D.width +
              "x" +
              D.height +
              ") to (" +
              Ye +
              "x" +
              Le +
              ")."
          ),
          Fe
        );
      } else
        return (
          "data" in D &&
            console.warn(
              "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                D.width +
                "x" +
                D.height +
                ")."
            ),
          D
        );
    return D;
  }
  function S(D) {
    return k_(D.width) && k_(D.height);
  }
  function v(D) {
    return a
      ? !1
      : D.wrapS !== fi ||
          D.wrapT !== fi ||
          (D.minFilter !== Sn && D.minFilter !== wn);
  }
  function M(D, I) {
    return D.generateMipmaps && I && D.minFilter !== Sn && D.minFilter !== wn;
  }
  function _(D) {
    n.generateMipmap(D);
  }
  function T(D, I, te, xe, ye = !1) {
    if (a === !1) return I;
    if (D !== null) {
      if (n[D] !== void 0) return n[D];
      console.warn(
        "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
          D +
          "'"
      );
    }
    let ge = I;
    if (
      (I === n.RED &&
        (te === n.FLOAT && (ge = n.R32F),
        te === n.HALF_FLOAT && (ge = n.R16F),
        te === n.UNSIGNED_BYTE && (ge = n.R8)),
      I === n.RED_INTEGER &&
        (te === n.UNSIGNED_BYTE && (ge = n.R8UI),
        te === n.UNSIGNED_SHORT && (ge = n.R16UI),
        te === n.UNSIGNED_INT && (ge = n.R32UI),
        te === n.BYTE && (ge = n.R8I),
        te === n.SHORT && (ge = n.R16I),
        te === n.INT && (ge = n.R32I)),
      I === n.RG &&
        (te === n.FLOAT && (ge = n.RG32F),
        te === n.HALF_FLOAT && (ge = n.RG16F),
        te === n.UNSIGNED_BYTE && (ge = n.RG8)),
      I === n.RGBA)
    ) {
      const Ye = ye ? zf : zt.getTransfer(xe);
      te === n.FLOAT && (ge = n.RGBA32F),
        te === n.HALF_FLOAT && (ge = n.RGBA16F),
        te === n.UNSIGNED_BYTE && (ge = Ye === jt ? n.SRGB8_ALPHA8 : n.RGBA8),
        te === n.UNSIGNED_SHORT_4_4_4_4 && (ge = n.RGBA4),
        te === n.UNSIGNED_SHORT_5_5_5_1 && (ge = n.RGB5_A1);
    }
    return (
      (ge === n.R16F ||
        ge === n.R32F ||
        ge === n.RG16F ||
        ge === n.RG32F ||
        ge === n.RGBA16F ||
        ge === n.RGBA32F) &&
        e.get("EXT_color_buffer_float"),
      ge
    );
  }
  function P(D, I, te) {
    return M(D, te) === !0 ||
      (D.isFramebufferTexture && D.minFilter !== Sn && D.minFilter !== wn)
      ? Math.log2(Math.max(I.width, I.height)) + 1
      : D.mipmaps !== void 0 && D.mipmaps.length > 0
      ? D.mipmaps.length
      : D.isCompressedTexture && Array.isArray(D.image)
      ? I.mipmaps.length
      : 1;
  }
  function b(D) {
    return D === Sn || D === Jm || D === of ? n.NEAREST : n.LINEAR;
  }
  function L(D) {
    const I = D.target;
    I.removeEventListener("dispose", L), C(I), I.isVideoTexture && h.delete(I);
  }
  function N(D) {
    const I = D.target;
    I.removeEventListener("dispose", N), B(I);
  }
  function C(D) {
    const I = i.get(D);
    if (I.__webglInit === void 0) return;
    const te = D.source,
      xe = p.get(te);
    if (xe) {
      const ye = xe[I.__cacheKey];
      ye.usedTimes--,
        ye.usedTimes === 0 && R(D),
        Object.keys(xe).length === 0 && p.delete(te);
    }
    i.remove(D);
  }
  function R(D) {
    const I = i.get(D);
    n.deleteTexture(I.__webglTexture);
    const te = D.source,
      xe = p.get(te);
    delete xe[I.__cacheKey], o.memory.textures--;
  }
  function B(D) {
    const I = D.texture,
      te = i.get(D),
      xe = i.get(I);
    if (
      (xe.__webglTexture !== void 0 &&
        (n.deleteTexture(xe.__webglTexture), o.memory.textures--),
      D.depthTexture && D.depthTexture.dispose(),
      D.isWebGLCubeRenderTarget)
    )
      for (let ye = 0; ye < 6; ye++) {
        if (Array.isArray(te.__webglFramebuffer[ye]))
          for (let ge = 0; ge < te.__webglFramebuffer[ye].length; ge++)
            n.deleteFramebuffer(te.__webglFramebuffer[ye][ge]);
        else n.deleteFramebuffer(te.__webglFramebuffer[ye]);
        te.__webglDepthbuffer &&
          n.deleteRenderbuffer(te.__webglDepthbuffer[ye]);
      }
    else {
      if (Array.isArray(te.__webglFramebuffer))
        for (let ye = 0; ye < te.__webglFramebuffer.length; ye++)
          n.deleteFramebuffer(te.__webglFramebuffer[ye]);
      else n.deleteFramebuffer(te.__webglFramebuffer);
      if (
        (te.__webglDepthbuffer && n.deleteRenderbuffer(te.__webglDepthbuffer),
        te.__webglMultisampledFramebuffer &&
          n.deleteFramebuffer(te.__webglMultisampledFramebuffer),
        te.__webglColorRenderbuffer)
      )
        for (let ye = 0; ye < te.__webglColorRenderbuffer.length; ye++)
          te.__webglColorRenderbuffer[ye] &&
            n.deleteRenderbuffer(te.__webglColorRenderbuffer[ye]);
      te.__webglDepthRenderbuffer &&
        n.deleteRenderbuffer(te.__webglDepthRenderbuffer);
    }
    if (D.isWebGLMultipleRenderTargets)
      for (let ye = 0, ge = I.length; ye < ge; ye++) {
        const Ye = i.get(I[ye]);
        Ye.__webglTexture &&
          (n.deleteTexture(Ye.__webglTexture), o.memory.textures--),
          i.remove(I[ye]);
      }
    i.remove(I), i.remove(D);
  }
  let Z = 0;
  function ae() {
    Z = 0;
  }
  function V() {
    const D = Z;
    return (
      D >= r.maxTextures &&
        console.warn(
          "THREE.WebGLTextures: Trying to use " +
            D +
            " texture units while this GPU supports only " +
            r.maxTextures
        ),
      (Z += 1),
      D
    );
  }
  function Q(D) {
    const I = [];
    return (
      I.push(D.wrapS),
      I.push(D.wrapT),
      I.push(D.wrapR || 0),
      I.push(D.magFilter),
      I.push(D.minFilter),
      I.push(D.anisotropy),
      I.push(D.internalFormat),
      I.push(D.format),
      I.push(D.type),
      I.push(D.generateMipmaps),
      I.push(D.premultiplyAlpha),
      I.push(D.flipY),
      I.push(D.unpackAlignment),
      I.push(D.colorSpace),
      I.join()
    );
  }
  function $(D, I) {
    const te = i.get(D);
    if (
      (D.isVideoTexture && Ke(D),
      D.isRenderTargetTexture === !1 &&
        D.version > 0 &&
        te.__version !== D.version)
    ) {
      const xe = D.image;
      if (xe === null)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but no image data found."
        );
      else if (xe.complete === !1)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
        );
      else {
        Ee(te, D, I);
        return;
      }
    }
    t.bindTexture(n.TEXTURE_2D, te.__webglTexture, n.TEXTURE0 + I);
  }
  function ce(D, I) {
    const te = i.get(D);
    if (D.version > 0 && te.__version !== D.version) {
      Ee(te, D, I);
      return;
    }
    t.bindTexture(n.TEXTURE_2D_ARRAY, te.__webglTexture, n.TEXTURE0 + I);
  }
  function k(D, I) {
    const te = i.get(D);
    if (D.version > 0 && te.__version !== D.version) {
      Ee(te, D, I);
      return;
    }
    t.bindTexture(n.TEXTURE_3D, te.__webglTexture, n.TEXTURE0 + I);
  }
  function G(D, I) {
    const te = i.get(D);
    if (D.version > 0 && te.__version !== D.version) {
      be(te, D, I);
      return;
    }
    t.bindTexture(n.TEXTURE_CUBE_MAP, te.__webglTexture, n.TEXTURE0 + I);
  }
  const W = { [Df]: n.REPEAT, [fi]: n.CLAMP_TO_EDGE, [Of]: n.MIRRORED_REPEAT },
    Y = {
      [Sn]: n.NEAREST,
      [Jm]: n.NEAREST_MIPMAP_NEAREST,
      [of]: n.NEAREST_MIPMAP_LINEAR,
      [wn]: n.LINEAR,
      [SS]: n.LINEAR_MIPMAP_NEAREST,
      [Wo]: n.LINEAR_MIPMAP_LINEAR,
    },
    ie = {
      [mL]: n.NEVER,
      [SL]: n.ALWAYS,
      [gL]: n.LESS,
      [LS]: n.LEQUAL,
      [vL]: n.EQUAL,
      [_L]: n.GEQUAL,
      [yL]: n.GREATER,
      [xL]: n.NOTEQUAL,
    };
  function J(D, I, te) {
    if (
      (te
        ? (n.texParameteri(D, n.TEXTURE_WRAP_S, W[I.wrapS]),
          n.texParameteri(D, n.TEXTURE_WRAP_T, W[I.wrapT]),
          (D === n.TEXTURE_3D || D === n.TEXTURE_2D_ARRAY) &&
            n.texParameteri(D, n.TEXTURE_WRAP_R, W[I.wrapR]),
          n.texParameteri(D, n.TEXTURE_MAG_FILTER, Y[I.magFilter]),
          n.texParameteri(D, n.TEXTURE_MIN_FILTER, Y[I.minFilter]))
        : (n.texParameteri(D, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE),
          n.texParameteri(D, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE),
          (D === n.TEXTURE_3D || D === n.TEXTURE_2D_ARRAY) &&
            n.texParameteri(D, n.TEXTURE_WRAP_R, n.CLAMP_TO_EDGE),
          (I.wrapS !== fi || I.wrapT !== fi) &&
            console.warn(
              "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
            ),
          n.texParameteri(D, n.TEXTURE_MAG_FILTER, b(I.magFilter)),
          n.texParameteri(D, n.TEXTURE_MIN_FILTER, b(I.minFilter)),
          I.minFilter !== Sn &&
            I.minFilter !== wn &&
            console.warn(
              "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
            )),
      I.compareFunction &&
        (n.texParameteri(D, n.TEXTURE_COMPARE_MODE, n.COMPARE_REF_TO_TEXTURE),
        n.texParameteri(D, n.TEXTURE_COMPARE_FUNC, ie[I.compareFunction])),
      e.has("EXT_texture_filter_anisotropic") === !0)
    ) {
      const xe = e.get("EXT_texture_filter_anisotropic");
      if (
        I.magFilter === Sn ||
        (I.minFilter !== of && I.minFilter !== Wo) ||
        (I.type === Ur && e.has("OES_texture_float_linear") === !1) ||
        (a === !1 &&
          I.type === Ou &&
          e.has("OES_texture_half_float_linear") === !1)
      )
        return;
      (I.anisotropy > 1 || i.get(I).__currentAnisotropy) &&
        (n.texParameterf(
          D,
          xe.TEXTURE_MAX_ANISOTROPY_EXT,
          Math.min(I.anisotropy, r.getMaxAnisotropy())
        ),
        (i.get(I).__currentAnisotropy = I.anisotropy));
    }
  }
  function he(D, I) {
    let te = !1;
    D.__webglInit === void 0 &&
      ((D.__webglInit = !0), I.addEventListener("dispose", L));
    const xe = I.source;
    let ye = p.get(xe);
    ye === void 0 && ((ye = {}), p.set(xe, ye));
    const ge = Q(I);
    if (ge !== D.__cacheKey) {
      ye[ge] === void 0 &&
        ((ye[ge] = { texture: n.createTexture(), usedTimes: 0 }),
        o.memory.textures++,
        (te = !0)),
        ye[ge].usedTimes++;
      const Ye = ye[D.__cacheKey];
      Ye !== void 0 &&
        (ye[D.__cacheKey].usedTimes--, Ye.usedTimes === 0 && R(I)),
        (D.__cacheKey = ge),
        (D.__webglTexture = ye[ge].texture);
    }
    return te;
  }
  function Ee(D, I, te) {
    let xe = n.TEXTURE_2D;
    (I.isDataArrayTexture || I.isCompressedArrayTexture) &&
      (xe = n.TEXTURE_2D_ARRAY),
      I.isData3DTexture && (xe = n.TEXTURE_3D);
    const ye = he(D, I),
      ge = I.source;
    t.bindTexture(xe, D.__webglTexture, n.TEXTURE0 + te);
    const Ye = i.get(ge);
    if (ge.version !== Ye.__version || ye === !0) {
      t.activeTexture(n.TEXTURE0 + te);
      const Le = zt.getPrimaries(zt.workingColorSpace),
        Fe = I.colorSpace === Qi ? null : zt.getPrimaries(I.colorSpace),
        tt =
          I.colorSpace === Qi || Le === Fe ? n.NONE : n.BROWSER_DEFAULT_WEBGL;
      n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, I.flipY),
        n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, I.premultiplyAlpha),
        n.pixelStorei(n.UNPACK_ALIGNMENT, I.unpackAlignment),
        n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, tt);
      const mt = v(I) && S(I.image) === !1;
      let _e = w(I.image, mt, !1, r.maxTextureSize);
      _e = Ne(I, _e);
      const Rt = S(_e) || a,
        _t = s.convert(I.format, I.colorSpace);
      let ht = s.convert(I.type),
        et = T(I.internalFormat, _t, ht, I.colorSpace, I.isVideoTexture);
      J(xe, I, Rt);
      let He;
      const j = I.mipmaps,
        ve = a && I.isVideoTexture !== !0 && et !== CS,
        ke = Ye.__version === void 0 || ye === !0,
        Oe = P(I, _e, Rt);
      if (I.isDepthTexture)
        (et = n.DEPTH_COMPONENT),
          a
            ? I.type === Ur
              ? (et = n.DEPTH_COMPONENT32F)
              : I.type === Ds
              ? (et = n.DEPTH_COMPONENT24)
              : I.type === Oo
              ? (et = n.DEPTH24_STENCIL8)
              : (et = n.DEPTH_COMPONENT16)
            : I.type === Ur &&
              console.error(
                "WebGLRenderer: Floating point depth texture requires WebGL2."
              ),
          I.format === Uo &&
            et === n.DEPTH_COMPONENT &&
            I.type !== Fg &&
            I.type !== Ds &&
            (console.warn(
              "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
            ),
            (I.type = Ds),
            (ht = s.convert(I.type))),
          I.format === Qa &&
            et === n.DEPTH_COMPONENT &&
            ((et = n.DEPTH_STENCIL),
            I.type !== Oo &&
              (console.warn(
                "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
              ),
              (I.type = Oo),
              (ht = s.convert(I.type)))),
          ke &&
            (ve
              ? t.texStorage2D(n.TEXTURE_2D, 1, et, _e.width, _e.height)
              : t.texImage2D(
                  n.TEXTURE_2D,
                  0,
                  et,
                  _e.width,
                  _e.height,
                  0,
                  _t,
                  ht,
                  null
                ));
      else if (I.isDataTexture)
        if (j.length > 0 && Rt) {
          ve &&
            ke &&
            t.texStorage2D(n.TEXTURE_2D, Oe, et, j[0].width, j[0].height);
          for (let Se = 0, X = j.length; Se < X; Se++)
            (He = j[Se]),
              ve
                ? t.texSubImage2D(
                    n.TEXTURE_2D,
                    Se,
                    0,
                    0,
                    He.width,
                    He.height,
                    _t,
                    ht,
                    He.data
                  )
                : t.texImage2D(
                    n.TEXTURE_2D,
                    Se,
                    et,
                    He.width,
                    He.height,
                    0,
                    _t,
                    ht,
                    He.data
                  );
          I.generateMipmaps = !1;
        } else
          ve
            ? (ke && t.texStorage2D(n.TEXTURE_2D, Oe, et, _e.width, _e.height),
              t.texSubImage2D(
                n.TEXTURE_2D,
                0,
                0,
                0,
                _e.width,
                _e.height,
                _t,
                ht,
                _e.data
              ))
            : t.texImage2D(
                n.TEXTURE_2D,
                0,
                et,
                _e.width,
                _e.height,
                0,
                _t,
                ht,
                _e.data
              );
      else if (I.isCompressedTexture)
        if (I.isCompressedArrayTexture) {
          ve &&
            ke &&
            t.texStorage3D(
              n.TEXTURE_2D_ARRAY,
              Oe,
              et,
              j[0].width,
              j[0].height,
              _e.depth
            );
          for (let Se = 0, X = j.length; Se < X; Se++)
            (He = j[Se]),
              I.format !== wi
                ? _t !== null
                  ? ve
                    ? t.compressedTexSubImage3D(
                        n.TEXTURE_2D_ARRAY,
                        Se,
                        0,
                        0,
                        0,
                        He.width,
                        He.height,
                        _e.depth,
                        _t,
                        He.data,
                        0,
                        0
                      )
                    : t.compressedTexImage3D(
                        n.TEXTURE_2D_ARRAY,
                        Se,
                        et,
                        He.width,
                        He.height,
                        _e.depth,
                        0,
                        He.data,
                        0,
                        0
                      )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                    )
                : ve
                ? t.texSubImage3D(
                    n.TEXTURE_2D_ARRAY,
                    Se,
                    0,
                    0,
                    0,
                    He.width,
                    He.height,
                    _e.depth,
                    _t,
                    ht,
                    He.data
                  )
                : t.texImage3D(
                    n.TEXTURE_2D_ARRAY,
                    Se,
                    et,
                    He.width,
                    He.height,
                    _e.depth,
                    0,
                    _t,
                    ht,
                    He.data
                  );
        } else {
          ve &&
            ke &&
            t.texStorage2D(n.TEXTURE_2D, Oe, et, j[0].width, j[0].height);
          for (let Se = 0, X = j.length; Se < X; Se++)
            (He = j[Se]),
              I.format !== wi
                ? _t !== null
                  ? ve
                    ? t.compressedTexSubImage2D(
                        n.TEXTURE_2D,
                        Se,
                        0,
                        0,
                        He.width,
                        He.height,
                        _t,
                        He.data
                      )
                    : t.compressedTexImage2D(
                        n.TEXTURE_2D,
                        Se,
                        et,
                        He.width,
                        He.height,
                        0,
                        He.data
                      )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                    )
                : ve
                ? t.texSubImage2D(
                    n.TEXTURE_2D,
                    Se,
                    0,
                    0,
                    He.width,
                    He.height,
                    _t,
                    ht,
                    He.data
                  )
                : t.texImage2D(
                    n.TEXTURE_2D,
                    Se,
                    et,
                    He.width,
                    He.height,
                    0,
                    _t,
                    ht,
                    He.data
                  );
        }
      else if (I.isDataArrayTexture)
        ve
          ? (ke &&
              t.texStorage3D(
                n.TEXTURE_2D_ARRAY,
                Oe,
                et,
                _e.width,
                _e.height,
                _e.depth
              ),
            t.texSubImage3D(
              n.TEXTURE_2D_ARRAY,
              0,
              0,
              0,
              0,
              _e.width,
              _e.height,
              _e.depth,
              _t,
              ht,
              _e.data
            ))
          : t.texImage3D(
              n.TEXTURE_2D_ARRAY,
              0,
              et,
              _e.width,
              _e.height,
              _e.depth,
              0,
              _t,
              ht,
              _e.data
            );
      else if (I.isData3DTexture)
        ve
          ? (ke &&
              t.texStorage3D(
                n.TEXTURE_3D,
                Oe,
                et,
                _e.width,
                _e.height,
                _e.depth
              ),
            t.texSubImage3D(
              n.TEXTURE_3D,
              0,
              0,
              0,
              0,
              _e.width,
              _e.height,
              _e.depth,
              _t,
              ht,
              _e.data
            ))
          : t.texImage3D(
              n.TEXTURE_3D,
              0,
              et,
              _e.width,
              _e.height,
              _e.depth,
              0,
              _t,
              ht,
              _e.data
            );
      else if (I.isFramebufferTexture) {
        if (ke)
          if (ve) t.texStorage2D(n.TEXTURE_2D, Oe, et, _e.width, _e.height);
          else {
            let Se = _e.width,
              X = _e.height;
            for (let Ce = 0; Ce < Oe; Ce++)
              t.texImage2D(n.TEXTURE_2D, Ce, et, Se, X, 0, _t, ht, null),
                (Se >>= 1),
                (X >>= 1);
          }
      } else if (j.length > 0 && Rt) {
        ve &&
          ke &&
          t.texStorage2D(n.TEXTURE_2D, Oe, et, j[0].width, j[0].height);
        for (let Se = 0, X = j.length; Se < X; Se++)
          (He = j[Se]),
            ve
              ? t.texSubImage2D(n.TEXTURE_2D, Se, 0, 0, _t, ht, He)
              : t.texImage2D(n.TEXTURE_2D, Se, et, _t, ht, He);
        I.generateMipmaps = !1;
      } else
        ve
          ? (ke && t.texStorage2D(n.TEXTURE_2D, Oe, et, _e.width, _e.height),
            t.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, _t, ht, _e))
          : t.texImage2D(n.TEXTURE_2D, 0, et, _t, ht, _e);
      M(I, Rt) && _(xe),
        (Ye.__version = ge.version),
        I.onUpdate && I.onUpdate(I);
    }
    D.__version = I.version;
  }
  function be(D, I, te) {
    if (I.image.length !== 6) return;
    const xe = he(D, I),
      ye = I.source;
    t.bindTexture(n.TEXTURE_CUBE_MAP, D.__webglTexture, n.TEXTURE0 + te);
    const ge = i.get(ye);
    if (ye.version !== ge.__version || xe === !0) {
      t.activeTexture(n.TEXTURE0 + te);
      const Ye = zt.getPrimaries(zt.workingColorSpace),
        Le = I.colorSpace === Qi ? null : zt.getPrimaries(I.colorSpace),
        Fe =
          I.colorSpace === Qi || Ye === Le ? n.NONE : n.BROWSER_DEFAULT_WEBGL;
      n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, I.flipY),
        n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, I.premultiplyAlpha),
        n.pixelStorei(n.UNPACK_ALIGNMENT, I.unpackAlignment),
        n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, Fe);
      const tt = I.isCompressedTexture || I.image[0].isCompressedTexture,
        mt = I.image[0] && I.image[0].isDataTexture,
        _e = [];
      for (let Se = 0; Se < 6; Se++)
        !tt && !mt
          ? (_e[Se] = w(I.image[Se], !1, !0, r.maxCubemapSize))
          : (_e[Se] = mt ? I.image[Se].image : I.image[Se]),
          (_e[Se] = Ne(I, _e[Se]));
      const Rt = _e[0],
        _t = S(Rt) || a,
        ht = s.convert(I.format, I.colorSpace),
        et = s.convert(I.type),
        He = T(I.internalFormat, ht, et, I.colorSpace),
        j = a && I.isVideoTexture !== !0,
        ve = ge.__version === void 0 || xe === !0;
      let ke = P(I, Rt, _t);
      J(n.TEXTURE_CUBE_MAP, I, _t);
      let Oe;
      if (tt) {
        j &&
          ve &&
          t.texStorage2D(n.TEXTURE_CUBE_MAP, ke, He, Rt.width, Rt.height);
        for (let Se = 0; Se < 6; Se++) {
          Oe = _e[Se].mipmaps;
          for (let X = 0; X < Oe.length; X++) {
            const Ce = Oe[X];
            I.format !== wi
              ? ht !== null
                ? j
                  ? t.compressedTexSubImage2D(
                      n.TEXTURE_CUBE_MAP_POSITIVE_X + Se,
                      X,
                      0,
                      0,
                      Ce.width,
                      Ce.height,
                      ht,
                      Ce.data
                    )
                  : t.compressedTexImage2D(
                      n.TEXTURE_CUBE_MAP_POSITIVE_X + Se,
                      X,
                      He,
                      Ce.width,
                      Ce.height,
                      0,
                      Ce.data
                    )
                : console.warn(
                    "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                  )
              : j
              ? t.texSubImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + Se,
                  X,
                  0,
                  0,
                  Ce.width,
                  Ce.height,
                  ht,
                  et,
                  Ce.data
                )
              : t.texImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + Se,
                  X,
                  He,
                  Ce.width,
                  Ce.height,
                  0,
                  ht,
                  et,
                  Ce.data
                );
          }
        }
      } else {
        (Oe = I.mipmaps),
          j &&
            ve &&
            (Oe.length > 0 && ke++,
            t.texStorage2D(
              n.TEXTURE_CUBE_MAP,
              ke,
              He,
              _e[0].width,
              _e[0].height
            ));
        for (let Se = 0; Se < 6; Se++)
          if (mt) {
            j
              ? t.texSubImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + Se,
                  0,
                  0,
                  0,
                  _e[Se].width,
                  _e[Se].height,
                  ht,
                  et,
                  _e[Se].data
                )
              : t.texImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + Se,
                  0,
                  He,
                  _e[Se].width,
                  _e[Se].height,
                  0,
                  ht,
                  et,
                  _e[Se].data
                );
            for (let X = 0; X < Oe.length; X++) {
              const Ie = Oe[X].image[Se].image;
              j
                ? t.texSubImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + Se,
                    X + 1,
                    0,
                    0,
                    Ie.width,
                    Ie.height,
                    ht,
                    et,
                    Ie.data
                  )
                : t.texImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + Se,
                    X + 1,
                    He,
                    Ie.width,
                    Ie.height,
                    0,
                    ht,
                    et,
                    Ie.data
                  );
            }
          } else {
            j
              ? t.texSubImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + Se,
                  0,
                  0,
                  0,
                  ht,
                  et,
                  _e[Se]
                )
              : t.texImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + Se,
                  0,
                  He,
                  ht,
                  et,
                  _e[Se]
                );
            for (let X = 0; X < Oe.length; X++) {
              const Ce = Oe[X];
              j
                ? t.texSubImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + Se,
                    X + 1,
                    0,
                    0,
                    ht,
                    et,
                    Ce.image[Se]
                  )
                : t.texImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + Se,
                    X + 1,
                    He,
                    ht,
                    et,
                    Ce.image[Se]
                  );
            }
          }
      }
      M(I, _t) && _(n.TEXTURE_CUBE_MAP),
        (ge.__version = ye.version),
        I.onUpdate && I.onUpdate(I);
    }
    D.__version = I.version;
  }
  function Pe(D, I, te, xe, ye, ge) {
    const Ye = s.convert(te.format, te.colorSpace),
      Le = s.convert(te.type),
      Fe = T(te.internalFormat, Ye, Le, te.colorSpace);
    if (!i.get(I).__hasExternalTextures) {
      const mt = Math.max(1, I.width >> ge),
        _e = Math.max(1, I.height >> ge);
      ye === n.TEXTURE_3D || ye === n.TEXTURE_2D_ARRAY
        ? t.texImage3D(ye, ge, Fe, mt, _e, I.depth, 0, Ye, Le, null)
        : t.texImage2D(ye, ge, Fe, mt, _e, 0, Ye, Le, null);
    }
    t.bindFramebuffer(n.FRAMEBUFFER, D),
      me(I)
        ? u.framebufferTexture2DMultisampleEXT(
            n.FRAMEBUFFER,
            xe,
            ye,
            i.get(te).__webglTexture,
            0,
            Te(I)
          )
        : (ye === n.TEXTURE_2D ||
            (ye >= n.TEXTURE_CUBE_MAP_POSITIVE_X &&
              ye <= n.TEXTURE_CUBE_MAP_NEGATIVE_Z)) &&
          n.framebufferTexture2D(
            n.FRAMEBUFFER,
            xe,
            ye,
            i.get(te).__webglTexture,
            ge
          ),
      t.bindFramebuffer(n.FRAMEBUFFER, null);
  }
  function it(D, I, te) {
    if (
      (n.bindRenderbuffer(n.RENDERBUFFER, D), I.depthBuffer && !I.stencilBuffer)
    ) {
      let xe = a === !0 ? n.DEPTH_COMPONENT24 : n.DEPTH_COMPONENT16;
      if (te || me(I)) {
        const ye = I.depthTexture;
        ye &&
          ye.isDepthTexture &&
          (ye.type === Ur
            ? (xe = n.DEPTH_COMPONENT32F)
            : ye.type === Ds && (xe = n.DEPTH_COMPONENT24));
        const ge = Te(I);
        me(I)
          ? u.renderbufferStorageMultisampleEXT(
              n.RENDERBUFFER,
              ge,
              xe,
              I.width,
              I.height
            )
          : n.renderbufferStorageMultisample(
              n.RENDERBUFFER,
              ge,
              xe,
              I.width,
              I.height
            );
      } else n.renderbufferStorage(n.RENDERBUFFER, xe, I.width, I.height);
      n.framebufferRenderbuffer(
        n.FRAMEBUFFER,
        n.DEPTH_ATTACHMENT,
        n.RENDERBUFFER,
        D
      );
    } else if (I.depthBuffer && I.stencilBuffer) {
      const xe = Te(I);
      te && me(I) === !1
        ? n.renderbufferStorageMultisample(
            n.RENDERBUFFER,
            xe,
            n.DEPTH24_STENCIL8,
            I.width,
            I.height
          )
        : me(I)
        ? u.renderbufferStorageMultisampleEXT(
            n.RENDERBUFFER,
            xe,
            n.DEPTH24_STENCIL8,
            I.width,
            I.height
          )
        : n.renderbufferStorage(
            n.RENDERBUFFER,
            n.DEPTH_STENCIL,
            I.width,
            I.height
          ),
        n.framebufferRenderbuffer(
          n.FRAMEBUFFER,
          n.DEPTH_STENCIL_ATTACHMENT,
          n.RENDERBUFFER,
          D
        );
    } else {
      const xe =
        I.isWebGLMultipleRenderTargets === !0 ? I.texture : [I.texture];
      for (let ye = 0; ye < xe.length; ye++) {
        const ge = xe[ye],
          Ye = s.convert(ge.format, ge.colorSpace),
          Le = s.convert(ge.type),
          Fe = T(ge.internalFormat, Ye, Le, ge.colorSpace),
          tt = Te(I);
        te && me(I) === !1
          ? n.renderbufferStorageMultisample(
              n.RENDERBUFFER,
              tt,
              Fe,
              I.width,
              I.height
            )
          : me(I)
          ? u.renderbufferStorageMultisampleEXT(
              n.RENDERBUFFER,
              tt,
              Fe,
              I.width,
              I.height
            )
          : n.renderbufferStorage(n.RENDERBUFFER, Fe, I.width, I.height);
      }
    }
    n.bindRenderbuffer(n.RENDERBUFFER, null);
  }
  function rt(D, I) {
    if (I && I.isWebGLCubeRenderTarget)
      throw new Error(
        "Depth Texture with cube render targets is not supported"
      );
    if (
      (t.bindFramebuffer(n.FRAMEBUFFER, D),
      !(I.depthTexture && I.depthTexture.isDepthTexture))
    )
      throw new Error(
        "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
      );
    (!i.get(I.depthTexture).__webglTexture ||
      I.depthTexture.image.width !== I.width ||
      I.depthTexture.image.height !== I.height) &&
      ((I.depthTexture.image.width = I.width),
      (I.depthTexture.image.height = I.height),
      (I.depthTexture.needsUpdate = !0)),
      $(I.depthTexture, 0);
    const xe = i.get(I.depthTexture).__webglTexture,
      ye = Te(I);
    if (I.depthTexture.format === Uo)
      me(I)
        ? u.framebufferTexture2DMultisampleEXT(
            n.FRAMEBUFFER,
            n.DEPTH_ATTACHMENT,
            n.TEXTURE_2D,
            xe,
            0,
            ye
          )
        : n.framebufferTexture2D(
            n.FRAMEBUFFER,
            n.DEPTH_ATTACHMENT,
            n.TEXTURE_2D,
            xe,
            0
          );
    else if (I.depthTexture.format === Qa)
      me(I)
        ? u.framebufferTexture2DMultisampleEXT(
            n.FRAMEBUFFER,
            n.DEPTH_STENCIL_ATTACHMENT,
            n.TEXTURE_2D,
            xe,
            0,
            ye
          )
        : n.framebufferTexture2D(
            n.FRAMEBUFFER,
            n.DEPTH_STENCIL_ATTACHMENT,
            n.TEXTURE_2D,
            xe,
            0
          );
    else throw new Error("Unknown depthTexture format");
  }
  function Ve(D) {
    const I = i.get(D),
      te = D.isWebGLCubeRenderTarget === !0;
    if (D.depthTexture && !I.__autoAllocateDepthBuffer) {
      if (te)
        throw new Error(
          "target.depthTexture not supported in Cube render targets"
        );
      rt(I.__webglFramebuffer, D);
    } else if (te) {
      I.__webglDepthbuffer = [];
      for (let xe = 0; xe < 6; xe++)
        t.bindFramebuffer(n.FRAMEBUFFER, I.__webglFramebuffer[xe]),
          (I.__webglDepthbuffer[xe] = n.createRenderbuffer()),
          it(I.__webglDepthbuffer[xe], D, !1);
    } else
      t.bindFramebuffer(n.FRAMEBUFFER, I.__webglFramebuffer),
        (I.__webglDepthbuffer = n.createRenderbuffer()),
        it(I.__webglDepthbuffer, D, !1);
    t.bindFramebuffer(n.FRAMEBUFFER, null);
  }
  function We(D, I, te) {
    const xe = i.get(D);
    I !== void 0 &&
      Pe(
        xe.__webglFramebuffer,
        D,
        D.texture,
        n.COLOR_ATTACHMENT0,
        n.TEXTURE_2D,
        0
      ),
      te !== void 0 && Ve(D);
  }
  function H(D) {
    const I = D.texture,
      te = i.get(D),
      xe = i.get(I);
    D.addEventListener("dispose", N),
      D.isWebGLMultipleRenderTargets !== !0 &&
        (xe.__webglTexture === void 0 &&
          (xe.__webglTexture = n.createTexture()),
        (xe.__version = I.version),
        o.memory.textures++);
    const ye = D.isWebGLCubeRenderTarget === !0,
      ge = D.isWebGLMultipleRenderTargets === !0,
      Ye = S(D) || a;
    if (ye) {
      te.__webglFramebuffer = [];
      for (let Le = 0; Le < 6; Le++)
        if (a && I.mipmaps && I.mipmaps.length > 0) {
          te.__webglFramebuffer[Le] = [];
          for (let Fe = 0; Fe < I.mipmaps.length; Fe++)
            te.__webglFramebuffer[Le][Fe] = n.createFramebuffer();
        } else te.__webglFramebuffer[Le] = n.createFramebuffer();
    } else {
      if (a && I.mipmaps && I.mipmaps.length > 0) {
        te.__webglFramebuffer = [];
        for (let Le = 0; Le < I.mipmaps.length; Le++)
          te.__webglFramebuffer[Le] = n.createFramebuffer();
      } else te.__webglFramebuffer = n.createFramebuffer();
      if (ge)
        if (r.drawBuffers) {
          const Le = D.texture;
          for (let Fe = 0, tt = Le.length; Fe < tt; Fe++) {
            const mt = i.get(Le[Fe]);
            mt.__webglTexture === void 0 &&
              ((mt.__webglTexture = n.createTexture()), o.memory.textures++);
          }
        } else
          console.warn(
            "THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."
          );
      if (a && D.samples > 0 && me(D) === !1) {
        const Le = ge ? I : [I];
        (te.__webglMultisampledFramebuffer = n.createFramebuffer()),
          (te.__webglColorRenderbuffer = []),
          t.bindFramebuffer(n.FRAMEBUFFER, te.__webglMultisampledFramebuffer);
        for (let Fe = 0; Fe < Le.length; Fe++) {
          const tt = Le[Fe];
          (te.__webglColorRenderbuffer[Fe] = n.createRenderbuffer()),
            n.bindRenderbuffer(n.RENDERBUFFER, te.__webglColorRenderbuffer[Fe]);
          const mt = s.convert(tt.format, tt.colorSpace),
            _e = s.convert(tt.type),
            Rt = T(
              tt.internalFormat,
              mt,
              _e,
              tt.colorSpace,
              D.isXRRenderTarget === !0
            ),
            _t = Te(D);
          n.renderbufferStorageMultisample(
            n.RENDERBUFFER,
            _t,
            Rt,
            D.width,
            D.height
          ),
            n.framebufferRenderbuffer(
              n.FRAMEBUFFER,
              n.COLOR_ATTACHMENT0 + Fe,
              n.RENDERBUFFER,
              te.__webglColorRenderbuffer[Fe]
            );
        }
        n.bindRenderbuffer(n.RENDERBUFFER, null),
          D.depthBuffer &&
            ((te.__webglDepthRenderbuffer = n.createRenderbuffer()),
            it(te.__webglDepthRenderbuffer, D, !0)),
          t.bindFramebuffer(n.FRAMEBUFFER, null);
      }
    }
    if (ye) {
      t.bindTexture(n.TEXTURE_CUBE_MAP, xe.__webglTexture),
        J(n.TEXTURE_CUBE_MAP, I, Ye);
      for (let Le = 0; Le < 6; Le++)
        if (a && I.mipmaps && I.mipmaps.length > 0)
          for (let Fe = 0; Fe < I.mipmaps.length; Fe++)
            Pe(
              te.__webglFramebuffer[Le][Fe],
              D,
              I,
              n.COLOR_ATTACHMENT0,
              n.TEXTURE_CUBE_MAP_POSITIVE_X + Le,
              Fe
            );
        else
          Pe(
            te.__webglFramebuffer[Le],
            D,
            I,
            n.COLOR_ATTACHMENT0,
            n.TEXTURE_CUBE_MAP_POSITIVE_X + Le,
            0
          );
      M(I, Ye) && _(n.TEXTURE_CUBE_MAP), t.unbindTexture();
    } else if (ge) {
      const Le = D.texture;
      for (let Fe = 0, tt = Le.length; Fe < tt; Fe++) {
        const mt = Le[Fe],
          _e = i.get(mt);
        t.bindTexture(n.TEXTURE_2D, _e.__webglTexture),
          J(n.TEXTURE_2D, mt, Ye),
          Pe(
            te.__webglFramebuffer,
            D,
            mt,
            n.COLOR_ATTACHMENT0 + Fe,
            n.TEXTURE_2D,
            0
          ),
          M(mt, Ye) && _(n.TEXTURE_2D);
      }
      t.unbindTexture();
    } else {
      let Le = n.TEXTURE_2D;
      if (
        ((D.isWebGL3DRenderTarget || D.isWebGLArrayRenderTarget) &&
          (a
            ? (Le = D.isWebGL3DRenderTarget ? n.TEXTURE_3D : n.TEXTURE_2D_ARRAY)
            : console.error(
                "THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2."
              )),
        t.bindTexture(Le, xe.__webglTexture),
        J(Le, I, Ye),
        a && I.mipmaps && I.mipmaps.length > 0)
      )
        for (let Fe = 0; Fe < I.mipmaps.length; Fe++)
          Pe(te.__webglFramebuffer[Fe], D, I, n.COLOR_ATTACHMENT0, Le, Fe);
      else Pe(te.__webglFramebuffer, D, I, n.COLOR_ATTACHMENT0, Le, 0);
      M(I, Ye) && _(Le), t.unbindTexture();
    }
    D.depthBuffer && Ve(D);
  }
  function Me(D) {
    const I = S(D) || a,
      te = D.isWebGLMultipleRenderTargets === !0 ? D.texture : [D.texture];
    for (let xe = 0, ye = te.length; xe < ye; xe++) {
      const ge = te[xe];
      if (M(ge, I)) {
        const Ye = D.isWebGLCubeRenderTarget
            ? n.TEXTURE_CUBE_MAP
            : n.TEXTURE_2D,
          Le = i.get(ge).__webglTexture;
        t.bindTexture(Ye, Le), _(Ye), t.unbindTexture();
      }
    }
  }
  function pe(D) {
    if (a && D.samples > 0 && me(D) === !1) {
      const I = D.isWebGLMultipleRenderTargets ? D.texture : [D.texture],
        te = D.width,
        xe = D.height;
      let ye = n.COLOR_BUFFER_BIT;
      const ge = [],
        Ye = D.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT,
        Le = i.get(D),
        Fe = D.isWebGLMultipleRenderTargets === !0;
      if (Fe)
        for (let tt = 0; tt < I.length; tt++)
          t.bindFramebuffer(n.FRAMEBUFFER, Le.__webglMultisampledFramebuffer),
            n.framebufferRenderbuffer(
              n.FRAMEBUFFER,
              n.COLOR_ATTACHMENT0 + tt,
              n.RENDERBUFFER,
              null
            ),
            t.bindFramebuffer(n.FRAMEBUFFER, Le.__webglFramebuffer),
            n.framebufferTexture2D(
              n.DRAW_FRAMEBUFFER,
              n.COLOR_ATTACHMENT0 + tt,
              n.TEXTURE_2D,
              null,
              0
            );
      t.bindFramebuffer(n.READ_FRAMEBUFFER, Le.__webglMultisampledFramebuffer),
        t.bindFramebuffer(n.DRAW_FRAMEBUFFER, Le.__webglFramebuffer);
      for (let tt = 0; tt < I.length; tt++) {
        ge.push(n.COLOR_ATTACHMENT0 + tt), D.depthBuffer && ge.push(Ye);
        const mt =
          Le.__ignoreDepthValues !== void 0 ? Le.__ignoreDepthValues : !1;
        if (
          (mt === !1 &&
            (D.depthBuffer && (ye |= n.DEPTH_BUFFER_BIT),
            D.stencilBuffer && (ye |= n.STENCIL_BUFFER_BIT)),
          Fe &&
            n.framebufferRenderbuffer(
              n.READ_FRAMEBUFFER,
              n.COLOR_ATTACHMENT0,
              n.RENDERBUFFER,
              Le.__webglColorRenderbuffer[tt]
            ),
          mt === !0 &&
            (n.invalidateFramebuffer(n.READ_FRAMEBUFFER, [Ye]),
            n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, [Ye])),
          Fe)
        ) {
          const _e = i.get(I[tt]).__webglTexture;
          n.framebufferTexture2D(
            n.DRAW_FRAMEBUFFER,
            n.COLOR_ATTACHMENT0,
            n.TEXTURE_2D,
            _e,
            0
          );
        }
        n.blitFramebuffer(0, 0, te, xe, 0, 0, te, xe, ye, n.NEAREST),
          f && n.invalidateFramebuffer(n.READ_FRAMEBUFFER, ge);
      }
      if (
        (t.bindFramebuffer(n.READ_FRAMEBUFFER, null),
        t.bindFramebuffer(n.DRAW_FRAMEBUFFER, null),
        Fe)
      )
        for (let tt = 0; tt < I.length; tt++) {
          t.bindFramebuffer(n.FRAMEBUFFER, Le.__webglMultisampledFramebuffer),
            n.framebufferRenderbuffer(
              n.FRAMEBUFFER,
              n.COLOR_ATTACHMENT0 + tt,
              n.RENDERBUFFER,
              Le.__webglColorRenderbuffer[tt]
            );
          const mt = i.get(I[tt]).__webglTexture;
          t.bindFramebuffer(n.FRAMEBUFFER, Le.__webglFramebuffer),
            n.framebufferTexture2D(
              n.DRAW_FRAMEBUFFER,
              n.COLOR_ATTACHMENT0 + tt,
              n.TEXTURE_2D,
              mt,
              0
            );
        }
      t.bindFramebuffer(n.DRAW_FRAMEBUFFER, Le.__webglMultisampledFramebuffer);
    }
  }
  function Te(D) {
    return Math.min(r.maxSamples, D.samples);
  }
  function me(D) {
    const I = i.get(D);
    return (
      a &&
      D.samples > 0 &&
      e.has("WEBGL_multisampled_render_to_texture") === !0 &&
      I.__useRenderToTexture !== !1
    );
  }
  function Ke(D) {
    const I = o.render.frame;
    h.get(D) !== I && (h.set(D, I), D.update());
  }
  function Ne(D, I) {
    const te = D.colorSpace,
      xe = D.format,
      ye = D.type;
    return (
      D.isCompressedTexture === !0 ||
        D.isVideoTexture === !0 ||
        D.format === eg ||
        (te !== hs &&
          te !== Qi &&
          (zt.getTransfer(te) === jt
            ? a === !1
              ? e.has("EXT_sRGB") === !0 && xe === wi
                ? ((D.format = eg),
                  (D.minFilter = wn),
                  (D.generateMipmaps = !1))
                : (I = NS.sRGBToLinear(I))
              : (xe !== wi || ye !== cs) &&
                console.warn(
                  "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."
                )
            : console.error(
                "THREE.WebGLTextures: Unsupported texture color space:",
                te
              ))),
      I
    );
  }
  (this.allocateTextureUnit = V),
    (this.resetTextureUnits = ae),
    (this.setTexture2D = $),
    (this.setTexture2DArray = ce),
    (this.setTexture3D = k),
    (this.setTextureCube = G),
    (this.rebindTextures = We),
    (this.setupRenderTarget = H),
    (this.updateRenderTargetMipmap = Me),
    (this.updateMultisampleRenderTarget = pe),
    (this.setupDepthRenderbuffer = Ve),
    (this.setupFrameBufferTexture = Pe),
    (this.useMultisampledRTT = me);
}
function kL(n, e, t) {
  const i = t.isWebGL2;
  function r(s, o = Qi) {
    let a;
    const u = zt.getTransfer(o);
    if (s === cs) return n.UNSIGNED_BYTE;
    if (s === wS) return n.UNSIGNED_SHORT_4_4_4_4;
    if (s === ES) return n.UNSIGNED_SHORT_5_5_5_1;
    if (s === tL) return n.BYTE;
    if (s === nL) return n.SHORT;
    if (s === Fg) return n.UNSIGNED_SHORT;
    if (s === MS) return n.INT;
    if (s === Ds) return n.UNSIGNED_INT;
    if (s === Ur) return n.FLOAT;
    if (s === Ou)
      return i
        ? n.HALF_FLOAT
        : ((a = e.get("OES_texture_half_float")),
          a !== null ? a.HALF_FLOAT_OES : null);
    if (s === iL) return n.ALPHA;
    if (s === wi) return n.RGBA;
    if (s === rL) return n.LUMINANCE;
    if (s === sL) return n.LUMINANCE_ALPHA;
    if (s === Uo) return n.DEPTH_COMPONENT;
    if (s === Qa) return n.DEPTH_STENCIL;
    if (s === eg)
      return (a = e.get("EXT_sRGB")), a !== null ? a.SRGB_ALPHA_EXT : null;
    if (s === oL) return n.RED;
    if (s === TS) return n.RED_INTEGER;
    if (s === aL) return n.RG;
    if (s === AS) return n.RG_INTEGER;
    if (s === bS) return n.RGBA_INTEGER;
    if (s === am || s === lm || s === um || s === cm)
      if (u === jt)
        if (((a = e.get("WEBGL_compressed_texture_s3tc_srgb")), a !== null)) {
          if (s === am) return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (s === lm) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (s === um) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (s === cm) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else return null;
      else if (((a = e.get("WEBGL_compressed_texture_s3tc")), a !== null)) {
        if (s === am) return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (s === lm) return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (s === um) return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (s === cm) return a.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else return null;
    if (s === c_ || s === f_ || s === h_ || s === d_)
      if (((a = e.get("WEBGL_compressed_texture_pvrtc")), a !== null)) {
        if (s === c_) return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (s === f_) return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (s === h_) return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (s === d_) return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else return null;
    if (s === CS)
      return (
        (a = e.get("WEBGL_compressed_texture_etc1")),
        a !== null ? a.COMPRESSED_RGB_ETC1_WEBGL : null
      );
    if (s === p_ || s === m_)
      if (((a = e.get("WEBGL_compressed_texture_etc")), a !== null)) {
        if (s === p_)
          return u === jt ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2;
        if (s === m_)
          return u === jt
            ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
            : a.COMPRESSED_RGBA8_ETC2_EAC;
      } else return null;
    if (
      s === g_ ||
      s === v_ ||
      s === y_ ||
      s === x_ ||
      s === __ ||
      s === S_ ||
      s === M_ ||
      s === w_ ||
      s === E_ ||
      s === T_ ||
      s === A_ ||
      s === b_ ||
      s === C_ ||
      s === P_
    )
      if (((a = e.get("WEBGL_compressed_texture_astc")), a !== null)) {
        if (s === g_)
          return u === jt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
            : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (s === v_)
          return u === jt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
            : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (s === y_)
          return u === jt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
            : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (s === x_)
          return u === jt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
            : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (s === __)
          return u === jt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
            : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (s === S_)
          return u === jt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
            : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (s === M_)
          return u === jt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
            : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (s === w_)
          return u === jt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
            : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (s === E_)
          return u === jt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
            : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (s === T_)
          return u === jt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
            : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (s === A_)
          return u === jt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
            : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (s === b_)
          return u === jt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
            : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (s === C_)
          return u === jt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
            : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (s === P_)
          return u === jt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
            : a.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else return null;
    if (s === fm || s === R_ || s === L_)
      if (((a = e.get("EXT_texture_compression_bptc")), a !== null)) {
        if (s === fm)
          return u === jt
            ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
            : a.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (s === R_) return a.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (s === L_) return a.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else return null;
    if (s === lL || s === I_ || s === N_ || s === D_)
      if (((a = e.get("EXT_texture_compression_rgtc")), a !== null)) {
        if (s === fm) return a.COMPRESSED_RED_RGTC1_EXT;
        if (s === I_) return a.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (s === N_) return a.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (s === D_) return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else return null;
    return s === Oo
      ? i
        ? n.UNSIGNED_INT_24_8
        : ((a = e.get("WEBGL_depth_texture")),
          a !== null ? a.UNSIGNED_INT_24_8_WEBGL : null)
      : n[s] !== void 0
      ? n[s]
      : null;
  }
  return { convert: r };
}
class FL extends En {
  constructor(e = []) {
    super(), (this.isArrayCamera = !0), (this.cameras = e);
  }
}
class gu extends Ft {
  constructor() {
    super(), (this.isGroup = !0), (this.type = "Group");
  }
}
const G9 = { type: "move" };
class by {
  constructor() {
    (this._targetRay = null), (this._grip = null), (this._hand = null);
  }
  getHandSpace() {
    return (
      this._hand === null &&
        ((this._hand = new gu()),
        (this._hand.matrixAutoUpdate = !1),
        (this._hand.visible = !1),
        (this._hand.joints = {}),
        (this._hand.inputState = { pinching: !1 })),
      this._hand
    );
  }
  getTargetRaySpace() {
    return (
      this._targetRay === null &&
        ((this._targetRay = new gu()),
        (this._targetRay.matrixAutoUpdate = !1),
        (this._targetRay.visible = !1),
        (this._targetRay.hasLinearVelocity = !1),
        (this._targetRay.linearVelocity = new U()),
        (this._targetRay.hasAngularVelocity = !1),
        (this._targetRay.angularVelocity = new U())),
      this._targetRay
    );
  }
  getGripSpace() {
    return (
      this._grip === null &&
        ((this._grip = new gu()),
        (this._grip.matrixAutoUpdate = !1),
        (this._grip.visible = !1),
        (this._grip.hasLinearVelocity = !1),
        (this._grip.linearVelocity = new U()),
        (this._grip.hasAngularVelocity = !1),
        (this._grip.angularVelocity = new U())),
      this._grip
    );
  }
  dispatchEvent(e) {
    return (
      this._targetRay !== null && this._targetRay.dispatchEvent(e),
      this._grip !== null && this._grip.dispatchEvent(e),
      this._hand !== null && this._hand.dispatchEvent(e),
      this
    );
  }
  connect(e) {
    if (e && e.hand) {
      const t = this._hand;
      if (t) for (const i of e.hand.values()) this._getHandJoint(t, i);
    }
    return this.dispatchEvent({ type: "connected", data: e }), this;
  }
  disconnect(e) {
    return (
      this.dispatchEvent({ type: "disconnected", data: e }),
      this._targetRay !== null && (this._targetRay.visible = !1),
      this._grip !== null && (this._grip.visible = !1),
      this._hand !== null && (this._hand.visible = !1),
      this
    );
  }
  update(e, t, i) {
    let r = null,
      s = null,
      o = null;
    const a = this._targetRay,
      u = this._grip,
      f = this._hand;
    if (e && t.session.visibilityState !== "visible-blurred") {
      if (f && e.hand) {
        o = !0;
        for (const w of e.hand.values()) {
          const S = t.getJointPose(w, i),
            v = this._getHandJoint(f, w);
          S !== null &&
            (v.matrix.fromArray(S.transform.matrix),
            v.matrix.decompose(v.position, v.rotation, v.scale),
            (v.matrixWorldNeedsUpdate = !0),
            (v.jointRadius = S.radius)),
            (v.visible = S !== null);
        }
        const h = f.joints["index-finger-tip"],
          d = f.joints["thumb-tip"],
          p = h.position.distanceTo(d.position),
          m = 0.02,
          y = 0.005;
        f.inputState.pinching && p > m + y
          ? ((f.inputState.pinching = !1),
            this.dispatchEvent({
              type: "pinchend",
              handedness: e.handedness,
              target: this,
            }))
          : !f.inputState.pinching &&
            p <= m - y &&
            ((f.inputState.pinching = !0),
            this.dispatchEvent({
              type: "pinchstart",
              handedness: e.handedness,
              target: this,
            }));
      } else
        u !== null &&
          e.gripSpace &&
          ((s = t.getPose(e.gripSpace, i)),
          s !== null &&
            (u.matrix.fromArray(s.transform.matrix),
            u.matrix.decompose(u.position, u.rotation, u.scale),
            (u.matrixWorldNeedsUpdate = !0),
            s.linearVelocity
              ? ((u.hasLinearVelocity = !0),
                u.linearVelocity.copy(s.linearVelocity))
              : (u.hasLinearVelocity = !1),
            s.angularVelocity
              ? ((u.hasAngularVelocity = !0),
                u.angularVelocity.copy(s.angularVelocity))
              : (u.hasAngularVelocity = !1)));
      a !== null &&
        ((r = t.getPose(e.targetRaySpace, i)),
        r === null && s !== null && (r = s),
        r !== null &&
          (a.matrix.fromArray(r.transform.matrix),
          a.matrix.decompose(a.position, a.rotation, a.scale),
          (a.matrixWorldNeedsUpdate = !0),
          r.linearVelocity
            ? ((a.hasLinearVelocity = !0),
              a.linearVelocity.copy(r.linearVelocity))
            : (a.hasLinearVelocity = !1),
          r.angularVelocity
            ? ((a.hasAngularVelocity = !0),
              a.angularVelocity.copy(r.angularVelocity))
            : (a.hasAngularVelocity = !1),
          this.dispatchEvent(G9)));
    }
    return (
      a !== null && (a.visible = r !== null),
      u !== null && (u.visible = s !== null),
      f !== null && (f.visible = o !== null),
      this
    );
  }
  _getHandJoint(e, t) {
    if (e.joints[t.jointName] === void 0) {
      const i = new gu();
      (i.matrixAutoUpdate = !1),
        (i.visible = !1),
        (e.joints[t.jointName] = i),
        e.add(i);
    }
    return e.joints[t.jointName];
  }
}
class W9 extends Zs {
  constructor(e, t) {
    super();
    const i = this;
    let r = null,
      s = 1,
      o = null,
      a = "local-floor",
      u = 1,
      f = null,
      h = null,
      d = null,
      p = null,
      m = null,
      y = null;
    const w = t.getContextAttributes();
    let S = null,
      v = null;
    const M = [],
      _ = [],
      T = new de();
    let P = null;
    const b = new En();
    b.layers.enable(1), (b.viewport = new Bt());
    const L = new En();
    L.layers.enable(2), (L.viewport = new Bt());
    const N = [b, L],
      C = new FL();
    C.layers.enable(1), C.layers.enable(2);
    let R = null,
      B = null;
    (this.cameraAutoUpdate = !0),
      (this.enabled = !1),
      (this.isPresenting = !1),
      (this.getController = function (J) {
        let he = M[J];
        return (
          he === void 0 && ((he = new by()), (M[J] = he)),
          he.getTargetRaySpace()
        );
      }),
      (this.getControllerGrip = function (J) {
        let he = M[J];
        return (
          he === void 0 && ((he = new by()), (M[J] = he)), he.getGripSpace()
        );
      }),
      (this.getHand = function (J) {
        let he = M[J];
        return (
          he === void 0 && ((he = new by()), (M[J] = he)), he.getHandSpace()
        );
      });
    function Z(J) {
      const he = _.indexOf(J.inputSource);
      if (he === -1) return;
      const Ee = M[he];
      Ee !== void 0 &&
        (Ee.update(J.inputSource, J.frame, f || o),
        Ee.dispatchEvent({ type: J.type, data: J.inputSource }));
    }
    function ae() {
      r.removeEventListener("select", Z),
        r.removeEventListener("selectstart", Z),
        r.removeEventListener("selectend", Z),
        r.removeEventListener("squeeze", Z),
        r.removeEventListener("squeezestart", Z),
        r.removeEventListener("squeezeend", Z),
        r.removeEventListener("end", ae),
        r.removeEventListener("inputsourceschange", V);
      for (let J = 0; J < M.length; J++) {
        const he = _[J];
        he !== null && ((_[J] = null), M[J].disconnect(he));
      }
      (R = null),
        (B = null),
        e.setRenderTarget(S),
        (m = null),
        (p = null),
        (d = null),
        (r = null),
        (v = null),
        ie.stop(),
        (i.isPresenting = !1),
        e.setPixelRatio(P),
        e.setSize(T.width, T.height, !1),
        i.dispatchEvent({ type: "sessionend" });
    }
    (this.setFramebufferScaleFactor = function (J) {
      (s = J),
        i.isPresenting === !0 &&
          console.warn(
            "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
          );
    }),
      (this.setReferenceSpaceType = function (J) {
        (a = J),
          i.isPresenting === !0 &&
            console.warn(
              "THREE.WebXRManager: Cannot change reference space type while presenting."
            );
      }),
      (this.getReferenceSpace = function () {
        return f || o;
      }),
      (this.setReferenceSpace = function (J) {
        f = J;
      }),
      (this.getBaseLayer = function () {
        return p !== null ? p : m;
      }),
      (this.getBinding = function () {
        return d;
      }),
      (this.getFrame = function () {
        return y;
      }),
      (this.getSession = function () {
        return r;
      }),
      (this.setSession = async function (J) {
        if (((r = J), r !== null)) {
          if (
            ((S = e.getRenderTarget()),
            r.addEventListener("select", Z),
            r.addEventListener("selectstart", Z),
            r.addEventListener("selectend", Z),
            r.addEventListener("squeeze", Z),
            r.addEventListener("squeezestart", Z),
            r.addEventListener("squeezeend", Z),
            r.addEventListener("end", ae),
            r.addEventListener("inputsourceschange", V),
            w.xrCompatible !== !0 && (await t.makeXRCompatible()),
            (P = e.getPixelRatio()),
            e.getSize(T),
            r.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1)
          ) {
            const he = {
              antialias: r.renderState.layers === void 0 ? w.antialias : !0,
              alpha: !0,
              depth: w.depth,
              stencil: w.stencil,
              framebufferScaleFactor: s,
            };
            (m = new XRWebGLLayer(r, t, he)),
              r.updateRenderState({ baseLayer: m }),
              e.setPixelRatio(1),
              e.setSize(m.framebufferWidth, m.framebufferHeight, !1),
              (v = new Vr(m.framebufferWidth, m.framebufferHeight, {
                format: wi,
                type: cs,
                colorSpace: e.outputColorSpace,
                stencilBuffer: w.stencil,
              }));
          } else {
            let he = null,
              Ee = null,
              be = null;
            w.depth &&
              ((be = w.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24),
              (he = w.stencil ? Qa : Uo),
              (Ee = w.stencil ? Oo : Ds));
            const Pe = {
              colorFormat: t.RGBA8,
              depthFormat: be,
              scaleFactor: s,
            };
            (d = new XRWebGLBinding(r, t)),
              (p = d.createProjectionLayer(Pe)),
              r.updateRenderState({ layers: [p] }),
              e.setPixelRatio(1),
              e.setSize(p.textureWidth, p.textureHeight, !1),
              (v = new Vr(p.textureWidth, p.textureHeight, {
                format: wi,
                type: cs,
                depthTexture: new FS(
                  p.textureWidth,
                  p.textureHeight,
                  Ee,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  he
                ),
                stencilBuffer: w.stencil,
                colorSpace: e.outputColorSpace,
                samples: w.antialias ? 4 : 0,
              }));
            const it = e.properties.get(v);
            it.__ignoreDepthValues = p.ignoreDepthValues;
          }
          (v.isXRRenderTarget = !0),
            this.setFoveation(u),
            (f = null),
            (o = await r.requestReferenceSpace(a)),
            ie.setContext(r),
            ie.start(),
            (i.isPresenting = !0),
            i.dispatchEvent({ type: "sessionstart" });
        }
      }),
      (this.getEnvironmentBlendMode = function () {
        if (r !== null) return r.environmentBlendMode;
      });
    function V(J) {
      for (let he = 0; he < J.removed.length; he++) {
        const Ee = J.removed[he],
          be = _.indexOf(Ee);
        be >= 0 && ((_[be] = null), M[be].disconnect(Ee));
      }
      for (let he = 0; he < J.added.length; he++) {
        const Ee = J.added[he];
        let be = _.indexOf(Ee);
        if (be === -1) {
          for (let it = 0; it < M.length; it++)
            if (it >= _.length) {
              _.push(Ee), (be = it);
              break;
            } else if (_[it] === null) {
              (_[it] = Ee), (be = it);
              break;
            }
          if (be === -1) break;
        }
        const Pe = M[be];
        Pe && Pe.connect(Ee);
      }
    }
    const Q = new U(),
      $ = new U();
    function ce(J, he, Ee) {
      Q.setFromMatrixPosition(he.matrixWorld),
        $.setFromMatrixPosition(Ee.matrixWorld);
      const be = Q.distanceTo($),
        Pe = he.projectionMatrix.elements,
        it = Ee.projectionMatrix.elements,
        rt = Pe[14] / (Pe[10] - 1),
        Ve = Pe[14] / (Pe[10] + 1),
        We = (Pe[9] + 1) / Pe[5],
        H = (Pe[9] - 1) / Pe[5],
        Me = (Pe[8] - 1) / Pe[0],
        pe = (it[8] + 1) / it[0],
        Te = rt * Me,
        me = rt * pe,
        Ke = be / (-Me + pe),
        Ne = Ke * -Me;
      he.matrixWorld.decompose(J.position, J.quaternion, J.scale),
        J.translateX(Ne),
        J.translateZ(Ke),
        J.matrixWorld.compose(J.position, J.quaternion, J.scale),
        J.matrixWorldInverse.copy(J.matrixWorld).invert();
      const D = rt + Ke,
        I = Ve + Ke,
        te = Te - Ne,
        xe = me + (be - Ne),
        ye = ((We * Ve) / I) * D,
        ge = ((H * Ve) / I) * D;
      J.projectionMatrix.makePerspective(te, xe, ye, ge, D, I),
        J.projectionMatrixInverse.copy(J.projectionMatrix).invert();
    }
    function k(J, he) {
      he === null
        ? J.matrixWorld.copy(J.matrix)
        : J.matrixWorld.multiplyMatrices(he.matrixWorld, J.matrix),
        J.matrixWorldInverse.copy(J.matrixWorld).invert();
    }
    this.updateCamera = function (J) {
      if (r === null) return;
      (C.near = L.near = b.near = J.near),
        (C.far = L.far = b.far = J.far),
        (R !== C.near || B !== C.far) &&
          (r.updateRenderState({ depthNear: C.near, depthFar: C.far }),
          (R = C.near),
          (B = C.far));
      const he = J.parent,
        Ee = C.cameras;
      k(C, he);
      for (let be = 0; be < Ee.length; be++) k(Ee[be], he);
      Ee.length === 2
        ? ce(C, b, L)
        : C.projectionMatrix.copy(b.projectionMatrix),
        G(J, C, he);
    };
    function G(J, he, Ee) {
      Ee === null
        ? J.matrix.copy(he.matrixWorld)
        : (J.matrix.copy(Ee.matrixWorld),
          J.matrix.invert(),
          J.matrix.multiply(he.matrixWorld)),
        J.matrix.decompose(J.position, J.quaternion, J.scale),
        J.updateMatrixWorld(!0),
        J.projectionMatrix.copy(he.projectionMatrix),
        J.projectionMatrixInverse.copy(he.projectionMatrixInverse),
        J.isPerspectiveCamera &&
          ((J.fov = ku * 2 * Math.atan(1 / J.projectionMatrix.elements[5])),
          (J.zoom = 1));
    }
    (this.getCamera = function () {
      return C;
    }),
      (this.getFoveation = function () {
        if (!(p === null && m === null)) return u;
      }),
      (this.setFoveation = function (J) {
        (u = J),
          p !== null && (p.fixedFoveation = J),
          m !== null && m.fixedFoveation !== void 0 && (m.fixedFoveation = J);
      });
    let W = null;
    function Y(J, he) {
      if (((h = he.getViewerPose(f || o)), (y = he), h !== null)) {
        const Ee = h.views;
        m !== null &&
          (e.setRenderTargetFramebuffer(v, m.framebuffer),
          e.setRenderTarget(v));
        let be = !1;
        Ee.length !== C.cameras.length && ((C.cameras.length = 0), (be = !0));
        for (let Pe = 0; Pe < Ee.length; Pe++) {
          const it = Ee[Pe];
          let rt = null;
          if (m !== null) rt = m.getViewport(it);
          else {
            const We = d.getViewSubImage(p, it);
            (rt = We.viewport),
              Pe === 0 &&
                (e.setRenderTargetTextures(
                  v,
                  We.colorTexture,
                  p.ignoreDepthValues ? void 0 : We.depthStencilTexture
                ),
                e.setRenderTarget(v));
          }
          let Ve = N[Pe];
          Ve === void 0 &&
            ((Ve = new En()),
            Ve.layers.enable(Pe),
            (Ve.viewport = new Bt()),
            (N[Pe] = Ve)),
            Ve.matrix.fromArray(it.transform.matrix),
            Ve.matrix.decompose(Ve.position, Ve.quaternion, Ve.scale),
            Ve.projectionMatrix.fromArray(it.projectionMatrix),
            Ve.projectionMatrixInverse.copy(Ve.projectionMatrix).invert(),
            Ve.viewport.set(rt.x, rt.y, rt.width, rt.height),
            Pe === 0 &&
              (C.matrix.copy(Ve.matrix),
              C.matrix.decompose(C.position, C.quaternion, C.scale)),
            be === !0 && C.cameras.push(Ve);
        }
      }
      for (let Ee = 0; Ee < M.length; Ee++) {
        const be = _[Ee],
          Pe = M[Ee];
        be !== null && Pe !== void 0 && Pe.update(be, he, f || o);
      }
      W && W(J, he),
        he.detectedPlanes &&
          i.dispatchEvent({ type: "planesdetected", data: he }),
        (y = null);
    }
    const ie = new LL();
    ie.setAnimationLoop(Y),
      (this.setAnimationLoop = function (J) {
        W = J;
      }),
      (this.dispose = function () {});
  }
}
function j9(n, e) {
  function t(S, v) {
    S.matrixAutoUpdate === !0 && S.updateMatrix(), v.value.copy(S.matrix);
  }
  function i(S, v) {
    v.color.getRGB(S.fogColor.value, bL(n)),
      v.isFog
        ? ((S.fogNear.value = v.near), (S.fogFar.value = v.far))
        : v.isFogExp2 && (S.fogDensity.value = v.density);
  }
  function r(S, v, M, _, T) {
    v.isMeshBasicMaterial || v.isMeshLambertMaterial
      ? s(S, v)
      : v.isMeshToonMaterial
      ? (s(S, v), d(S, v))
      : v.isMeshPhongMaterial
      ? (s(S, v), h(S, v))
      : v.isMeshStandardMaterial
      ? (s(S, v), p(S, v), v.isMeshPhysicalMaterial && m(S, v, T))
      : v.isMeshMatcapMaterial
      ? (s(S, v), y(S, v))
      : v.isMeshDepthMaterial
      ? s(S, v)
      : v.isMeshDistanceMaterial
      ? (s(S, v), w(S, v))
      : v.isMeshNormalMaterial
      ? s(S, v)
      : v.isLineBasicMaterial
      ? (o(S, v), v.isLineDashedMaterial && a(S, v))
      : v.isPointsMaterial
      ? u(S, v, M, _)
      : v.isSpriteMaterial
      ? f(S, v)
      : v.isShadowMaterial
      ? (S.color.value.copy(v.color), (S.opacity.value = v.opacity))
      : v.isShaderMaterial && (v.uniformsNeedUpdate = !1);
  }
  function s(S, v) {
    (S.opacity.value = v.opacity),
      v.color && S.diffuse.value.copy(v.color),
      v.emissive &&
        S.emissive.value.copy(v.emissive).multiplyScalar(v.emissiveIntensity),
      v.map && ((S.map.value = v.map), t(v.map, S.mapTransform)),
      v.alphaMap &&
        ((S.alphaMap.value = v.alphaMap), t(v.alphaMap, S.alphaMapTransform)),
      v.bumpMap &&
        ((S.bumpMap.value = v.bumpMap),
        t(v.bumpMap, S.bumpMapTransform),
        (S.bumpScale.value = v.bumpScale),
        v.side === Ti && (S.bumpScale.value *= -1)),
      v.normalMap &&
        ((S.normalMap.value = v.normalMap),
        t(v.normalMap, S.normalMapTransform),
        S.normalScale.value.copy(v.normalScale),
        v.side === Ti && S.normalScale.value.negate()),
      v.displacementMap &&
        ((S.displacementMap.value = v.displacementMap),
        t(v.displacementMap, S.displacementMapTransform),
        (S.displacementScale.value = v.displacementScale),
        (S.displacementBias.value = v.displacementBias)),
      v.emissiveMap &&
        ((S.emissiveMap.value = v.emissiveMap),
        t(v.emissiveMap, S.emissiveMapTransform)),
      v.specularMap &&
        ((S.specularMap.value = v.specularMap),
        t(v.specularMap, S.specularMapTransform)),
      v.alphaTest > 0 && (S.alphaTest.value = v.alphaTest);
    const M = e.get(v).envMap;
    if (
      (M &&
        ((S.envMap.value = M),
        (S.flipEnvMap.value =
          M.isCubeTexture && M.isRenderTargetTexture === !1 ? -1 : 1),
        (S.reflectivity.value = v.reflectivity),
        (S.ior.value = v.ior),
        (S.refractionRatio.value = v.refractionRatio)),
      v.lightMap)
    ) {
      S.lightMap.value = v.lightMap;
      const _ = n._useLegacyLights === !0 ? Math.PI : 1;
      (S.lightMapIntensity.value = v.lightMapIntensity * _),
        t(v.lightMap, S.lightMapTransform);
    }
    v.aoMap &&
      ((S.aoMap.value = v.aoMap),
      (S.aoMapIntensity.value = v.aoMapIntensity),
      t(v.aoMap, S.aoMapTransform));
  }
  function o(S, v) {
    S.diffuse.value.copy(v.color),
      (S.opacity.value = v.opacity),
      v.map && ((S.map.value = v.map), t(v.map, S.mapTransform));
  }
  function a(S, v) {
    (S.dashSize.value = v.dashSize),
      (S.totalSize.value = v.dashSize + v.gapSize),
      (S.scale.value = v.scale);
  }
  function u(S, v, M, _) {
    S.diffuse.value.copy(v.color),
      (S.opacity.value = v.opacity),
      (S.size.value = v.size * M),
      (S.scale.value = _ * 0.5),
      v.map && ((S.map.value = v.map), t(v.map, S.uvTransform)),
      v.alphaMap &&
        ((S.alphaMap.value = v.alphaMap), t(v.alphaMap, S.alphaMapTransform)),
      v.alphaTest > 0 && (S.alphaTest.value = v.alphaTest);
  }
  function f(S, v) {
    S.diffuse.value.copy(v.color),
      (S.opacity.value = v.opacity),
      (S.rotation.value = v.rotation),
      v.map && ((S.map.value = v.map), t(v.map, S.mapTransform)),
      v.alphaMap &&
        ((S.alphaMap.value = v.alphaMap), t(v.alphaMap, S.alphaMapTransform)),
      v.alphaTest > 0 && (S.alphaTest.value = v.alphaTest);
  }
  function h(S, v) {
    S.specular.value.copy(v.specular),
      (S.shininess.value = Math.max(v.shininess, 1e-4));
  }
  function d(S, v) {
    v.gradientMap && (S.gradientMap.value = v.gradientMap);
  }
  function p(S, v) {
    (S.metalness.value = v.metalness),
      v.metalnessMap &&
        ((S.metalnessMap.value = v.metalnessMap),
        t(v.metalnessMap, S.metalnessMapTransform)),
      (S.roughness.value = v.roughness),
      v.roughnessMap &&
        ((S.roughnessMap.value = v.roughnessMap),
        t(v.roughnessMap, S.roughnessMapTransform)),
      e.get(v).envMap && (S.envMapIntensity.value = v.envMapIntensity);
  }
  function m(S, v, M) {
    (S.ior.value = v.ior),
      v.sheen > 0 &&
        (S.sheenColor.value.copy(v.sheenColor).multiplyScalar(v.sheen),
        (S.sheenRoughness.value = v.sheenRoughness),
        v.sheenColorMap &&
          ((S.sheenColorMap.value = v.sheenColorMap),
          t(v.sheenColorMap, S.sheenColorMapTransform)),
        v.sheenRoughnessMap &&
          ((S.sheenRoughnessMap.value = v.sheenRoughnessMap),
          t(v.sheenRoughnessMap, S.sheenRoughnessMapTransform))),
      v.clearcoat > 0 &&
        ((S.clearcoat.value = v.clearcoat),
        (S.clearcoatRoughness.value = v.clearcoatRoughness),
        v.clearcoatMap &&
          ((S.clearcoatMap.value = v.clearcoatMap),
          t(v.clearcoatMap, S.clearcoatMapTransform)),
        v.clearcoatRoughnessMap &&
          ((S.clearcoatRoughnessMap.value = v.clearcoatRoughnessMap),
          t(v.clearcoatRoughnessMap, S.clearcoatRoughnessMapTransform)),
        v.clearcoatNormalMap &&
          ((S.clearcoatNormalMap.value = v.clearcoatNormalMap),
          t(v.clearcoatNormalMap, S.clearcoatNormalMapTransform),
          S.clearcoatNormalScale.value.copy(v.clearcoatNormalScale),
          v.side === Ti && S.clearcoatNormalScale.value.negate())),
      v.iridescence > 0 &&
        ((S.iridescence.value = v.iridescence),
        (S.iridescenceIOR.value = v.iridescenceIOR),
        (S.iridescenceThicknessMinimum.value = v.iridescenceThicknessRange[0]),
        (S.iridescenceThicknessMaximum.value = v.iridescenceThicknessRange[1]),
        v.iridescenceMap &&
          ((S.iridescenceMap.value = v.iridescenceMap),
          t(v.iridescenceMap, S.iridescenceMapTransform)),
        v.iridescenceThicknessMap &&
          ((S.iridescenceThicknessMap.value = v.iridescenceThicknessMap),
          t(v.iridescenceThicknessMap, S.iridescenceThicknessMapTransform))),
      v.transmission > 0 &&
        ((S.transmission.value = v.transmission),
        (S.transmissionSamplerMap.value = M.texture),
        S.transmissionSamplerSize.value.set(M.width, M.height),
        v.transmissionMap &&
          ((S.transmissionMap.value = v.transmissionMap),
          t(v.transmissionMap, S.transmissionMapTransform)),
        (S.thickness.value = v.thickness),
        v.thicknessMap &&
          ((S.thicknessMap.value = v.thicknessMap),
          t(v.thicknessMap, S.thicknessMapTransform)),
        (S.attenuationDistance.value = v.attenuationDistance),
        S.attenuationColor.value.copy(v.attenuationColor)),
      v.anisotropy > 0 &&
        (S.anisotropyVector.value.set(
          v.anisotropy * Math.cos(v.anisotropyRotation),
          v.anisotropy * Math.sin(v.anisotropyRotation)
        ),
        v.anisotropyMap &&
          ((S.anisotropyMap.value = v.anisotropyMap),
          t(v.anisotropyMap, S.anisotropyMapTransform))),
      (S.specularIntensity.value = v.specularIntensity),
      S.specularColor.value.copy(v.specularColor),
      v.specularColorMap &&
        ((S.specularColorMap.value = v.specularColorMap),
        t(v.specularColorMap, S.specularColorMapTransform)),
      v.specularIntensityMap &&
        ((S.specularIntensityMap.value = v.specularIntensityMap),
        t(v.specularIntensityMap, S.specularIntensityMapTransform));
  }
  function y(S, v) {
    v.matcap && (S.matcap.value = v.matcap);
  }
  function w(S, v) {
    const M = e.get(v).light;
    S.referencePosition.value.setFromMatrixPosition(M.matrixWorld),
      (S.nearDistance.value = M.shadow.camera.near),
      (S.farDistance.value = M.shadow.camera.far);
  }
  return { refreshFogUniforms: i, refreshMaterialUniforms: r };
}
function X9(n, e, t, i) {
  let r = {},
    s = {},
    o = [];
  const a = t.isWebGL2 ? n.getParameter(n.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
  function u(M, _) {
    const T = _.program;
    i.uniformBlockBinding(M, T);
  }
  function f(M, _) {
    let T = r[M.id];
    T === void 0 &&
      (y(M), (T = h(M)), (r[M.id] = T), M.addEventListener("dispose", S));
    const P = _.program;
    i.updateUBOMapping(M, P);
    const b = e.render.frame;
    s[M.id] !== b && (p(M), (s[M.id] = b));
  }
  function h(M) {
    const _ = d();
    M.__bindingPointIndex = _;
    const T = n.createBuffer(),
      P = M.__size,
      b = M.usage;
    return (
      n.bindBuffer(n.UNIFORM_BUFFER, T),
      n.bufferData(n.UNIFORM_BUFFER, P, b),
      n.bindBuffer(n.UNIFORM_BUFFER, null),
      n.bindBufferBase(n.UNIFORM_BUFFER, _, T),
      T
    );
  }
  function d() {
    for (let M = 0; M < a; M++) if (o.indexOf(M) === -1) return o.push(M), M;
    return (
      console.error(
        "THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."
      ),
      0
    );
  }
  function p(M) {
    const _ = r[M.id],
      T = M.uniforms,
      P = M.__cache;
    n.bindBuffer(n.UNIFORM_BUFFER, _);
    for (let b = 0, L = T.length; b < L; b++) {
      const N = Array.isArray(T[b]) ? T[b] : [T[b]];
      for (let C = 0, R = N.length; C < R; C++) {
        const B = N[C];
        if (m(B, b, C, P) === !0) {
          const Z = B.__offset,
            ae = Array.isArray(B.value) ? B.value : [B.value];
          let V = 0;
          for (let Q = 0; Q < ae.length; Q++) {
            const $ = ae[Q],
              ce = w($);
            typeof $ == "number" || typeof $ == "boolean"
              ? ((B.__data[0] = $),
                n.bufferSubData(n.UNIFORM_BUFFER, Z + V, B.__data))
              : $.isMatrix3
              ? ((B.__data[0] = $.elements[0]),
                (B.__data[1] = $.elements[1]),
                (B.__data[2] = $.elements[2]),
                (B.__data[3] = 0),
                (B.__data[4] = $.elements[3]),
                (B.__data[5] = $.elements[4]),
                (B.__data[6] = $.elements[5]),
                (B.__data[7] = 0),
                (B.__data[8] = $.elements[6]),
                (B.__data[9] = $.elements[7]),
                (B.__data[10] = $.elements[8]),
                (B.__data[11] = 0))
              : ($.toArray(B.__data, V),
                (V += ce.storage / Float32Array.BYTES_PER_ELEMENT));
          }
          n.bufferSubData(n.UNIFORM_BUFFER, Z, B.__data);
        }
      }
    }
    n.bindBuffer(n.UNIFORM_BUFFER, null);
  }
  function m(M, _, T, P) {
    const b = M.value,
      L = _ + "_" + T;
    if (P[L] === void 0)
      return (
        typeof b == "number" || typeof b == "boolean"
          ? (P[L] = b)
          : (P[L] = b.clone()),
        !0
      );
    {
      const N = P[L];
      if (typeof b == "number" || typeof b == "boolean") {
        if (N !== b) return (P[L] = b), !0;
      } else if (N.equals(b) === !1) return N.copy(b), !0;
    }
    return !1;
  }
  function y(M) {
    const _ = M.uniforms;
    let T = 0;
    const P = 16;
    for (let L = 0, N = _.length; L < N; L++) {
      const C = Array.isArray(_[L]) ? _[L] : [_[L]];
      for (let R = 0, B = C.length; R < B; R++) {
        const Z = C[R],
          ae = Array.isArray(Z.value) ? Z.value : [Z.value];
        for (let V = 0, Q = ae.length; V < Q; V++) {
          const $ = ae[V],
            ce = w($),
            k = T % P;
          k !== 0 && P - k < ce.boundary && (T += P - k),
            (Z.__data = new Float32Array(
              ce.storage / Float32Array.BYTES_PER_ELEMENT
            )),
            (Z.__offset = T),
            (T += ce.storage);
        }
      }
    }
    const b = T % P;
    return b > 0 && (T += P - b), (M.__size = T), (M.__cache = {}), this;
  }
  function w(M) {
    const _ = { boundary: 0, storage: 0 };
    return (
      typeof M == "number" || typeof M == "boolean"
        ? ((_.boundary = 4), (_.storage = 4))
        : M.isVector2
        ? ((_.boundary = 8), (_.storage = 8))
        : M.isVector3 || M.isColor
        ? ((_.boundary = 16), (_.storage = 12))
        : M.isVector4
        ? ((_.boundary = 16), (_.storage = 16))
        : M.isMatrix3
        ? ((_.boundary = 48), (_.storage = 48))
        : M.isMatrix4
        ? ((_.boundary = 64), (_.storage = 64))
        : M.isTexture
        ? console.warn(
            "THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."
          )
        : console.warn(
            "THREE.WebGLRenderer: Unsupported uniform value type.",
            M
          ),
      _
    );
  }
  function S(M) {
    const _ = M.target;
    _.removeEventListener("dispose", S);
    const T = o.indexOf(_.__bindingPointIndex);
    o.splice(T, 1), n.deleteBuffer(r[_.id]), delete r[_.id], delete s[_.id];
  }
  function v() {
    for (const M in r) n.deleteBuffer(r[M]);
    (o = []), (r = {}), (s = {});
  }
  return { bind: u, update: f, dispose: v };
}
class VS {
  constructor(e = {}) {
    const {
      canvas: t = EL(),
      context: i = null,
      depth: r = !0,
      stencil: s = !0,
      alpha: o = !1,
      antialias: a = !1,
      premultipliedAlpha: u = !0,
      preserveDrawingBuffer: f = !1,
      powerPreference: h = "default",
      failIfMajorPerformanceCaveat: d = !1,
    } = e;
    this.isWebGLRenderer = !0;
    let p;
    i !== null ? (p = i.getContextAttributes().alpha) : (p = o);
    const m = new Uint32Array(4),
      y = new Int32Array(4);
    let w = null,
      S = null;
    const v = [],
      M = [];
    (this.domElement = t),
      (this.debug = { checkShaderErrors: !0, onShaderError: null }),
      (this.autoClear = !0),
      (this.autoClearColor = !0),
      (this.autoClearDepth = !0),
      (this.autoClearStencil = !0),
      (this.sortObjects = !0),
      (this.clippingPlanes = []),
      (this.localClippingEnabled = !1),
      (this._outputColorSpace = Dn),
      (this._useLegacyLights = !1),
      (this.toneMapping = us),
      (this.toneMappingExposure = 1);
    const _ = this;
    let T = !1,
      P = 0,
      b = 0,
      L = null,
      N = -1,
      C = null;
    const R = new Bt(),
      B = new Bt();
    let Z = null;
    const ae = new Be(0);
    let V = 0,
      Q = t.width,
      $ = t.height,
      ce = 1,
      k = null,
      G = null;
    const W = new Bt(0, 0, Q, $),
      Y = new Bt(0, 0, Q, $);
    let ie = !1;
    const J = new Sh();
    let he = !1,
      Ee = !1,
      be = null;
    const Pe = new dt(),
      it = new de(),
      rt = new U(),
      Ve = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: !0,
      };
    function We() {
      return L === null ? ce : 1;
    }
    let H = i;
    function Me(O, ee) {
      for (let oe = 0; oe < O.length; oe++) {
        const le = O[oe],
          re = t.getContext(le, ee);
        if (re !== null) return re;
      }
      return null;
    }
    try {
      const O = {
        alpha: !0,
        depth: r,
        stencil: s,
        antialias: a,
        premultipliedAlpha: u,
        preserveDrawingBuffer: f,
        powerPreference: h,
        failIfMajorPerformanceCaveat: d,
      };
      if (
        ("setAttribute" in t &&
          t.setAttribute("data-engine", `three.js r${mh}`),
        t.addEventListener("webglcontextlost", Se, !1),
        t.addEventListener("webglcontextrestored", X, !1),
        t.addEventListener("webglcontextcreationerror", Ce, !1),
        H === null)
      ) {
        const ee = ["webgl2", "webgl", "experimental-webgl"];
        if (
          (_.isWebGL1Renderer === !0 && ee.shift(), (H = Me(ee, O)), H === null)
        )
          throw Me(ee)
            ? new Error(
                "Error creating WebGL context with your selected attributes."
              )
            : new Error("Error creating WebGL context.");
      }
      typeof WebGLRenderingContext < "u" &&
        H instanceof WebGLRenderingContext &&
        console.warn(
          "THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."
        ),
        H.getShaderPrecisionFormat === void 0 &&
          (H.getShaderPrecisionFormat = function () {
            return { rangeMin: 1, rangeMax: 1, precision: 1 };
          });
    } catch (O) {
      throw (console.error("THREE.WebGLRenderer: " + O.message), O);
    }
    let pe,
      Te,
      me,
      Ke,
      Ne,
      D,
      I,
      te,
      xe,
      ye,
      ge,
      Ye,
      Le,
      Fe,
      tt,
      mt,
      _e,
      Rt,
      _t,
      ht,
      et,
      He,
      j,
      ve;
    function ke() {
      (pe = new oG(H)),
        (Te = new eG(H, pe, e)),
        pe.init(Te),
        (He = new kL(H, pe, Te)),
        (me = new V9(H, pe, Te)),
        (Ke = new uG(H)),
        (Ne = new P9()),
        (D = new H9(H, pe, me, Ne, Te, He, Ke)),
        (I = new nG(_)),
        (te = new sG(_)),
        (xe = new vV(H, Te)),
        (j = new $H(H, pe, xe, Te)),
        (ye = new aG(H, xe, Ke, j)),
        (ge = new dG(H, ye, xe, Ke)),
        (_t = new hG(H, Te, D)),
        (mt = new tG(Ne)),
        (Ye = new C9(_, I, te, pe, Te, j, mt)),
        (Le = new j9(_, Ne)),
        (Fe = new L9()),
        (tt = new k9(pe, Te)),
        (Rt = new QH(_, I, te, me, ge, p, u)),
        (_e = new B9(_, ge, Te)),
        (ve = new X9(H, Ke, Te, me)),
        (ht = new JH(H, pe, Ke, Te)),
        (et = new lG(H, pe, Ke, Te)),
        (Ke.programs = Ye.programs),
        (_.capabilities = Te),
        (_.extensions = pe),
        (_.properties = Ne),
        (_.renderLists = Fe),
        (_.shadowMap = _e),
        (_.state = me),
        (_.info = Ke);
    }
    ke();
    const Oe = new W9(_, H);
    (this.xr = Oe),
      (this.getContext = function () {
        return H;
      }),
      (this.getContextAttributes = function () {
        return H.getContextAttributes();
      }),
      (this.forceContextLoss = function () {
        const O = pe.get("WEBGL_lose_context");
        O && O.loseContext();
      }),
      (this.forceContextRestore = function () {
        const O = pe.get("WEBGL_lose_context");
        O && O.restoreContext();
      }),
      (this.getPixelRatio = function () {
        return ce;
      }),
      (this.setPixelRatio = function (O) {
        O !== void 0 && ((ce = O), this.setSize(Q, $, !1));
      }),
      (this.getSize = function (O) {
        return O.set(Q, $);
      }),
      (this.setSize = function (O, ee, oe = !0) {
        if (Oe.isPresenting) {
          console.warn(
            "THREE.WebGLRenderer: Can't change size while VR device is presenting."
          );
          return;
        }
        (Q = O),
          ($ = ee),
          (t.width = Math.floor(O * ce)),
          (t.height = Math.floor(ee * ce)),
          oe === !0 &&
            ((t.style.width = O + "px"), (t.style.height = ee + "px")),
          this.setViewport(0, 0, O, ee);
      }),
      (this.getDrawingBufferSize = function (O) {
        return O.set(Q * ce, $ * ce).floor();
      }),
      (this.setDrawingBufferSize = function (O, ee, oe) {
        (Q = O),
          ($ = ee),
          (ce = oe),
          (t.width = Math.floor(O * oe)),
          (t.height = Math.floor(ee * oe)),
          this.setViewport(0, 0, O, ee);
      }),
      (this.getCurrentViewport = function (O) {
        return O.copy(R);
      }),
      (this.getViewport = function (O) {
        return O.copy(W);
      }),
      (this.setViewport = function (O, ee, oe, le) {
        O.isVector4 ? W.set(O.x, O.y, O.z, O.w) : W.set(O, ee, oe, le),
          me.viewport(R.copy(W).multiplyScalar(ce).floor());
      }),
      (this.getScissor = function (O) {
        return O.copy(Y);
      }),
      (this.setScissor = function (O, ee, oe, le) {
        O.isVector4 ? Y.set(O.x, O.y, O.z, O.w) : Y.set(O, ee, oe, le),
          me.scissor(B.copy(Y).multiplyScalar(ce).floor());
      }),
      (this.getScissorTest = function () {
        return ie;
      }),
      (this.setScissorTest = function (O) {
        me.setScissorTest((ie = O));
      }),
      (this.setOpaqueSort = function (O) {
        k = O;
      }),
      (this.setTransparentSort = function (O) {
        G = O;
      }),
      (this.getClearColor = function (O) {
        return O.copy(Rt.getClearColor());
      }),
      (this.setClearColor = function () {
        Rt.setClearColor.apply(Rt, arguments);
      }),
      (this.getClearAlpha = function () {
        return Rt.getClearAlpha();
      }),
      (this.setClearAlpha = function () {
        Rt.setClearAlpha.apply(Rt, arguments);
      }),
      (this.clear = function (O = !0, ee = !0, oe = !0) {
        let le = 0;
        if (O) {
          let re = !1;
          if (L !== null) {
            const ze = L.texture.format;
            re = ze === bS || ze === AS || ze === TS;
          }
          if (re) {
            const ze = L.texture.type,
              $e =
                ze === cs ||
                ze === Ds ||
                ze === Fg ||
                ze === Oo ||
                ze === wS ||
                ze === ES,
              lt = Rt.getClearColor(),
              ut = Rt.getClearAlpha(),
              gt = lt.r,
              pt = lt.g,
              vt = lt.b;
            $e
              ? ((m[0] = gt),
                (m[1] = pt),
                (m[2] = vt),
                (m[3] = ut),
                H.clearBufferuiv(H.COLOR, 0, m))
              : ((y[0] = gt),
                (y[1] = pt),
                (y[2] = vt),
                (y[3] = ut),
                H.clearBufferiv(H.COLOR, 0, y));
          } else le |= H.COLOR_BUFFER_BIT;
        }
        ee && (le |= H.DEPTH_BUFFER_BIT),
          oe &&
            ((le |= H.STENCIL_BUFFER_BIT),
            this.state.buffers.stencil.setMask(4294967295)),
          H.clear(le);
      }),
      (this.clearColor = function () {
        this.clear(!0, !1, !1);
      }),
      (this.clearDepth = function () {
        this.clear(!1, !0, !1);
      }),
      (this.clearStencil = function () {
        this.clear(!1, !1, !0);
      }),
      (this.dispose = function () {
        t.removeEventListener("webglcontextlost", Se, !1),
          t.removeEventListener("webglcontextrestored", X, !1),
          t.removeEventListener("webglcontextcreationerror", Ce, !1),
          Fe.dispose(),
          tt.dispose(),
          Ne.dispose(),
          I.dispose(),
          te.dispose(),
          ge.dispose(),
          j.dispose(),
          ve.dispose(),
          Ye.dispose(),
          Oe.dispose(),
          Oe.removeEventListener("sessionstart", Jt),
          Oe.removeEventListener("sessionend", It),
          be && (be.dispose(), (be = null)),
          Yn.stop();
      });
    function Se(O) {
      O.preventDefault(),
        console.log("THREE.WebGLRenderer: Context Lost."),
        (T = !0);
    }
    function X() {
      console.log("THREE.WebGLRenderer: Context Restored."), (T = !1);
      const O = Ke.autoReset,
        ee = _e.enabled,
        oe = _e.autoUpdate,
        le = _e.needsUpdate,
        re = _e.type;
      ke(),
        (Ke.autoReset = O),
        (_e.enabled = ee),
        (_e.autoUpdate = oe),
        (_e.needsUpdate = le),
        (_e.type = re);
    }
    function Ce(O) {
      console.error(
        "THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",
        O.statusMessage
      );
    }
    function Ie(O) {
      const ee = O.target;
      ee.removeEventListener("dispose", Ie), st(ee);
    }
    function st(O) {
      qe(O), Ne.remove(O);
    }
    function qe(O) {
      const ee = Ne.get(O).programs;
      ee !== void 0 &&
        (ee.forEach(function (oe) {
          Ye.releaseProgram(oe);
        }),
        O.isShaderMaterial && Ye.releaseShaderCache(O));
    }
    this.renderBufferDirect = function (O, ee, oe, le, re, ze) {
      ee === null && (ee = Ve);
      const $e = re.isMesh && re.matrixWorld.determinant() < 0,
        lt = uv(O, ee, oe, le, re);
      me.setMaterial(le, $e);
      let ut = oe.index,
        gt = 1;
      if (le.wireframe === !0) {
        if (((ut = ye.getWireframeAttribute(oe)), ut === void 0)) return;
        gt = 2;
      }
      const pt = oe.drawRange,
        vt = oe.attributes.position;
      let rn = pt.start * gt,
        qn = (pt.start + pt.count) * gt;
      ze !== null &&
        ((rn = Math.max(rn, ze.start * gt)),
        (qn = Math.min(qn, (ze.start + ze.count) * gt))),
        ut !== null
          ? ((rn = Math.max(rn, 0)), (qn = Math.min(qn, ut.count)))
          : vt != null &&
            ((rn = Math.max(rn, 0)), (qn = Math.min(qn, vt.count)));
      const Yt = qn - rn;
      if (Yt < 0 || Yt === 1 / 0) return;
      j.setup(re, le, lt, oe, ut);
      let zn,
        ct = ht;
      if (
        (ut !== null && ((zn = xe.get(ut)), (ct = et), ct.setIndex(zn)),
        re.isMesh)
      )
        le.wireframe === !0
          ? (me.setLineWidth(le.wireframeLinewidth * We()), ct.setMode(H.LINES))
          : ct.setMode(H.TRIANGLES);
      else if (re.isLine) {
        let je = le.linewidth;
        je === void 0 && (je = 1),
          me.setLineWidth(je * We()),
          re.isLineSegments
            ? ct.setMode(H.LINES)
            : re.isLineLoop
            ? ct.setMode(H.LINE_LOOP)
            : ct.setMode(H.LINE_STRIP);
      } else
        re.isPoints
          ? ct.setMode(H.POINTS)
          : re.isSprite && ct.setMode(H.TRIANGLES);
      if (re.isBatchedMesh)
        ct.renderMultiDraw(
          re._multiDrawStarts,
          re._multiDrawCounts,
          re._multiDrawCount
        );
      else if (re.isInstancedMesh) ct.renderInstances(rn, Yt, re.count);
      else if (oe.isInstancedBufferGeometry) {
        const je =
            oe._maxInstanceCount !== void 0 ? oe._maxInstanceCount : 1 / 0,
          or = Math.min(oe.instanceCount, je);
        ct.renderInstances(rn, Yt, or);
      } else ct.render(rn, Yt);
    };
    function Ct(O, ee, oe) {
      O.transparent === !0 && O.side === rs && O.forceSinglePass === !1
        ? ((O.side = Ti),
          (O.needsUpdate = !0),
          cl(O, ee, oe),
          (O.side = js),
          (O.needsUpdate = !0),
          cl(O, ee, oe),
          (O.side = rs))
        : cl(O, ee, oe);
    }
    (this.compile = function (O, ee, oe = null) {
      oe === null && (oe = O),
        (S = tt.get(oe)),
        S.init(),
        M.push(S),
        oe.traverseVisible(function (re) {
          re.isLight &&
            re.layers.test(ee.layers) &&
            (S.pushLight(re), re.castShadow && S.pushShadow(re));
        }),
        O !== oe &&
          O.traverseVisible(function (re) {
            re.isLight &&
              re.layers.test(ee.layers) &&
              (S.pushLight(re), re.castShadow && S.pushShadow(re));
          }),
        S.setupLights(_._useLegacyLights);
      const le = new Set();
      return (
        O.traverse(function (re) {
          const ze = re.material;
          if (ze)
            if (Array.isArray(ze))
              for (let $e = 0; $e < ze.length; $e++) {
                const lt = ze[$e];
                Ct(lt, oe, re), le.add(lt);
              }
            else Ct(ze, oe, re), le.add(ze);
        }),
        M.pop(),
        (S = null),
        le
      );
    }),
      (this.compileAsync = function (O, ee, oe = null) {
        const le = this.compile(O, ee, oe);
        return new Promise((re) => {
          function ze() {
            if (
              (le.forEach(function ($e) {
                Ne.get($e).currentProgram.isReady() && le.delete($e);
              }),
              le.size === 0)
            ) {
              re(O);
              return;
            }
            setTimeout(ze, 10);
          }
          pe.get("KHR_parallel_shader_compile") !== null
            ? ze()
            : setTimeout(ze, 10);
        });
      });
    let Lt = null;
    function Gt(O) {
      Lt && Lt(O);
    }
    function Jt() {
      Yn.stop();
    }
    function It() {
      Yn.start();
    }
    const Yn = new LL();
    Yn.setAnimationLoop(Gt),
      typeof self < "u" && Yn.setContext(self),
      (this.setAnimationLoop = function (O) {
        (Lt = O), Oe.setAnimationLoop(O), O === null ? Yn.stop() : Yn.start();
      }),
      Oe.addEventListener("sessionstart", Jt),
      Oe.addEventListener("sessionend", It),
      (this.render = function (O, ee) {
        if (ee !== void 0 && ee.isCamera !== !0) {
          console.error(
            "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
          );
          return;
        }
        if (T === !0) return;
        O.matrixWorldAutoUpdate === !0 && O.updateMatrixWorld(),
          ee.parent === null &&
            ee.matrixWorldAutoUpdate === !0 &&
            ee.updateMatrixWorld(),
          Oe.enabled === !0 &&
            Oe.isPresenting === !0 &&
            (Oe.cameraAutoUpdate === !0 && Oe.updateCamera(ee),
            (ee = Oe.getCamera())),
          O.isScene === !0 && O.onBeforeRender(_, O, ee, L),
          (S = tt.get(O, M.length)),
          S.init(),
          M.push(S),
          Pe.multiplyMatrices(ee.projectionMatrix, ee.matrixWorldInverse),
          J.setFromProjectionMatrix(Pe),
          (Ee = this.localClippingEnabled),
          (he = mt.init(this.clippingPlanes, Ee)),
          (w = Fe.get(O, v.length)),
          w.init(),
          v.push(w),
          sr(O, ee, 0, _.sortObjects),
          w.finish(),
          _.sortObjects === !0 && w.sort(k, G),
          this.info.render.frame++,
          he === !0 && mt.beginShadows();
        const oe = S.state.shadowsArray;
        if (
          (_e.render(oe, O, ee),
          he === !0 && mt.endShadows(),
          this.info.autoReset === !0 && this.info.reset(),
          Rt.render(w, O),
          S.setupLights(_._useLegacyLights),
          ee.isArrayCamera)
        ) {
          const le = ee.cameras;
          for (let re = 0, ze = le.length; re < ze; re++) {
            const $e = le[re];
            Zu(w, O, $e, $e.viewport);
          }
        } else Zu(w, O, ee);
        L !== null &&
          (D.updateMultisampleRenderTarget(L), D.updateRenderTargetMipmap(L)),
          O.isScene === !0 && O.onAfterRender(_, O, ee),
          j.resetDefaultState(),
          (N = -1),
          (C = null),
          M.pop(),
          M.length > 0 ? (S = M[M.length - 1]) : (S = null),
          v.pop(),
          v.length > 0 ? (w = v[v.length - 1]) : (w = null);
      });
    function sr(O, ee, oe, le) {
      if (O.visible === !1) return;
      if (O.layers.test(ee.layers)) {
        if (O.isGroup) oe = O.renderOrder;
        else if (O.isLOD) O.autoUpdate === !0 && O.update(ee);
        else if (O.isLight) S.pushLight(O), O.castShadow && S.pushShadow(O);
        else if (O.isSprite) {
          if (!O.frustumCulled || J.intersectsSprite(O)) {
            le && rt.setFromMatrixPosition(O.matrixWorld).applyMatrix4(Pe);
            const $e = ge.update(O),
              lt = O.material;
            lt.visible && w.push(O, $e, lt, oe, rt.z, null);
          }
        } else if (
          (O.isMesh || O.isLine || O.isPoints) &&
          (!O.frustumCulled || J.intersectsObject(O))
        ) {
          const $e = ge.update(O),
            lt = O.material;
          if (
            (le &&
              (O.boundingSphere !== void 0
                ? (O.boundingSphere === null && O.computeBoundingSphere(),
                  rt.copy(O.boundingSphere.center))
                : ($e.boundingSphere === null && $e.computeBoundingSphere(),
                  rt.copy($e.boundingSphere.center)),
              rt.applyMatrix4(O.matrixWorld).applyMatrix4(Pe)),
            Array.isArray(lt))
          ) {
            const ut = $e.groups;
            for (let gt = 0, pt = ut.length; gt < pt; gt++) {
              const vt = ut[gt],
                rn = lt[vt.materialIndex];
              rn && rn.visible && w.push(O, $e, rn, oe, rt.z, vt);
            }
          } else lt.visible && w.push(O, $e, lt, oe, rt.z, null);
        }
      }
      const ze = O.children;
      for (let $e = 0, lt = ze.length; $e < lt; $e++) sr(ze[$e], ee, oe, le);
    }
    function Zu(O, ee, oe, le) {
      const re = O.opaque,
        ze = O.transmissive,
        $e = O.transparent;
      S.setupLightsView(oe),
        he === !0 && mt.setGlobalState(_.clippingPlanes, oe),
        ze.length > 0 && Ku(re, ze, ee, oe),
        le && me.viewport(R.copy(le)),
        re.length > 0 && ul(re, ee, oe),
        ze.length > 0 && ul(ze, ee, oe),
        $e.length > 0 && ul($e, ee, oe),
        me.buffers.depth.setTest(!0),
        me.buffers.depth.setMask(!0),
        me.buffers.color.setMask(!0),
        me.setPolygonOffset(!1);
    }
    function Ku(O, ee, oe, le) {
      if ((oe.isScene === !0 ? oe.overrideMaterial : null) !== null) return;
      const ze = Te.isWebGL2;
      be === null &&
        (be = new Vr(1, 1, {
          generateMipmaps: !0,
          type: pe.has("EXT_color_buffer_half_float") ? Ou : cs,
          minFilter: Wo,
          samples: ze ? 4 : 0,
        })),
        _.getDrawingBufferSize(it),
        ze ? be.setSize(it.x, it.y) : be.setSize(tg(it.x), tg(it.y));
      const $e = _.getRenderTarget();
      _.setRenderTarget(be),
        _.getClearColor(ae),
        (V = _.getClearAlpha()),
        V < 1 && _.setClearColor(16777215, 0.5),
        _.clear();
      const lt = _.toneMapping;
      (_.toneMapping = us),
        ul(O, oe, le),
        D.updateMultisampleRenderTarget(be),
        D.updateRenderTargetMipmap(be);
      let ut = !1;
      for (let gt = 0, pt = ee.length; gt < pt; gt++) {
        const vt = ee[gt],
          rn = vt.object,
          qn = vt.geometry,
          Yt = vt.material,
          zn = vt.group;
        if (Yt.side === rs && rn.layers.test(le.layers)) {
          const ct = Yt.side;
          (Yt.side = Ti),
            (Yt.needsUpdate = !0),
            Ks(rn, oe, le, qn, Yt, zn),
            (Yt.side = ct),
            (Yt.needsUpdate = !0),
            (ut = !0);
        }
      }
      ut === !0 &&
        (D.updateMultisampleRenderTarget(be), D.updateRenderTargetMipmap(be)),
        _.setRenderTarget($e),
        _.setClearColor(ae, V),
        (_.toneMapping = lt);
    }
    function ul(O, ee, oe) {
      const le = ee.isScene === !0 ? ee.overrideMaterial : null;
      for (let re = 0, ze = O.length; re < ze; re++) {
        const $e = O[re],
          lt = $e.object,
          ut = $e.geometry,
          gt = le === null ? $e.material : le,
          pt = $e.group;
        lt.layers.test(oe.layers) && Ks(lt, ee, oe, ut, gt, pt);
      }
    }
    function Ks(O, ee, oe, le, re, ze) {
      O.onBeforeRender(_, ee, oe, le, re, ze),
        O.modelViewMatrix.multiplyMatrices(
          oe.matrixWorldInverse,
          O.matrixWorld
        ),
        O.normalMatrix.getNormalMatrix(O.modelViewMatrix),
        re.onBeforeRender(_, ee, oe, le, O, ze),
        re.transparent === !0 && re.side === rs && re.forceSinglePass === !1
          ? ((re.side = Ti),
            (re.needsUpdate = !0),
            _.renderBufferDirect(oe, ee, le, re, O, ze),
            (re.side = js),
            (re.needsUpdate = !0),
            _.renderBufferDirect(oe, ee, le, re, O, ze),
            (re.side = rs))
          : _.renderBufferDirect(oe, ee, le, re, O, ze),
        O.onAfterRender(_, ee, oe, le, re, ze);
    }
    function cl(O, ee, oe) {
      ee.isScene !== !0 && (ee = Ve);
      const le = Ne.get(O),
        re = S.state.lights,
        ze = S.state.shadowsArray,
        $e = re.state.version,
        lt = Ye.getParameters(O, re.state, ze, ee, oe),
        ut = Ye.getProgramCacheKey(lt);
      let gt = le.programs;
      (le.environment = O.isMeshStandardMaterial ? ee.environment : null),
        (le.fog = ee.fog),
        (le.envMap = (O.isMeshStandardMaterial ? te : I).get(
          O.envMap || le.environment
        )),
        gt === void 0 &&
          (O.addEventListener("dispose", Ie),
          (gt = new Map()),
          (le.programs = gt));
      let pt = gt.get(ut);
      if (pt !== void 0) {
        if (le.currentProgram === pt && le.lightsStateVersion === $e)
          return Rh(O, lt), pt;
      } else
        (lt.uniforms = Ye.getUniforms(O)),
          O.onBuild(oe, lt, _),
          O.onBeforeCompile(lt, _),
          (pt = Ye.acquireProgram(lt, ut)),
          gt.set(ut, pt),
          (le.uniforms = lt.uniforms);
      const vt = le.uniforms;
      return (
        ((!O.isShaderMaterial && !O.isRawShaderMaterial) ||
          O.clipping === !0) &&
          (vt.clippingPlanes = mt.uniform),
        Rh(O, lt),
        (le.needsLights = fv(O)),
        (le.lightsStateVersion = $e),
        le.needsLights &&
          ((vt.ambientLightColor.value = re.state.ambient),
          (vt.lightProbe.value = re.state.probe),
          (vt.directionalLights.value = re.state.directional),
          (vt.directionalLightShadows.value = re.state.directionalShadow),
          (vt.spotLights.value = re.state.spot),
          (vt.spotLightShadows.value = re.state.spotShadow),
          (vt.rectAreaLights.value = re.state.rectArea),
          (vt.ltc_1.value = re.state.rectAreaLTC1),
          (vt.ltc_2.value = re.state.rectAreaLTC2),
          (vt.pointLights.value = re.state.point),
          (vt.pointLightShadows.value = re.state.pointShadow),
          (vt.hemisphereLights.value = re.state.hemi),
          (vt.directionalShadowMap.value = re.state.directionalShadowMap),
          (vt.directionalShadowMatrix.value = re.state.directionalShadowMatrix),
          (vt.spotShadowMap.value = re.state.spotShadowMap),
          (vt.spotLightMatrix.value = re.state.spotLightMatrix),
          (vt.spotLightMap.value = re.state.spotLightMap),
          (vt.pointShadowMap.value = re.state.pointShadowMap),
          (vt.pointShadowMatrix.value = re.state.pointShadowMatrix)),
        (le.currentProgram = pt),
        (le.uniformsList = null),
        pt
      );
    }
    function Ph(O) {
      if (O.uniformsList === null) {
        const ee = O.currentProgram.getUniforms();
        O.uniformsList = dm.seqWithValue(ee.seq, O.uniforms);
      }
      return O.uniformsList;
    }
    function Rh(O, ee) {
      const oe = Ne.get(O);
      (oe.outputColorSpace = ee.outputColorSpace),
        (oe.batching = ee.batching),
        (oe.instancing = ee.instancing),
        (oe.instancingColor = ee.instancingColor),
        (oe.skinning = ee.skinning),
        (oe.morphTargets = ee.morphTargets),
        (oe.morphNormals = ee.morphNormals),
        (oe.morphColors = ee.morphColors),
        (oe.morphTargetsCount = ee.morphTargetsCount),
        (oe.numClippingPlanes = ee.numClippingPlanes),
        (oe.numIntersection = ee.numClipIntersection),
        (oe.vertexAlphas = ee.vertexAlphas),
        (oe.vertexTangents = ee.vertexTangents),
        (oe.toneMapping = ee.toneMapping);
    }
    function uv(O, ee, oe, le, re) {
      ee.isScene !== !0 && (ee = Ve), D.resetTextureUnits();
      const ze = ee.fog,
        $e = le.isMeshStandardMaterial ? ee.environment : null,
        lt =
          L === null
            ? _.outputColorSpace
            : L.isXRRenderTarget === !0
            ? L.texture.colorSpace
            : hs,
        ut = (le.isMeshStandardMaterial ? te : I).get(le.envMap || $e),
        gt =
          le.vertexColors === !0 &&
          !!oe.attributes.color &&
          oe.attributes.color.itemSize === 4,
        pt = !!oe.attributes.tangent && (!!le.normalMap || le.anisotropy > 0),
        vt = !!oe.morphAttributes.position,
        rn = !!oe.morphAttributes.normal,
        qn = !!oe.morphAttributes.color;
      let Yt = us;
      le.toneMapped &&
        (L === null || L.isXRRenderTarget === !0) &&
        (Yt = _.toneMapping);
      const zn =
          oe.morphAttributes.position ||
          oe.morphAttributes.normal ||
          oe.morphAttributes.color,
        ct = zn !== void 0 ? zn.length : 0,
        je = Ne.get(le),
        or = S.state.lights;
      if (he === !0 && (Ee === !0 || O !== C)) {
        const Zn = O === C && le.id === N;
        mt.setState(le, O, Zn);
      }
      let At = !1;
      le.version === je.__version
        ? ((je.needsLights && je.lightsStateVersion !== or.state.version) ||
            je.outputColorSpace !== lt ||
            (re.isBatchedMesh && je.batching === !1) ||
            (!re.isBatchedMesh && je.batching === !0) ||
            (re.isInstancedMesh && je.instancing === !1) ||
            (!re.isInstancedMesh && je.instancing === !0) ||
            (re.isSkinnedMesh && je.skinning === !1) ||
            (!re.isSkinnedMesh && je.skinning === !0) ||
            (re.isInstancedMesh &&
              je.instancingColor === !0 &&
              re.instanceColor === null) ||
            (re.isInstancedMesh &&
              je.instancingColor === !1 &&
              re.instanceColor !== null) ||
            je.envMap !== ut ||
            (le.fog === !0 && je.fog !== ze) ||
            (je.numClippingPlanes !== void 0 &&
              (je.numClippingPlanes !== mt.numPlanes ||
                je.numIntersection !== mt.numIntersection)) ||
            je.vertexAlphas !== gt ||
            je.vertexTangents !== pt ||
            je.morphTargets !== vt ||
            je.morphNormals !== rn ||
            je.morphColors !== qn ||
            je.toneMapping !== Yt ||
            (Te.isWebGL2 === !0 && je.morphTargetsCount !== ct)) &&
          (At = !0)
        : ((At = !0), (je.__version = le.version));
      let dn = je.currentProgram;
      At === !0 && (dn = cl(le, ee, re));
      let jr = !1,
        ar = !1,
        Bn = !1;
      const yn = dn.getUniforms(),
        Xr = je.uniforms;
      if (
        (me.useProgram(dn.program) && ((jr = !0), (ar = !0), (Bn = !0)),
        le.id !== N && ((N = le.id), (ar = !0)),
        jr || C !== O)
      ) {
        yn.setValue(H, "projectionMatrix", O.projectionMatrix),
          yn.setValue(H, "viewMatrix", O.matrixWorldInverse);
        const Zn = yn.map.cameraPosition;
        Zn !== void 0 &&
          Zn.setValue(H, rt.setFromMatrixPosition(O.matrixWorld)),
          Te.logarithmicDepthBuffer &&
            yn.setValue(
              H,
              "logDepthBufFC",
              2 / (Math.log(O.far + 1) / Math.LN2)
            ),
          (le.isMeshPhongMaterial ||
            le.isMeshToonMaterial ||
            le.isMeshLambertMaterial ||
            le.isMeshBasicMaterial ||
            le.isMeshStandardMaterial ||
            le.isShaderMaterial) &&
            yn.setValue(H, "isOrthographic", O.isOrthographicCamera === !0),
          C !== O && ((C = O), (ar = !0), (Bn = !0));
      }
      if (re.isSkinnedMesh) {
        yn.setOptional(H, re, "bindMatrix"),
          yn.setOptional(H, re, "bindMatrixInverse");
        const Zn = re.skeleton;
        Zn &&
          (Te.floatVertexTextures
            ? (Zn.boneTexture === null && Zn.computeBoneTexture(),
              yn.setValue(H, "boneTexture", Zn.boneTexture, D))
            : console.warn(
                "THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."
              ));
      }
      re.isBatchedMesh &&
        (yn.setOptional(H, re, "batchingTexture"),
        yn.setValue(H, "batchingTexture", re._matricesTexture, D));
      const fl = oe.morphAttributes;
      if (
        ((fl.position !== void 0 ||
          fl.normal !== void 0 ||
          (fl.color !== void 0 && Te.isWebGL2 === !0)) &&
          _t.update(re, oe, dn),
        (ar || je.receiveShadow !== re.receiveShadow) &&
          ((je.receiveShadow = re.receiveShadow),
          yn.setValue(H, "receiveShadow", re.receiveShadow)),
        le.isMeshGouraudMaterial &&
          le.envMap !== null &&
          ((Xr.envMap.value = ut),
          (Xr.flipEnvMap.value =
            ut.isCubeTexture && ut.isRenderTargetTexture === !1 ? -1 : 1)),
        ar &&
          (yn.setValue(H, "toneMappingExposure", _.toneMappingExposure),
          je.needsLights && cv(Xr, Bn),
          ze && le.fog === !0 && Le.refreshFogUniforms(Xr, ze),
          Le.refreshMaterialUniforms(Xr, le, ce, $, be),
          dm.upload(H, Ph(je), Xr, D)),
        le.isShaderMaterial &&
          le.uniformsNeedUpdate === !0 &&
          (dm.upload(H, Ph(je), Xr, D), (le.uniformsNeedUpdate = !1)),
        le.isSpriteMaterial && yn.setValue(H, "center", re.center),
        yn.setValue(H, "modelViewMatrix", re.modelViewMatrix),
        yn.setValue(H, "normalMatrix", re.normalMatrix),
        yn.setValue(H, "modelMatrix", re.matrixWorld),
        le.isShaderMaterial || le.isRawShaderMaterial)
      ) {
        const Zn = le.uniformsGroups;
        for (let hl = 0, Gi = Zn.length; hl < Gi; hl++)
          if (Te.isWebGL2) {
            const Lh = Zn[hl];
            ve.update(Lh, dn), ve.bind(Lh, dn);
          } else
            console.warn(
              "THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2."
            );
      }
      return dn;
    }
    function cv(O, ee) {
      (O.ambientLightColor.needsUpdate = ee),
        (O.lightProbe.needsUpdate = ee),
        (O.directionalLights.needsUpdate = ee),
        (O.directionalLightShadows.needsUpdate = ee),
        (O.pointLights.needsUpdate = ee),
        (O.pointLightShadows.needsUpdate = ee),
        (O.spotLights.needsUpdate = ee),
        (O.spotLightShadows.needsUpdate = ee),
        (O.rectAreaLights.needsUpdate = ee),
        (O.hemisphereLights.needsUpdate = ee);
    }
    function fv(O) {
      return (
        O.isMeshLambertMaterial ||
        O.isMeshToonMaterial ||
        O.isMeshPhongMaterial ||
        O.isMeshStandardMaterial ||
        O.isShadowMaterial ||
        (O.isShaderMaterial && O.lights === !0)
      );
    }
    (this.getActiveCubeFace = function () {
      return P;
    }),
      (this.getActiveMipmapLevel = function () {
        return b;
      }),
      (this.getRenderTarget = function () {
        return L;
      }),
      (this.setRenderTargetTextures = function (O, ee, oe) {
        (Ne.get(O.texture).__webglTexture = ee),
          (Ne.get(O.depthTexture).__webglTexture = oe);
        const le = Ne.get(O);
        (le.__hasExternalTextures = !0),
          le.__hasExternalTextures &&
            ((le.__autoAllocateDepthBuffer = oe === void 0),
            le.__autoAllocateDepthBuffer ||
              (pe.has("WEBGL_multisampled_render_to_texture") === !0 &&
                (console.warn(
                  "THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"
                ),
                (le.__useRenderToTexture = !1))));
      }),
      (this.setRenderTargetFramebuffer = function (O, ee) {
        const oe = Ne.get(O);
        (oe.__webglFramebuffer = ee),
          (oe.__useDefaultFramebuffer = ee === void 0);
      }),
      (this.setRenderTarget = function (O, ee = 0, oe = 0) {
        (L = O), (P = ee), (b = oe);
        let le = !0,
          re = null,
          ze = !1,
          $e = !1;
        if (O) {
          const ut = Ne.get(O);
          ut.__useDefaultFramebuffer !== void 0
            ? (me.bindFramebuffer(H.FRAMEBUFFER, null), (le = !1))
            : ut.__webglFramebuffer === void 0
            ? D.setupRenderTarget(O)
            : ut.__hasExternalTextures &&
              D.rebindTextures(
                O,
                Ne.get(O.texture).__webglTexture,
                Ne.get(O.depthTexture).__webglTexture
              );
          const gt = O.texture;
          (gt.isData3DTexture ||
            gt.isDataArrayTexture ||
            gt.isCompressedArrayTexture) &&
            ($e = !0);
          const pt = Ne.get(O).__webglFramebuffer;
          O.isWebGLCubeRenderTarget
            ? (Array.isArray(pt[ee]) ? (re = pt[ee][oe]) : (re = pt[ee]),
              (ze = !0))
            : Te.isWebGL2 && O.samples > 0 && D.useMultisampledRTT(O) === !1
            ? (re = Ne.get(O).__webglMultisampledFramebuffer)
            : Array.isArray(pt)
            ? (re = pt[oe])
            : (re = pt),
            R.copy(O.viewport),
            B.copy(O.scissor),
            (Z = O.scissorTest);
        } else
          R.copy(W).multiplyScalar(ce).floor(),
            B.copy(Y).multiplyScalar(ce).floor(),
            (Z = ie);
        if (
          (me.bindFramebuffer(H.FRAMEBUFFER, re) &&
            Te.drawBuffers &&
            le &&
            me.drawBuffers(O, re),
          me.viewport(R),
          me.scissor(B),
          me.setScissorTest(Z),
          ze)
        ) {
          const ut = Ne.get(O.texture);
          H.framebufferTexture2D(
            H.FRAMEBUFFER,
            H.COLOR_ATTACHMENT0,
            H.TEXTURE_CUBE_MAP_POSITIVE_X + ee,
            ut.__webglTexture,
            oe
          );
        } else if ($e) {
          const ut = Ne.get(O.texture),
            gt = ee || 0;
          H.framebufferTextureLayer(
            H.FRAMEBUFFER,
            H.COLOR_ATTACHMENT0,
            ut.__webglTexture,
            oe || 0,
            gt
          );
        }
        N = -1;
      }),
      (this.readRenderTargetPixels = function (O, ee, oe, le, re, ze, $e) {
        if (!(O && O.isWebGLRenderTarget)) {
          console.error(
            "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
          );
          return;
        }
        let lt = Ne.get(O).__webglFramebuffer;
        if ((O.isWebGLCubeRenderTarget && $e !== void 0 && (lt = lt[$e]), lt)) {
          me.bindFramebuffer(H.FRAMEBUFFER, lt);
          try {
            const ut = O.texture,
              gt = ut.format,
              pt = ut.type;
            if (
              gt !== wi &&
              He.convert(gt) !==
                H.getParameter(H.IMPLEMENTATION_COLOR_READ_FORMAT)
            ) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
              );
              return;
            }
            const vt =
              pt === Ou &&
              (pe.has("EXT_color_buffer_half_float") ||
                (Te.isWebGL2 && pe.has("EXT_color_buffer_float")));
            if (
              pt !== cs &&
              He.convert(pt) !==
                H.getParameter(H.IMPLEMENTATION_COLOR_READ_TYPE) &&
              !(
                pt === Ur &&
                (Te.isWebGL2 ||
                  pe.has("OES_texture_float") ||
                  pe.has("WEBGL_color_buffer_float"))
              ) &&
              !vt
            ) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
              );
              return;
            }
            ee >= 0 &&
              ee <= O.width - le &&
              oe >= 0 &&
              oe <= O.height - re &&
              H.readPixels(ee, oe, le, re, He.convert(gt), He.convert(pt), ze);
          } finally {
            const ut = L !== null ? Ne.get(L).__webglFramebuffer : null;
            me.bindFramebuffer(H.FRAMEBUFFER, ut);
          }
        }
      }),
      (this.copyFramebufferToTexture = function (O, ee, oe = 0) {
        const le = Math.pow(2, -oe),
          re = Math.floor(ee.image.width * le),
          ze = Math.floor(ee.image.height * le);
        D.setTexture2D(ee, 0),
          H.copyTexSubImage2D(H.TEXTURE_2D, oe, 0, 0, O.x, O.y, re, ze),
          me.unbindTexture();
      }),
      (this.copyTextureToTexture = function (O, ee, oe, le = 0) {
        const re = ee.image.width,
          ze = ee.image.height,
          $e = He.convert(oe.format),
          lt = He.convert(oe.type);
        D.setTexture2D(oe, 0),
          H.pixelStorei(H.UNPACK_FLIP_Y_WEBGL, oe.flipY),
          H.pixelStorei(H.UNPACK_PREMULTIPLY_ALPHA_WEBGL, oe.premultiplyAlpha),
          H.pixelStorei(H.UNPACK_ALIGNMENT, oe.unpackAlignment),
          ee.isDataTexture
            ? H.texSubImage2D(
                H.TEXTURE_2D,
                le,
                O.x,
                O.y,
                re,
                ze,
                $e,
                lt,
                ee.image.data
              )
            : ee.isCompressedTexture
            ? H.compressedTexSubImage2D(
                H.TEXTURE_2D,
                le,
                O.x,
                O.y,
                ee.mipmaps[0].width,
                ee.mipmaps[0].height,
                $e,
                ee.mipmaps[0].data
              )
            : H.texSubImage2D(H.TEXTURE_2D, le, O.x, O.y, $e, lt, ee.image),
          le === 0 && oe.generateMipmaps && H.generateMipmap(H.TEXTURE_2D),
          me.unbindTexture();
      }),
      (this.copyTextureToTexture3D = function (O, ee, oe, le, re = 0) {
        if (_.isWebGL1Renderer) {
          console.warn(
            "THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."
          );
          return;
        }
        const ze = O.max.x - O.min.x + 1,
          $e = O.max.y - O.min.y + 1,
          lt = O.max.z - O.min.z + 1,
          ut = He.convert(le.format),
          gt = He.convert(le.type);
        let pt;
        if (le.isData3DTexture) D.setTexture3D(le, 0), (pt = H.TEXTURE_3D);
        else if (le.isDataArrayTexture || le.isCompressedArrayTexture)
          D.setTexture2DArray(le, 0), (pt = H.TEXTURE_2D_ARRAY);
        else {
          console.warn(
            "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."
          );
          return;
        }
        H.pixelStorei(H.UNPACK_FLIP_Y_WEBGL, le.flipY),
          H.pixelStorei(H.UNPACK_PREMULTIPLY_ALPHA_WEBGL, le.premultiplyAlpha),
          H.pixelStorei(H.UNPACK_ALIGNMENT, le.unpackAlignment);
        const vt = H.getParameter(H.UNPACK_ROW_LENGTH),
          rn = H.getParameter(H.UNPACK_IMAGE_HEIGHT),
          qn = H.getParameter(H.UNPACK_SKIP_PIXELS),
          Yt = H.getParameter(H.UNPACK_SKIP_ROWS),
          zn = H.getParameter(H.UNPACK_SKIP_IMAGES),
          ct = oe.isCompressedTexture ? oe.mipmaps[re] : oe.image;
        H.pixelStorei(H.UNPACK_ROW_LENGTH, ct.width),
          H.pixelStorei(H.UNPACK_IMAGE_HEIGHT, ct.height),
          H.pixelStorei(H.UNPACK_SKIP_PIXELS, O.min.x),
          H.pixelStorei(H.UNPACK_SKIP_ROWS, O.min.y),
          H.pixelStorei(H.UNPACK_SKIP_IMAGES, O.min.z),
          oe.isDataTexture || oe.isData3DTexture
            ? H.texSubImage3D(
                pt,
                re,
                ee.x,
                ee.y,
                ee.z,
                ze,
                $e,
                lt,
                ut,
                gt,
                ct.data
              )
            : oe.isCompressedArrayTexture
            ? (console.warn(
                "THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."
              ),
              H.compressedTexSubImage3D(
                pt,
                re,
                ee.x,
                ee.y,
                ee.z,
                ze,
                $e,
                lt,
                ut,
                ct.data
              ))
            : H.texSubImage3D(pt, re, ee.x, ee.y, ee.z, ze, $e, lt, ut, gt, ct),
          H.pixelStorei(H.UNPACK_ROW_LENGTH, vt),
          H.pixelStorei(H.UNPACK_IMAGE_HEIGHT, rn),
          H.pixelStorei(H.UNPACK_SKIP_PIXELS, qn),
          H.pixelStorei(H.UNPACK_SKIP_ROWS, Yt),
          H.pixelStorei(H.UNPACK_SKIP_IMAGES, zn),
          re === 0 && le.generateMipmaps && H.generateMipmap(pt),
          me.unbindTexture();
      }),
      (this.initTexture = function (O) {
        O.isCubeTexture
          ? D.setTextureCube(O, 0)
          : O.isData3DTexture
          ? D.setTexture3D(O, 0)
          : O.isDataArrayTexture || O.isCompressedArrayTexture
          ? D.setTexture2DArray(O, 0)
          : D.setTexture2D(O, 0),
          me.unbindTexture();
      }),
      (this.resetState = function () {
        (P = 0), (b = 0), (L = null), me.reset(), j.reset();
      }),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this })
        );
  }
  get coordinateSystem() {
    return kr;
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(e) {
    this._outputColorSpace = e;
    const t = this.getContext();
    (t.drawingBufferColorSpace = e === Bg ? "display-p3" : "srgb"),
      (t.unpackColorSpace =
        zt.workingColorSpace === vh ? "display-p3" : "srgb");
  }
  get outputEncoding() {
    return (
      console.warn(
        "THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."
      ),
      this.outputColorSpace === Dn ? ko : RS
    );
  }
  set outputEncoding(e) {
    console.warn(
      "THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."
    ),
      (this.outputColorSpace = e === ko ? Dn : hs);
  }
  get useLegacyLights() {
    return (
      console.warn(
        "THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."
      ),
      this._useLegacyLights
    );
  }
  set useLegacyLights(e) {
    console.warn(
      "THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."
    ),
      (this._useLegacyLights = e);
  }
}
class zL extends VS {}
zL.prototype.isWebGL1Renderer = !0;
class Gg {
  constructor(e, t = 25e-5) {
    (this.isFogExp2 = !0),
      (this.name = ""),
      (this.color = new Be(e)),
      (this.density = t);
  }
  clone() {
    return new Gg(this.color, this.density);
  }
  toJSON() {
    return {
      type: "FogExp2",
      name: this.name,
      color: this.color.getHex(),
      density: this.density,
    };
  }
}
class Wg {
  constructor(e, t = 1, i = 1e3) {
    (this.isFog = !0),
      (this.name = ""),
      (this.color = new Be(e)),
      (this.near = t),
      (this.far = i);
  }
  clone() {
    return new Wg(this.color, this.near, this.far);
  }
  toJSON() {
    return {
      type: "Fog",
      name: this.name,
      color: this.color.getHex(),
      near: this.near,
      far: this.far,
    };
  }
}
class HS extends Ft {
  constructor() {
    super(),
      (this.isScene = !0),
      (this.type = "Scene"),
      (this.background = null),
      (this.environment = null),
      (this.fog = null),
      (this.backgroundBlurriness = 0),
      (this.backgroundIntensity = 1),
      (this.overrideMaterial = null),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this })
        );
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.background !== null && (this.background = e.background.clone()),
      e.environment !== null && (this.environment = e.environment.clone()),
      e.fog !== null && (this.fog = e.fog.clone()),
      (this.backgroundBlurriness = e.backgroundBlurriness),
      (this.backgroundIntensity = e.backgroundIntensity),
      e.overrideMaterial !== null &&
        (this.overrideMaterial = e.overrideMaterial.clone()),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      this.fog !== null && (t.object.fog = this.fog.toJSON()),
      this.backgroundBlurriness > 0 &&
        (t.object.backgroundBlurriness = this.backgroundBlurriness),
      this.backgroundIntensity !== 1 &&
        (t.object.backgroundIntensity = this.backgroundIntensity),
      t
    );
  }
}
class jg {
  constructor(e, t) {
    (this.isInterleavedBuffer = !0),
      (this.array = e),
      (this.stride = t),
      (this.count = e !== void 0 ? e.length / t : 0),
      (this.usage = Hf),
      (this._updateRange = { offset: 0, count: -1 }),
      (this.updateRanges = []),
      (this.version = 0),
      (this.uuid = er());
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  get updateRange() {
    return (
      console.warn(
        "THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."
      ),
      this._updateRange
    );
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return (
      (this.array = new e.array.constructor(e.array)),
      (this.count = e.count),
      (this.stride = e.stride),
      (this.usage = e.usage),
      this
    );
  }
  copyAt(e, t, i) {
    (e *= this.stride), (i *= t.stride);
    for (let r = 0, s = this.stride; r < s; r++)
      this.array[e + r] = t.array[i + r];
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = er()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const t = new this.array.constructor(
        e.arrayBuffers[this.array.buffer._uuid]
      ),
      i = new this.constructor(t, this.stride);
    return i.setUsage(this.usage), i;
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  toJSON(e) {
    return (
      e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = er()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = Array.from(
          new Uint32Array(this.array.buffer)
        )),
      {
        uuid: this.uuid,
        buffer: this.array.buffer._uuid,
        type: this.array.constructor.name,
        stride: this.stride,
      }
    );
  }
}
const xi = new U();
class $a {
  constructor(e, t, i, r = !1) {
    (this.isInterleavedBufferAttribute = !0),
      (this.name = ""),
      (this.data = e),
      (this.itemSize = t),
      (this.offset = i),
      (this.normalized = r);
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let t = 0, i = this.data.count; t < i; t++)
      xi.fromBufferAttribute(this, t),
        xi.applyMatrix4(e),
        this.setXYZ(t, xi.x, xi.y, xi.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, i = this.count; t < i; t++)
      xi.fromBufferAttribute(this, t),
        xi.applyNormalMatrix(e),
        this.setXYZ(t, xi.x, xi.y, xi.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, i = this.count; t < i; t++)
      xi.fromBufferAttribute(this, t),
        xi.transformDirection(e),
        this.setXYZ(t, xi.x, xi.y, xi.z);
    return this;
  }
  setX(e, t) {
    return (
      this.normalized && (t = Mt(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset] = t),
      this
    );
  }
  setY(e, t) {
    return (
      this.normalized && (t = Mt(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 1] = t),
      this
    );
  }
  setZ(e, t) {
    return (
      this.normalized && (t = Mt(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 2] = t),
      this
    );
  }
  setW(e, t) {
    return (
      this.normalized && (t = Mt(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 3] = t),
      this
    );
  }
  getX(e) {
    let t = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (t = Ui(t, this.array)), t;
  }
  getY(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (t = Ui(t, this.array)), t;
  }
  getZ(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (t = Ui(t, this.array)), t;
  }
  getW(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (t = Ui(t, this.array)), t;
  }
  setXY(e, t, i) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized && ((t = Mt(t, this.array)), (i = Mt(i, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = i),
      this
    );
  }
  setXYZ(e, t, i, r) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((t = Mt(t, this.array)),
        (i = Mt(i, this.array)),
        (r = Mt(r, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = i),
      (this.data.array[e + 2] = r),
      this
    );
  }
  setXYZW(e, t, i, r, s) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((t = Mt(t, this.array)),
        (i = Mt(i, this.array)),
        (r = Mt(r, this.array)),
        (s = Mt(s, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = i),
      (this.data.array[e + 2] = r),
      (this.data.array[e + 3] = s),
      this
    );
  }
  clone(e) {
    if (e === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data."
      );
      const t = [];
      for (let i = 0; i < this.count; i++) {
        const r = i * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[r + s]);
      }
      return new Ht(
        new this.array.constructor(t),
        this.itemSize,
        this.normalized
      );
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
        new $a(
          e.interleavedBuffers[this.data.uuid],
          this.itemSize,
          this.offset,
          this.normalized
        )
      );
  }
  toJSON(e) {
    if (e === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data."
      );
      const t = [];
      for (let i = 0; i < this.count; i++) {
        const r = i * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[r + s]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: t,
        normalized: this.normalized,
      };
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
        {
          isInterleavedBufferAttribute: !0,
          itemSize: this.itemSize,
          data: this.data.uuid,
          offset: this.offset,
          normalized: this.normalized,
        }
      );
  }
}
class GS extends gi {
  constructor(e) {
    super(),
      (this.isSpriteMaterial = !0),
      (this.type = "SpriteMaterial"),
      (this.color = new Be(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.rotation = 0),
      (this.sizeAttenuation = !0),
      (this.transparent = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.rotation = e.rotation),
      (this.sizeAttenuation = e.sizeAttenuation),
      (this.fog = e.fog),
      this
    );
  }
}
let Vl;
const Rc = new U(),
  Hl = new U(),
  Gl = new U(),
  Wl = new de(),
  Lc = new de(),
  BL = new dt(),
  xp = new U(),
  Ic = new U(),
  _p = new U(),
  lA = new de(),
  Cy = new de(),
  uA = new de();
class VL extends Ft {
  constructor(e = new GS()) {
    if (
      (super(), (this.isSprite = !0), (this.type = "Sprite"), Vl === void 0)
    ) {
      Vl = new Tt();
      const t = new Float32Array([
          -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5,
          0, 0, 1,
        ]),
        i = new jg(t, 5);
      Vl.setIndex([0, 1, 2, 0, 2, 3]),
        Vl.setAttribute("position", new $a(i, 3, 0, !1)),
        Vl.setAttribute("uv", new $a(i, 2, 3, !1));
    }
    (this.geometry = Vl), (this.material = e), (this.center = new de(0.5, 0.5));
  }
  raycast(e, t) {
    e.camera === null &&
      console.error(
        'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'
      ),
      Hl.setFromMatrixScale(this.matrixWorld),
      BL.copy(e.camera.matrixWorld),
      this.modelViewMatrix.multiplyMatrices(
        e.camera.matrixWorldInverse,
        this.matrixWorld
      ),
      Gl.setFromMatrixPosition(this.modelViewMatrix),
      e.camera.isPerspectiveCamera &&
        this.material.sizeAttenuation === !1 &&
        Hl.multiplyScalar(-Gl.z);
    const i = this.material.rotation;
    let r, s;
    i !== 0 && ((s = Math.cos(i)), (r = Math.sin(i)));
    const o = this.center;
    Sp(xp.set(-0.5, -0.5, 0), Gl, o, Hl, r, s),
      Sp(Ic.set(0.5, -0.5, 0), Gl, o, Hl, r, s),
      Sp(_p.set(0.5, 0.5, 0), Gl, o, Hl, r, s),
      lA.set(0, 0),
      Cy.set(1, 0),
      uA.set(1, 1);
    let a = e.ray.intersectTriangle(xp, Ic, _p, !1, Rc);
    if (
      a === null &&
      (Sp(Ic.set(-0.5, 0.5, 0), Gl, o, Hl, r, s),
      Cy.set(0, 1),
      (a = e.ray.intersectTriangle(xp, _p, Ic, !1, Rc)),
      a === null)
    )
      return;
    const u = e.ray.origin.distanceTo(Rc);
    u < e.near ||
      u > e.far ||
      t.push({
        distance: u,
        point: Rc.clone(),
        uv: Oi.getInterpolation(Rc, xp, Ic, _p, lA, Cy, uA, new de()),
        face: null,
        object: this,
      });
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.center !== void 0 && this.center.copy(e.center),
      (this.material = e.material),
      this
    );
  }
}
function Sp(n, e, t, i, r, s) {
  Wl.subVectors(n, t).addScalar(0.5).multiply(i),
    r !== void 0
      ? ((Lc.x = s * Wl.x - r * Wl.y), (Lc.y = r * Wl.x + s * Wl.y))
      : Lc.copy(Wl),
    n.copy(e),
    (n.x += Lc.x),
    (n.y += Lc.y),
    n.applyMatrix4(BL);
}
const Mp = new U(),
  cA = new U();
class HL extends Ft {
  constructor() {
    super(),
      (this._currentLevel = 0),
      (this.type = "LOD"),
      Object.defineProperties(this, {
        levels: { enumerable: !0, value: [] },
        isLOD: { value: !0 },
      }),
      (this.autoUpdate = !0);
  }
  copy(e) {
    super.copy(e, !1);
    const t = e.levels;
    for (let i = 0, r = t.length; i < r; i++) {
      const s = t[i];
      this.addLevel(s.object.clone(), s.distance, s.hysteresis);
    }
    return (this.autoUpdate = e.autoUpdate), this;
  }
  addLevel(e, t = 0, i = 0) {
    t = Math.abs(t);
    const r = this.levels;
    let s;
    for (s = 0; s < r.length && !(t < r[s].distance); s++);
    return (
      r.splice(s, 0, { distance: t, hysteresis: i, object: e }),
      this.add(e),
      this
    );
  }
  getCurrentLevel() {
    return this._currentLevel;
  }
  getObjectForDistance(e) {
    const t = this.levels;
    if (t.length > 0) {
      let i, r;
      for (i = 1, r = t.length; i < r; i++) {
        let s = t[i].distance;
        if ((t[i].object.visible && (s -= s * t[i].hysteresis), e < s)) break;
      }
      return t[i - 1].object;
    }
    return null;
  }
  raycast(e, t) {
    if (this.levels.length > 0) {
      Mp.setFromMatrixPosition(this.matrixWorld);
      const r = e.ray.origin.distanceTo(Mp);
      this.getObjectForDistance(r).raycast(e, t);
    }
  }
  update(e) {
    const t = this.levels;
    if (t.length > 1) {
      Mp.setFromMatrixPosition(e.matrixWorld),
        cA.setFromMatrixPosition(this.matrixWorld);
      const i = Mp.distanceTo(cA) / e.zoom;
      t[0].object.visible = !0;
      let r, s;
      for (r = 1, s = t.length; r < s; r++) {
        let o = t[r].distance;
        if ((t[r].object.visible && (o -= o * t[r].hysteresis), i >= o))
          (t[r - 1].object.visible = !1), (t[r].object.visible = !0);
        else break;
      }
      for (this._currentLevel = r - 1; r < s; r++) t[r].object.visible = !1;
    }
  }
  toJSON(e) {
    const t = super.toJSON(e);
    this.autoUpdate === !1 && (t.object.autoUpdate = !1),
      (t.object.levels = []);
    const i = this.levels;
    for (let r = 0, s = i.length; r < s; r++) {
      const o = i[r];
      t.object.levels.push({
        object: o.object.uuid,
        distance: o.distance,
        hysteresis: o.hysteresis,
      });
    }
    return t;
  }
}
const fA = new U(),
  hA = new Bt(),
  dA = new Bt(),
  Y9 = new U(),
  pA = new dt(),
  wp = new U(),
  Py = new di(),
  mA = new dt(),
  Ry = new rl();
class GL extends Un {
  constructor(e, t) {
    super(e, t),
      (this.isSkinnedMesh = !0),
      (this.type = "SkinnedMesh"),
      (this.bindMode = u_),
      (this.bindMatrix = new dt()),
      (this.bindMatrixInverse = new dt()),
      (this.boundingBox = null),
      (this.boundingSphere = null);
  }
  computeBoundingBox() {
    const e = this.geometry;
    this.boundingBox === null && (this.boundingBox = new Ai()),
      this.boundingBox.makeEmpty();
    const t = e.getAttribute("position");
    for (let i = 0; i < t.count; i++)
      this.getVertexPosition(i, wp), this.boundingBox.expandByPoint(wp);
  }
  computeBoundingSphere() {
    const e = this.geometry;
    this.boundingSphere === null && (this.boundingSphere = new di()),
      this.boundingSphere.makeEmpty();
    const t = e.getAttribute("position");
    for (let i = 0; i < t.count; i++)
      this.getVertexPosition(i, wp), this.boundingSphere.expandByPoint(wp);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.bindMode = e.bindMode),
      this.bindMatrix.copy(e.bindMatrix),
      this.bindMatrixInverse.copy(e.bindMatrixInverse),
      (this.skeleton = e.skeleton),
      e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
      e.boundingSphere !== null &&
        (this.boundingSphere = e.boundingSphere.clone()),
      this
    );
  }
  raycast(e, t) {
    const i = this.material,
      r = this.matrixWorld;
    i !== void 0 &&
      (this.boundingSphere === null && this.computeBoundingSphere(),
      Py.copy(this.boundingSphere),
      Py.applyMatrix4(r),
      e.ray.intersectsSphere(Py) !== !1 &&
        (mA.copy(r).invert(),
        Ry.copy(e.ray).applyMatrix4(mA),
        !(
          this.boundingBox !== null && Ry.intersectsBox(this.boundingBox) === !1
        ) && this._computeIntersections(e, t, Ry)));
  }
  getVertexPosition(e, t) {
    return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t;
  }
  bind(e, t) {
    (this.skeleton = e),
      t === void 0 &&
        (this.updateMatrixWorld(!0),
        this.skeleton.calculateInverses(),
        (t = this.matrixWorld)),
      this.bindMatrix.copy(t),
      this.bindMatrixInverse.copy(t).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const e = new Bt(),
      t = this.geometry.attributes.skinWeight;
    for (let i = 0, r = t.count; i < r; i++) {
      e.fromBufferAttribute(t, i);
      const s = 1 / e.manhattanLength();
      s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0),
        t.setXYZW(i, e.x, e.y, e.z, e.w);
    }
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.bindMode === u_
        ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
        : this.bindMode === eL
        ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
        : console.warn(
            "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
          );
  }
  applyBoneTransform(e, t) {
    const i = this.skeleton,
      r = this.geometry;
    hA.fromBufferAttribute(r.attributes.skinIndex, e),
      dA.fromBufferAttribute(r.attributes.skinWeight, e),
      fA.copy(t).applyMatrix4(this.bindMatrix),
      t.set(0, 0, 0);
    for (let s = 0; s < 4; s++) {
      const o = dA.getComponent(s);
      if (o !== 0) {
        const a = hA.getComponent(s);
        pA.multiplyMatrices(i.bones[a].matrixWorld, i.boneInverses[a]),
          t.addScaledVector(Y9.copy(fA).applyMatrix4(pA), o);
      }
    }
    return t.applyMatrix4(this.bindMatrixInverse);
  }
  boneTransform(e, t) {
    return (
      console.warn(
        "THREE.SkinnedMesh: .boneTransform() was renamed to .applyBoneTransform() in r151."
      ),
      this.applyBoneTransform(e, t)
    );
  }
}
class WS extends Ft {
  constructor() {
    super(), (this.isBone = !0), (this.type = "Bone");
  }
}
class Wa extends An {
  constructor(e = null, t = 1, i = 1, r, s, o, a, u, f = Sn, h = Sn, d, p) {
    super(null, o, a, u, f, h, r, s, d, p),
      (this.isDataTexture = !0),
      (this.image = { data: e, width: t, height: i }),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
const gA = new dt(),
  q9 = new dt();
class Xg {
  constructor(e = [], t = []) {
    (this.uuid = er()),
      (this.bones = e.slice(0)),
      (this.boneInverses = t),
      (this.boneMatrices = null),
      (this.boneTexture = null),
      this.init();
  }
  init() {
    const e = this.bones,
      t = this.boneInverses;
    if (((this.boneMatrices = new Float32Array(e.length * 16)), t.length === 0))
      this.calculateInverses();
    else if (e.length !== t.length) {
      console.warn(
        "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."
      ),
        (this.boneInverses = []);
      for (let i = 0, r = this.bones.length; i < r; i++)
        this.boneInverses.push(new dt());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = new dt();
      this.bones[e] && i.copy(this.bones[e].matrixWorld).invert(),
        this.boneInverses.push(i);
    }
  }
  pose() {
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = this.bones[e];
      i && i.matrixWorld.copy(this.boneInverses[e]).invert();
    }
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = this.bones[e];
      i &&
        (i.parent && i.parent.isBone
          ? (i.matrix.copy(i.parent.matrixWorld).invert(),
            i.matrix.multiply(i.matrixWorld))
          : i.matrix.copy(i.matrixWorld),
        i.matrix.decompose(i.position, i.quaternion, i.scale));
    }
  }
  update() {
    const e = this.bones,
      t = this.boneInverses,
      i = this.boneMatrices,
      r = this.boneTexture;
    for (let s = 0, o = e.length; s < o; s++) {
      const a = e[s] ? e[s].matrixWorld : q9;
      gA.multiplyMatrices(a, t[s]), gA.toArray(i, s * 16);
    }
    r !== null && (r.needsUpdate = !0);
  }
  clone() {
    return new Xg(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let e = Math.sqrt(this.bones.length * 4);
    (e = Math.ceil(e / 4) * 4), (e = Math.max(e, 4));
    const t = new Float32Array(e * e * 4);
    t.set(this.boneMatrices);
    const i = new Wa(t, e, e, wi, Ur);
    return (
      (i.needsUpdate = !0),
      (this.boneMatrices = t),
      (this.boneTexture = i),
      this
    );
  }
  getBoneByName(e) {
    for (let t = 0, i = this.bones.length; t < i; t++) {
      const r = this.bones[t];
      if (r.name === e) return r;
    }
  }
  dispose() {
    this.boneTexture !== null &&
      (this.boneTexture.dispose(), (this.boneTexture = null));
  }
  fromJSON(e, t) {
    this.uuid = e.uuid;
    for (let i = 0, r = e.bones.length; i < r; i++) {
      const s = e.bones[i];
      let o = t[s];
      o === void 0 &&
        (console.warn("THREE.Skeleton: No bone found with UUID:", s),
        (o = new WS())),
        this.bones.push(o),
        this.boneInverses.push(new dt().fromArray(e.boneInverses[i]));
    }
    return this.init(), this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "Skeleton",
        generator: "Skeleton.toJSON",
      },
      bones: [],
      boneInverses: [],
    };
    e.uuid = this.uuid;
    const t = this.bones,
      i = this.boneInverses;
    for (let r = 0, s = t.length; r < s; r++) {
      const o = t[r];
      e.bones.push(o.uuid);
      const a = i[r];
      e.boneInverses.push(a.toArray());
    }
    return e;
  }
}
class zu extends Ht {
  constructor(e, t, i, r = 1) {
    super(e, t, i),
      (this.isInstancedBufferAttribute = !0),
      (this.meshPerAttribute = r);
  }
  copy(e) {
    return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.meshPerAttribute = this.meshPerAttribute),
      (e.isInstancedBufferAttribute = !0),
      e
    );
  }
}
const jl = new dt(),
  vA = new dt(),
  Ep = [],
  yA = new Ai(),
  Z9 = new dt(),
  Nc = new Un(),
  Dc = new di();
class WL extends Un {
  constructor(e, t, i) {
    super(e, t),
      (this.isInstancedMesh = !0),
      (this.instanceMatrix = new zu(new Float32Array(i * 16), 16)),
      (this.instanceColor = null),
      (this.count = i),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    for (let r = 0; r < i; r++) this.setMatrixAt(r, Z9);
  }
  computeBoundingBox() {
    const e = this.geometry,
      t = this.count;
    this.boundingBox === null && (this.boundingBox = new Ai()),
      e.boundingBox === null && e.computeBoundingBox(),
      this.boundingBox.makeEmpty();
    for (let i = 0; i < t; i++)
      this.getMatrixAt(i, jl),
        yA.copy(e.boundingBox).applyMatrix4(jl),
        this.boundingBox.union(yA);
  }
  computeBoundingSphere() {
    const e = this.geometry,
      t = this.count;
    this.boundingSphere === null && (this.boundingSphere = new di()),
      e.boundingSphere === null && e.computeBoundingSphere(),
      this.boundingSphere.makeEmpty();
    for (let i = 0; i < t; i++)
      this.getMatrixAt(i, jl),
        Dc.copy(e.boundingSphere).applyMatrix4(jl),
        this.boundingSphere.union(Dc);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.instanceMatrix.copy(e.instanceMatrix),
      e.instanceColor !== null &&
        (this.instanceColor = e.instanceColor.clone()),
      (this.count = e.count),
      e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
      e.boundingSphere !== null &&
        (this.boundingSphere = e.boundingSphere.clone()),
      this
    );
  }
  getColorAt(e, t) {
    t.fromArray(this.instanceColor.array, e * 3);
  }
  getMatrixAt(e, t) {
    t.fromArray(this.instanceMatrix.array, e * 16);
  }
  raycast(e, t) {
    const i = this.matrixWorld,
      r = this.count;
    if (
      ((Nc.geometry = this.geometry),
      (Nc.material = this.material),
      Nc.material !== void 0 &&
        (this.boundingSphere === null && this.computeBoundingSphere(),
        Dc.copy(this.boundingSphere),
        Dc.applyMatrix4(i),
        e.ray.intersectsSphere(Dc) !== !1))
    )
      for (let s = 0; s < r; s++) {
        this.getMatrixAt(s, jl),
          vA.multiplyMatrices(i, jl),
          (Nc.matrixWorld = vA),
          Nc.raycast(e, Ep);
        for (let o = 0, a = Ep.length; o < a; o++) {
          const u = Ep[o];
          (u.instanceId = s), (u.object = this), t.push(u);
        }
        Ep.length = 0;
      }
  }
  setColorAt(e, t) {
    this.instanceColor === null &&
      (this.instanceColor = new zu(
        new Float32Array(this.instanceMatrix.count * 3),
        3
      )),
      t.toArray(this.instanceColor.array, e * 3);
  }
  setMatrixAt(e, t) {
    t.toArray(this.instanceMatrix.array, e * 16);
  }
  updateMorphTargets() {}
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
function K9(n, e) {
  return n.z - e.z;
}
function Q9(n, e) {
  return e.z - n.z;
}
class $9 {
  constructor() {
    (this.index = 0), (this.pool = []), (this.list = []);
  }
  push(e, t) {
    const i = this.pool,
      r = this.list;
    this.index >= i.length && i.push({ start: -1, count: -1, z: -1 });
    const s = i[this.index];
    r.push(s),
      this.index++,
      (s.start = e.start),
      (s.count = e.count),
      (s.z = t);
  }
  reset() {
    (this.list.length = 0), (this.index = 0);
  }
}
const Xl = "batchId",
  po = new dt(),
  xA = new dt(),
  J9 = new dt(),
  _A = new dt(),
  Ly = new Sh(),
  Tp = new Ai(),
  ma = new di(),
  Oc = new U(),
  Iy = new $9(),
  li = new Un(),
  Ap = [];
function e7(n, e, t = 0) {
  const i = e.itemSize;
  if (
    n.isInterleavedBufferAttribute ||
    n.array.constructor !== e.array.constructor
  ) {
    const r = n.count;
    for (let s = 0; s < r; s++)
      for (let o = 0; o < i; o++)
        e.setComponent(s + t, o, n.getComponent(s, o));
  } else e.array.set(n.array, t * i);
  e.needsUpdate = !0;
}
class jL extends Un {
  get maxGeometryCount() {
    return this._maxGeometryCount;
  }
  constructor(e, t, i = t * 2, r) {
    super(new Tt(), r),
      (this.isBatchedMesh = !0),
      (this.perObjectFrustumCulled = !0),
      (this.sortObjects = !0),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.customSort = null),
      (this._drawRanges = []),
      (this._reservedRanges = []),
      (this._visibility = []),
      (this._active = []),
      (this._bounds = []),
      (this._maxGeometryCount = e),
      (this._maxVertexCount = t),
      (this._maxIndexCount = i),
      (this._geometryInitialized = !1),
      (this._geometryCount = 0),
      (this._multiDrawCounts = new Int32Array(e)),
      (this._multiDrawStarts = new Int32Array(e)),
      (this._multiDrawCount = 0),
      (this._visibilityChanged = !0),
      (this._matricesTexture = null),
      this._initMatricesTexture();
  }
  _initMatricesTexture() {
    let e = Math.sqrt(this._maxGeometryCount * 4);
    (e = Math.ceil(e / 4) * 4), (e = Math.max(e, 4));
    const t = new Float32Array(e * e * 4),
      i = new Wa(t, e, e, wi, Ur);
    this._matricesTexture = i;
  }
  _initializeGeometry(e) {
    const t = this.geometry,
      i = this._maxVertexCount,
      r = this._maxGeometryCount,
      s = this._maxIndexCount;
    if (this._geometryInitialized === !1) {
      for (const a in e.attributes) {
        const u = e.getAttribute(a),
          { array: f, itemSize: h, normalized: d } = u,
          p = new f.constructor(i * h),
          m = new u.constructor(p, h, d);
        m.setUsage(u.usage), t.setAttribute(a, m);
      }
      if (e.getIndex() !== null) {
        const a = i > 65536 ? new Uint32Array(s) : new Uint16Array(s);
        t.setIndex(new Ht(a, 1));
      }
      const o = r > 65536 ? new Uint32Array(i) : new Uint16Array(i);
      t.setAttribute(Xl, new Ht(o, 1)), (this._geometryInitialized = !0);
    }
  }
  _validateGeometry(e) {
    if (e.getAttribute(Xl))
      throw new Error(`BatchedMesh: Geometry cannot use attribute "${Xl}"`);
    const t = this.geometry;
    if (!!e.getIndex() != !!t.getIndex())
      throw new Error(
        'BatchedMesh: All geometries must consistently have "index".'
      );
    for (const i in t.attributes) {
      if (i === Xl) continue;
      if (!e.hasAttribute(i))
        throw new Error(
          `BatchedMesh: Added geometry missing "${i}". All geometries must have consistent attributes.`
        );
      const r = e.getAttribute(i),
        s = t.getAttribute(i);
      if (r.itemSize !== s.itemSize || r.normalized !== s.normalized)
        throw new Error(
          "BatchedMesh: All attributes must have a consistent itemSize and normalized value."
        );
    }
  }
  setCustomSort(e) {
    return (this.customSort = e), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Ai());
    const e = this._geometryCount,
      t = this.boundingBox,
      i = this._active;
    t.makeEmpty();
    for (let r = 0; r < e; r++)
      i[r] !== !1 &&
        (this.getMatrixAt(r, po),
        this.getBoundingBoxAt(r, Tp).applyMatrix4(po),
        t.union(Tp));
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new di());
    const e = this._geometryCount,
      t = this.boundingSphere,
      i = this._active;
    t.makeEmpty();
    for (let r = 0; r < e; r++)
      i[r] !== !1 &&
        (this.getMatrixAt(r, po),
        this.getBoundingSphereAt(r, ma).applyMatrix4(po),
        t.union(ma));
  }
  addGeometry(e, t = -1, i = -1) {
    if (
      (this._initializeGeometry(e),
      this._validateGeometry(e),
      this._geometryCount >= this._maxGeometryCount)
    )
      throw new Error("BatchedMesh: Maximum geometry count reached.");
    const r = {
      vertexStart: -1,
      vertexCount: -1,
      indexStart: -1,
      indexCount: -1,
    };
    let s = null;
    const o = this._reservedRanges,
      a = this._drawRanges,
      u = this._bounds;
    this._geometryCount !== 0 && (s = o[o.length - 1]),
      t === -1
        ? (r.vertexCount = e.getAttribute("position").count)
        : (r.vertexCount = t),
      s === null
        ? (r.vertexStart = 0)
        : (r.vertexStart = s.vertexStart + s.vertexCount);
    const f = e.getIndex(),
      h = f !== null;
    if (
      (h &&
        (i === -1 ? (r.indexCount = f.count) : (r.indexCount = i),
        s === null
          ? (r.indexStart = 0)
          : (r.indexStart = s.indexStart + s.indexCount)),
      (r.indexStart !== -1 &&
        r.indexStart + r.indexCount > this._maxIndexCount) ||
        r.vertexStart + r.vertexCount > this._maxVertexCount)
    )
      throw new Error(
        "BatchedMesh: Reserved space request exceeds the maximum buffer size."
      );
    const d = this._visibility,
      p = this._active,
      m = this._matricesTexture,
      y = this._matricesTexture.image.data;
    d.push(!0), p.push(!0);
    const w = this._geometryCount;
    this._geometryCount++,
      J9.toArray(y, w * 16),
      (m.needsUpdate = !0),
      o.push(r),
      a.push({ start: h ? r.indexStart : r.vertexStart, count: -1 }),
      u.push({
        boxInitialized: !1,
        box: new Ai(),
        sphereInitialized: !1,
        sphere: new di(),
      });
    const S = this.geometry.getAttribute(Xl);
    for (let v = 0; v < r.vertexCount; v++) S.setX(r.vertexStart + v, w);
    return (S.needsUpdate = !0), this.setGeometryAt(w, e), w;
  }
  setGeometryAt(e, t) {
    if (e >= this._geometryCount)
      throw new Error("BatchedMesh: Maximum geometry count reached.");
    this._validateGeometry(t);
    const i = this.geometry,
      r = i.getIndex() !== null,
      s = i.getIndex(),
      o = t.getIndex(),
      a = this._reservedRanges[e];
    if (
      (r && o.count > a.indexCount) ||
      t.attributes.position.count > a.vertexCount
    )
      throw new Error(
        "BatchedMesh: Reserved space not large enough for provided geometry."
      );
    const u = a.vertexStart,
      f = a.vertexCount;
    for (const m in i.attributes) {
      if (m === Xl) continue;
      const y = t.getAttribute(m),
        w = i.getAttribute(m);
      e7(y, w, u);
      const S = y.itemSize;
      for (let v = y.count, M = f; v < M; v++) {
        const _ = u + v;
        for (let T = 0; T < S; T++) w.setComponent(_, T, 0);
      }
      w.needsUpdate = !0;
    }
    if (r) {
      const m = a.indexStart;
      for (let y = 0; y < o.count; y++) s.setX(m + y, u + o.getX(y));
      for (let y = o.count, w = a.indexCount; y < w; y++) s.setX(m + y, u);
      s.needsUpdate = !0;
    }
    const h = this._bounds[e];
    t.boundingBox !== null
      ? (h.box.copy(t.boundingBox), (h.boxInitialized = !0))
      : (h.boxInitialized = !1),
      t.boundingSphere !== null
        ? (h.sphere.copy(t.boundingSphere), (h.sphereInitialized = !0))
        : (h.sphereInitialized = !1);
    const d = this._drawRanges[e],
      p = t.getAttribute("position");
    return (d.count = r ? o.count : p.count), (this._visibilityChanged = !0), e;
  }
  deleteGeometry(e) {
    const t = this._active;
    return e >= t.length || t[e] === !1
      ? this
      : ((t[e] = !1), (this._visibilityChanged = !0), this);
  }
  getBoundingBoxAt(e, t) {
    if (this._active[e] === !1) return this;
    const r = this._bounds[e],
      s = r.box,
      o = this.geometry;
    if (r.boxInitialized === !1) {
      s.makeEmpty();
      const a = o.index,
        u = o.attributes.position,
        f = this._drawRanges[e];
      for (let h = f.start, d = f.start + f.count; h < d; h++) {
        let p = h;
        a && (p = a.getX(p)), s.expandByPoint(Oc.fromBufferAttribute(u, p));
      }
      r.boxInitialized = !0;
    }
    return t.copy(s), t;
  }
  getBoundingSphereAt(e, t) {
    if (this._active[e] === !1) return this;
    const r = this._bounds[e],
      s = r.sphere,
      o = this.geometry;
    if (r.sphereInitialized === !1) {
      s.makeEmpty(), this.getBoundingBoxAt(e, Tp), Tp.getCenter(s.center);
      const a = o.index,
        u = o.attributes.position,
        f = this._drawRanges[e];
      let h = 0;
      for (let d = f.start, p = f.start + f.count; d < p; d++) {
        let m = d;
        a && (m = a.getX(m)),
          Oc.fromBufferAttribute(u, m),
          (h = Math.max(h, s.center.distanceToSquared(Oc)));
      }
      (s.radius = Math.sqrt(h)), (r.sphereInitialized = !0);
    }
    return t.copy(s), t;
  }
  setMatrixAt(e, t) {
    const i = this._active,
      r = this._matricesTexture,
      s = this._matricesTexture.image.data,
      o = this._geometryCount;
    return e >= o || i[e] === !1
      ? this
      : (t.toArray(s, e * 16), (r.needsUpdate = !0), this);
  }
  getMatrixAt(e, t) {
    const i = this._active,
      r = this._matricesTexture.image.data,
      s = this._geometryCount;
    return e >= s || i[e] === !1 ? null : t.fromArray(r, e * 16);
  }
  setVisibleAt(e, t) {
    const i = this._visibility,
      r = this._active,
      s = this._geometryCount;
    return e >= s || r[e] === !1 || i[e] === t
      ? this
      : ((i[e] = t), (this._visibilityChanged = !0), this);
  }
  getVisibleAt(e) {
    const t = this._visibility,
      i = this._active,
      r = this._geometryCount;
    return e >= r || i[e] === !1 ? !1 : t[e];
  }
  raycast(e, t) {
    const i = this._visibility,
      r = this._active,
      s = this._drawRanges,
      o = this._geometryCount,
      a = this.matrixWorld,
      u = this.geometry;
    (li.material = this.material),
      (li.geometry.index = u.index),
      (li.geometry.attributes = u.attributes),
      li.geometry.boundingBox === null && (li.geometry.boundingBox = new Ai()),
      li.geometry.boundingSphere === null &&
        (li.geometry.boundingSphere = new di());
    for (let f = 0; f < o; f++) {
      if (!i[f] || !r[f]) continue;
      const h = s[f];
      li.geometry.setDrawRange(h.start, h.count),
        this.getMatrixAt(f, li.matrixWorld).premultiply(a),
        this.getBoundingBoxAt(f, li.geometry.boundingBox),
        this.getBoundingSphereAt(f, li.geometry.boundingSphere),
        li.raycast(e, Ap);
      for (let d = 0, p = Ap.length; d < p; d++) {
        const m = Ap[d];
        (m.object = this), (m.batchId = f), t.push(m);
      }
      Ap.length = 0;
    }
    (li.material = null),
      (li.geometry.index = null),
      (li.geometry.attributes = {}),
      li.geometry.setDrawRange(0, 1 / 0);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.geometry = e.geometry.clone()),
      (this.perObjectFrustumCulled = e.perObjectFrustumCulled),
      (this.sortObjects = e.sortObjects),
      (this.boundingBox =
        e.boundingBox !== null ? e.boundingBox.clone() : null),
      (this.boundingSphere =
        e.boundingSphere !== null ? e.boundingSphere.clone() : null),
      (this._drawRanges = e._drawRanges.map((t) => ({ ...t }))),
      (this._reservedRanges = e._reservedRanges.map((t) => ({ ...t }))),
      (this._visibility = e._visibility.slice()),
      (this._active = e._active.slice()),
      (this._bounds = e._bounds.map((t) => ({
        boxInitialized: t.boxInitialized,
        box: t.box.clone(),
        sphereInitialized: t.sphereInitialized,
        sphere: t.sphere.clone(),
      }))),
      (this._maxGeometryCount = e._maxGeometryCount),
      (this._maxVertexCount = e._maxVertexCount),
      (this._maxIndexCount = e._maxIndexCount),
      (this._geometryInitialized = e._geometryInitialized),
      (this._geometryCount = e._geometryCount),
      (this._multiDrawCounts = e._multiDrawCounts.slice()),
      (this._multiDrawStarts = e._multiDrawStarts.slice()),
      (this._matricesTexture = e._matricesTexture.clone()),
      (this._matricesTexture.image.data = this._matricesTexture.image.slice()),
      this
    );
  }
  dispose() {
    return (
      this.geometry.dispose(),
      this._matricesTexture.dispose(),
      (this._matricesTexture = null),
      this
    );
  }
  onBeforeRender(e, t, i, r, s) {
    if (
      !this._visibilityChanged &&
      !this.perObjectFrustumCulled &&
      !this.sortObjects
    )
      return;
    const o = r.getIndex(),
      a = o === null ? 1 : o.array.BYTES_PER_ELEMENT,
      u = this._visibility,
      f = this._multiDrawStarts,
      h = this._multiDrawCounts,
      d = this._drawRanges,
      p = this.perObjectFrustumCulled;
    p &&
      (_A
        .multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse)
        .multiply(this.matrixWorld),
      Ly.setFromProjectionMatrix(_A, e.isWebGPURenderer ? Uu : kr));
    let m = 0;
    if (this.sortObjects) {
      xA.copy(this.matrixWorld).invert(),
        Oc.setFromMatrixPosition(i.matrixWorld).applyMatrix4(xA);
      for (let S = 0, v = u.length; S < v; S++)
        if (u[S]) {
          this.getMatrixAt(S, po),
            this.getBoundingSphereAt(S, ma).applyMatrix4(po);
          let M = !1;
          if ((p && (M = !Ly.intersectsSphere(ma)), !M)) {
            const _ = Oc.distanceTo(ma.center);
            Iy.push(d[S], _);
          }
        }
      const y = Iy.list,
        w = this.customSort;
      w === null ? y.sort(s.transparent ? Q9 : K9) : w.call(this, y, i);
      for (let S = 0, v = y.length; S < v; S++) {
        const M = y[S];
        (f[m] = M.start * a), (h[m] = M.count), m++;
      }
      Iy.reset();
    } else
      for (let y = 0, w = u.length; y < w; y++)
        if (u[y]) {
          let S = !1;
          if (
            (p &&
              (this.getMatrixAt(y, po),
              this.getBoundingSphereAt(y, ma).applyMatrix4(po),
              (S = !Ly.intersectsSphere(ma))),
            !S)
          ) {
            const v = d[y];
            (f[m] = v.start * a), (h[m] = v.count), m++;
          }
        }
    (this._multiDrawCount = m), (this._visibilityChanged = !1);
  }
  onBeforeShadow(e, t, i, r, s, o) {
    this.onBeforeRender(e, null, r, s, o);
  }
}
class Pi extends gi {
  constructor(e) {
    super(),
      (this.isLineBasicMaterial = !0),
      (this.type = "LineBasicMaterial"),
      (this.color = new Be(16777215)),
      (this.map = null),
      (this.linewidth = 1),
      (this.linecap = "round"),
      (this.linejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.linewidth = e.linewidth),
      (this.linecap = e.linecap),
      (this.linejoin = e.linejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const SA = new U(),
  MA = new U(),
  wA = new dt(),
  Ny = new rl(),
  bp = new di();
class jo extends Ft {
  constructor(e = new Tt(), t = new Pi()) {
    super(),
      (this.isLine = !0),
      (this.type = "Line"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position,
        i = [0];
      for (let r = 1, s = t.count; r < s; r++)
        SA.fromBufferAttribute(t, r - 1),
          MA.fromBufferAttribute(t, r),
          (i[r] = i[r - 1]),
          (i[r] += SA.distanceTo(MA));
      e.setAttribute("lineDistance", new Ze(i, 1));
    } else
      console.warn(
        "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
      );
    return this;
  }
  raycast(e, t) {
    const i = this.geometry,
      r = this.matrixWorld,
      s = e.params.Line.threshold,
      o = i.drawRange;
    if (
      (i.boundingSphere === null && i.computeBoundingSphere(),
      bp.copy(i.boundingSphere),
      bp.applyMatrix4(r),
      (bp.radius += s),
      e.ray.intersectsSphere(bp) === !1)
    )
      return;
    wA.copy(r).invert(), Ny.copy(e.ray).applyMatrix4(wA);
    const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      u = a * a,
      f = new U(),
      h = new U(),
      d = new U(),
      p = new U(),
      m = this.isLineSegments ? 2 : 1,
      y = i.index,
      S = i.attributes.position;
    if (y !== null) {
      const v = Math.max(0, o.start),
        M = Math.min(y.count, o.start + o.count);
      for (let _ = v, T = M - 1; _ < T; _ += m) {
        const P = y.getX(_),
          b = y.getX(_ + 1);
        if (
          (f.fromBufferAttribute(S, P),
          h.fromBufferAttribute(S, b),
          Ny.distanceSqToSegment(f, h, p, d) > u)
        )
          continue;
        p.applyMatrix4(this.matrixWorld);
        const N = e.ray.origin.distanceTo(p);
        N < e.near ||
          N > e.far ||
          t.push({
            distance: N,
            point: d.clone().applyMatrix4(this.matrixWorld),
            index: _,
            face: null,
            faceIndex: null,
            object: this,
          });
      }
    } else {
      const v = Math.max(0, o.start),
        M = Math.min(S.count, o.start + o.count);
      for (let _ = v, T = M - 1; _ < T; _ += m) {
        if (
          (f.fromBufferAttribute(S, _),
          h.fromBufferAttribute(S, _ + 1),
          Ny.distanceSqToSegment(f, h, p, d) > u)
        )
          continue;
        p.applyMatrix4(this.matrixWorld);
        const b = e.ray.origin.distanceTo(p);
        b < e.near ||
          b > e.far ||
          t.push({
            distance: b,
            point: d.clone().applyMatrix4(this.matrixWorld),
            index: _,
            face: null,
            faceIndex: null,
            object: this,
          });
      }
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      i = Object.keys(t);
    if (i.length > 0) {
      const r = t[i[0]];
      if (r !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let s = 0, o = r.length; s < o; s++) {
          const a = r[s].name || String(s);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[a] = s);
        }
      }
    }
  }
}
const EA = new U(),
  TA = new U();
class ps extends jo {
  constructor(e, t) {
    super(e, t), (this.isLineSegments = !0), (this.type = "LineSegments");
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position,
        i = [];
      for (let r = 0, s = t.count; r < s; r += 2)
        EA.fromBufferAttribute(t, r),
          TA.fromBufferAttribute(t, r + 1),
          (i[r] = r === 0 ? 0 : i[r - 1]),
          (i[r + 1] = i[r] + EA.distanceTo(TA));
      e.setAttribute("lineDistance", new Ze(i, 1));
    } else
      console.warn(
        "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
      );
    return this;
  }
}
class XL extends jo {
  constructor(e, t) {
    super(e, t), (this.isLineLoop = !0), (this.type = "LineLoop");
  }
}
class jS extends gi {
  constructor(e) {
    super(),
      (this.isPointsMaterial = !0),
      (this.type = "PointsMaterial"),
      (this.color = new Be(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.size = 1),
      (this.sizeAttenuation = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.size = e.size),
      (this.sizeAttenuation = e.sizeAttenuation),
      (this.fog = e.fog),
      this
    );
  }
}
const AA = new dt(),
  B_ = new rl(),
  Cp = new di(),
  Pp = new U();
class YL extends Ft {
  constructor(e = new Tt(), t = new jS()) {
    super(),
      (this.isPoints = !0),
      (this.type = "Points"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  raycast(e, t) {
    const i = this.geometry,
      r = this.matrixWorld,
      s = e.params.Points.threshold,
      o = i.drawRange;
    if (
      (i.boundingSphere === null && i.computeBoundingSphere(),
      Cp.copy(i.boundingSphere),
      Cp.applyMatrix4(r),
      (Cp.radius += s),
      e.ray.intersectsSphere(Cp) === !1)
    )
      return;
    AA.copy(r).invert(), B_.copy(e.ray).applyMatrix4(AA);
    const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      u = a * a,
      f = i.index,
      d = i.attributes.position;
    if (f !== null) {
      const p = Math.max(0, o.start),
        m = Math.min(f.count, o.start + o.count);
      for (let y = p, w = m; y < w; y++) {
        const S = f.getX(y);
        Pp.fromBufferAttribute(d, S), bA(Pp, S, u, r, e, t, this);
      }
    } else {
      const p = Math.max(0, o.start),
        m = Math.min(d.count, o.start + o.count);
      for (let y = p, w = m; y < w; y++)
        Pp.fromBufferAttribute(d, y), bA(Pp, y, u, r, e, t, this);
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      i = Object.keys(t);
    if (i.length > 0) {
      const r = t[i[0]];
      if (r !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let s = 0, o = r.length; s < o; s++) {
          const a = r[s].name || String(s);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[a] = s);
        }
      }
    }
  }
}
function bA(n, e, t, i, r, s, o) {
  const a = B_.distanceSqToPoint(n);
  if (a < t) {
    const u = new U();
    B_.closestPointToPoint(n, u), u.applyMatrix4(i);
    const f = r.ray.origin.distanceTo(u);
    if (f < r.near || f > r.far) return;
    s.push({
      distance: f,
      distanceToRay: Math.sqrt(a),
      point: u,
      index: e,
      face: null,
      object: o,
    });
  }
}
class t7 extends An {
  constructor(e, t, i, r, s, o, a, u, f) {
    super(e, t, i, r, s, o, a, u, f),
      (this.isVideoTexture = !0),
      (this.minFilter = o !== void 0 ? o : wn),
      (this.magFilter = s !== void 0 ? s : wn),
      (this.generateMipmaps = !1);
    const h = this;
    function d() {
      (h.needsUpdate = !0), e.requestVideoFrameCallback(d);
    }
    "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(d);
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const e = this.image;
    "requestVideoFrameCallback" in e === !1 &&
      e.readyState >= e.HAVE_CURRENT_DATA &&
      (this.needsUpdate = !0);
  }
}
class n7 extends An {
  constructor(e, t) {
    super({ width: e, height: t }),
      (this.isFramebufferTexture = !0),
      (this.magFilter = Sn),
      (this.minFilter = Sn),
      (this.generateMipmaps = !1),
      (this.needsUpdate = !0);
  }
}
class Yg extends An {
  constructor(e, t, i, r, s, o, a, u, f, h, d, p) {
    super(null, o, a, u, f, h, r, s, d, p),
      (this.isCompressedTexture = !0),
      (this.image = { width: t, height: i }),
      (this.mipmaps = e),
      (this.flipY = !1),
      (this.generateMipmaps = !1);
  }
}
class i7 extends Yg {
  constructor(e, t, i, r, s, o) {
    super(e, t, i, s, o),
      (this.isCompressedArrayTexture = !0),
      (this.image.depth = r),
      (this.wrapR = fi);
  }
}
class r7 extends Yg {
  constructor(e, t, i) {
    super(void 0, e[0].width, e[0].height, t, i, Xs),
      (this.isCompressedCubeTexture = !0),
      (this.isCubeTexture = !0),
      (this.image = e);
  }
}
class s7 extends An {
  constructor(e, t, i, r, s, o, a, u, f) {
    super(e, t, i, r, s, o, a, u, f),
      (this.isCanvasTexture = !0),
      (this.needsUpdate = !0);
  }
}
class Gr {
  constructor() {
    (this.type = "Curve"), (this.arcLengthDivisions = 200);
  }
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  }
  getPointAt(e, t) {
    const i = this.getUtoTmapping(e);
    return this.getPoint(i, t);
  }
  getPoints(e = 5) {
    const t = [];
    for (let i = 0; i <= e; i++) t.push(this.getPoint(i / e));
    return t;
  }
  getSpacedPoints(e = 5) {
    const t = [];
    for (let i = 0; i <= e; i++) t.push(this.getPointAt(i / e));
    return t;
  }
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  getLengths(e = this.arcLengthDivisions) {
    if (
      this.cacheArcLengths &&
      this.cacheArcLengths.length === e + 1 &&
      !this.needsUpdate
    )
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const t = [];
    let i,
      r = this.getPoint(0),
      s = 0;
    t.push(0);
    for (let o = 1; o <= e; o++)
      (i = this.getPoint(o / e)), (s += i.distanceTo(r)), t.push(s), (r = i);
    return (this.cacheArcLengths = t), t;
  }
  updateArcLengths() {
    (this.needsUpdate = !0), this.getLengths();
  }
  getUtoTmapping(e, t) {
    const i = this.getLengths();
    let r = 0;
    const s = i.length;
    let o;
    t ? (o = t) : (o = e * i[s - 1]);
    let a = 0,
      u = s - 1,
      f;
    for (; a <= u; )
      if (((r = Math.floor(a + (u - a) / 2)), (f = i[r] - o), f < 0)) a = r + 1;
      else if (f > 0) u = r - 1;
      else {
        u = r;
        break;
      }
    if (((r = u), i[r] === o)) return r / (s - 1);
    const h = i[r],
      p = i[r + 1] - h,
      m = (o - h) / p;
    return (r + m) / (s - 1);
  }
  getTangent(e, t) {
    let r = e - 1e-4,
      s = e + 1e-4;
    r < 0 && (r = 0), s > 1 && (s = 1);
    const o = this.getPoint(r),
      a = this.getPoint(s),
      u = t || (o.isVector2 ? new de() : new U());
    return u.copy(a).sub(o).normalize(), u;
  }
  getTangentAt(e, t) {
    const i = this.getUtoTmapping(e);
    return this.getTangent(i, t);
  }
  computeFrenetFrames(e, t) {
    const i = new U(),
      r = [],
      s = [],
      o = [],
      a = new U(),
      u = new dt();
    for (let m = 0; m <= e; m++) {
      const y = m / e;
      r[m] = this.getTangentAt(y, new U());
    }
    (s[0] = new U()), (o[0] = new U());
    let f = Number.MAX_VALUE;
    const h = Math.abs(r[0].x),
      d = Math.abs(r[0].y),
      p = Math.abs(r[0].z);
    h <= f && ((f = h), i.set(1, 0, 0)),
      d <= f && ((f = d), i.set(0, 1, 0)),
      p <= f && i.set(0, 0, 1),
      a.crossVectors(r[0], i).normalize(),
      s[0].crossVectors(r[0], a),
      o[0].crossVectors(r[0], s[0]);
    for (let m = 1; m <= e; m++) {
      if (
        ((s[m] = s[m - 1].clone()),
        (o[m] = o[m - 1].clone()),
        a.crossVectors(r[m - 1], r[m]),
        a.length() > Number.EPSILON)
      ) {
        a.normalize();
        const y = Math.acos(vn(r[m - 1].dot(r[m]), -1, 1));
        s[m].applyMatrix4(u.makeRotationAxis(a, y));
      }
      o[m].crossVectors(r[m], s[m]);
    }
    if (t === !0) {
      let m = Math.acos(vn(s[0].dot(s[e]), -1, 1));
      (m /= e), r[0].dot(a.crossVectors(s[0], s[e])) > 0 && (m = -m);
      for (let y = 1; y <= e; y++)
        s[y].applyMatrix4(u.makeRotationAxis(r[y], m * y)),
          o[y].crossVectors(r[y], s[y]);
    }
    return { tangents: r, normals: s, binormals: o };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (this.arcLengthDivisions = e.arcLengthDivisions), this;
  }
  toJSON() {
    const e = {
      metadata: { version: 4.6, type: "Curve", generator: "Curve.toJSON" },
    };
    return (
      (e.arcLengthDivisions = this.arcLengthDivisions), (e.type = this.type), e
    );
  }
  fromJSON(e) {
    return (this.arcLengthDivisions = e.arcLengthDivisions), this;
  }
}
class qg extends Gr {
  constructor(
    e = 0,
    t = 0,
    i = 1,
    r = 1,
    s = 0,
    o = Math.PI * 2,
    a = !1,
    u = 0
  ) {
    super(),
      (this.isEllipseCurve = !0),
      (this.type = "EllipseCurve"),
      (this.aX = e),
      (this.aY = t),
      (this.xRadius = i),
      (this.yRadius = r),
      (this.aStartAngle = s),
      (this.aEndAngle = o),
      (this.aClockwise = a),
      (this.aRotation = u);
  }
  getPoint(e, t) {
    const i = t || new de(),
      r = Math.PI * 2;
    let s = this.aEndAngle - this.aStartAngle;
    const o = Math.abs(s) < Number.EPSILON;
    for (; s < 0; ) s += r;
    for (; s > r; ) s -= r;
    s < Number.EPSILON && (o ? (s = 0) : (s = r)),
      this.aClockwise === !0 && !o && (s === r ? (s = -r) : (s = s - r));
    const a = this.aStartAngle + e * s;
    let u = this.aX + this.xRadius * Math.cos(a),
      f = this.aY + this.yRadius * Math.sin(a);
    if (this.aRotation !== 0) {
      const h = Math.cos(this.aRotation),
        d = Math.sin(this.aRotation),
        p = u - this.aX,
        m = f - this.aY;
      (u = p * h - m * d + this.aX), (f = p * d + m * h + this.aY);
    }
    return i.set(u, f);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.aX = e.aX),
      (this.aY = e.aY),
      (this.xRadius = e.xRadius),
      (this.yRadius = e.yRadius),
      (this.aStartAngle = e.aStartAngle),
      (this.aEndAngle = e.aEndAngle),
      (this.aClockwise = e.aClockwise),
      (this.aRotation = e.aRotation),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.aX = this.aX),
      (e.aY = this.aY),
      (e.xRadius = this.xRadius),
      (e.yRadius = this.yRadius),
      (e.aStartAngle = this.aStartAngle),
      (e.aEndAngle = this.aEndAngle),
      (e.aClockwise = this.aClockwise),
      (e.aRotation = this.aRotation),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      (this.aX = e.aX),
      (this.aY = e.aY),
      (this.xRadius = e.xRadius),
      (this.yRadius = e.yRadius),
      (this.aStartAngle = e.aStartAngle),
      (this.aEndAngle = e.aEndAngle),
      (this.aClockwise = e.aClockwise),
      (this.aRotation = e.aRotation),
      this
    );
  }
}
class qL extends qg {
  constructor(e, t, i, r, s, o) {
    super(e, t, i, i, r, s, o),
      (this.isArcCurve = !0),
      (this.type = "ArcCurve");
  }
}
function XS() {
  let n = 0,
    e = 0,
    t = 0,
    i = 0;
  function r(s, o, a, u) {
    (n = s),
      (e = a),
      (t = -3 * s + 3 * o - 2 * a - u),
      (i = 2 * s - 2 * o + a + u);
  }
  return {
    initCatmullRom: function (s, o, a, u, f) {
      r(o, a, f * (a - s), f * (u - o));
    },
    initNonuniformCatmullRom: function (s, o, a, u, f, h, d) {
      let p = (o - s) / f - (a - s) / (f + h) + (a - o) / h,
        m = (a - o) / h - (u - o) / (h + d) + (u - a) / d;
      (p *= h), (m *= h), r(o, a, p, m);
    },
    calc: function (s) {
      const o = s * s,
        a = o * s;
      return n + e * s + t * o + i * a;
    },
  };
}
const Rp = new U(),
  Dy = new XS(),
  Oy = new XS(),
  Uy = new XS();
class ZL extends Gr {
  constructor(e = [], t = !1, i = "centripetal", r = 0.5) {
    super(),
      (this.isCatmullRomCurve3 = !0),
      (this.type = "CatmullRomCurve3"),
      (this.points = e),
      (this.closed = t),
      (this.curveType = i),
      (this.tension = r);
  }
  getPoint(e, t = new U()) {
    const i = t,
      r = this.points,
      s = r.length,
      o = (s - (this.closed ? 0 : 1)) * e;
    let a = Math.floor(o),
      u = o - a;
    this.closed
      ? (a += a > 0 ? 0 : (Math.floor(Math.abs(a) / s) + 1) * s)
      : u === 0 && a === s - 1 && ((a = s - 2), (u = 1));
    let f, h;
    this.closed || a > 0
      ? (f = r[(a - 1) % s])
      : (Rp.subVectors(r[0], r[1]).add(r[0]), (f = Rp));
    const d = r[a % s],
      p = r[(a + 1) % s];
    if (
      (this.closed || a + 2 < s
        ? (h = r[(a + 2) % s])
        : (Rp.subVectors(r[s - 1], r[s - 2]).add(r[s - 1]), (h = Rp)),
      this.curveType === "centripetal" || this.curveType === "chordal")
    ) {
      const m = this.curveType === "chordal" ? 0.5 : 0.25;
      let y = Math.pow(f.distanceToSquared(d), m),
        w = Math.pow(d.distanceToSquared(p), m),
        S = Math.pow(p.distanceToSquared(h), m);
      w < 1e-4 && (w = 1),
        y < 1e-4 && (y = w),
        S < 1e-4 && (S = w),
        Dy.initNonuniformCatmullRom(f.x, d.x, p.x, h.x, y, w, S),
        Oy.initNonuniformCatmullRom(f.y, d.y, p.y, h.y, y, w, S),
        Uy.initNonuniformCatmullRom(f.z, d.z, p.z, h.z, y, w, S);
    } else
      this.curveType === "catmullrom" &&
        (Dy.initCatmullRom(f.x, d.x, p.x, h.x, this.tension),
        Oy.initCatmullRom(f.y, d.y, p.y, h.y, this.tension),
        Uy.initCatmullRom(f.z, d.z, p.z, h.z, this.tension));
    return i.set(Dy.calc(u), Oy.calc(u), Uy.calc(u)), i;
  }
  copy(e) {
    super.copy(e), (this.points = []);
    for (let t = 0, i = e.points.length; t < i; t++) {
      const r = e.points[t];
      this.points.push(r.clone());
    }
    return (
      (this.closed = e.closed),
      (this.curveType = e.curveType),
      (this.tension = e.tension),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, i = this.points.length; t < i; t++) {
      const r = this.points[t];
      e.points.push(r.toArray());
    }
    return (
      (e.closed = this.closed),
      (e.curveType = this.curveType),
      (e.tension = this.tension),
      e
    );
  }
  fromJSON(e) {
    super.fromJSON(e), (this.points = []);
    for (let t = 0, i = e.points.length; t < i; t++) {
      const r = e.points[t];
      this.points.push(new U().fromArray(r));
    }
    return (
      (this.closed = e.closed),
      (this.curveType = e.curveType),
      (this.tension = e.tension),
      this
    );
  }
}
function CA(n, e, t, i, r) {
  const s = (i - e) * 0.5,
    o = (r - t) * 0.5,
    a = n * n,
    u = n * a;
  return (
    (2 * t - 2 * i + s + o) * u + (-3 * t + 3 * i - 2 * s - o) * a + s * n + t
  );
}
function o7(n, e) {
  const t = 1 - n;
  return t * t * e;
}
function a7(n, e) {
  return 2 * (1 - n) * n * e;
}
function l7(n, e) {
  return n * n * e;
}
function uf(n, e, t, i) {
  return o7(n, e) + a7(n, t) + l7(n, i);
}
function u7(n, e) {
  const t = 1 - n;
  return t * t * t * e;
}
function c7(n, e) {
  const t = 1 - n;
  return 3 * t * t * n * e;
}
function f7(n, e) {
  return 3 * (1 - n) * n * n * e;
}
function h7(n, e) {
  return n * n * n * e;
}
function cf(n, e, t, i, r) {
  return u7(n, e) + c7(n, t) + f7(n, i) + h7(n, r);
}
class YS extends Gr {
  constructor(e = new de(), t = new de(), i = new de(), r = new de()) {
    super(),
      (this.isCubicBezierCurve = !0),
      (this.type = "CubicBezierCurve"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = i),
      (this.v3 = r);
  }
  getPoint(e, t = new de()) {
    const i = t,
      r = this.v0,
      s = this.v1,
      o = this.v2,
      a = this.v3;
    return i.set(cf(e, r.x, s.x, o.x, a.x), cf(e, r.y, s.y, o.y, a.y)), i;
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this.v3.copy(e.v3),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      (e.v3 = this.v3.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this.v3.fromArray(e.v3),
      this
    );
  }
}
class KL extends Gr {
  constructor(e = new U(), t = new U(), i = new U(), r = new U()) {
    super(),
      (this.isCubicBezierCurve3 = !0),
      (this.type = "CubicBezierCurve3"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = i),
      (this.v3 = r);
  }
  getPoint(e, t = new U()) {
    const i = t,
      r = this.v0,
      s = this.v1,
      o = this.v2,
      a = this.v3;
    return (
      i.set(
        cf(e, r.x, s.x, o.x, a.x),
        cf(e, r.y, s.y, o.y, a.y),
        cf(e, r.z, s.z, o.z, a.z)
      ),
      i
    );
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this.v3.copy(e.v3),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      (e.v3 = this.v3.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this.v3.fromArray(e.v3),
      this
    );
  }
}
class qS extends Gr {
  constructor(e = new de(), t = new de()) {
    super(),
      (this.isLineCurve = !0),
      (this.type = "LineCurve"),
      (this.v1 = e),
      (this.v2 = t);
  }
  getPoint(e, t = new de()) {
    const i = t;
    return (
      e === 1
        ? i.copy(this.v2)
        : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)),
      i
    );
  }
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new de()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
  }
  fromJSON(e) {
    return (
      super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    );
  }
}
class QL extends Gr {
  constructor(e = new U(), t = new U()) {
    super(),
      (this.isLineCurve3 = !0),
      (this.type = "LineCurve3"),
      (this.v1 = e),
      (this.v2 = t);
  }
  getPoint(e, t = new U()) {
    const i = t;
    return (
      e === 1
        ? i.copy(this.v2)
        : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)),
      i
    );
  }
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new U()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
  }
  fromJSON(e) {
    return (
      super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    );
  }
}
class ZS extends Gr {
  constructor(e = new de(), t = new de(), i = new de()) {
    super(),
      (this.isQuadraticBezierCurve = !0),
      (this.type = "QuadraticBezierCurve"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = i);
  }
  getPoint(e, t = new de()) {
    const i = t,
      r = this.v0,
      s = this.v1,
      o = this.v2;
    return i.set(uf(e, r.x, s.x, o.x), uf(e, r.y, s.y, o.y)), i;
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this
    );
  }
}
class KS extends Gr {
  constructor(e = new U(), t = new U(), i = new U()) {
    super(),
      (this.isQuadraticBezierCurve3 = !0),
      (this.type = "QuadraticBezierCurve3"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = i);
  }
  getPoint(e, t = new U()) {
    const i = t,
      r = this.v0,
      s = this.v1,
      o = this.v2;
    return (
      i.set(uf(e, r.x, s.x, o.x), uf(e, r.y, s.y, o.y), uf(e, r.z, s.z, o.z)), i
    );
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this
    );
  }
}
class QS extends Gr {
  constructor(e = []) {
    super(),
      (this.isSplineCurve = !0),
      (this.type = "SplineCurve"),
      (this.points = e);
  }
  getPoint(e, t = new de()) {
    const i = t,
      r = this.points,
      s = (r.length - 1) * e,
      o = Math.floor(s),
      a = s - o,
      u = r[o === 0 ? o : o - 1],
      f = r[o],
      h = r[o > r.length - 2 ? r.length - 1 : o + 1],
      d = r[o > r.length - 3 ? r.length - 1 : o + 2];
    return i.set(CA(a, u.x, f.x, h.x, d.x), CA(a, u.y, f.y, h.y, d.y)), i;
  }
  copy(e) {
    super.copy(e), (this.points = []);
    for (let t = 0, i = e.points.length; t < i; t++) {
      const r = e.points[t];
      this.points.push(r.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, i = this.points.length; t < i; t++) {
      const r = this.points[t];
      e.points.push(r.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.points = []);
    for (let t = 0, i = e.points.length; t < i; t++) {
      const r = e.points[t];
      this.points.push(new de().fromArray(r));
    }
    return this;
  }
}
var ng = Object.freeze({
  __proto__: null,
  ArcCurve: qL,
  CatmullRomCurve3: ZL,
  CubicBezierCurve: YS,
  CubicBezierCurve3: KL,
  EllipseCurve: qg,
  LineCurve: qS,
  LineCurve3: QL,
  QuadraticBezierCurve: ZS,
  QuadraticBezierCurve3: KS,
  SplineCurve: QS,
});
class $L extends Gr {
  constructor() {
    super(),
      (this.type = "CurvePath"),
      (this.curves = []),
      (this.autoClose = !1);
  }
  add(e) {
    this.curves.push(e);
  }
  closePath() {
    const e = this.curves[0].getPoint(0),
      t = this.curves[this.curves.length - 1].getPoint(1);
    if (!e.equals(t)) {
      const i = e.isVector2 === !0 ? "LineCurve" : "LineCurve3";
      this.curves.push(new ng[i](t, e));
    }
    return this;
  }
  getPoint(e, t) {
    const i = e * this.getLength(),
      r = this.getCurveLengths();
    let s = 0;
    for (; s < r.length; ) {
      if (r[s] >= i) {
        const o = r[s] - i,
          a = this.curves[s],
          u = a.getLength(),
          f = u === 0 ? 0 : 1 - o / u;
        return a.getPointAt(f, t);
      }
      s++;
    }
    return null;
  }
  getLength() {
    const e = this.getCurveLengths();
    return e[e.length - 1];
  }
  updateArcLengths() {
    (this.needsUpdate = !0), (this.cacheLengths = null), this.getCurveLengths();
  }
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const e = [];
    let t = 0;
    for (let i = 0, r = this.curves.length; i < r; i++)
      (t += this.curves[i].getLength()), e.push(t);
    return (this.cacheLengths = e), e;
  }
  getSpacedPoints(e = 40) {
    const t = [];
    for (let i = 0; i <= e; i++) t.push(this.getPoint(i / e));
    return this.autoClose && t.push(t[0]), t;
  }
  getPoints(e = 12) {
    const t = [];
    let i;
    for (let r = 0, s = this.curves; r < s.length; r++) {
      const o = s[r],
        a = o.isEllipseCurve
          ? e * 2
          : o.isLineCurve || o.isLineCurve3
          ? 1
          : o.isSplineCurve
          ? e * o.points.length
          : e,
        u = o.getPoints(a);
      for (let f = 0; f < u.length; f++) {
        const h = u[f];
        (i && i.equals(h)) || (t.push(h), (i = h));
      }
    }
    return (
      this.autoClose &&
        t.length > 1 &&
        !t[t.length - 1].equals(t[0]) &&
        t.push(t[0]),
      t
    );
  }
  copy(e) {
    super.copy(e), (this.curves = []);
    for (let t = 0, i = e.curves.length; t < i; t++) {
      const r = e.curves[t];
      this.curves.push(r.clone());
    }
    return (this.autoClose = e.autoClose), this;
  }
  toJSON() {
    const e = super.toJSON();
    (e.autoClose = this.autoClose), (e.curves = []);
    for (let t = 0, i = this.curves.length; t < i; t++) {
      const r = this.curves[t];
      e.curves.push(r.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.autoClose = e.autoClose), (this.curves = []);
    for (let t = 0, i = e.curves.length; t < i; t++) {
      const r = e.curves[t];
      this.curves.push(new ng[r.type]().fromJSON(r));
    }
    return this;
  }
}
class Wf extends $L {
  constructor(e) {
    super(),
      (this.type = "Path"),
      (this.currentPoint = new de()),
      e && this.setFromPoints(e);
  }
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y);
    for (let t = 1, i = e.length; t < i; t++) this.lineTo(e[t].x, e[t].y);
    return this;
  }
  moveTo(e, t) {
    return this.currentPoint.set(e, t), this;
  }
  lineTo(e, t) {
    const i = new qS(this.currentPoint.clone(), new de(e, t));
    return this.curves.push(i), this.currentPoint.set(e, t), this;
  }
  quadraticCurveTo(e, t, i, r) {
    const s = new ZS(this.currentPoint.clone(), new de(e, t), new de(i, r));
    return this.curves.push(s), this.currentPoint.set(i, r), this;
  }
  bezierCurveTo(e, t, i, r, s, o) {
    const a = new YS(
      this.currentPoint.clone(),
      new de(e, t),
      new de(i, r),
      new de(s, o)
    );
    return this.curves.push(a), this.currentPoint.set(s, o), this;
  }
  splineThru(e) {
    const t = [this.currentPoint.clone()].concat(e),
      i = new QS(t);
    return this.curves.push(i), this.currentPoint.copy(e[e.length - 1]), this;
  }
  arc(e, t, i, r, s, o) {
    const a = this.currentPoint.x,
      u = this.currentPoint.y;
    return this.absarc(e + a, t + u, i, r, s, o), this;
  }
  absarc(e, t, i, r, s, o) {
    return this.absellipse(e, t, i, i, r, s, o), this;
  }
  ellipse(e, t, i, r, s, o, a, u) {
    const f = this.currentPoint.x,
      h = this.currentPoint.y;
    return this.absellipse(e + f, t + h, i, r, s, o, a, u), this;
  }
  absellipse(e, t, i, r, s, o, a, u) {
    const f = new qg(e, t, i, r, s, o, a, u);
    if (this.curves.length > 0) {
      const d = f.getPoint(0);
      d.equals(this.currentPoint) || this.lineTo(d.x, d.y);
    }
    this.curves.push(f);
    const h = f.getPoint(1);
    return this.currentPoint.copy(h), this;
  }
  copy(e) {
    return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.currentPoint = this.currentPoint.toArray()), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
  }
}
class wh extends Tt {
  constructor(
    e = [new de(0, -0.5), new de(0.5, 0), new de(0, 0.5)],
    t = 12,
    i = 0,
    r = Math.PI * 2
  ) {
    super(),
      (this.type = "LatheGeometry"),
      (this.parameters = { points: e, segments: t, phiStart: i, phiLength: r }),
      (t = Math.floor(t)),
      (r = vn(r, 0, Math.PI * 2));
    const s = [],
      o = [],
      a = [],
      u = [],
      f = [],
      h = 1 / t,
      d = new U(),
      p = new de(),
      m = new U(),
      y = new U(),
      w = new U();
    let S = 0,
      v = 0;
    for (let M = 0; M <= e.length - 1; M++)
      switch (M) {
        case 0:
          (S = e[M + 1].x - e[M].x),
            (v = e[M + 1].y - e[M].y),
            (m.x = v * 1),
            (m.y = -S),
            (m.z = v * 0),
            w.copy(m),
            m.normalize(),
            u.push(m.x, m.y, m.z);
          break;
        case e.length - 1:
          u.push(w.x, w.y, w.z);
          break;
        default:
          (S = e[M + 1].x - e[M].x),
            (v = e[M + 1].y - e[M].y),
            (m.x = v * 1),
            (m.y = -S),
            (m.z = v * 0),
            y.copy(m),
            (m.x += w.x),
            (m.y += w.y),
            (m.z += w.z),
            m.normalize(),
            u.push(m.x, m.y, m.z),
            w.copy(y);
      }
    for (let M = 0; M <= t; M++) {
      const _ = i + M * h * r,
        T = Math.sin(_),
        P = Math.cos(_);
      for (let b = 0; b <= e.length - 1; b++) {
        (d.x = e[b].x * T),
          (d.y = e[b].y),
          (d.z = e[b].x * P),
          o.push(d.x, d.y, d.z),
          (p.x = M / t),
          (p.y = b / (e.length - 1)),
          a.push(p.x, p.y);
        const L = u[3 * b + 0] * T,
          N = u[3 * b + 1],
          C = u[3 * b + 0] * P;
        f.push(L, N, C);
      }
    }
    for (let M = 0; M < t; M++)
      for (let _ = 0; _ < e.length - 1; _++) {
        const T = _ + M * e.length,
          P = T,
          b = T + e.length,
          L = T + e.length + 1,
          N = T + 1;
        s.push(P, b, N), s.push(L, N, b);
      }
    this.setIndex(s),
      this.setAttribute("position", new Ze(o, 3)),
      this.setAttribute("uv", new Ze(a, 2)),
      this.setAttribute("normal", new Ze(f, 3));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new wh(e.points, e.segments, e.phiStart, e.phiLength);
  }
}
class Zg extends wh {
  constructor(e = 1, t = 1, i = 4, r = 8) {
    const s = new Wf();
    s.absarc(0, -t / 2, e, Math.PI * 1.5, 0),
      s.absarc(0, t / 2, e, 0, Math.PI * 0.5),
      super(s.getPoints(i), r),
      (this.type = "CapsuleGeometry"),
      (this.parameters = {
        radius: e,
        length: t,
        capSegments: i,
        radialSegments: r,
      });
  }
  static fromJSON(e) {
    return new Zg(e.radius, e.length, e.capSegments, e.radialSegments);
  }
}
class Kg extends Tt {
  constructor(e = 1, t = 32, i = 0, r = Math.PI * 2) {
    super(),
      (this.type = "CircleGeometry"),
      (this.parameters = {
        radius: e,
        segments: t,
        thetaStart: i,
        thetaLength: r,
      }),
      (t = Math.max(3, t));
    const s = [],
      o = [],
      a = [],
      u = [],
      f = new U(),
      h = new de();
    o.push(0, 0, 0), a.push(0, 0, 1), u.push(0.5, 0.5);
    for (let d = 0, p = 3; d <= t; d++, p += 3) {
      const m = i + (d / t) * r;
      (f.x = e * Math.cos(m)),
        (f.y = e * Math.sin(m)),
        o.push(f.x, f.y, f.z),
        a.push(0, 0, 1),
        (h.x = (o[p] / e + 1) / 2),
        (h.y = (o[p + 1] / e + 1) / 2),
        u.push(h.x, h.y);
    }
    for (let d = 1; d <= t; d++) s.push(d, d + 1, 0);
    this.setIndex(s),
      this.setAttribute("position", new Ze(o, 3)),
      this.setAttribute("normal", new Ze(a, 3)),
      this.setAttribute("uv", new Ze(u, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Kg(e.radius, e.segments, e.thetaStart, e.thetaLength);
  }
}
class Yu extends Tt {
  constructor(
    e = 1,
    t = 1,
    i = 1,
    r = 32,
    s = 1,
    o = !1,
    a = 0,
    u = Math.PI * 2
  ) {
    super(),
      (this.type = "CylinderGeometry"),
      (this.parameters = {
        radiusTop: e,
        radiusBottom: t,
        height: i,
        radialSegments: r,
        heightSegments: s,
        openEnded: o,
        thetaStart: a,
        thetaLength: u,
      });
    const f = this;
    (r = Math.floor(r)), (s = Math.floor(s));
    const h = [],
      d = [],
      p = [],
      m = [];
    let y = 0;
    const w = [],
      S = i / 2;
    let v = 0;
    M(),
      o === !1 && (e > 0 && _(!0), t > 0 && _(!1)),
      this.setIndex(h),
      this.setAttribute("position", new Ze(d, 3)),
      this.setAttribute("normal", new Ze(p, 3)),
      this.setAttribute("uv", new Ze(m, 2));
    function M() {
      const T = new U(),
        P = new U();
      let b = 0;
      const L = (t - e) / i;
      for (let N = 0; N <= s; N++) {
        const C = [],
          R = N / s,
          B = R * (t - e) + e;
        for (let Z = 0; Z <= r; Z++) {
          const ae = Z / r,
            V = ae * u + a,
            Q = Math.sin(V),
            $ = Math.cos(V);
          (P.x = B * Q),
            (P.y = -R * i + S),
            (P.z = B * $),
            d.push(P.x, P.y, P.z),
            T.set(Q, L, $).normalize(),
            p.push(T.x, T.y, T.z),
            m.push(ae, 1 - R),
            C.push(y++);
        }
        w.push(C);
      }
      for (let N = 0; N < r; N++)
        for (let C = 0; C < s; C++) {
          const R = w[C][N],
            B = w[C + 1][N],
            Z = w[C + 1][N + 1],
            ae = w[C][N + 1];
          h.push(R, B, ae), h.push(B, Z, ae), (b += 6);
        }
      f.addGroup(v, b, 0), (v += b);
    }
    function _(T) {
      const P = y,
        b = new de(),
        L = new U();
      let N = 0;
      const C = T === !0 ? e : t,
        R = T === !0 ? 1 : -1;
      for (let Z = 1; Z <= r; Z++)
        d.push(0, S * R, 0), p.push(0, R, 0), m.push(0.5, 0.5), y++;
      const B = y;
      for (let Z = 0; Z <= r; Z++) {
        const V = (Z / r) * u + a,
          Q = Math.cos(V),
          $ = Math.sin(V);
        (L.x = C * $),
          (L.y = S * R),
          (L.z = C * Q),
          d.push(L.x, L.y, L.z),
          p.push(0, R, 0),
          (b.x = Q * 0.5 + 0.5),
          (b.y = $ * 0.5 * R + 0.5),
          m.push(b.x, b.y),
          y++;
      }
      for (let Z = 0; Z < r; Z++) {
        const ae = P + Z,
          V = B + Z;
        T === !0 ? h.push(V, V + 1, ae) : h.push(V + 1, V, ae), (N += 3);
      }
      f.addGroup(v, N, T === !0 ? 1 : 2), (v += N);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Yu(
      e.radiusTop,
      e.radiusBottom,
      e.height,
      e.radialSegments,
      e.heightSegments,
      e.openEnded,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class Qg extends Yu {
  constructor(e = 1, t = 1, i = 32, r = 1, s = !1, o = 0, a = Math.PI * 2) {
    super(0, e, t, i, r, s, o, a),
      (this.type = "ConeGeometry"),
      (this.parameters = {
        radius: e,
        height: t,
        radialSegments: i,
        heightSegments: r,
        openEnded: s,
        thetaStart: o,
        thetaLength: a,
      });
  }
  static fromJSON(e) {
    return new Qg(
      e.radius,
      e.height,
      e.radialSegments,
      e.heightSegments,
      e.openEnded,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class $o extends Tt {
  constructor(e = [], t = [], i = 1, r = 0) {
    super(),
      (this.type = "PolyhedronGeometry"),
      (this.parameters = { vertices: e, indices: t, radius: i, detail: r });
    const s = [],
      o = [];
    a(r),
      f(i),
      h(),
      this.setAttribute("position", new Ze(s, 3)),
      this.setAttribute("normal", new Ze(s.slice(), 3)),
      this.setAttribute("uv", new Ze(o, 2)),
      r === 0 ? this.computeVertexNormals() : this.normalizeNormals();
    function a(M) {
      const _ = new U(),
        T = new U(),
        P = new U();
      for (let b = 0; b < t.length; b += 3)
        m(t[b + 0], _), m(t[b + 1], T), m(t[b + 2], P), u(_, T, P, M);
    }
    function u(M, _, T, P) {
      const b = P + 1,
        L = [];
      for (let N = 0; N <= b; N++) {
        L[N] = [];
        const C = M.clone().lerp(T, N / b),
          R = _.clone().lerp(T, N / b),
          B = b - N;
        for (let Z = 0; Z <= B; Z++)
          Z === 0 && N === b
            ? (L[N][Z] = C)
            : (L[N][Z] = C.clone().lerp(R, Z / B));
      }
      for (let N = 0; N < b; N++)
        for (let C = 0; C < 2 * (b - N) - 1; C++) {
          const R = Math.floor(C / 2);
          C % 2 === 0
            ? (p(L[N][R + 1]), p(L[N + 1][R]), p(L[N][R]))
            : (p(L[N][R + 1]), p(L[N + 1][R + 1]), p(L[N + 1][R]));
        }
    }
    function f(M) {
      const _ = new U();
      for (let T = 0; T < s.length; T += 3)
        (_.x = s[T + 0]),
          (_.y = s[T + 1]),
          (_.z = s[T + 2]),
          _.normalize().multiplyScalar(M),
          (s[T + 0] = _.x),
          (s[T + 1] = _.y),
          (s[T + 2] = _.z);
    }
    function h() {
      const M = new U();
      for (let _ = 0; _ < s.length; _ += 3) {
        (M.x = s[_ + 0]), (M.y = s[_ + 1]), (M.z = s[_ + 2]);
        const T = S(M) / 2 / Math.PI + 0.5,
          P = v(M) / Math.PI + 0.5;
        o.push(T, 1 - P);
      }
      y(), d();
    }
    function d() {
      for (let M = 0; M < o.length; M += 6) {
        const _ = o[M + 0],
          T = o[M + 2],
          P = o[M + 4],
          b = Math.max(_, T, P),
          L = Math.min(_, T, P);
        b > 0.9 &&
          L < 0.1 &&
          (_ < 0.2 && (o[M + 0] += 1),
          T < 0.2 && (o[M + 2] += 1),
          P < 0.2 && (o[M + 4] += 1));
      }
    }
    function p(M) {
      s.push(M.x, M.y, M.z);
    }
    function m(M, _) {
      const T = M * 3;
      (_.x = e[T + 0]), (_.y = e[T + 1]), (_.z = e[T + 2]);
    }
    function y() {
      const M = new U(),
        _ = new U(),
        T = new U(),
        P = new U(),
        b = new de(),
        L = new de(),
        N = new de();
      for (let C = 0, R = 0; C < s.length; C += 9, R += 6) {
        M.set(s[C + 0], s[C + 1], s[C + 2]),
          _.set(s[C + 3], s[C + 4], s[C + 5]),
          T.set(s[C + 6], s[C + 7], s[C + 8]),
          b.set(o[R + 0], o[R + 1]),
          L.set(o[R + 2], o[R + 3]),
          N.set(o[R + 4], o[R + 5]),
          P.copy(M).add(_).add(T).divideScalar(3);
        const B = S(P);
        w(b, R + 0, M, B), w(L, R + 2, _, B), w(N, R + 4, T, B);
      }
    }
    function w(M, _, T, P) {
      P < 0 && M.x === 1 && (o[_] = M.x - 1),
        T.x === 0 && T.z === 0 && (o[_] = P / 2 / Math.PI + 0.5);
    }
    function S(M) {
      return Math.atan2(M.z, -M.x);
    }
    function v(M) {
      return Math.atan2(-M.y, Math.sqrt(M.x * M.x + M.z * M.z));
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new $o(e.vertices, e.indices, e.radius, e.details);
  }
}
class $g extends $o {
  constructor(e = 1, t = 0) {
    const i = (1 + Math.sqrt(5)) / 2,
      r = 1 / i,
      s = [
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        1,
        -1,
        -1,
        1,
        1,
        1,
        -1,
        -1,
        1,
        -1,
        1,
        1,
        1,
        -1,
        1,
        1,
        1,
        0,
        -r,
        -i,
        0,
        -r,
        i,
        0,
        r,
        -i,
        0,
        r,
        i,
        -r,
        -i,
        0,
        -r,
        i,
        0,
        r,
        -i,
        0,
        r,
        i,
        0,
        -i,
        0,
        -r,
        i,
        0,
        -r,
        -i,
        0,
        r,
        i,
        0,
        r,
      ],
      o = [
        3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8,
        17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18,
        0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13,
        18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5,
        11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14,
        5, 1, 5, 9,
      ];
    super(s, o, e, t),
      (this.type = "DodecahedronGeometry"),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new $g(e.radius, e.detail);
  }
}
const Lp = new U(),
  Ip = new U(),
  ky = new U(),
  Np = new Oi();
class JL extends Tt {
  constructor(e = null, t = 1) {
    if (
      (super(),
      (this.type = "EdgesGeometry"),
      (this.parameters = { geometry: e, thresholdAngle: t }),
      e !== null)
    ) {
      const r = Math.pow(10, 4),
        s = Math.cos(Ha * t),
        o = e.getIndex(),
        a = e.getAttribute("position"),
        u = o ? o.count : a.count,
        f = [0, 0, 0],
        h = ["a", "b", "c"],
        d = new Array(3),
        p = {},
        m = [];
      for (let y = 0; y < u; y += 3) {
        o
          ? ((f[0] = o.getX(y)), (f[1] = o.getX(y + 1)), (f[2] = o.getX(y + 2)))
          : ((f[0] = y), (f[1] = y + 1), (f[2] = y + 2));
        const { a: w, b: S, c: v } = Np;
        if (
          (w.fromBufferAttribute(a, f[0]),
          S.fromBufferAttribute(a, f[1]),
          v.fromBufferAttribute(a, f[2]),
          Np.getNormal(ky),
          (d[0] = `${Math.round(w.x * r)},${Math.round(w.y * r)},${Math.round(
            w.z * r
          )}`),
          (d[1] = `${Math.round(S.x * r)},${Math.round(S.y * r)},${Math.round(
            S.z * r
          )}`),
          (d[2] = `${Math.round(v.x * r)},${Math.round(v.y * r)},${Math.round(
            v.z * r
          )}`),
          !(d[0] === d[1] || d[1] === d[2] || d[2] === d[0]))
        )
          for (let M = 0; M < 3; M++) {
            const _ = (M + 1) % 3,
              T = d[M],
              P = d[_],
              b = Np[h[M]],
              L = Np[h[_]],
              N = `${T}_${P}`,
              C = `${P}_${T}`;
            C in p && p[C]
              ? (ky.dot(p[C].normal) <= s &&
                  (m.push(b.x, b.y, b.z), m.push(L.x, L.y, L.z)),
                (p[C] = null))
              : N in p ||
                (p[N] = { index0: f[M], index1: f[_], normal: ky.clone() });
          }
      }
      for (const y in p)
        if (p[y]) {
          const { index0: w, index1: S } = p[y];
          Lp.fromBufferAttribute(a, w),
            Ip.fromBufferAttribute(a, S),
            m.push(Lp.x, Lp.y, Lp.z),
            m.push(Ip.x, Ip.y, Ip.z);
        }
      this.setAttribute("position", new Ze(m, 3));
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
}
class ja extends Wf {
  constructor(e) {
    super(e), (this.uuid = er()), (this.type = "Shape"), (this.holes = []);
  }
  getPointsHoles(e) {
    const t = [];
    for (let i = 0, r = this.holes.length; i < r; i++)
      t[i] = this.holes[i].getPoints(e);
    return t;
  }
  extractPoints(e) {
    return { shape: this.getPoints(e), holes: this.getPointsHoles(e) };
  }
  copy(e) {
    super.copy(e), (this.holes = []);
    for (let t = 0, i = e.holes.length; t < i; t++) {
      const r = e.holes[t];
      this.holes.push(r.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    (e.uuid = this.uuid), (e.holes = []);
    for (let t = 0, i = this.holes.length; t < i; t++) {
      const r = this.holes[t];
      e.holes.push(r.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.uuid = e.uuid), (this.holes = []);
    for (let t = 0, i = e.holes.length; t < i; t++) {
      const r = e.holes[t];
      this.holes.push(new Wf().fromJSON(r));
    }
    return this;
  }
}
const d7 = {
  triangulate: function (n, e, t = 2) {
    const i = e && e.length,
      r = i ? e[0] * t : n.length;
    let s = eI(n, 0, r, t, !0);
    const o = [];
    if (!s || s.next === s.prev) return o;
    let a, u, f, h, d, p, m;
    if ((i && (s = y7(n, e, s, t)), n.length > 80 * t)) {
      (a = f = n[0]), (u = h = n[1]);
      for (let y = t; y < r; y += t)
        (d = n[y]),
          (p = n[y + 1]),
          d < a && (a = d),
          p < u && (u = p),
          d > f && (f = d),
          p > h && (h = p);
      (m = Math.max(f - a, h - u)), (m = m !== 0 ? 32767 / m : 0);
    }
    return jf(s, o, t, a, u, m, 0), o;
  },
};
function eI(n, e, t, i, r) {
  let s, o;
  if (r === P7(n, e, t, i) > 0)
    for (s = e; s < t; s += i) o = PA(s, n[s], n[s + 1], o);
  else for (s = t - i; s >= e; s -= i) o = PA(s, n[s], n[s + 1], o);
  return o && Jg(o, o.next) && (Yf(o), (o = o.next)), o;
}
function Ja(n, e) {
  if (!n) return n;
  e || (e = n);
  let t = n,
    i;
  do
    if (
      ((i = !1), !t.steiner && (Jg(t, t.next) || cn(t.prev, t, t.next) === 0))
    ) {
      if ((Yf(t), (t = e = t.prev), t === t.next)) break;
      i = !0;
    } else t = t.next;
  while (i || t !== e);
  return e;
}
function jf(n, e, t, i, r, s, o) {
  if (!n) return;
  !o && s && w7(n, i, r, s);
  let a = n,
    u,
    f;
  for (; n.prev !== n.next; ) {
    if (((u = n.prev), (f = n.next), s ? m7(n, i, r, s) : p7(n))) {
      e.push((u.i / t) | 0),
        e.push((n.i / t) | 0),
        e.push((f.i / t) | 0),
        Yf(n),
        (n = f.next),
        (a = f.next);
      continue;
    }
    if (((n = f), n === a)) {
      o
        ? o === 1
          ? ((n = g7(Ja(n), e, t)), jf(n, e, t, i, r, s, 2))
          : o === 2 && v7(n, e, t, i, r, s)
        : jf(Ja(n), e, t, i, r, s, 1);
      break;
    }
  }
}
function p7(n) {
  const e = n.prev,
    t = n,
    i = n.next;
  if (cn(e, t, i) >= 0) return !1;
  const r = e.x,
    s = t.x,
    o = i.x,
    a = e.y,
    u = t.y,
    f = i.y,
    h = r < s ? (r < o ? r : o) : s < o ? s : o,
    d = a < u ? (a < f ? a : f) : u < f ? u : f,
    p = r > s ? (r > o ? r : o) : s > o ? s : o,
    m = a > u ? (a > f ? a : f) : u > f ? u : f;
  let y = i.next;
  for (; y !== e; ) {
    if (
      y.x >= h &&
      y.x <= p &&
      y.y >= d &&
      y.y <= m &&
      vu(r, a, s, u, o, f, y.x, y.y) &&
      cn(y.prev, y, y.next) >= 0
    )
      return !1;
    y = y.next;
  }
  return !0;
}
function m7(n, e, t, i) {
  const r = n.prev,
    s = n,
    o = n.next;
  if (cn(r, s, o) >= 0) return !1;
  const a = r.x,
    u = s.x,
    f = o.x,
    h = r.y,
    d = s.y,
    p = o.y,
    m = a < u ? (a < f ? a : f) : u < f ? u : f,
    y = h < d ? (h < p ? h : p) : d < p ? d : p,
    w = a > u ? (a > f ? a : f) : u > f ? u : f,
    S = h > d ? (h > p ? h : p) : d > p ? d : p,
    v = V_(m, y, e, t, i),
    M = V_(w, S, e, t, i);
  let _ = n.prevZ,
    T = n.nextZ;
  for (; _ && _.z >= v && T && T.z <= M; ) {
    if (
      (_.x >= m &&
        _.x <= w &&
        _.y >= y &&
        _.y <= S &&
        _ !== r &&
        _ !== o &&
        vu(a, h, u, d, f, p, _.x, _.y) &&
        cn(_.prev, _, _.next) >= 0) ||
      ((_ = _.prevZ),
      T.x >= m &&
        T.x <= w &&
        T.y >= y &&
        T.y <= S &&
        T !== r &&
        T !== o &&
        vu(a, h, u, d, f, p, T.x, T.y) &&
        cn(T.prev, T, T.next) >= 0)
    )
      return !1;
    T = T.nextZ;
  }
  for (; _ && _.z >= v; ) {
    if (
      _.x >= m &&
      _.x <= w &&
      _.y >= y &&
      _.y <= S &&
      _ !== r &&
      _ !== o &&
      vu(a, h, u, d, f, p, _.x, _.y) &&
      cn(_.prev, _, _.next) >= 0
    )
      return !1;
    _ = _.prevZ;
  }
  for (; T && T.z <= M; ) {
    if (
      T.x >= m &&
      T.x <= w &&
      T.y >= y &&
      T.y <= S &&
      T !== r &&
      T !== o &&
      vu(a, h, u, d, f, p, T.x, T.y) &&
      cn(T.prev, T, T.next) >= 0
    )
      return !1;
    T = T.nextZ;
  }
  return !0;
}
function g7(n, e, t) {
  let i = n;
  do {
    const r = i.prev,
      s = i.next.next;
    !Jg(r, s) &&
      tI(r, i, i.next, s) &&
      Xf(r, s) &&
      Xf(s, r) &&
      (e.push((r.i / t) | 0),
      e.push((i.i / t) | 0),
      e.push((s.i / t) | 0),
      Yf(i),
      Yf(i.next),
      (i = n = s)),
      (i = i.next);
  } while (i !== n);
  return Ja(i);
}
function v7(n, e, t, i, r, s) {
  let o = n;
  do {
    let a = o.next.next;
    for (; a !== o.prev; ) {
      if (o.i !== a.i && A7(o, a)) {
        let u = nI(o, a);
        (o = Ja(o, o.next)),
          (u = Ja(u, u.next)),
          jf(o, e, t, i, r, s, 0),
          jf(u, e, t, i, r, s, 0);
        return;
      }
      a = a.next;
    }
    o = o.next;
  } while (o !== n);
}
function y7(n, e, t, i) {
  const r = [];
  let s, o, a, u, f;
  for (s = 0, o = e.length; s < o; s++)
    (a = e[s] * i),
      (u = s < o - 1 ? e[s + 1] * i : n.length),
      (f = eI(n, a, u, i, !1)),
      f === f.next && (f.steiner = !0),
      r.push(T7(f));
  for (r.sort(x7), s = 0; s < r.length; s++) t = _7(r[s], t);
  return t;
}
function x7(n, e) {
  return n.x - e.x;
}
function _7(n, e) {
  const t = S7(n, e);
  if (!t) return e;
  const i = nI(t, n);
  return Ja(i, i.next), Ja(t, t.next);
}
function S7(n, e) {
  let t = e,
    i = -1 / 0,
    r;
  const s = n.x,
    o = n.y;
  do {
    if (o <= t.y && o >= t.next.y && t.next.y !== t.y) {
      const p = t.x + ((o - t.y) * (t.next.x - t.x)) / (t.next.y - t.y);
      if (
        p <= s &&
        p > i &&
        ((i = p), (r = t.x < t.next.x ? t : t.next), p === s)
      )
        return r;
    }
    t = t.next;
  } while (t !== e);
  if (!r) return null;
  const a = r,
    u = r.x,
    f = r.y;
  let h = 1 / 0,
    d;
  t = r;
  do
    s >= t.x &&
      t.x >= u &&
      s !== t.x &&
      vu(o < f ? s : i, o, u, f, o < f ? i : s, o, t.x, t.y) &&
      ((d = Math.abs(o - t.y) / (s - t.x)),
      Xf(t, n) &&
        (d < h || (d === h && (t.x > r.x || (t.x === r.x && M7(r, t))))) &&
        ((r = t), (h = d))),
      (t = t.next);
  while (t !== a);
  return r;
}
function M7(n, e) {
  return cn(n.prev, n, e.prev) < 0 && cn(e.next, n, n.next) < 0;
}
function w7(n, e, t, i) {
  let r = n;
  do
    r.z === 0 && (r.z = V_(r.x, r.y, e, t, i)),
      (r.prevZ = r.prev),
      (r.nextZ = r.next),
      (r = r.next);
  while (r !== n);
  (r.prevZ.nextZ = null), (r.prevZ = null), E7(r);
}
function E7(n) {
  let e,
    t,
    i,
    r,
    s,
    o,
    a,
    u,
    f = 1;
  do {
    for (t = n, n = null, s = null, o = 0; t; ) {
      for (o++, i = t, a = 0, e = 0; e < f && (a++, (i = i.nextZ), !!i); e++);
      for (u = f; a > 0 || (u > 0 && i); )
        a !== 0 && (u === 0 || !i || t.z <= i.z)
          ? ((r = t), (t = t.nextZ), a--)
          : ((r = i), (i = i.nextZ), u--),
          s ? (s.nextZ = r) : (n = r),
          (r.prevZ = s),
          (s = r);
      t = i;
    }
    (s.nextZ = null), (f *= 2);
  } while (o > 1);
  return n;
}
function V_(n, e, t, i, r) {
  return (
    (n = ((n - t) * r) | 0),
    (e = ((e - i) * r) | 0),
    (n = (n | (n << 8)) & 16711935),
    (n = (n | (n << 4)) & 252645135),
    (n = (n | (n << 2)) & 858993459),
    (n = (n | (n << 1)) & 1431655765),
    (e = (e | (e << 8)) & 16711935),
    (e = (e | (e << 4)) & 252645135),
    (e = (e | (e << 2)) & 858993459),
    (e = (e | (e << 1)) & 1431655765),
    n | (e << 1)
  );
}
function T7(n) {
  let e = n,
    t = n;
  do (e.x < t.x || (e.x === t.x && e.y < t.y)) && (t = e), (e = e.next);
  while (e !== n);
  return t;
}
function vu(n, e, t, i, r, s, o, a) {
  return (
    (r - o) * (e - a) >= (n - o) * (s - a) &&
    (n - o) * (i - a) >= (t - o) * (e - a) &&
    (t - o) * (s - a) >= (r - o) * (i - a)
  );
}
function A7(n, e) {
  return (
    n.next.i !== e.i &&
    n.prev.i !== e.i &&
    !b7(n, e) &&
    ((Xf(n, e) &&
      Xf(e, n) &&
      C7(n, e) &&
      (cn(n.prev, n, e.prev) || cn(n, e.prev, e))) ||
      (Jg(n, e) && cn(n.prev, n, n.next) > 0 && cn(e.prev, e, e.next) > 0))
  );
}
function cn(n, e, t) {
  return (e.y - n.y) * (t.x - e.x) - (e.x - n.x) * (t.y - e.y);
}
function Jg(n, e) {
  return n.x === e.x && n.y === e.y;
}
function tI(n, e, t, i) {
  const r = Op(cn(n, e, t)),
    s = Op(cn(n, e, i)),
    o = Op(cn(t, i, n)),
    a = Op(cn(t, i, e));
  return !!(
    (r !== s && o !== a) ||
    (r === 0 && Dp(n, t, e)) ||
    (s === 0 && Dp(n, i, e)) ||
    (o === 0 && Dp(t, n, i)) ||
    (a === 0 && Dp(t, e, i))
  );
}
function Dp(n, e, t) {
  return (
    e.x <= Math.max(n.x, t.x) &&
    e.x >= Math.min(n.x, t.x) &&
    e.y <= Math.max(n.y, t.y) &&
    e.y >= Math.min(n.y, t.y)
  );
}
function Op(n) {
  return n > 0 ? 1 : n < 0 ? -1 : 0;
}
function b7(n, e) {
  let t = n;
  do {
    if (
      t.i !== n.i &&
      t.next.i !== n.i &&
      t.i !== e.i &&
      t.next.i !== e.i &&
      tI(t, t.next, n, e)
    )
      return !0;
    t = t.next;
  } while (t !== n);
  return !1;
}
function Xf(n, e) {
  return cn(n.prev, n, n.next) < 0
    ? cn(n, e, n.next) >= 0 && cn(n, n.prev, e) >= 0
    : cn(n, e, n.prev) < 0 || cn(n, n.next, e) < 0;
}
function C7(n, e) {
  let t = n,
    i = !1;
  const r = (n.x + e.x) / 2,
    s = (n.y + e.y) / 2;
  do
    t.y > s != t.next.y > s &&
      t.next.y !== t.y &&
      r < ((t.next.x - t.x) * (s - t.y)) / (t.next.y - t.y) + t.x &&
      (i = !i),
      (t = t.next);
  while (t !== n);
  return i;
}
function nI(n, e) {
  const t = new H_(n.i, n.x, n.y),
    i = new H_(e.i, e.x, e.y),
    r = n.next,
    s = e.prev;
  return (
    (n.next = e),
    (e.prev = n),
    (t.next = r),
    (r.prev = t),
    (i.next = t),
    (t.prev = i),
    (s.next = i),
    (i.prev = s),
    i
  );
}
function PA(n, e, t, i) {
  const r = new H_(n, e, t);
  return (
    i
      ? ((r.next = i.next), (r.prev = i), (i.next.prev = r), (i.next = r))
      : ((r.prev = r), (r.next = r)),
    r
  );
}
function Yf(n) {
  (n.next.prev = n.prev),
    (n.prev.next = n.next),
    n.prevZ && (n.prevZ.nextZ = n.nextZ),
    n.nextZ && (n.nextZ.prevZ = n.prevZ);
}
function H_(n, e, t) {
  (this.i = n),
    (this.x = e),
    (this.y = t),
    (this.prev = null),
    (this.next = null),
    (this.z = 0),
    (this.prevZ = null),
    (this.nextZ = null),
    (this.steiner = !1);
}
function P7(n, e, t, i) {
  let r = 0;
  for (let s = e, o = t - i; s < t; s += i)
    (r += (n[o] - n[s]) * (n[s + 1] + n[o + 1])), (o = s);
  return r;
}
class fs {
  static area(e) {
    const t = e.length;
    let i = 0;
    for (let r = t - 1, s = 0; s < t; r = s++)
      i += e[r].x * e[s].y - e[s].x * e[r].y;
    return i * 0.5;
  }
  static isClockWise(e) {
    return fs.area(e) < 0;
  }
  static triangulateShape(e, t) {
    const i = [],
      r = [],
      s = [];
    RA(e), LA(i, e);
    let o = e.length;
    t.forEach(RA);
    for (let u = 0; u < t.length; u++)
      r.push(o), (o += t[u].length), LA(i, t[u]);
    const a = d7.triangulate(i, r);
    for (let u = 0; u < a.length; u += 3) s.push(a.slice(u, u + 3));
    return s;
  }
}
function RA(n) {
  const e = n.length;
  e > 2 && n[e - 1].equals(n[0]) && n.pop();
}
function LA(n, e) {
  for (let t = 0; t < e.length; t++) n.push(e[t].x), n.push(e[t].y);
}
class ev extends Tt {
  constructor(
    e = new ja([
      new de(0.5, 0.5),
      new de(-0.5, 0.5),
      new de(-0.5, -0.5),
      new de(0.5, -0.5),
    ]),
    t = {}
  ) {
    super(),
      (this.type = "ExtrudeGeometry"),
      (this.parameters = { shapes: e, options: t }),
      (e = Array.isArray(e) ? e : [e]);
    const i = this,
      r = [],
      s = [];
    for (let a = 0, u = e.length; a < u; a++) {
      const f = e[a];
      o(f);
    }
    this.setAttribute("position", new Ze(r, 3)),
      this.setAttribute("uv", new Ze(s, 2)),
      this.computeVertexNormals();
    function o(a) {
      const u = [],
        f = t.curveSegments !== void 0 ? t.curveSegments : 12,
        h = t.steps !== void 0 ? t.steps : 1,
        d = t.depth !== void 0 ? t.depth : 1;
      let p = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0,
        m = t.bevelThickness !== void 0 ? t.bevelThickness : 0.2,
        y = t.bevelSize !== void 0 ? t.bevelSize : m - 0.1,
        w = t.bevelOffset !== void 0 ? t.bevelOffset : 0,
        S = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
      const v = t.extrudePath,
        M = t.UVGenerator !== void 0 ? t.UVGenerator : R7;
      let _,
        T = !1,
        P,
        b,
        L,
        N;
      v &&
        ((_ = v.getSpacedPoints(h)),
        (T = !0),
        (p = !1),
        (P = v.computeFrenetFrames(h, !1)),
        (b = new U()),
        (L = new U()),
        (N = new U())),
        p || ((S = 0), (m = 0), (y = 0), (w = 0));
      const C = a.extractPoints(f);
      let R = C.shape;
      const B = C.holes;
      if (!fs.isClockWise(R)) {
        R = R.reverse();
        for (let H = 0, Me = B.length; H < Me; H++) {
          const pe = B[H];
          fs.isClockWise(pe) && (B[H] = pe.reverse());
        }
      }
      const ae = fs.triangulateShape(R, B),
        V = R;
      for (let H = 0, Me = B.length; H < Me; H++) {
        const pe = B[H];
        R = R.concat(pe);
      }
      function Q(H, Me, pe) {
        return (
          Me || console.error("THREE.ExtrudeGeometry: vec does not exist"),
          H.clone().addScaledVector(Me, pe)
        );
      }
      const $ = R.length,
        ce = ae.length;
      function k(H, Me, pe) {
        let Te, me, Ke;
        const Ne = H.x - Me.x,
          D = H.y - Me.y,
          I = pe.x - H.x,
          te = pe.y - H.y,
          xe = Ne * Ne + D * D,
          ye = Ne * te - D * I;
        if (Math.abs(ye) > Number.EPSILON) {
          const ge = Math.sqrt(xe),
            Ye = Math.sqrt(I * I + te * te),
            Le = Me.x - D / ge,
            Fe = Me.y + Ne / ge,
            tt = pe.x - te / Ye,
            mt = pe.y + I / Ye,
            _e = ((tt - Le) * te - (mt - Fe) * I) / (Ne * te - D * I);
          (Te = Le + Ne * _e - H.x), (me = Fe + D * _e - H.y);
          const Rt = Te * Te + me * me;
          if (Rt <= 2) return new de(Te, me);
          Ke = Math.sqrt(Rt / 2);
        } else {
          let ge = !1;
          Ne > Number.EPSILON
            ? I > Number.EPSILON && (ge = !0)
            : Ne < -Number.EPSILON
            ? I < -Number.EPSILON && (ge = !0)
            : Math.sign(D) === Math.sign(te) && (ge = !0),
            ge
              ? ((Te = -D), (me = Ne), (Ke = Math.sqrt(xe)))
              : ((Te = Ne), (me = D), (Ke = Math.sqrt(xe / 2)));
        }
        return new de(Te / Ke, me / Ke);
      }
      const G = [];
      for (
        let H = 0, Me = V.length, pe = Me - 1, Te = H + 1;
        H < Me;
        H++, pe++, Te++
      )
        pe === Me && (pe = 0),
          Te === Me && (Te = 0),
          (G[H] = k(V[H], V[pe], V[Te]));
      const W = [];
      let Y,
        ie = G.concat();
      for (let H = 0, Me = B.length; H < Me; H++) {
        const pe = B[H];
        Y = [];
        for (
          let Te = 0, me = pe.length, Ke = me - 1, Ne = Te + 1;
          Te < me;
          Te++, Ke++, Ne++
        )
          Ke === me && (Ke = 0),
            Ne === me && (Ne = 0),
            (Y[Te] = k(pe[Te], pe[Ke], pe[Ne]));
        W.push(Y), (ie = ie.concat(Y));
      }
      for (let H = 0; H < S; H++) {
        const Me = H / S,
          pe = m * Math.cos((Me * Math.PI) / 2),
          Te = y * Math.sin((Me * Math.PI) / 2) + w;
        for (let me = 0, Ke = V.length; me < Ke; me++) {
          const Ne = Q(V[me], G[me], Te);
          Pe(Ne.x, Ne.y, -pe);
        }
        for (let me = 0, Ke = B.length; me < Ke; me++) {
          const Ne = B[me];
          Y = W[me];
          for (let D = 0, I = Ne.length; D < I; D++) {
            const te = Q(Ne[D], Y[D], Te);
            Pe(te.x, te.y, -pe);
          }
        }
      }
      const J = y + w;
      for (let H = 0; H < $; H++) {
        const Me = p ? Q(R[H], ie[H], J) : R[H];
        T
          ? (L.copy(P.normals[0]).multiplyScalar(Me.x),
            b.copy(P.binormals[0]).multiplyScalar(Me.y),
            N.copy(_[0]).add(L).add(b),
            Pe(N.x, N.y, N.z))
          : Pe(Me.x, Me.y, 0);
      }
      for (let H = 1; H <= h; H++)
        for (let Me = 0; Me < $; Me++) {
          const pe = p ? Q(R[Me], ie[Me], J) : R[Me];
          T
            ? (L.copy(P.normals[H]).multiplyScalar(pe.x),
              b.copy(P.binormals[H]).multiplyScalar(pe.y),
              N.copy(_[H]).add(L).add(b),
              Pe(N.x, N.y, N.z))
            : Pe(pe.x, pe.y, (d / h) * H);
        }
      for (let H = S - 1; H >= 0; H--) {
        const Me = H / S,
          pe = m * Math.cos((Me * Math.PI) / 2),
          Te = y * Math.sin((Me * Math.PI) / 2) + w;
        for (let me = 0, Ke = V.length; me < Ke; me++) {
          const Ne = Q(V[me], G[me], Te);
          Pe(Ne.x, Ne.y, d + pe);
        }
        for (let me = 0, Ke = B.length; me < Ke; me++) {
          const Ne = B[me];
          Y = W[me];
          for (let D = 0, I = Ne.length; D < I; D++) {
            const te = Q(Ne[D], Y[D], Te);
            T
              ? Pe(te.x, te.y + _[h - 1].y, _[h - 1].x + pe)
              : Pe(te.x, te.y, d + pe);
          }
        }
      }
      he(), Ee();
      function he() {
        const H = r.length / 3;
        if (p) {
          let Me = 0,
            pe = $ * Me;
          for (let Te = 0; Te < ce; Te++) {
            const me = ae[Te];
            it(me[2] + pe, me[1] + pe, me[0] + pe);
          }
          (Me = h + S * 2), (pe = $ * Me);
          for (let Te = 0; Te < ce; Te++) {
            const me = ae[Te];
            it(me[0] + pe, me[1] + pe, me[2] + pe);
          }
        } else {
          for (let Me = 0; Me < ce; Me++) {
            const pe = ae[Me];
            it(pe[2], pe[1], pe[0]);
          }
          for (let Me = 0; Me < ce; Me++) {
            const pe = ae[Me];
            it(pe[0] + $ * h, pe[1] + $ * h, pe[2] + $ * h);
          }
        }
        i.addGroup(H, r.length / 3 - H, 0);
      }
      function Ee() {
        const H = r.length / 3;
        let Me = 0;
        be(V, Me), (Me += V.length);
        for (let pe = 0, Te = B.length; pe < Te; pe++) {
          const me = B[pe];
          be(me, Me), (Me += me.length);
        }
        i.addGroup(H, r.length / 3 - H, 1);
      }
      function be(H, Me) {
        let pe = H.length;
        for (; --pe >= 0; ) {
          const Te = pe;
          let me = pe - 1;
          me < 0 && (me = H.length - 1);
          for (let Ke = 0, Ne = h + S * 2; Ke < Ne; Ke++) {
            const D = $ * Ke,
              I = $ * (Ke + 1),
              te = Me + Te + D,
              xe = Me + me + D,
              ye = Me + me + I,
              ge = Me + Te + I;
            rt(te, xe, ye, ge);
          }
        }
      }
      function Pe(H, Me, pe) {
        u.push(H), u.push(Me), u.push(pe);
      }
      function it(H, Me, pe) {
        Ve(H), Ve(Me), Ve(pe);
        const Te = r.length / 3,
          me = M.generateTopUV(i, r, Te - 3, Te - 2, Te - 1);
        We(me[0]), We(me[1]), We(me[2]);
      }
      function rt(H, Me, pe, Te) {
        Ve(H), Ve(Me), Ve(Te), Ve(Me), Ve(pe), Ve(Te);
        const me = r.length / 3,
          Ke = M.generateSideWallUV(i, r, me - 6, me - 3, me - 2, me - 1);
        We(Ke[0]), We(Ke[1]), We(Ke[3]), We(Ke[1]), We(Ke[2]), We(Ke[3]);
      }
      function Ve(H) {
        r.push(u[H * 3 + 0]), r.push(u[H * 3 + 1]), r.push(u[H * 3 + 2]);
      }
      function We(H) {
        s.push(H.x), s.push(H.y);
      }
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  toJSON() {
    const e = super.toJSON(),
      t = this.parameters.shapes,
      i = this.parameters.options;
    return L7(t, i, e);
  }
  static fromJSON(e, t) {
    const i = [];
    for (let s = 0, o = e.shapes.length; s < o; s++) {
      const a = t[e.shapes[s]];
      i.push(a);
    }
    const r = e.options.extrudePath;
    return (
      r !== void 0 && (e.options.extrudePath = new ng[r.type]().fromJSON(r)),
      new ev(i, e.options)
    );
  }
}
const R7 = {
  generateTopUV: function (n, e, t, i, r) {
    const s = e[t * 3],
      o = e[t * 3 + 1],
      a = e[i * 3],
      u = e[i * 3 + 1],
      f = e[r * 3],
      h = e[r * 3 + 1];
    return [new de(s, o), new de(a, u), new de(f, h)];
  },
  generateSideWallUV: function (n, e, t, i, r, s) {
    const o = e[t * 3],
      a = e[t * 3 + 1],
      u = e[t * 3 + 2],
      f = e[i * 3],
      h = e[i * 3 + 1],
      d = e[i * 3 + 2],
      p = e[r * 3],
      m = e[r * 3 + 1],
      y = e[r * 3 + 2],
      w = e[s * 3],
      S = e[s * 3 + 1],
      v = e[s * 3 + 2];
    return Math.abs(a - h) < Math.abs(o - f)
      ? [new de(o, 1 - u), new de(f, 1 - d), new de(p, 1 - y), new de(w, 1 - v)]
      : [
          new de(a, 1 - u),
          new de(h, 1 - d),
          new de(m, 1 - y),
          new de(S, 1 - v),
        ];
  },
};
function L7(n, e, t) {
  if (((t.shapes = []), Array.isArray(n)))
    for (let i = 0, r = n.length; i < r; i++) {
      const s = n[i];
      t.shapes.push(s.uuid);
    }
  else t.shapes.push(n.uuid);
  return (
    (t.options = Object.assign({}, e)),
    e.extrudePath !== void 0 &&
      (t.options.extrudePath = e.extrudePath.toJSON()),
    t
  );
}
class tv extends $o {
  constructor(e = 1, t = 0) {
    const i = (1 + Math.sqrt(5)) / 2,
      r = [
        -1,
        i,
        0,
        1,
        i,
        0,
        -1,
        -i,
        0,
        1,
        -i,
        0,
        0,
        -1,
        i,
        0,
        1,
        i,
        0,
        -1,
        -i,
        0,
        1,
        -i,
        i,
        0,
        -1,
        i,
        0,
        1,
        -i,
        0,
        -1,
        -i,
        0,
        1,
      ],
      s = [
        0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11,
        10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9,
        4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1,
      ];
    super(r, s, e, t),
      (this.type = "IcosahedronGeometry"),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new tv(e.radius, e.detail);
  }
}
class Eh extends $o {
  constructor(e = 1, t = 0) {
    const i = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
      r = [
        0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2,
      ];
    super(i, r, e, t),
      (this.type = "OctahedronGeometry"),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new Eh(e.radius, e.detail);
  }
}
class nv extends Tt {
  constructor(e = 0.5, t = 1, i = 32, r = 1, s = 0, o = Math.PI * 2) {
    super(),
      (this.type = "RingGeometry"),
      (this.parameters = {
        innerRadius: e,
        outerRadius: t,
        thetaSegments: i,
        phiSegments: r,
        thetaStart: s,
        thetaLength: o,
      }),
      (i = Math.max(3, i)),
      (r = Math.max(1, r));
    const a = [],
      u = [],
      f = [],
      h = [];
    let d = e;
    const p = (t - e) / r,
      m = new U(),
      y = new de();
    for (let w = 0; w <= r; w++) {
      for (let S = 0; S <= i; S++) {
        const v = s + (S / i) * o;
        (m.x = d * Math.cos(v)),
          (m.y = d * Math.sin(v)),
          u.push(m.x, m.y, m.z),
          f.push(0, 0, 1),
          (y.x = (m.x / t + 1) / 2),
          (y.y = (m.y / t + 1) / 2),
          h.push(y.x, y.y);
      }
      d += p;
    }
    for (let w = 0; w < r; w++) {
      const S = w * (i + 1);
      for (let v = 0; v < i; v++) {
        const M = v + S,
          _ = M,
          T = M + i + 1,
          P = M + i + 2,
          b = M + 1;
        a.push(_, T, b), a.push(T, P, b);
      }
    }
    this.setIndex(a),
      this.setAttribute("position", new Ze(u, 3)),
      this.setAttribute("normal", new Ze(f, 3)),
      this.setAttribute("uv", new Ze(h, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new nv(
      e.innerRadius,
      e.outerRadius,
      e.thetaSegments,
      e.phiSegments,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class iv extends Tt {
  constructor(
    e = new ja([new de(0, 0.5), new de(-0.5, -0.5), new de(0.5, -0.5)]),
    t = 12
  ) {
    super(),
      (this.type = "ShapeGeometry"),
      (this.parameters = { shapes: e, curveSegments: t });
    const i = [],
      r = [],
      s = [],
      o = [];
    let a = 0,
      u = 0;
    if (Array.isArray(e) === !1) f(e);
    else
      for (let h = 0; h < e.length; h++)
        f(e[h]), this.addGroup(a, u, h), (a += u), (u = 0);
    this.setIndex(i),
      this.setAttribute("position", new Ze(r, 3)),
      this.setAttribute("normal", new Ze(s, 3)),
      this.setAttribute("uv", new Ze(o, 2));
    function f(h) {
      const d = r.length / 3,
        p = h.extractPoints(t);
      let m = p.shape;
      const y = p.holes;
      fs.isClockWise(m) === !1 && (m = m.reverse());
      for (let S = 0, v = y.length; S < v; S++) {
        const M = y[S];
        fs.isClockWise(M) === !0 && (y[S] = M.reverse());
      }
      const w = fs.triangulateShape(m, y);
      for (let S = 0, v = y.length; S < v; S++) {
        const M = y[S];
        m = m.concat(M);
      }
      for (let S = 0, v = m.length; S < v; S++) {
        const M = m[S];
        r.push(M.x, M.y, 0), s.push(0, 0, 1), o.push(M.x, M.y);
      }
      for (let S = 0, v = w.length; S < v; S++) {
        const M = w[S],
          _ = M[0] + d,
          T = M[1] + d,
          P = M[2] + d;
        i.push(_, T, P), (u += 3);
      }
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  toJSON() {
    const e = super.toJSON(),
      t = this.parameters.shapes;
    return I7(t, e);
  }
  static fromJSON(e, t) {
    const i = [];
    for (let r = 0, s = e.shapes.length; r < s; r++) {
      const o = t[e.shapes[r]];
      i.push(o);
    }
    return new iv(i, e.curveSegments);
  }
}
function I7(n, e) {
  if (((e.shapes = []), Array.isArray(n)))
    for (let t = 0, i = n.length; t < i; t++) {
      const r = n[t];
      e.shapes.push(r.uuid);
    }
  else e.shapes.push(n.uuid);
  return e;
}
class Th extends Tt {
  constructor(
    e = 1,
    t = 32,
    i = 16,
    r = 0,
    s = Math.PI * 2,
    o = 0,
    a = Math.PI
  ) {
    super(),
      (this.type = "SphereGeometry"),
      (this.parameters = {
        radius: e,
        widthSegments: t,
        heightSegments: i,
        phiStart: r,
        phiLength: s,
        thetaStart: o,
        thetaLength: a,
      }),
      (t = Math.max(3, Math.floor(t))),
      (i = Math.max(2, Math.floor(i)));
    const u = Math.min(o + a, Math.PI);
    let f = 0;
    const h = [],
      d = new U(),
      p = new U(),
      m = [],
      y = [],
      w = [],
      S = [];
    for (let v = 0; v <= i; v++) {
      const M = [],
        _ = v / i;
      let T = 0;
      v === 0 && o === 0
        ? (T = 0.5 / t)
        : v === i && u === Math.PI && (T = -0.5 / t);
      for (let P = 0; P <= t; P++) {
        const b = P / t;
        (d.x = -e * Math.cos(r + b * s) * Math.sin(o + _ * a)),
          (d.y = e * Math.cos(o + _ * a)),
          (d.z = e * Math.sin(r + b * s) * Math.sin(o + _ * a)),
          y.push(d.x, d.y, d.z),
          p.copy(d).normalize(),
          w.push(p.x, p.y, p.z),
          S.push(b + T, 1 - _),
          M.push(f++);
      }
      h.push(M);
    }
    for (let v = 0; v < i; v++)
      for (let M = 0; M < t; M++) {
        const _ = h[v][M + 1],
          T = h[v][M],
          P = h[v + 1][M],
          b = h[v + 1][M + 1];
        (v !== 0 || o > 0) && m.push(_, T, b),
          (v !== i - 1 || u < Math.PI) && m.push(T, P, b);
      }
    this.setIndex(m),
      this.setAttribute("position", new Ze(y, 3)),
      this.setAttribute("normal", new Ze(w, 3)),
      this.setAttribute("uv", new Ze(S, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Th(
      e.radius,
      e.widthSegments,
      e.heightSegments,
      e.phiStart,
      e.phiLength,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class rv extends $o {
  constructor(e = 1, t = 0) {
    const i = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
      r = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
    super(i, r, e, t),
      (this.type = "TetrahedronGeometry"),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new rv(e.radius, e.detail);
  }
}
class sv extends Tt {
  constructor(e = 1, t = 0.4, i = 12, r = 48, s = Math.PI * 2) {
    super(),
      (this.type = "TorusGeometry"),
      (this.parameters = {
        radius: e,
        tube: t,
        radialSegments: i,
        tubularSegments: r,
        arc: s,
      }),
      (i = Math.floor(i)),
      (r = Math.floor(r));
    const o = [],
      a = [],
      u = [],
      f = [],
      h = new U(),
      d = new U(),
      p = new U();
    for (let m = 0; m <= i; m++)
      for (let y = 0; y <= r; y++) {
        const w = (y / r) * s,
          S = (m / i) * Math.PI * 2;
        (d.x = (e + t * Math.cos(S)) * Math.cos(w)),
          (d.y = (e + t * Math.cos(S)) * Math.sin(w)),
          (d.z = t * Math.sin(S)),
          a.push(d.x, d.y, d.z),
          (h.x = e * Math.cos(w)),
          (h.y = e * Math.sin(w)),
          p.subVectors(d, h).normalize(),
          u.push(p.x, p.y, p.z),
          f.push(y / r),
          f.push(m / i);
      }
    for (let m = 1; m <= i; m++)
      for (let y = 1; y <= r; y++) {
        const w = (r + 1) * m + y - 1,
          S = (r + 1) * (m - 1) + y - 1,
          v = (r + 1) * (m - 1) + y,
          M = (r + 1) * m + y;
        o.push(w, S, M), o.push(S, v, M);
      }
    this.setIndex(o),
      this.setAttribute("position", new Ze(a, 3)),
      this.setAttribute("normal", new Ze(u, 3)),
      this.setAttribute("uv", new Ze(f, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new sv(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
  }
}
class ov extends Tt {
  constructor(e = 1, t = 0.4, i = 64, r = 8, s = 2, o = 3) {
    super(),
      (this.type = "TorusKnotGeometry"),
      (this.parameters = {
        radius: e,
        tube: t,
        tubularSegments: i,
        radialSegments: r,
        p: s,
        q: o,
      }),
      (i = Math.floor(i)),
      (r = Math.floor(r));
    const a = [],
      u = [],
      f = [],
      h = [],
      d = new U(),
      p = new U(),
      m = new U(),
      y = new U(),
      w = new U(),
      S = new U(),
      v = new U();
    for (let _ = 0; _ <= i; ++_) {
      const T = (_ / i) * s * Math.PI * 2;
      M(T, s, o, e, m),
        M(T + 0.01, s, o, e, y),
        S.subVectors(y, m),
        v.addVectors(y, m),
        w.crossVectors(S, v),
        v.crossVectors(w, S),
        w.normalize(),
        v.normalize();
      for (let P = 0; P <= r; ++P) {
        const b = (P / r) * Math.PI * 2,
          L = -t * Math.cos(b),
          N = t * Math.sin(b);
        (d.x = m.x + (L * v.x + N * w.x)),
          (d.y = m.y + (L * v.y + N * w.y)),
          (d.z = m.z + (L * v.z + N * w.z)),
          u.push(d.x, d.y, d.z),
          p.subVectors(d, m).normalize(),
          f.push(p.x, p.y, p.z),
          h.push(_ / i),
          h.push(P / r);
      }
    }
    for (let _ = 1; _ <= i; _++)
      for (let T = 1; T <= r; T++) {
        const P = (r + 1) * (_ - 1) + (T - 1),
          b = (r + 1) * _ + (T - 1),
          L = (r + 1) * _ + T,
          N = (r + 1) * (_ - 1) + T;
        a.push(P, b, N), a.push(b, L, N);
      }
    this.setIndex(a),
      this.setAttribute("position", new Ze(u, 3)),
      this.setAttribute("normal", new Ze(f, 3)),
      this.setAttribute("uv", new Ze(h, 2));
    function M(_, T, P, b, L) {
      const N = Math.cos(_),
        C = Math.sin(_),
        R = (P / T) * _,
        B = Math.cos(R);
      (L.x = b * (2 + B) * 0.5 * N),
        (L.y = b * (2 + B) * C * 0.5),
        (L.z = b * Math.sin(R) * 0.5);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new ov(
      e.radius,
      e.tube,
      e.tubularSegments,
      e.radialSegments,
      e.p,
      e.q
    );
  }
}
class av extends Tt {
  constructor(
    e = new KS(new U(-1, -1, 0), new U(-1, 1, 0), new U(1, 1, 0)),
    t = 64,
    i = 1,
    r = 8,
    s = !1
  ) {
    super(),
      (this.type = "TubeGeometry"),
      (this.parameters = {
        path: e,
        tubularSegments: t,
        radius: i,
        radialSegments: r,
        closed: s,
      });
    const o = e.computeFrenetFrames(t, s);
    (this.tangents = o.tangents),
      (this.normals = o.normals),
      (this.binormals = o.binormals);
    const a = new U(),
      u = new U(),
      f = new de();
    let h = new U();
    const d = [],
      p = [],
      m = [],
      y = [];
    w(),
      this.setIndex(y),
      this.setAttribute("position", new Ze(d, 3)),
      this.setAttribute("normal", new Ze(p, 3)),
      this.setAttribute("uv", new Ze(m, 2));
    function w() {
      for (let _ = 0; _ < t; _++) S(_);
      S(s === !1 ? t : 0), M(), v();
    }
    function S(_) {
      h = e.getPointAt(_ / t, h);
      const T = o.normals[_],
        P = o.binormals[_];
      for (let b = 0; b <= r; b++) {
        const L = (b / r) * Math.PI * 2,
          N = Math.sin(L),
          C = -Math.cos(L);
        (u.x = C * T.x + N * P.x),
          (u.y = C * T.y + N * P.y),
          (u.z = C * T.z + N * P.z),
          u.normalize(),
          p.push(u.x, u.y, u.z),
          (a.x = h.x + i * u.x),
          (a.y = h.y + i * u.y),
          (a.z = h.z + i * u.z),
          d.push(a.x, a.y, a.z);
      }
    }
    function v() {
      for (let _ = 1; _ <= t; _++)
        for (let T = 1; T <= r; T++) {
          const P = (r + 1) * (_ - 1) + (T - 1),
            b = (r + 1) * _ + (T - 1),
            L = (r + 1) * _ + T,
            N = (r + 1) * (_ - 1) + T;
          y.push(P, b, N), y.push(b, L, N);
        }
    }
    function M() {
      for (let _ = 0; _ <= t; _++)
        for (let T = 0; T <= r; T++)
          (f.x = _ / t), (f.y = T / r), m.push(f.x, f.y);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (e.path = this.parameters.path.toJSON()), e;
  }
  static fromJSON(e) {
    return new av(
      new ng[e.path.type]().fromJSON(e.path),
      e.tubularSegments,
      e.radius,
      e.radialSegments,
      e.closed
    );
  }
}
class iI extends Tt {
  constructor(e = null) {
    if (
      (super(),
      (this.type = "WireframeGeometry"),
      (this.parameters = { geometry: e }),
      e !== null)
    ) {
      const t = [],
        i = new Set(),
        r = new U(),
        s = new U();
      if (e.index !== null) {
        const o = e.attributes.position,
          a = e.index;
        let u = e.groups;
        u.length === 0 &&
          (u = [{ start: 0, count: a.count, materialIndex: 0 }]);
        for (let f = 0, h = u.length; f < h; ++f) {
          const d = u[f],
            p = d.start,
            m = d.count;
          for (let y = p, w = p + m; y < w; y += 3)
            for (let S = 0; S < 3; S++) {
              const v = a.getX(y + S),
                M = a.getX(y + ((S + 1) % 3));
              r.fromBufferAttribute(o, v),
                s.fromBufferAttribute(o, M),
                IA(r, s, i) === !0 &&
                  (t.push(r.x, r.y, r.z), t.push(s.x, s.y, s.z));
            }
        }
      } else {
        const o = e.attributes.position;
        for (let a = 0, u = o.count / 3; a < u; a++)
          for (let f = 0; f < 3; f++) {
            const h = 3 * a + f,
              d = 3 * a + ((f + 1) % 3);
            r.fromBufferAttribute(o, h),
              s.fromBufferAttribute(o, d),
              IA(r, s, i) === !0 &&
                (t.push(r.x, r.y, r.z), t.push(s.x, s.y, s.z));
          }
      }
      this.setAttribute("position", new Ze(t, 3));
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
}
function IA(n, e, t) {
  const i = `${n.x},${n.y},${n.z}-${e.x},${e.y},${e.z}`,
    r = `${e.x},${e.y},${e.z}-${n.x},${n.y},${n.z}`;
  return t.has(i) === !0 || t.has(r) === !0 ? !1 : (t.add(i), t.add(r), !0);
}
var NA = Object.freeze({
  __proto__: null,
  BoxGeometry: sl,
  CapsuleGeometry: Zg,
  CircleGeometry: Kg,
  ConeGeometry: Qg,
  CylinderGeometry: Yu,
  DodecahedronGeometry: $g,
  EdgesGeometry: JL,
  ExtrudeGeometry: ev,
  IcosahedronGeometry: tv,
  LatheGeometry: wh,
  OctahedronGeometry: Eh,
  PlaneGeometry: Mh,
  PolyhedronGeometry: $o,
  RingGeometry: nv,
  ShapeGeometry: iv,
  SphereGeometry: Th,
  TetrahedronGeometry: rv,
  TorusGeometry: sv,
  TorusKnotGeometry: ov,
  TubeGeometry: av,
  WireframeGeometry: iI,
});
class rI extends gi {
  constructor(e) {
    super(),
      (this.isShadowMaterial = !0),
      (this.type = "ShadowMaterial"),
      (this.color = new Be(0)),
      (this.transparent = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), (this.fog = e.fog), this;
  }
}
class sI extends Hr {
  constructor(e) {
    super(e),
      (this.isRawShaderMaterial = !0),
      (this.type = "RawShaderMaterial");
  }
}
class $S extends gi {
  constructor(e) {
    super(),
      (this.isMeshStandardMaterial = !0),
      (this.defines = { STANDARD: "" }),
      (this.type = "MeshStandardMaterial"),
      (this.color = new Be(16777215)),
      (this.roughness = 1),
      (this.metalness = 0),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Be(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Ko),
      (this.normalScale = new de(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.roughnessMap = null),
      (this.metalnessMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapIntensity = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "" }),
      this.color.copy(e.color),
      (this.roughness = e.roughness),
      (this.metalness = e.metalness),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.roughnessMap = e.roughnessMap),
      (this.metalnessMap = e.metalnessMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.envMapIntensity = e.envMapIntensity),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class JS extends $S {
  constructor(e) {
    super(),
      (this.isMeshPhysicalMaterial = !0),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.type = "MeshPhysicalMaterial"),
      (this.anisotropyRotation = 0),
      (this.anisotropyMap = null),
      (this.clearcoatMap = null),
      (this.clearcoatRoughness = 0),
      (this.clearcoatRoughnessMap = null),
      (this.clearcoatNormalScale = new de(1, 1)),
      (this.clearcoatNormalMap = null),
      (this.ior = 1.5),
      Object.defineProperty(this, "reflectivity", {
        get: function () {
          return vn((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
        },
        set: function (t) {
          this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
        },
      }),
      (this.iridescenceMap = null),
      (this.iridescenceIOR = 1.3),
      (this.iridescenceThicknessRange = [100, 400]),
      (this.iridescenceThicknessMap = null),
      (this.sheenColor = new Be(0)),
      (this.sheenColorMap = null),
      (this.sheenRoughness = 1),
      (this.sheenRoughnessMap = null),
      (this.transmissionMap = null),
      (this.thickness = 0),
      (this.thicknessMap = null),
      (this.attenuationDistance = 1 / 0),
      (this.attenuationColor = new Be(1, 1, 1)),
      (this.specularIntensity = 1),
      (this.specularIntensityMap = null),
      (this.specularColor = new Be(1, 1, 1)),
      (this.specularColorMap = null),
      (this._anisotropy = 0),
      (this._clearcoat = 0),
      (this._iridescence = 0),
      (this._sheen = 0),
      (this._transmission = 0),
      this.setValues(e);
  }
  get anisotropy() {
    return this._anisotropy;
  }
  set anisotropy(e) {
    this._anisotropy > 0 != e > 0 && this.version++, (this._anisotropy = e);
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(e) {
    this._clearcoat > 0 != e > 0 && this.version++, (this._clearcoat = e);
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(e) {
    this._iridescence > 0 != e > 0 && this.version++, (this._iridescence = e);
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(e) {
    this._sheen > 0 != e > 0 && this.version++, (this._sheen = e);
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(e) {
    this._transmission > 0 != e > 0 && this.version++, (this._transmission = e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.anisotropy = e.anisotropy),
      (this.anisotropyRotation = e.anisotropyRotation),
      (this.anisotropyMap = e.anisotropyMap),
      (this.clearcoat = e.clearcoat),
      (this.clearcoatMap = e.clearcoatMap),
      (this.clearcoatRoughness = e.clearcoatRoughness),
      (this.clearcoatRoughnessMap = e.clearcoatRoughnessMap),
      (this.clearcoatNormalMap = e.clearcoatNormalMap),
      this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
      (this.ior = e.ior),
      (this.iridescence = e.iridescence),
      (this.iridescenceMap = e.iridescenceMap),
      (this.iridescenceIOR = e.iridescenceIOR),
      (this.iridescenceThicknessRange = [...e.iridescenceThicknessRange]),
      (this.iridescenceThicknessMap = e.iridescenceThicknessMap),
      (this.sheen = e.sheen),
      this.sheenColor.copy(e.sheenColor),
      (this.sheenColorMap = e.sheenColorMap),
      (this.sheenRoughness = e.sheenRoughness),
      (this.sheenRoughnessMap = e.sheenRoughnessMap),
      (this.transmission = e.transmission),
      (this.transmissionMap = e.transmissionMap),
      (this.thickness = e.thickness),
      (this.thicknessMap = e.thicknessMap),
      (this.attenuationDistance = e.attenuationDistance),
      this.attenuationColor.copy(e.attenuationColor),
      (this.specularIntensity = e.specularIntensity),
      (this.specularIntensityMap = e.specularIntensityMap),
      this.specularColor.copy(e.specularColor),
      (this.specularColorMap = e.specularColorMap),
      this
    );
  }
}
class oI extends gi {
  constructor(e) {
    super(),
      (this.isMeshPhongMaterial = !0),
      (this.type = "MeshPhongMaterial"),
      (this.color = new Be(16777215)),
      (this.specular = new Be(1118481)),
      (this.shininess = 30),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Be(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Ko),
      (this.normalScale = new de(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = gh),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      this.specular.copy(e.specular),
      (this.shininess = e.shininess),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class aI extends gi {
  constructor(e) {
    super(),
      (this.isMeshToonMaterial = !0),
      (this.defines = { TOON: "" }),
      (this.type = "MeshToonMaterial"),
      (this.color = new Be(16777215)),
      (this.map = null),
      (this.gradientMap = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Be(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Ko),
      (this.normalScale = new de(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.gradientMap = e.gradientMap),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.alphaMap = e.alphaMap),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.fog = e.fog),
      this
    );
  }
}
class lI extends gi {
  constructor(e) {
    super(),
      (this.isMeshNormalMaterial = !0),
      (this.type = "MeshNormalMaterial"),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Ko),
      (this.normalScale = new de(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.flatShading = !1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.flatShading = e.flatShading),
      this
    );
  }
}
class uI extends gi {
  constructor(e) {
    super(),
      (this.isMeshLambertMaterial = !0),
      (this.type = "MeshLambertMaterial"),
      (this.color = new Be(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Be(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Ko),
      (this.normalScale = new de(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = gh),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class cI extends gi {
  constructor(e) {
    super(),
      (this.isMeshMatcapMaterial = !0),
      (this.defines = { MATCAP: "" }),
      (this.type = "MeshMatcapMaterial"),
      (this.color = new Be(16777215)),
      (this.matcap = null),
      (this.map = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Ko),
      (this.normalScale = new de(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { MATCAP: "" }),
      this.color.copy(e.color),
      (this.matcap = e.matcap),
      (this.map = e.map),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.alphaMap = e.alphaMap),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class fI extends Pi {
  constructor(e) {
    super(),
      (this.isLineDashedMaterial = !0),
      (this.type = "LineDashedMaterial"),
      (this.scale = 1),
      (this.dashSize = 3),
      (this.gapSize = 1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.scale = e.scale),
      (this.dashSize = e.dashSize),
      (this.gapSize = e.gapSize),
      this
    );
  }
}
function ka(n, e, t) {
  return !n || (!t && n.constructor === e)
    ? n
    : typeof e.BYTES_PER_ELEMENT == "number"
    ? new e(n)
    : Array.prototype.slice.call(n);
}
function hI(n) {
  return ArrayBuffer.isView(n) && !(n instanceof DataView);
}
function dI(n) {
  function e(r, s) {
    return n[r] - n[s];
  }
  const t = n.length,
    i = new Array(t);
  for (let r = 0; r !== t; ++r) i[r] = r;
  return i.sort(e), i;
}
function G_(n, e, t) {
  const i = n.length,
    r = new n.constructor(i);
  for (let s = 0, o = 0; o !== i; ++s) {
    const a = t[s] * e;
    for (let u = 0; u !== e; ++u) r[o++] = n[a + u];
  }
  return r;
}
function eM(n, e, t, i) {
  let r = 1,
    s = n[0];
  for (; s !== void 0 && s[i] === void 0; ) s = n[r++];
  if (s === void 0) return;
  let o = s[i];
  if (o !== void 0)
    if (Array.isArray(o))
      do
        (o = s[i]),
          o !== void 0 && (e.push(s.time), t.push.apply(t, o)),
          (s = n[r++]);
      while (s !== void 0);
    else if (o.toArray !== void 0)
      do
        (o = s[i]),
          o !== void 0 && (e.push(s.time), o.toArray(t, t.length)),
          (s = n[r++]);
      while (s !== void 0);
    else
      do (o = s[i]), o !== void 0 && (e.push(s.time), t.push(o)), (s = n[r++]);
      while (s !== void 0);
}
function N7(n, e, t, i, r = 30) {
  const s = n.clone();
  s.name = e;
  const o = [];
  for (let u = 0; u < s.tracks.length; ++u) {
    const f = s.tracks[u],
      h = f.getValueSize(),
      d = [],
      p = [];
    for (let m = 0; m < f.times.length; ++m) {
      const y = f.times[m] * r;
      if (!(y < t || y >= i)) {
        d.push(f.times[m]);
        for (let w = 0; w < h; ++w) p.push(f.values[m * h + w]);
      }
    }
    d.length !== 0 &&
      ((f.times = ka(d, f.times.constructor)),
      (f.values = ka(p, f.values.constructor)),
      o.push(f));
  }
  s.tracks = o;
  let a = 1 / 0;
  for (let u = 0; u < s.tracks.length; ++u)
    a > s.tracks[u].times[0] && (a = s.tracks[u].times[0]);
  for (let u = 0; u < s.tracks.length; ++u) s.tracks[u].shift(-1 * a);
  return s.resetDuration(), s;
}
function D7(n, e = 0, t = n, i = 30) {
  i <= 0 && (i = 30);
  const r = t.tracks.length,
    s = e / i;
  for (let o = 0; o < r; ++o) {
    const a = t.tracks[o],
      u = a.ValueTypeName;
    if (u === "bool" || u === "string") continue;
    const f = n.tracks.find(function (v) {
      return v.name === a.name && v.ValueTypeName === u;
    });
    if (f === void 0) continue;
    let h = 0;
    const d = a.getValueSize();
    a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
      (h = d / 3);
    let p = 0;
    const m = f.getValueSize();
    f.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
      (p = m / 3);
    const y = a.times.length - 1;
    let w;
    if (s <= a.times[0]) {
      const v = h,
        M = d - h;
      w = a.values.slice(v, M);
    } else if (s >= a.times[y]) {
      const v = y * d + h,
        M = v + d - h;
      w = a.values.slice(v, M);
    } else {
      const v = a.createInterpolant(),
        M = h,
        _ = d - h;
      v.evaluate(s), (w = v.resultBuffer.slice(M, _));
    }
    u === "quaternion" &&
      new hi().fromArray(w).normalize().conjugate().toArray(w);
    const S = f.times.length;
    for (let v = 0; v < S; ++v) {
      const M = v * m + p;
      if (u === "quaternion")
        hi.multiplyQuaternionsFlat(f.values, M, w, 0, f.values, M);
      else {
        const _ = m - p * 2;
        for (let T = 0; T < _; ++T) f.values[M + T] -= w[T];
      }
    }
  }
  return (n.blendMode = PS), n;
}
const O7 = {
  convertArray: ka,
  isTypedArray: hI,
  getKeyframeOrder: dI,
  sortedArray: G_,
  flattenJSON: eM,
  subclip: N7,
  makeClipAdditive: D7,
};
class Ah {
  constructor(e, t, i, r) {
    (this.parameterPositions = e),
      (this._cachedIndex = 0),
      (this.resultBuffer = r !== void 0 ? r : new t.constructor(i)),
      (this.sampleValues = t),
      (this.valueSize = i),
      (this.settings = null),
      (this.DefaultSettings_ = {});
  }
  evaluate(e) {
    const t = this.parameterPositions;
    let i = this._cachedIndex,
      r = t[i],
      s = t[i - 1];
    e: {
      t: {
        let o;
        n: {
          i: if (!(e < r)) {
            for (let a = i + 2; ; ) {
              if (r === void 0) {
                if (e < s) break i;
                return (
                  (i = t.length),
                  (this._cachedIndex = i),
                  this.copySampleValue_(i - 1)
                );
              }
              if (i === a) break;
              if (((s = r), (r = t[++i]), e < r)) break t;
            }
            o = t.length;
            break n;
          }
          if (!(e >= s)) {
            const a = t[1];
            e < a && ((i = 2), (s = a));
            for (let u = i - 2; ; ) {
              if (s === void 0)
                return (this._cachedIndex = 0), this.copySampleValue_(0);
              if (i === u) break;
              if (((r = s), (s = t[--i - 1]), e >= s)) break t;
            }
            (o = i), (i = 0);
            break n;
          }
          break e;
        }
        for (; i < o; ) {
          const a = (i + o) >>> 1;
          e < t[a] ? (o = a) : (i = a + 1);
        }
        if (((r = t[i]), (s = t[i - 1]), s === void 0))
          return (this._cachedIndex = 0), this.copySampleValue_(0);
        if (r === void 0)
          return (
            (i = t.length),
            (this._cachedIndex = i),
            this.copySampleValue_(i - 1)
          );
      }
      (this._cachedIndex = i), this.intervalChanged_(i, s, r);
    }
    return this.interpolate_(i, s, e, r);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(e) {
    const t = this.resultBuffer,
      i = this.sampleValues,
      r = this.valueSize,
      s = e * r;
    for (let o = 0; o !== r; ++o) t[o] = i[s + o];
    return t;
  }
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {}
}
class pI extends Ah {
  constructor(e, t, i, r) {
    super(e, t, i, r),
      (this._weightPrev = -0),
      (this._offsetPrev = -0),
      (this._weightNext = -0),
      (this._offsetNext = -0),
      (this.DefaultSettings_ = { endingStart: Da, endingEnd: Da });
  }
  intervalChanged_(e, t, i) {
    const r = this.parameterPositions;
    let s = e - 2,
      o = e + 1,
      a = r[s],
      u = r[o];
    if (a === void 0)
      switch (this.getSettings_().endingStart) {
        case Oa:
          (s = e), (a = 2 * t - i);
          break;
        case Ff:
          (s = r.length - 2), (a = t + r[s] - r[s + 1]);
          break;
        default:
          (s = e), (a = i);
      }
    if (u === void 0)
      switch (this.getSettings_().endingEnd) {
        case Oa:
          (o = e), (u = 2 * i - t);
          break;
        case Ff:
          (o = 1), (u = i + r[1] - r[0]);
          break;
        default:
          (o = e - 1), (u = t);
      }
    const f = (i - t) * 0.5,
      h = this.valueSize;
    (this._weightPrev = f / (t - a)),
      (this._weightNext = f / (u - i)),
      (this._offsetPrev = s * h),
      (this._offsetNext = o * h);
  }
  interpolate_(e, t, i, r) {
    const s = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      u = e * a,
      f = u - a,
      h = this._offsetPrev,
      d = this._offsetNext,
      p = this._weightPrev,
      m = this._weightNext,
      y = (i - t) / (r - t),
      w = y * y,
      S = w * y,
      v = -p * S + 2 * p * w - p * y,
      M = (1 + p) * S + (-1.5 - 2 * p) * w + (-0.5 + p) * y + 1,
      _ = (-1 - m) * S + (1.5 + m) * w + 0.5 * y,
      T = m * S - m * w;
    for (let P = 0; P !== a; ++P)
      s[P] = v * o[h + P] + M * o[f + P] + _ * o[u + P] + T * o[d + P];
    return s;
  }
}
class tM extends Ah {
  constructor(e, t, i, r) {
    super(e, t, i, r);
  }
  interpolate_(e, t, i, r) {
    const s = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      u = e * a,
      f = u - a,
      h = (i - t) / (r - t),
      d = 1 - h;
    for (let p = 0; p !== a; ++p) s[p] = o[f + p] * d + o[u + p] * h;
    return s;
  }
}
class mI extends Ah {
  constructor(e, t, i, r) {
    super(e, t, i, r);
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1);
  }
}
class Wr {
  constructor(e, t, i, r) {
    if (e === void 0)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (t === void 0 || t.length === 0)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
    (this.name = e),
      (this.times = ka(t, this.TimeBufferType)),
      (this.values = ka(i, this.ValueBufferType)),
      this.setInterpolation(r || this.DefaultInterpolation);
  }
  static toJSON(e) {
    const t = e.constructor;
    let i;
    if (t.toJSON !== this.toJSON) i = t.toJSON(e);
    else {
      i = {
        name: e.name,
        times: ka(e.times, Array),
        values: ka(e.values, Array),
      };
      const r = e.getInterpolation();
      r !== e.DefaultInterpolation && (i.interpolation = r);
    }
    return (i.type = e.ValueTypeName), i;
  }
  InterpolantFactoryMethodDiscrete(e) {
    return new mI(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodLinear(e) {
    return new tM(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodSmooth(e) {
    return new pI(this.times, this.values, this.getValueSize(), e);
  }
  setInterpolation(e) {
    let t;
    switch (e) {
      case Uf:
        t = this.InterpolantFactoryMethodDiscrete;
        break;
      case kf:
        t = this.InterpolantFactoryMethodLinear;
        break;
      case hm:
        t = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (t === void 0) {
      const i =
        "unsupported interpolation for " +
        this.ValueTypeName +
        " keyframe track named " +
        this.name;
      if (this.createInterpolant === void 0)
        if (e !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else throw new Error(i);
      return console.warn("THREE.KeyframeTrack:", i), this;
    }
    return (this.createInterpolant = t), this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return Uf;
      case this.InterpolantFactoryMethodLinear:
        return kf;
      case this.InterpolantFactoryMethodSmooth:
        return hm;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  shift(e) {
    if (e !== 0) {
      const t = this.times;
      for (let i = 0, r = t.length; i !== r; ++i) t[i] += e;
    }
    return this;
  }
  scale(e) {
    if (e !== 1) {
      const t = this.times;
      for (let i = 0, r = t.length; i !== r; ++i) t[i] *= e;
    }
    return this;
  }
  trim(e, t) {
    const i = this.times,
      r = i.length;
    let s = 0,
      o = r - 1;
    for (; s !== r && i[s] < e; ) ++s;
    for (; o !== -1 && i[o] > t; ) --o;
    if ((++o, s !== 0 || o !== r)) {
      s >= o && ((o = Math.max(o, 1)), (s = o - 1));
      const a = this.getValueSize();
      (this.times = i.slice(s, o)),
        (this.values = this.values.slice(s * a, o * a));
    }
    return this;
  }
  validate() {
    let e = !0;
    const t = this.getValueSize();
    t - Math.floor(t) !== 0 &&
      (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
      (e = !1));
    const i = this.times,
      r = this.values,
      s = i.length;
    s === 0 &&
      (console.error("THREE.KeyframeTrack: Track is empty.", this), (e = !1));
    let o = null;
    for (let a = 0; a !== s; a++) {
      const u = i[a];
      if (typeof u == "number" && isNaN(u)) {
        console.error(
          "THREE.KeyframeTrack: Time is not a valid number.",
          this,
          a,
          u
        ),
          (e = !1);
        break;
      }
      if (o !== null && o > u) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, a, u, o),
          (e = !1);
        break;
      }
      o = u;
    }
    if (r !== void 0 && hI(r))
      for (let a = 0, u = r.length; a !== u; ++a) {
        const f = r[a];
        if (isNaN(f)) {
          console.error(
            "THREE.KeyframeTrack: Value is not a valid number.",
            this,
            a,
            f
          ),
            (e = !1);
          break;
        }
      }
    return e;
  }
  optimize() {
    const e = this.times.slice(),
      t = this.values.slice(),
      i = this.getValueSize(),
      r = this.getInterpolation() === hm,
      s = e.length - 1;
    let o = 1;
    for (let a = 1; a < s; ++a) {
      let u = !1;
      const f = e[a],
        h = e[a + 1];
      if (f !== h && (a !== 1 || f !== e[0]))
        if (r) u = !0;
        else {
          const d = a * i,
            p = d - i,
            m = d + i;
          for (let y = 0; y !== i; ++y) {
            const w = t[d + y];
            if (w !== t[p + y] || w !== t[m + y]) {
              u = !0;
              break;
            }
          }
        }
      if (u) {
        if (a !== o) {
          e[o] = e[a];
          const d = a * i,
            p = o * i;
          for (let m = 0; m !== i; ++m) t[p + m] = t[d + m];
        }
        ++o;
      }
    }
    if (s > 0) {
      e[o] = e[s];
      for (let a = s * i, u = o * i, f = 0; f !== i; ++f) t[u + f] = t[a + f];
      ++o;
    }
    return (
      o !== e.length
        ? ((this.times = e.slice(0, o)), (this.values = t.slice(0, o * i)))
        : ((this.times = e), (this.values = t)),
      this
    );
  }
  clone() {
    const e = this.times.slice(),
      t = this.values.slice(),
      i = this.constructor,
      r = new i(this.name, e, t);
    return (r.createInterpolant = this.createInterpolant), r;
  }
}
Wr.prototype.TimeBufferType = Float32Array;
Wr.prototype.ValueBufferType = Float32Array;
Wr.prototype.DefaultInterpolation = kf;
class ol extends Wr {}
ol.prototype.ValueTypeName = "bool";
ol.prototype.ValueBufferType = Array;
ol.prototype.DefaultInterpolation = Uf;
ol.prototype.InterpolantFactoryMethodLinear = void 0;
ol.prototype.InterpolantFactoryMethodSmooth = void 0;
class nM extends Wr {}
nM.prototype.ValueTypeName = "color";
class qf extends Wr {}
qf.prototype.ValueTypeName = "number";
class gI extends Ah {
  constructor(e, t, i, r) {
    super(e, t, i, r);
  }
  interpolate_(e, t, i, r) {
    const s = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      u = (i - t) / (r - t);
    let f = e * a;
    for (let h = f + a; f !== h; f += 4) hi.slerpFlat(s, 0, o, f - a, o, f, u);
    return s;
  }
}
class qu extends Wr {
  InterpolantFactoryMethodLinear(e) {
    return new gI(this.times, this.values, this.getValueSize(), e);
  }
}
qu.prototype.ValueTypeName = "quaternion";
qu.prototype.DefaultInterpolation = kf;
qu.prototype.InterpolantFactoryMethodSmooth = void 0;
class al extends Wr {}
al.prototype.ValueTypeName = "string";
al.prototype.ValueBufferType = Array;
al.prototype.DefaultInterpolation = Uf;
al.prototype.InterpolantFactoryMethodLinear = void 0;
al.prototype.InterpolantFactoryMethodSmooth = void 0;
class Zf extends Wr {}
Zf.prototype.ValueTypeName = "vector";
class Kf {
  constructor(e, t = -1, i, r = zg) {
    (this.name = e),
      (this.tracks = i),
      (this.duration = t),
      (this.blendMode = r),
      (this.uuid = er()),
      this.duration < 0 && this.resetDuration();
  }
  static parse(e) {
    const t = [],
      i = e.tracks,
      r = 1 / (e.fps || 1);
    for (let o = 0, a = i.length; o !== a; ++o) t.push(k7(i[o]).scale(r));
    const s = new this(e.name, e.duration, t, e.blendMode);
    return (s.uuid = e.uuid), s;
  }
  static toJSON(e) {
    const t = [],
      i = e.tracks,
      r = {
        name: e.name,
        duration: e.duration,
        tracks: t,
        uuid: e.uuid,
        blendMode: e.blendMode,
      };
    for (let s = 0, o = i.length; s !== o; ++s) t.push(Wr.toJSON(i[s]));
    return r;
  }
  static CreateFromMorphTargetSequence(e, t, i, r) {
    const s = t.length,
      o = [];
    for (let a = 0; a < s; a++) {
      let u = [],
        f = [];
      u.push((a + s - 1) % s, a, (a + 1) % s), f.push(0, 1, 0);
      const h = dI(u);
      (u = G_(u, 1, h)),
        (f = G_(f, 1, h)),
        !r && u[0] === 0 && (u.push(s), f.push(f[0])),
        o.push(
          new qf(".morphTargetInfluences[" + t[a].name + "]", u, f).scale(1 / i)
        );
    }
    return new this(e, -1, o);
  }
  static findByName(e, t) {
    let i = e;
    if (!Array.isArray(e)) {
      const r = e;
      i = (r.geometry && r.geometry.animations) || r.animations;
    }
    for (let r = 0; r < i.length; r++) if (i[r].name === t) return i[r];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(e, t, i) {
    const r = {},
      s = /^([\w-]*?)([\d]+)$/;
    for (let a = 0, u = e.length; a < u; a++) {
      const f = e[a],
        h = f.name.match(s);
      if (h && h.length > 1) {
        const d = h[1];
        let p = r[d];
        p || (r[d] = p = []), p.push(f);
      }
    }
    const o = [];
    for (const a in r)
      o.push(this.CreateFromMorphTargetSequence(a, r[a], t, i));
    return o;
  }
  static parseAnimation(e, t) {
    if (!e)
      return (
        console.error("THREE.AnimationClip: No animation in JSONLoader data."),
        null
      );
    const i = function (d, p, m, y, w) {
        if (m.length !== 0) {
          const S = [],
            v = [];
          eM(m, S, v, y), S.length !== 0 && w.push(new d(p, S, v));
        }
      },
      r = [],
      s = e.name || "default",
      o = e.fps || 30,
      a = e.blendMode;
    let u = e.length || -1;
    const f = e.hierarchy || [];
    for (let d = 0; d < f.length; d++) {
      const p = f[d].keys;
      if (!(!p || p.length === 0))
        if (p[0].morphTargets) {
          const m = {};
          let y;
          for (y = 0; y < p.length; y++)
            if (p[y].morphTargets)
              for (let w = 0; w < p[y].morphTargets.length; w++)
                m[p[y].morphTargets[w]] = -1;
          for (const w in m) {
            const S = [],
              v = [];
            for (let M = 0; M !== p[y].morphTargets.length; ++M) {
              const _ = p[y];
              S.push(_.time), v.push(_.morphTarget === w ? 1 : 0);
            }
            r.push(new qf(".morphTargetInfluence[" + w + "]", S, v));
          }
          u = m.length * o;
        } else {
          const m = ".bones[" + t[d].name + "]";
          i(Zf, m + ".position", p, "pos", r),
            i(qu, m + ".quaternion", p, "rot", r),
            i(Zf, m + ".scale", p, "scl", r);
        }
    }
    return r.length === 0 ? null : new this(s, u, r, a);
  }
  resetDuration() {
    const e = this.tracks;
    let t = 0;
    for (let i = 0, r = e.length; i !== r; ++i) {
      const s = this.tracks[i];
      t = Math.max(t, s.times[s.times.length - 1]);
    }
    return (this.duration = t), this;
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration);
    return this;
  }
  validate() {
    let e = !0;
    for (let t = 0; t < this.tracks.length; t++)
      e = e && this.tracks[t].validate();
    return e;
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
    return this;
  }
  clone() {
    const e = [];
    for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
    return new this.constructor(this.name, this.duration, e, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function U7(n) {
  switch (n.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return qf;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return Zf;
    case "color":
      return nM;
    case "quaternion":
      return qu;
    case "bool":
    case "boolean":
      return ol;
    case "string":
      return al;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + n);
}
function k7(n) {
  if (n.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const e = U7(n.type);
  if (n.times === void 0) {
    const t = [],
      i = [];
    eM(n.keys, t, i, "value"), (n.times = t), (n.values = i);
  }
  return e.parse !== void 0
    ? e.parse(n)
    : new e(n.name, n.times, n.values, n.interpolation);
}
const Os = {
  enabled: !1,
  files: {},
  add: function (n, e) {
    this.enabled !== !1 && (this.files[n] = e);
  },
  get: function (n) {
    if (this.enabled !== !1) return this.files[n];
  },
  remove: function (n) {
    delete this.files[n];
  },
  clear: function () {
    this.files = {};
  },
};
class iM {
  constructor(e, t, i) {
    const r = this;
    let s = !1,
      o = 0,
      a = 0,
      u;
    const f = [];
    (this.onStart = void 0),
      (this.onLoad = e),
      (this.onProgress = t),
      (this.onError = i),
      (this.itemStart = function (h) {
        a++, s === !1 && r.onStart !== void 0 && r.onStart(h, o, a), (s = !0);
      }),
      (this.itemEnd = function (h) {
        o++,
          r.onProgress !== void 0 && r.onProgress(h, o, a),
          o === a && ((s = !1), r.onLoad !== void 0 && r.onLoad());
      }),
      (this.itemError = function (h) {
        r.onError !== void 0 && r.onError(h);
      }),
      (this.resolveURL = function (h) {
        return u ? u(h) : h;
      }),
      (this.setURLModifier = function (h) {
        return (u = h), this;
      }),
      (this.addHandler = function (h, d) {
        return f.push(h, d), this;
      }),
      (this.removeHandler = function (h) {
        const d = f.indexOf(h);
        return d !== -1 && f.splice(d, 2), this;
      }),
      (this.getHandler = function (h) {
        for (let d = 0, p = f.length; d < p; d += 2) {
          const m = f[d],
            y = f[d + 1];
          if ((m.global && (m.lastIndex = 0), m.test(h))) return y;
        }
        return null;
      });
  }
}
const vI = new iM();
class Hi {
  constructor(e) {
    (this.manager = e !== void 0 ? e : vI),
      (this.crossOrigin = "anonymous"),
      (this.withCredentials = !1),
      (this.path = ""),
      (this.resourcePath = ""),
      (this.requestHeader = {});
  }
  load() {}
  loadAsync(e, t) {
    const i = this;
    return new Promise(function (r, s) {
      i.load(e, r, t, s);
    });
  }
  parse() {}
  setCrossOrigin(e) {
    return (this.crossOrigin = e), this;
  }
  setWithCredentials(e) {
    return (this.withCredentials = e), this;
  }
  setPath(e) {
    return (this.path = e), this;
  }
  setResourcePath(e) {
    return (this.resourcePath = e), this;
  }
  setRequestHeader(e) {
    return (this.requestHeader = e), this;
  }
}
Hi.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const As = {};
class F7 extends Error {
  constructor(e, t) {
    super(e), (this.response = t);
  }
}
class Ys extends Hi {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    e === void 0 && (e = ""),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const s = Os.get(e);
    if (s !== void 0)
      return (
        this.manager.itemStart(e),
        setTimeout(() => {
          t && t(s), this.manager.itemEnd(e);
        }, 0),
        s
      );
    if (As[e] !== void 0) {
      As[e].push({ onLoad: t, onProgress: i, onError: r });
      return;
    }
    (As[e] = []), As[e].push({ onLoad: t, onProgress: i, onError: r });
    const o = new Request(e, {
        headers: new Headers(this.requestHeader),
        credentials: this.withCredentials ? "include" : "same-origin",
      }),
      a = this.mimeType,
      u = this.responseType;
    fetch(o)
      .then((f) => {
        if (f.status === 200 || f.status === 0) {
          if (
            (f.status === 0 &&
              console.warn("THREE.FileLoader: HTTP Status 0 received."),
            typeof ReadableStream > "u" ||
              f.body === void 0 ||
              f.body.getReader === void 0)
          )
            return f;
          const h = As[e],
            d = f.body.getReader(),
            p = f.headers.get("Content-Length") || f.headers.get("X-File-Size"),
            m = p ? parseInt(p) : 0,
            y = m !== 0;
          let w = 0;
          const S = new ReadableStream({
            start(v) {
              M();
              function M() {
                d.read().then(({ done: _, value: T }) => {
                  if (_) v.close();
                  else {
                    w += T.byteLength;
                    const P = new ProgressEvent("progress", {
                      lengthComputable: y,
                      loaded: w,
                      total: m,
                    });
                    for (let b = 0, L = h.length; b < L; b++) {
                      const N = h[b];
                      N.onProgress && N.onProgress(P);
                    }
                    v.enqueue(T), M();
                  }
                });
              }
            },
          });
          return new Response(S);
        } else
          throw new F7(
            `fetch for "${f.url}" responded with ${f.status}: ${f.statusText}`,
            f
          );
      })
      .then((f) => {
        switch (u) {
          case "arraybuffer":
            return f.arrayBuffer();
          case "blob":
            return f.blob();
          case "document":
            return f.text().then((h) => new DOMParser().parseFromString(h, a));
          case "json":
            return f.json();
          default:
            if (a === void 0) return f.text();
            {
              const d = /charset="?([^;"\s]*)"?/i.exec(a),
                p = d && d[1] ? d[1].toLowerCase() : void 0,
                m = new TextDecoder(p);
              return f.arrayBuffer().then((y) => m.decode(y));
            }
        }
      })
      .then((f) => {
        Os.add(e, f);
        const h = As[e];
        delete As[e];
        for (let d = 0, p = h.length; d < p; d++) {
          const m = h[d];
          m.onLoad && m.onLoad(f);
        }
      })
      .catch((f) => {
        const h = As[e];
        if (h === void 0) throw (this.manager.itemError(e), f);
        delete As[e];
        for (let d = 0, p = h.length; d < p; d++) {
          const m = h[d];
          m.onError && m.onError(f);
        }
        this.manager.itemError(e);
      })
      .finally(() => {
        this.manager.itemEnd(e);
      }),
      this.manager.itemStart(e);
  }
  setResponseType(e) {
    return (this.responseType = e), this;
  }
  setMimeType(e) {
    return (this.mimeType = e), this;
  }
}
class z7 extends Hi {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = this,
      o = new Ys(this.manager);
    o.setPath(this.path),
      o.setRequestHeader(this.requestHeader),
      o.setWithCredentials(this.withCredentials),
      o.load(
        e,
        function (a) {
          try {
            t(s.parse(JSON.parse(a)));
          } catch (u) {
            r ? r(u) : console.error(u), s.manager.itemError(e);
          }
        },
        i,
        r
      );
  }
  parse(e) {
    const t = [];
    for (let i = 0; i < e.length; i++) {
      const r = Kf.parse(e[i]);
      t.push(r);
    }
    return t;
  }
}
class B7 extends Hi {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = this,
      o = [],
      a = new Yg(),
      u = new Ys(this.manager);
    u.setPath(this.path),
      u.setResponseType("arraybuffer"),
      u.setRequestHeader(this.requestHeader),
      u.setWithCredentials(s.withCredentials);
    let f = 0;
    function h(d) {
      u.load(
        e[d],
        function (p) {
          const m = s.parse(p, !0);
          (o[d] = {
            width: m.width,
            height: m.height,
            format: m.format,
            mipmaps: m.mipmaps,
          }),
            (f += 1),
            f === 6 &&
              (m.mipmapCount === 1 && (a.minFilter = wn),
              (a.image = o),
              (a.format = m.format),
              (a.needsUpdate = !0),
              t && t(a));
        },
        i,
        r
      );
    }
    if (Array.isArray(e)) for (let d = 0, p = e.length; d < p; ++d) h(d);
    else
      u.load(
        e,
        function (d) {
          const p = s.parse(d, !0);
          if (p.isCubemap) {
            const m = p.mipmaps.length / p.mipmapCount;
            for (let y = 0; y < m; y++) {
              o[y] = { mipmaps: [] };
              for (let w = 0; w < p.mipmapCount; w++)
                o[y].mipmaps.push(p.mipmaps[y * p.mipmapCount + w]),
                  (o[y].format = p.format),
                  (o[y].width = p.width),
                  (o[y].height = p.height);
            }
            a.image = o;
          } else
            (a.image.width = p.width),
              (a.image.height = p.height),
              (a.mipmaps = p.mipmaps);
          p.mipmapCount === 1 && (a.minFilter = wn),
            (a.format = p.format),
            (a.needsUpdate = !0),
            t && t(a);
        },
        i,
        r
      );
    return a;
  }
}
class Qf extends Hi {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const s = this,
      o = Os.get(e);
    if (o !== void 0)
      return (
        s.manager.itemStart(e),
        setTimeout(function () {
          t && t(o), s.manager.itemEnd(e);
        }, 0),
        o
      );
    const a = Gf("img");
    function u() {
      h(), Os.add(e, this), t && t(this), s.manager.itemEnd(e);
    }
    function f(d) {
      h(), r && r(d), s.manager.itemError(e), s.manager.itemEnd(e);
    }
    function h() {
      a.removeEventListener("load", u, !1),
        a.removeEventListener("error", f, !1);
    }
    return (
      a.addEventListener("load", u, !1),
      a.addEventListener("error", f, !1),
      e.slice(0, 5) !== "data:" &&
        this.crossOrigin !== void 0 &&
        (a.crossOrigin = this.crossOrigin),
      s.manager.itemStart(e),
      (a.src = e),
      a
    );
  }
}
class V7 extends Hi {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = new _h();
    s.colorSpace = Dn;
    const o = new Qf(this.manager);
    o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
    let a = 0;
    function u(f) {
      o.load(
        e[f],
        function (h) {
          (s.images[f] = h), a++, a === 6 && ((s.needsUpdate = !0), t && t(s));
        },
        void 0,
        r
      );
    }
    for (let f = 0; f < e.length; ++f) u(f);
    return s;
  }
}
class H7 extends Hi {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = this,
      o = new Wa(),
      a = new Ys(this.manager);
    return (
      a.setResponseType("arraybuffer"),
      a.setRequestHeader(this.requestHeader),
      a.setPath(this.path),
      a.setWithCredentials(s.withCredentials),
      a.load(
        e,
        function (u) {
          let f;
          try {
            f = s.parse(u);
          } catch (h) {
            if (r !== void 0) r(h);
            else {
              console.error(h);
              return;
            }
          }
          f.image !== void 0
            ? (o.image = f.image)
            : f.data !== void 0 &&
              ((o.image.width = f.width),
              (o.image.height = f.height),
              (o.image.data = f.data)),
            (o.wrapS = f.wrapS !== void 0 ? f.wrapS : fi),
            (o.wrapT = f.wrapT !== void 0 ? f.wrapT : fi),
            (o.magFilter = f.magFilter !== void 0 ? f.magFilter : wn),
            (o.minFilter = f.minFilter !== void 0 ? f.minFilter : wn),
            (o.anisotropy = f.anisotropy !== void 0 ? f.anisotropy : 1),
            f.colorSpace !== void 0
              ? (o.colorSpace = f.colorSpace)
              : f.encoding !== void 0 && (o.encoding = f.encoding),
            f.flipY !== void 0 && (o.flipY = f.flipY),
            f.format !== void 0 && (o.format = f.format),
            f.type !== void 0 && (o.type = f.type),
            f.mipmaps !== void 0 &&
              ((o.mipmaps = f.mipmaps), (o.minFilter = Wo)),
            f.mipmapCount === 1 && (o.minFilter = wn),
            f.generateMipmaps !== void 0 &&
              (o.generateMipmaps = f.generateMipmaps),
            (o.needsUpdate = !0),
            t && t(o, f);
        },
        i,
        r
      ),
      o
    );
  }
}
class G7 extends Hi {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = new An(),
      o = new Qf(this.manager);
    return (
      o.setCrossOrigin(this.crossOrigin),
      o.setPath(this.path),
      o.load(
        e,
        function (a) {
          (s.image = a), (s.needsUpdate = !0), t !== void 0 && t(s);
        },
        i,
        r
      ),
      s
    );
  }
}
class Jo extends Ft {
  constructor(e, t = 1) {
    super(),
      (this.isLight = !0),
      (this.type = "Light"),
      (this.color = new Be(e)),
      (this.intensity = t);
  }
  dispose() {}
  copy(e, t) {
    return (
      super.copy(e, t),
      this.color.copy(e.color),
      (this.intensity = e.intensity),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.color = this.color.getHex()),
      (t.object.intensity = this.intensity),
      this.groundColor !== void 0 &&
        (t.object.groundColor = this.groundColor.getHex()),
      this.distance !== void 0 && (t.object.distance = this.distance),
      this.angle !== void 0 && (t.object.angle = this.angle),
      this.decay !== void 0 && (t.object.decay = this.decay),
      this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
      this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()),
      t
    );
  }
}
class yI extends Jo {
  constructor(e, t, i) {
    super(e, i),
      (this.isHemisphereLight = !0),
      (this.type = "HemisphereLight"),
      this.position.copy(Ft.DEFAULT_UP),
      this.updateMatrix(),
      (this.groundColor = new Be(t));
  }
  copy(e, t) {
    return super.copy(e, t), this.groundColor.copy(e.groundColor), this;
  }
}
const Fy = new dt(),
  DA = new U(),
  OA = new U();
class rM {
  constructor(e) {
    (this.camera = e),
      (this.bias = 0),
      (this.normalBias = 0),
      (this.radius = 1),
      (this.blurSamples = 8),
      (this.mapSize = new de(512, 512)),
      (this.map = null),
      (this.mapPass = null),
      (this.matrix = new dt()),
      (this.autoUpdate = !0),
      (this.needsUpdate = !1),
      (this._frustum = new Sh()),
      (this._frameExtents = new de(1, 1)),
      (this._viewportCount = 1),
      (this._viewports = [new Bt(0, 0, 1, 1)]);
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const t = this.camera,
      i = this.matrix;
    DA.setFromMatrixPosition(e.matrixWorld),
      t.position.copy(DA),
      OA.setFromMatrixPosition(e.target.matrixWorld),
      t.lookAt(OA),
      t.updateMatrixWorld(),
      Fy.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(Fy),
      i.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
      i.multiply(Fy);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return (
      (this.camera = e.camera.clone()),
      (this.bias = e.bias),
      (this.radius = e.radius),
      this.mapSize.copy(e.mapSize),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return (
      this.bias !== 0 && (e.bias = this.bias),
      this.normalBias !== 0 && (e.normalBias = this.normalBias),
      this.radius !== 1 && (e.radius = this.radius),
      (this.mapSize.x !== 512 || this.mapSize.y !== 512) &&
        (e.mapSize = this.mapSize.toArray()),
      (e.camera = this.camera.toJSON(!1).object),
      delete e.camera.matrix,
      e
    );
  }
}
class W7 extends rM {
  constructor() {
    super(new En(50, 1, 0.5, 500)),
      (this.isSpotLightShadow = !0),
      (this.focus = 1);
  }
  updateMatrices(e) {
    const t = this.camera,
      i = ku * 2 * e.angle * this.focus,
      r = this.mapSize.width / this.mapSize.height,
      s = e.distance || t.far;
    (i !== t.fov || r !== t.aspect || s !== t.far) &&
      ((t.fov = i), (t.aspect = r), (t.far = s), t.updateProjectionMatrix()),
      super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), (this.focus = e.focus), this;
  }
}
class xI extends Jo {
  constructor(e, t, i = 0, r = Math.PI / 3, s = 0, o = 2) {
    super(e, t),
      (this.isSpotLight = !0),
      (this.type = "SpotLight"),
      this.position.copy(Ft.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new Ft()),
      (this.distance = i),
      (this.angle = r),
      (this.penumbra = s),
      (this.decay = o),
      (this.map = null),
      (this.shadow = new W7());
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.distance = e.distance),
      (this.angle = e.angle),
      (this.penumbra = e.penumbra),
      (this.decay = e.decay),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
const UA = new dt(),
  Uc = new U(),
  zy = new U();
class j7 extends rM {
  constructor() {
    super(new En(90, 1, 0.5, 500)),
      (this.isPointLightShadow = !0),
      (this._frameExtents = new de(4, 2)),
      (this._viewportCount = 6),
      (this._viewports = [
        new Bt(2, 1, 1, 1),
        new Bt(0, 1, 1, 1),
        new Bt(3, 1, 1, 1),
        new Bt(1, 1, 1, 1),
        new Bt(3, 0, 1, 1),
        new Bt(1, 0, 1, 1),
      ]),
      (this._cubeDirections = [
        new U(1, 0, 0),
        new U(-1, 0, 0),
        new U(0, 0, 1),
        new U(0, 0, -1),
        new U(0, 1, 0),
        new U(0, -1, 0),
      ]),
      (this._cubeUps = [
        new U(0, 1, 0),
        new U(0, 1, 0),
        new U(0, 1, 0),
        new U(0, 1, 0),
        new U(0, 0, 1),
        new U(0, 0, -1),
      ]);
  }
  updateMatrices(e, t = 0) {
    const i = this.camera,
      r = this.matrix,
      s = e.distance || i.far;
    s !== i.far && ((i.far = s), i.updateProjectionMatrix()),
      Uc.setFromMatrixPosition(e.matrixWorld),
      i.position.copy(Uc),
      zy.copy(i.position),
      zy.add(this._cubeDirections[t]),
      i.up.copy(this._cubeUps[t]),
      i.lookAt(zy),
      i.updateMatrixWorld(),
      r.makeTranslation(-Uc.x, -Uc.y, -Uc.z),
      UA.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(UA);
  }
}
class _I extends Jo {
  constructor(e, t, i = 0, r = 2) {
    super(e, t),
      (this.isPointLight = !0),
      (this.type = "PointLight"),
      (this.distance = i),
      (this.decay = r),
      (this.shadow = new j7());
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.distance = e.distance),
      (this.decay = e.decay),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class X7 extends rM {
  constructor() {
    super(new Fo(-5, 5, 5, -5, 0.5, 500)), (this.isDirectionalLightShadow = !0);
  }
}
class SI extends Jo {
  constructor(e, t) {
    super(e, t),
      (this.isDirectionalLight = !0),
      (this.type = "DirectionalLight"),
      this.position.copy(Ft.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new Ft()),
      (this.shadow = new X7());
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return (
      super.copy(e),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class MI extends Jo {
  constructor(e, t) {
    super(e, t), (this.isAmbientLight = !0), (this.type = "AmbientLight");
  }
}
class wI extends Jo {
  constructor(e, t, i = 10, r = 10) {
    super(e, t),
      (this.isRectAreaLight = !0),
      (this.type = "RectAreaLight"),
      (this.width = i),
      (this.height = r);
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(e) {
    this.intensity = e / (this.width * this.height * Math.PI);
  }
  copy(e) {
    return (
      super.copy(e), (this.width = e.width), (this.height = e.height), this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (t.object.width = this.width), (t.object.height = this.height), t;
  }
}
class EI {
  constructor() {
    (this.isSphericalHarmonics3 = !0), (this.coefficients = []);
    for (let e = 0; e < 9; e++) this.coefficients.push(new U());
  }
  set(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);
    return this;
  }
  zero() {
    for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
    return this;
  }
  getAt(e, t) {
    const i = e.x,
      r = e.y,
      s = e.z,
      o = this.coefficients;
    return (
      t.copy(o[0]).multiplyScalar(0.282095),
      t.addScaledVector(o[1], 0.488603 * r),
      t.addScaledVector(o[2], 0.488603 * s),
      t.addScaledVector(o[3], 0.488603 * i),
      t.addScaledVector(o[4], 1.092548 * (i * r)),
      t.addScaledVector(o[5], 1.092548 * (r * s)),
      t.addScaledVector(o[6], 0.315392 * (3 * s * s - 1)),
      t.addScaledVector(o[7], 1.092548 * (i * s)),
      t.addScaledVector(o[8], 0.546274 * (i * i - r * r)),
      t
    );
  }
  getIrradianceAt(e, t) {
    const i = e.x,
      r = e.y,
      s = e.z,
      o = this.coefficients;
    return (
      t.copy(o[0]).multiplyScalar(0.886227),
      t.addScaledVector(o[1], 2 * 0.511664 * r),
      t.addScaledVector(o[2], 2 * 0.511664 * s),
      t.addScaledVector(o[3], 2 * 0.511664 * i),
      t.addScaledVector(o[4], 2 * 0.429043 * i * r),
      t.addScaledVector(o[5], 2 * 0.429043 * r * s),
      t.addScaledVector(o[6], 0.743125 * s * s - 0.247708),
      t.addScaledVector(o[7], 2 * 0.429043 * i * s),
      t.addScaledVector(o[8], 0.429043 * (i * i - r * r)),
      t
    );
  }
  add(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].add(e.coefficients[t]);
    return this;
  }
  addScaledSH(e, t) {
    for (let i = 0; i < 9; i++)
      this.coefficients[i].addScaledVector(e.coefficients[i], t);
    return this;
  }
  scale(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e);
    return this;
  }
  lerp(e, t) {
    for (let i = 0; i < 9; i++) this.coefficients[i].lerp(e.coefficients[i], t);
    return this;
  }
  equals(e) {
    for (let t = 0; t < 9; t++)
      if (!this.coefficients[t].equals(e.coefficients[t])) return !1;
    return !0;
  }
  copy(e) {
    return this.set(e.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(e, t = 0) {
    const i = this.coefficients;
    for (let r = 0; r < 9; r++) i[r].fromArray(e, t + r * 3);
    return this;
  }
  toArray(e = [], t = 0) {
    const i = this.coefficients;
    for (let r = 0; r < 9; r++) i[r].toArray(e, t + r * 3);
    return e;
  }
  static getBasisAt(e, t) {
    const i = e.x,
      r = e.y,
      s = e.z;
    (t[0] = 0.282095),
      (t[1] = 0.488603 * r),
      (t[2] = 0.488603 * s),
      (t[3] = 0.488603 * i),
      (t[4] = 1.092548 * i * r),
      (t[5] = 1.092548 * r * s),
      (t[6] = 0.315392 * (3 * s * s - 1)),
      (t[7] = 1.092548 * i * s),
      (t[8] = 0.546274 * (i * i - r * r));
  }
}
class TI extends Jo {
  constructor(e = new EI(), t = 1) {
    super(void 0, t), (this.isLightProbe = !0), (this.sh = e);
  }
  copy(e) {
    return super.copy(e), this.sh.copy(e.sh), this;
  }
  fromJSON(e) {
    return (this.intensity = e.intensity), this.sh.fromArray(e.sh), this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (t.object.sh = this.sh.toArray()), t;
  }
}
class lv extends Hi {
  constructor(e) {
    super(e), (this.textures = {});
  }
  load(e, t, i, r) {
    const s = this,
      o = new Ys(s.manager);
    o.setPath(s.path),
      o.setRequestHeader(s.requestHeader),
      o.setWithCredentials(s.withCredentials),
      o.load(
        e,
        function (a) {
          try {
            t(s.parse(JSON.parse(a)));
          } catch (u) {
            r ? r(u) : console.error(u), s.manager.itemError(e);
          }
        },
        i,
        r
      );
  }
  parse(e) {
    const t = this.textures;
    function i(s) {
      return (
        t[s] === void 0 &&
          console.warn("THREE.MaterialLoader: Undefined texture", s),
        t[s]
      );
    }
    const r = lv.createMaterialFromType(e.type);
    if (
      (e.uuid !== void 0 && (r.uuid = e.uuid),
      e.name !== void 0 && (r.name = e.name),
      e.color !== void 0 && r.color !== void 0 && r.color.setHex(e.color),
      e.roughness !== void 0 && (r.roughness = e.roughness),
      e.metalness !== void 0 && (r.metalness = e.metalness),
      e.sheen !== void 0 && (r.sheen = e.sheen),
      e.sheenColor !== void 0 && (r.sheenColor = new Be().setHex(e.sheenColor)),
      e.sheenRoughness !== void 0 && (r.sheenRoughness = e.sheenRoughness),
      e.emissive !== void 0 &&
        r.emissive !== void 0 &&
        r.emissive.setHex(e.emissive),
      e.specular !== void 0 &&
        r.specular !== void 0 &&
        r.specular.setHex(e.specular),
      e.specularIntensity !== void 0 &&
        (r.specularIntensity = e.specularIntensity),
      e.specularColor !== void 0 &&
        r.specularColor !== void 0 &&
        r.specularColor.setHex(e.specularColor),
      e.shininess !== void 0 && (r.shininess = e.shininess),
      e.clearcoat !== void 0 && (r.clearcoat = e.clearcoat),
      e.clearcoatRoughness !== void 0 &&
        (r.clearcoatRoughness = e.clearcoatRoughness),
      e.iridescence !== void 0 && (r.iridescence = e.iridescence),
      e.iridescenceIOR !== void 0 && (r.iridescenceIOR = e.iridescenceIOR),
      e.iridescenceThicknessRange !== void 0 &&
        (r.iridescenceThicknessRange = e.iridescenceThicknessRange),
      e.transmission !== void 0 && (r.transmission = e.transmission),
      e.thickness !== void 0 && (r.thickness = e.thickness),
      e.attenuationDistance !== void 0 &&
        (r.attenuationDistance = e.attenuationDistance),
      e.attenuationColor !== void 0 &&
        r.attenuationColor !== void 0 &&
        r.attenuationColor.setHex(e.attenuationColor),
      e.anisotropy !== void 0 && (r.anisotropy = e.anisotropy),
      e.anisotropyRotation !== void 0 &&
        (r.anisotropyRotation = e.anisotropyRotation),
      e.fog !== void 0 && (r.fog = e.fog),
      e.flatShading !== void 0 && (r.flatShading = e.flatShading),
      e.blending !== void 0 && (r.blending = e.blending),
      e.combine !== void 0 && (r.combine = e.combine),
      e.side !== void 0 && (r.side = e.side),
      e.shadowSide !== void 0 && (r.shadowSide = e.shadowSide),
      e.opacity !== void 0 && (r.opacity = e.opacity),
      e.transparent !== void 0 && (r.transparent = e.transparent),
      e.alphaTest !== void 0 && (r.alphaTest = e.alphaTest),
      e.alphaHash !== void 0 && (r.alphaHash = e.alphaHash),
      e.depthFunc !== void 0 && (r.depthFunc = e.depthFunc),
      e.depthTest !== void 0 && (r.depthTest = e.depthTest),
      e.depthWrite !== void 0 && (r.depthWrite = e.depthWrite),
      e.colorWrite !== void 0 && (r.colorWrite = e.colorWrite),
      e.blendSrc !== void 0 && (r.blendSrc = e.blendSrc),
      e.blendDst !== void 0 && (r.blendDst = e.blendDst),
      e.blendEquation !== void 0 && (r.blendEquation = e.blendEquation),
      e.blendSrcAlpha !== void 0 && (r.blendSrcAlpha = e.blendSrcAlpha),
      e.blendDstAlpha !== void 0 && (r.blendDstAlpha = e.blendDstAlpha),
      e.blendEquationAlpha !== void 0 &&
        (r.blendEquationAlpha = e.blendEquationAlpha),
      e.blendColor !== void 0 &&
        r.blendColor !== void 0 &&
        r.blendColor.setHex(e.blendColor),
      e.blendAlpha !== void 0 && (r.blendAlpha = e.blendAlpha),
      e.stencilWriteMask !== void 0 &&
        (r.stencilWriteMask = e.stencilWriteMask),
      e.stencilFunc !== void 0 && (r.stencilFunc = e.stencilFunc),
      e.stencilRef !== void 0 && (r.stencilRef = e.stencilRef),
      e.stencilFuncMask !== void 0 && (r.stencilFuncMask = e.stencilFuncMask),
      e.stencilFail !== void 0 && (r.stencilFail = e.stencilFail),
      e.stencilZFail !== void 0 && (r.stencilZFail = e.stencilZFail),
      e.stencilZPass !== void 0 && (r.stencilZPass = e.stencilZPass),
      e.stencilWrite !== void 0 && (r.stencilWrite = e.stencilWrite),
      e.wireframe !== void 0 && (r.wireframe = e.wireframe),
      e.wireframeLinewidth !== void 0 &&
        (r.wireframeLinewidth = e.wireframeLinewidth),
      e.wireframeLinecap !== void 0 &&
        (r.wireframeLinecap = e.wireframeLinecap),
      e.wireframeLinejoin !== void 0 &&
        (r.wireframeLinejoin = e.wireframeLinejoin),
      e.rotation !== void 0 && (r.rotation = e.rotation),
      e.linewidth !== void 0 && (r.linewidth = e.linewidth),
      e.dashSize !== void 0 && (r.dashSize = e.dashSize),
      e.gapSize !== void 0 && (r.gapSize = e.gapSize),
      e.scale !== void 0 && (r.scale = e.scale),
      e.polygonOffset !== void 0 && (r.polygonOffset = e.polygonOffset),
      e.polygonOffsetFactor !== void 0 &&
        (r.polygonOffsetFactor = e.polygonOffsetFactor),
      e.polygonOffsetUnits !== void 0 &&
        (r.polygonOffsetUnits = e.polygonOffsetUnits),
      e.dithering !== void 0 && (r.dithering = e.dithering),
      e.alphaToCoverage !== void 0 && (r.alphaToCoverage = e.alphaToCoverage),
      e.premultipliedAlpha !== void 0 &&
        (r.premultipliedAlpha = e.premultipliedAlpha),
      e.forceSinglePass !== void 0 && (r.forceSinglePass = e.forceSinglePass),
      e.visible !== void 0 && (r.visible = e.visible),
      e.toneMapped !== void 0 && (r.toneMapped = e.toneMapped),
      e.userData !== void 0 && (r.userData = e.userData),
      e.vertexColors !== void 0 &&
        (typeof e.vertexColors == "number"
          ? (r.vertexColors = e.vertexColors > 0)
          : (r.vertexColors = e.vertexColors)),
      e.uniforms !== void 0)
    )
      for (const s in e.uniforms) {
        const o = e.uniforms[s];
        switch (((r.uniforms[s] = {}), o.type)) {
          case "t":
            r.uniforms[s].value = i(o.value);
            break;
          case "c":
            r.uniforms[s].value = new Be().setHex(o.value);
            break;
          case "v2":
            r.uniforms[s].value = new de().fromArray(o.value);
            break;
          case "v3":
            r.uniforms[s].value = new U().fromArray(o.value);
            break;
          case "v4":
            r.uniforms[s].value = new Bt().fromArray(o.value);
            break;
          case "m3":
            r.uniforms[s].value = new Et().fromArray(o.value);
            break;
          case "m4":
            r.uniforms[s].value = new dt().fromArray(o.value);
            break;
          default:
            r.uniforms[s].value = o.value;
        }
      }
    if (
      (e.defines !== void 0 && (r.defines = e.defines),
      e.vertexShader !== void 0 && (r.vertexShader = e.vertexShader),
      e.fragmentShader !== void 0 && (r.fragmentShader = e.fragmentShader),
      e.glslVersion !== void 0 && (r.glslVersion = e.glslVersion),
      e.extensions !== void 0)
    )
      for (const s in e.extensions) r.extensions[s] = e.extensions[s];
    if (
      (e.lights !== void 0 && (r.lights = e.lights),
      e.clipping !== void 0 && (r.clipping = e.clipping),
      e.size !== void 0 && (r.size = e.size),
      e.sizeAttenuation !== void 0 && (r.sizeAttenuation = e.sizeAttenuation),
      e.map !== void 0 && (r.map = i(e.map)),
      e.matcap !== void 0 && (r.matcap = i(e.matcap)),
      e.alphaMap !== void 0 && (r.alphaMap = i(e.alphaMap)),
      e.bumpMap !== void 0 && (r.bumpMap = i(e.bumpMap)),
      e.bumpScale !== void 0 && (r.bumpScale = e.bumpScale),
      e.normalMap !== void 0 && (r.normalMap = i(e.normalMap)),
      e.normalMapType !== void 0 && (r.normalMapType = e.normalMapType),
      e.normalScale !== void 0)
    ) {
      let s = e.normalScale;
      Array.isArray(s) === !1 && (s = [s, s]),
        (r.normalScale = new de().fromArray(s));
    }
    return (
      e.displacementMap !== void 0 &&
        (r.displacementMap = i(e.displacementMap)),
      e.displacementScale !== void 0 &&
        (r.displacementScale = e.displacementScale),
      e.displacementBias !== void 0 &&
        (r.displacementBias = e.displacementBias),
      e.roughnessMap !== void 0 && (r.roughnessMap = i(e.roughnessMap)),
      e.metalnessMap !== void 0 && (r.metalnessMap = i(e.metalnessMap)),
      e.emissiveMap !== void 0 && (r.emissiveMap = i(e.emissiveMap)),
      e.emissiveIntensity !== void 0 &&
        (r.emissiveIntensity = e.emissiveIntensity),
      e.specularMap !== void 0 && (r.specularMap = i(e.specularMap)),
      e.specularIntensityMap !== void 0 &&
        (r.specularIntensityMap = i(e.specularIntensityMap)),
      e.specularColorMap !== void 0 &&
        (r.specularColorMap = i(e.specularColorMap)),
      e.envMap !== void 0 && (r.envMap = i(e.envMap)),
      e.envMapIntensity !== void 0 && (r.envMapIntensity = e.envMapIntensity),
      e.reflectivity !== void 0 && (r.reflectivity = e.reflectivity),
      e.refractionRatio !== void 0 && (r.refractionRatio = e.refractionRatio),
      e.lightMap !== void 0 && (r.lightMap = i(e.lightMap)),
      e.lightMapIntensity !== void 0 &&
        (r.lightMapIntensity = e.lightMapIntensity),
      e.aoMap !== void 0 && (r.aoMap = i(e.aoMap)),
      e.aoMapIntensity !== void 0 && (r.aoMapIntensity = e.aoMapIntensity),
      e.gradientMap !== void 0 && (r.gradientMap = i(e.gradientMap)),
      e.clearcoatMap !== void 0 && (r.clearcoatMap = i(e.clearcoatMap)),
      e.clearcoatRoughnessMap !== void 0 &&
        (r.clearcoatRoughnessMap = i(e.clearcoatRoughnessMap)),
      e.clearcoatNormalMap !== void 0 &&
        (r.clearcoatNormalMap = i(e.clearcoatNormalMap)),
      e.clearcoatNormalScale !== void 0 &&
        (r.clearcoatNormalScale = new de().fromArray(e.clearcoatNormalScale)),
      e.iridescenceMap !== void 0 && (r.iridescenceMap = i(e.iridescenceMap)),
      e.iridescenceThicknessMap !== void 0 &&
        (r.iridescenceThicknessMap = i(e.iridescenceThicknessMap)),
      e.transmissionMap !== void 0 &&
        (r.transmissionMap = i(e.transmissionMap)),
      e.thicknessMap !== void 0 && (r.thicknessMap = i(e.thicknessMap)),
      e.anisotropyMap !== void 0 && (r.anisotropyMap = i(e.anisotropyMap)),
      e.sheenColorMap !== void 0 && (r.sheenColorMap = i(e.sheenColorMap)),
      e.sheenRoughnessMap !== void 0 &&
        (r.sheenRoughnessMap = i(e.sheenRoughnessMap)),
      r
    );
  }
  setTextures(e) {
    return (this.textures = e), this;
  }
  static createMaterialFromType(e) {
    const t = {
      ShadowMaterial: rI,
      SpriteMaterial: GS,
      RawShaderMaterial: sI,
      ShaderMaterial: Hr,
      PointsMaterial: jS,
      MeshPhysicalMaterial: JS,
      MeshStandardMaterial: $S,
      MeshPhongMaterial: oI,
      MeshToonMaterial: aI,
      MeshNormalMaterial: lI,
      MeshLambertMaterial: uI,
      MeshDepthMaterial: zS,
      MeshDistanceMaterial: BS,
      MeshBasicMaterial: Qo,
      MeshMatcapMaterial: cI,
      LineDashedMaterial: fI,
      LineBasicMaterial: Pi,
      Material: gi,
    };
    return new t[e]();
  }
}
class W_ {
  static decodeText(e) {
    if (typeof TextDecoder < "u") return new TextDecoder().decode(e);
    let t = "";
    for (let i = 0, r = e.length; i < r; i++) t += String.fromCharCode(e[i]);
    try {
      return decodeURIComponent(escape(t));
    } catch {
      return t;
    }
  }
  static extractUrlBase(e) {
    const t = e.lastIndexOf("/");
    return t === -1 ? "./" : e.slice(0, t + 1);
  }
  static resolveURL(e, t) {
    return typeof e != "string" || e === ""
      ? ""
      : (/^https?:\/\//i.test(t) &&
          /^\//.test(e) &&
          (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
        /^(https?:)?\/\//i.test(e) ||
        /^data:.*,.*$/i.test(e) ||
        /^blob:.*$/i.test(e)
          ? e
          : t + e);
  }
}
class AI extends Tt {
  constructor() {
    super(),
      (this.isInstancedBufferGeometry = !0),
      (this.type = "InstancedBufferGeometry"),
      (this.instanceCount = 1 / 0);
  }
  copy(e) {
    return super.copy(e), (this.instanceCount = e.instanceCount), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.instanceCount = this.instanceCount),
      (e.isInstancedBufferGeometry = !0),
      e
    );
  }
}
class bI extends Hi {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = this,
      o = new Ys(s.manager);
    o.setPath(s.path),
      o.setRequestHeader(s.requestHeader),
      o.setWithCredentials(s.withCredentials),
      o.load(
        e,
        function (a) {
          try {
            t(s.parse(JSON.parse(a)));
          } catch (u) {
            r ? r(u) : console.error(u), s.manager.itemError(e);
          }
        },
        i,
        r
      );
  }
  parse(e) {
    const t = {},
      i = {};
    function r(m, y) {
      if (t[y] !== void 0) return t[y];
      const S = m.interleavedBuffers[y],
        v = s(m, S.buffer),
        M = du(S.type, v),
        _ = new jg(M, S.stride);
      return (_.uuid = S.uuid), (t[y] = _), _;
    }
    function s(m, y) {
      if (i[y] !== void 0) return i[y];
      const S = m.arrayBuffers[y],
        v = new Uint32Array(S).buffer;
      return (i[y] = v), v;
    }
    const o = e.isInstancedBufferGeometry ? new AI() : new Tt(),
      a = e.data.index;
    if (a !== void 0) {
      const m = du(a.type, a.array);
      o.setIndex(new Ht(m, 1));
    }
    const u = e.data.attributes;
    for (const m in u) {
      const y = u[m];
      let w;
      if (y.isInterleavedBufferAttribute) {
        const S = r(e.data, y.data);
        w = new $a(S, y.itemSize, y.offset, y.normalized);
      } else {
        const S = du(y.type, y.array),
          v = y.isInstancedBufferAttribute ? zu : Ht;
        w = new v(S, y.itemSize, y.normalized);
      }
      y.name !== void 0 && (w.name = y.name),
        y.usage !== void 0 && w.setUsage(y.usage),
        o.setAttribute(m, w);
    }
    const f = e.data.morphAttributes;
    if (f)
      for (const m in f) {
        const y = f[m],
          w = [];
        for (let S = 0, v = y.length; S < v; S++) {
          const M = y[S];
          let _;
          if (M.isInterleavedBufferAttribute) {
            const T = r(e.data, M.data);
            _ = new $a(T, M.itemSize, M.offset, M.normalized);
          } else {
            const T = du(M.type, M.array);
            _ = new Ht(T, M.itemSize, M.normalized);
          }
          M.name !== void 0 && (_.name = M.name), w.push(_);
        }
        o.morphAttributes[m] = w;
      }
    e.data.morphTargetsRelative && (o.morphTargetsRelative = !0);
    const d = e.data.groups || e.data.drawcalls || e.data.offsets;
    if (d !== void 0)
      for (let m = 0, y = d.length; m !== y; ++m) {
        const w = d[m];
        o.addGroup(w.start, w.count, w.materialIndex);
      }
    const p = e.data.boundingSphere;
    if (p !== void 0) {
      const m = new U();
      p.center !== void 0 && m.fromArray(p.center),
        (o.boundingSphere = new di(m, p.radius));
    }
    return (
      e.name && (o.name = e.name), e.userData && (o.userData = e.userData), o
    );
  }
}
class Y7 extends Hi {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = this,
      o = this.path === "" ? W_.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || o;
    const a = new Ys(this.manager);
    a.setPath(this.path),
      a.setRequestHeader(this.requestHeader),
      a.setWithCredentials(this.withCredentials),
      a.load(
        e,
        function (u) {
          let f = null;
          try {
            f = JSON.parse(u);
          } catch (d) {
            r !== void 0 && r(d),
              console.error(
                "THREE:ObjectLoader: Can't parse " + e + ".",
                d.message
              );
            return;
          }
          const h = f.metadata;
          if (
            h === void 0 ||
            h.type === void 0 ||
            h.type.toLowerCase() === "geometry"
          ) {
            r !== void 0 && r(new Error("THREE.ObjectLoader: Can't load " + e)),
              console.error("THREE.ObjectLoader: Can't load " + e);
            return;
          }
          s.parse(f, t);
        },
        i,
        r
      );
  }
  async loadAsync(e, t) {
    const i = this,
      r = this.path === "" ? W_.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || r;
    const s = new Ys(this.manager);
    s.setPath(this.path),
      s.setRequestHeader(this.requestHeader),
      s.setWithCredentials(this.withCredentials);
    const o = await s.loadAsync(e, t),
      a = JSON.parse(o),
      u = a.metadata;
    if (
      u === void 0 ||
      u.type === void 0 ||
      u.type.toLowerCase() === "geometry"
    )
      throw new Error("THREE.ObjectLoader: Can't load " + e);
    return await i.parseAsync(a);
  }
  parse(e, t) {
    const i = this.parseAnimations(e.animations),
      r = this.parseShapes(e.shapes),
      s = this.parseGeometries(e.geometries, r),
      o = this.parseImages(e.images, function () {
        t !== void 0 && t(f);
      }),
      a = this.parseTextures(e.textures, o),
      u = this.parseMaterials(e.materials, a),
      f = this.parseObject(e.object, s, u, a, i),
      h = this.parseSkeletons(e.skeletons, f);
    if ((this.bindSkeletons(f, h), t !== void 0)) {
      let d = !1;
      for (const p in o)
        if (o[p].data instanceof HTMLImageElement) {
          d = !0;
          break;
        }
      d === !1 && t(f);
    }
    return f;
  }
  async parseAsync(e) {
    const t = this.parseAnimations(e.animations),
      i = this.parseShapes(e.shapes),
      r = this.parseGeometries(e.geometries, i),
      s = await this.parseImagesAsync(e.images),
      o = this.parseTextures(e.textures, s),
      a = this.parseMaterials(e.materials, o),
      u = this.parseObject(e.object, r, a, o, t),
      f = this.parseSkeletons(e.skeletons, u);
    return this.bindSkeletons(u, f), u;
  }
  parseShapes(e) {
    const t = {};
    if (e !== void 0)
      for (let i = 0, r = e.length; i < r; i++) {
        const s = new ja().fromJSON(e[i]);
        t[s.uuid] = s;
      }
    return t;
  }
  parseSkeletons(e, t) {
    const i = {},
      r = {};
    if (
      (t.traverse(function (s) {
        s.isBone && (r[s.uuid] = s);
      }),
      e !== void 0)
    )
      for (let s = 0, o = e.length; s < o; s++) {
        const a = new Xg().fromJSON(e[s], r);
        i[a.uuid] = a;
      }
    return i;
  }
  parseGeometries(e, t) {
    const i = {};
    if (e !== void 0) {
      const r = new bI();
      for (let s = 0, o = e.length; s < o; s++) {
        let a;
        const u = e[s];
        switch (u.type) {
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            a = r.parse(u);
            break;
          default:
            u.type in NA
              ? (a = NA[u.type].fromJSON(u, t))
              : console.warn(
                  `THREE.ObjectLoader: Unsupported geometry type "${u.type}"`
                );
        }
        (a.uuid = u.uuid),
          u.name !== void 0 && (a.name = u.name),
          u.userData !== void 0 && (a.userData = u.userData),
          (i[u.uuid] = a);
      }
    }
    return i;
  }
  parseMaterials(e, t) {
    const i = {},
      r = {};
    if (e !== void 0) {
      const s = new lv();
      s.setTextures(t);
      for (let o = 0, a = e.length; o < a; o++) {
        const u = e[o];
        i[u.uuid] === void 0 && (i[u.uuid] = s.parse(u)),
          (r[u.uuid] = i[u.uuid]);
      }
    }
    return r;
  }
  parseAnimations(e) {
    const t = {};
    if (e !== void 0)
      for (let i = 0; i < e.length; i++) {
        const r = e[i],
          s = Kf.parse(r);
        t[s.uuid] = s;
      }
    return t;
  }
  parseImages(e, t) {
    const i = this,
      r = {};
    let s;
    function o(u) {
      return (
        i.manager.itemStart(u),
        s.load(
          u,
          function () {
            i.manager.itemEnd(u);
          },
          void 0,
          function () {
            i.manager.itemError(u), i.manager.itemEnd(u);
          }
        )
      );
    }
    function a(u) {
      if (typeof u == "string") {
        const f = u,
          h = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(f) ? f : i.resourcePath + f;
        return o(h);
      } else
        return u.data
          ? { data: du(u.type, u.data), width: u.width, height: u.height }
          : null;
    }
    if (e !== void 0 && e.length > 0) {
      const u = new iM(t);
      (s = new Qf(u)), s.setCrossOrigin(this.crossOrigin);
      for (let f = 0, h = e.length; f < h; f++) {
        const d = e[f],
          p = d.url;
        if (Array.isArray(p)) {
          const m = [];
          for (let y = 0, w = p.length; y < w; y++) {
            const S = p[y],
              v = a(S);
            v !== null &&
              (v instanceof HTMLImageElement
                ? m.push(v)
                : m.push(new Wa(v.data, v.width, v.height)));
          }
          r[d.uuid] = new Ua(m);
        } else {
          const m = a(d.url);
          r[d.uuid] = new Ua(m);
        }
      }
    }
    return r;
  }
  async parseImagesAsync(e) {
    const t = this,
      i = {};
    let r;
    async function s(o) {
      if (typeof o == "string") {
        const a = o,
          u = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(a) ? a : t.resourcePath + a;
        return await r.loadAsync(u);
      } else
        return o.data
          ? { data: du(o.type, o.data), width: o.width, height: o.height }
          : null;
    }
    if (e !== void 0 && e.length > 0) {
      (r = new Qf(this.manager)), r.setCrossOrigin(this.crossOrigin);
      for (let o = 0, a = e.length; o < a; o++) {
        const u = e[o],
          f = u.url;
        if (Array.isArray(f)) {
          const h = [];
          for (let d = 0, p = f.length; d < p; d++) {
            const m = f[d],
              y = await s(m);
            y !== null &&
              (y instanceof HTMLImageElement
                ? h.push(y)
                : h.push(new Wa(y.data, y.width, y.height)));
          }
          i[u.uuid] = new Ua(h);
        } else {
          const h = await s(u.url);
          i[u.uuid] = new Ua(h);
        }
      }
    }
    return i;
  }
  parseTextures(e, t) {
    function i(s, o) {
      return typeof s == "number"
        ? s
        : (console.warn(
            "THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",
            s
          ),
          o[s]);
    }
    const r = {};
    if (e !== void 0)
      for (let s = 0, o = e.length; s < o; s++) {
        const a = e[s];
        a.image === void 0 &&
          console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid),
          t[a.image] === void 0 &&
            console.warn("THREE.ObjectLoader: Undefined image", a.image);
        const u = t[a.image],
          f = u.data;
        let h;
        Array.isArray(f)
          ? ((h = new _h()), f.length === 6 && (h.needsUpdate = !0))
          : (f && f.data ? (h = new Wa()) : (h = new An()),
            f && (h.needsUpdate = !0)),
          (h.source = u),
          (h.uuid = a.uuid),
          a.name !== void 0 && (h.name = a.name),
          a.mapping !== void 0 && (h.mapping = i(a.mapping, q7)),
          a.channel !== void 0 && (h.channel = a.channel),
          a.offset !== void 0 && h.offset.fromArray(a.offset),
          a.repeat !== void 0 && h.repeat.fromArray(a.repeat),
          a.center !== void 0 && h.center.fromArray(a.center),
          a.rotation !== void 0 && (h.rotation = a.rotation),
          a.wrap !== void 0 &&
            ((h.wrapS = i(a.wrap[0], kA)), (h.wrapT = i(a.wrap[1], kA))),
          a.format !== void 0 && (h.format = a.format),
          a.internalFormat !== void 0 && (h.internalFormat = a.internalFormat),
          a.type !== void 0 && (h.type = a.type),
          a.colorSpace !== void 0 && (h.colorSpace = a.colorSpace),
          a.encoding !== void 0 && (h.encoding = a.encoding),
          a.minFilter !== void 0 && (h.minFilter = i(a.minFilter, FA)),
          a.magFilter !== void 0 && (h.magFilter = i(a.magFilter, FA)),
          a.anisotropy !== void 0 && (h.anisotropy = a.anisotropy),
          a.flipY !== void 0 && (h.flipY = a.flipY),
          a.generateMipmaps !== void 0 &&
            (h.generateMipmaps = a.generateMipmaps),
          a.premultiplyAlpha !== void 0 &&
            (h.premultiplyAlpha = a.premultiplyAlpha),
          a.unpackAlignment !== void 0 &&
            (h.unpackAlignment = a.unpackAlignment),
          a.compareFunction !== void 0 &&
            (h.compareFunction = a.compareFunction),
          a.userData !== void 0 && (h.userData = a.userData),
          (r[a.uuid] = h);
      }
    return r;
  }
  parseObject(e, t, i, r, s) {
    let o;
    function a(p) {
      return (
        t[p] === void 0 &&
          console.warn("THREE.ObjectLoader: Undefined geometry", p),
        t[p]
      );
    }
    function u(p) {
      if (p !== void 0) {
        if (Array.isArray(p)) {
          const m = [];
          for (let y = 0, w = p.length; y < w; y++) {
            const S = p[y];
            i[S] === void 0 &&
              console.warn("THREE.ObjectLoader: Undefined material", S),
              m.push(i[S]);
          }
          return m;
        }
        return (
          i[p] === void 0 &&
            console.warn("THREE.ObjectLoader: Undefined material", p),
          i[p]
        );
      }
    }
    function f(p) {
      return (
        r[p] === void 0 &&
          console.warn("THREE.ObjectLoader: Undefined texture", p),
        r[p]
      );
    }
    let h, d;
    switch (e.type) {
      case "Scene":
        (o = new HS()),
          e.background !== void 0 &&
            (Number.isInteger(e.background)
              ? (o.background = new Be(e.background))
              : (o.background = f(e.background))),
          e.environment !== void 0 && (o.environment = f(e.environment)),
          e.fog !== void 0 &&
            (e.fog.type === "Fog"
              ? (o.fog = new Wg(e.fog.color, e.fog.near, e.fog.far))
              : e.fog.type === "FogExp2" &&
                (o.fog = new Gg(e.fog.color, e.fog.density)),
            e.fog.name !== "" && (o.fog.name = e.fog.name)),
          e.backgroundBlurriness !== void 0 &&
            (o.backgroundBlurriness = e.backgroundBlurriness),
          e.backgroundIntensity !== void 0 &&
            (o.backgroundIntensity = e.backgroundIntensity);
        break;
      case "PerspectiveCamera":
        (o = new En(e.fov, e.aspect, e.near, e.far)),
          e.focus !== void 0 && (o.focus = e.focus),
          e.zoom !== void 0 && (o.zoom = e.zoom),
          e.filmGauge !== void 0 && (o.filmGauge = e.filmGauge),
          e.filmOffset !== void 0 && (o.filmOffset = e.filmOffset),
          e.view !== void 0 && (o.view = Object.assign({}, e.view));
        break;
      case "OrthographicCamera":
        (o = new Fo(e.left, e.right, e.top, e.bottom, e.near, e.far)),
          e.zoom !== void 0 && (o.zoom = e.zoom),
          e.view !== void 0 && (o.view = Object.assign({}, e.view));
        break;
      case "AmbientLight":
        o = new MI(e.color, e.intensity);
        break;
      case "DirectionalLight":
        o = new SI(e.color, e.intensity);
        break;
      case "PointLight":
        o = new _I(e.color, e.intensity, e.distance, e.decay);
        break;
      case "RectAreaLight":
        o = new wI(e.color, e.intensity, e.width, e.height);
        break;
      case "SpotLight":
        o = new xI(
          e.color,
          e.intensity,
          e.distance,
          e.angle,
          e.penumbra,
          e.decay
        );
        break;
      case "HemisphereLight":
        o = new yI(e.color, e.groundColor, e.intensity);
        break;
      case "LightProbe":
        o = new TI().fromJSON(e);
        break;
      case "SkinnedMesh":
        (h = a(e.geometry)),
          (d = u(e.material)),
          (o = new GL(h, d)),
          e.bindMode !== void 0 && (o.bindMode = e.bindMode),
          e.bindMatrix !== void 0 && o.bindMatrix.fromArray(e.bindMatrix),
          e.skeleton !== void 0 && (o.skeleton = e.skeleton);
        break;
      case "Mesh":
        (h = a(e.geometry)), (d = u(e.material)), (o = new Un(h, d));
        break;
      case "InstancedMesh":
        (h = a(e.geometry)), (d = u(e.material));
        const p = e.count,
          m = e.instanceMatrix,
          y = e.instanceColor;
        (o = new WL(h, d, p)),
          (o.instanceMatrix = new zu(new Float32Array(m.array), 16)),
          y !== void 0 &&
            (o.instanceColor = new zu(new Float32Array(y.array), y.itemSize));
        break;
      case "BatchedMesh":
        (h = a(e.geometry)),
          (d = u(e.material)),
          (o = new jL(
            e.maxGeometryCount,
            e.maxVertexCount,
            e.maxIndexCount,
            d
          )),
          (o.geometry = h),
          (o.perObjectFrustumCulled = e.perObjectFrustumCulled),
          (o.sortObjects = e.sortObjects),
          (o._drawRanges = e.drawRanges),
          (o._reservedRanges = e.reservedRanges),
          (o._visibility = e.visibility),
          (o._active = e.active),
          (o._bounds = e.bounds.map((w) => {
            const S = new Ai();
            S.min.fromArray(w.boxMin), S.max.fromArray(w.boxMax);
            const v = new di();
            return (
              (v.radius = w.sphereRadius),
              v.center.fromArray(w.sphereCenter),
              {
                boxInitialized: w.boxInitialized,
                box: S,
                sphereInitialized: w.sphereInitialized,
                sphere: v,
              }
            );
          })),
          (o._maxGeometryCount = e.maxGeometryCount),
          (o._maxVertexCount = e.maxVertexCount),
          (o._maxIndexCount = e.maxIndexCount),
          (o._geometryInitialized = e.geometryInitialized),
          (o._geometryCount = e.geometryCount),
          (o._matricesTexture = f(e.matricesTexture.uuid));
        break;
      case "LOD":
        o = new HL();
        break;
      case "Line":
        o = new jo(a(e.geometry), u(e.material));
        break;
      case "LineLoop":
        o = new XL(a(e.geometry), u(e.material));
        break;
      case "LineSegments":
        o = new ps(a(e.geometry), u(e.material));
        break;
      case "PointCloud":
      case "Points":
        o = new YL(a(e.geometry), u(e.material));
        break;
      case "Sprite":
        o = new VL(u(e.material));
        break;
      case "Group":
        o = new gu();
        break;
      case "Bone":
        o = new WS();
        break;
      default:
        o = new Ft();
    }
    if (
      ((o.uuid = e.uuid),
      e.name !== void 0 && (o.name = e.name),
      e.matrix !== void 0
        ? (o.matrix.fromArray(e.matrix),
          e.matrixAutoUpdate !== void 0 &&
            (o.matrixAutoUpdate = e.matrixAutoUpdate),
          o.matrixAutoUpdate &&
            o.matrix.decompose(o.position, o.quaternion, o.scale))
        : (e.position !== void 0 && o.position.fromArray(e.position),
          e.rotation !== void 0 && o.rotation.fromArray(e.rotation),
          e.quaternion !== void 0 && o.quaternion.fromArray(e.quaternion),
          e.scale !== void 0 && o.scale.fromArray(e.scale)),
      e.up !== void 0 && o.up.fromArray(e.up),
      e.castShadow !== void 0 && (o.castShadow = e.castShadow),
      e.receiveShadow !== void 0 && (o.receiveShadow = e.receiveShadow),
      e.shadow &&
        (e.shadow.bias !== void 0 && (o.shadow.bias = e.shadow.bias),
        e.shadow.normalBias !== void 0 &&
          (o.shadow.normalBias = e.shadow.normalBias),
        e.shadow.radius !== void 0 && (o.shadow.radius = e.shadow.radius),
        e.shadow.mapSize !== void 0 &&
          o.shadow.mapSize.fromArray(e.shadow.mapSize),
        e.shadow.camera !== void 0 &&
          (o.shadow.camera = this.parseObject(e.shadow.camera))),
      e.visible !== void 0 && (o.visible = e.visible),
      e.frustumCulled !== void 0 && (o.frustumCulled = e.frustumCulled),
      e.renderOrder !== void 0 && (o.renderOrder = e.renderOrder),
      e.userData !== void 0 && (o.userData = e.userData),
      e.layers !== void 0 && (o.layers.mask = e.layers),
      e.children !== void 0)
    ) {
      const p = e.children;
      for (let m = 0; m < p.length; m++)
        o.add(this.parseObject(p[m], t, i, r, s));
    }
    if (e.animations !== void 0) {
      const p = e.animations;
      for (let m = 0; m < p.length; m++) {
        const y = p[m];
        o.animations.push(s[y]);
      }
    }
    if (e.type === "LOD") {
      e.autoUpdate !== void 0 && (o.autoUpdate = e.autoUpdate);
      const p = e.levels;
      for (let m = 0; m < p.length; m++) {
        const y = p[m],
          w = o.getObjectByProperty("uuid", y.object);
        w !== void 0 && o.addLevel(w, y.distance, y.hysteresis);
      }
    }
    return o;
  }
  bindSkeletons(e, t) {
    Object.keys(t).length !== 0 &&
      e.traverse(function (i) {
        if (i.isSkinnedMesh === !0 && i.skeleton !== void 0) {
          const r = t[i.skeleton];
          r === void 0
            ? console.warn(
                "THREE.ObjectLoader: No skeleton found with UUID:",
                i.skeleton
              )
            : i.bind(r, i.bindMatrix);
        }
      });
  }
}
const q7 = {
    UVMapping: kg,
    CubeReflectionMapping: Xs,
    CubeRefractionMapping: Go,
    EquirectangularReflectionMapping: If,
    EquirectangularRefractionMapping: Nf,
    CubeUVReflectionMapping: ju,
  },
  kA = {
    RepeatWrapping: Df,
    ClampToEdgeWrapping: fi,
    MirroredRepeatWrapping: Of,
  },
  FA = {
    NearestFilter: Sn,
    NearestMipmapNearestFilter: Jm,
    NearestMipmapLinearFilter: of,
    LinearFilter: wn,
    LinearMipmapNearestFilter: SS,
    LinearMipmapLinearFilter: Wo,
  };
class Z7 extends Hi {
  constructor(e) {
    super(e),
      (this.isImageBitmapLoader = !0),
      typeof createImageBitmap > "u" &&
        console.warn(
          "THREE.ImageBitmapLoader: createImageBitmap() not supported."
        ),
      typeof fetch > "u" &&
        console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
      (this.options = { premultiplyAlpha: "none" });
  }
  setOptions(e) {
    return (this.options = e), this;
  }
  load(e, t, i, r) {
    e === void 0 && (e = ""),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const s = this,
      o = Os.get(e);
    if (o !== void 0) {
      if ((s.manager.itemStart(e), o.then)) {
        o.then((f) => {
          t && t(f), s.manager.itemEnd(e);
        }).catch((f) => {
          r && r(f);
        });
        return;
      }
      return (
        setTimeout(function () {
          t && t(o), s.manager.itemEnd(e);
        }, 0),
        o
      );
    }
    const a = {};
    (a.credentials =
      this.crossOrigin === "anonymous" ? "same-origin" : "include"),
      (a.headers = this.requestHeader);
    const u = fetch(e, a)
      .then(function (f) {
        return f.blob();
      })
      .then(function (f) {
        return createImageBitmap(
          f,
          Object.assign(s.options, { colorSpaceConversion: "none" })
        );
      })
      .then(function (f) {
        return Os.add(e, f), t && t(f), s.manager.itemEnd(e), f;
      })
      .catch(function (f) {
        r && r(f), Os.remove(e), s.manager.itemError(e), s.manager.itemEnd(e);
      });
    Os.add(e, u), s.manager.itemStart(e);
  }
}
let Up;
class sM {
  static getContext() {
    return (
      Up === void 0 &&
        (Up = new (window.AudioContext || window.webkitAudioContext)()),
      Up
    );
  }
  static setContext(e) {
    Up = e;
  }
}
class K7 extends Hi {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = this,
      o = new Ys(this.manager);
    o.setResponseType("arraybuffer"),
      o.setPath(this.path),
      o.setRequestHeader(this.requestHeader),
      o.setWithCredentials(this.withCredentials),
      o.load(
        e,
        function (u) {
          try {
            const f = u.slice(0);
            sM.getContext()
              .decodeAudioData(f, function (d) {
                t(d);
              })
              .catch(a);
          } catch (f) {
            a(f);
          }
        },
        i,
        r
      );
    function a(u) {
      r ? r(u) : console.error(u), s.manager.itemError(e);
    }
  }
}
const zA = new dt(),
  BA = new dt(),
  ga = new dt();
class Q7 {
  constructor() {
    (this.type = "StereoCamera"),
      (this.aspect = 1),
      (this.eyeSep = 0.064),
      (this.cameraL = new En()),
      this.cameraL.layers.enable(1),
      (this.cameraL.matrixAutoUpdate = !1),
      (this.cameraR = new En()),
      this.cameraR.layers.enable(2),
      (this.cameraR.matrixAutoUpdate = !1),
      (this._cache = {
        focus: null,
        fov: null,
        aspect: null,
        near: null,
        far: null,
        zoom: null,
        eyeSep: null,
      });
  }
  update(e) {
    const t = this._cache;
    if (
      t.focus !== e.focus ||
      t.fov !== e.fov ||
      t.aspect !== e.aspect * this.aspect ||
      t.near !== e.near ||
      t.far !== e.far ||
      t.zoom !== e.zoom ||
      t.eyeSep !== this.eyeSep
    ) {
      (t.focus = e.focus),
        (t.fov = e.fov),
        (t.aspect = e.aspect * this.aspect),
        (t.near = e.near),
        (t.far = e.far),
        (t.zoom = e.zoom),
        (t.eyeSep = this.eyeSep),
        ga.copy(e.projectionMatrix);
      const r = t.eyeSep / 2,
        s = (r * t.near) / t.focus,
        o = (t.near * Math.tan(Ha * t.fov * 0.5)) / t.zoom;
      let a, u;
      (BA.elements[12] = -r),
        (zA.elements[12] = r),
        (a = -o * t.aspect + s),
        (u = o * t.aspect + s),
        (ga.elements[0] = (2 * t.near) / (u - a)),
        (ga.elements[8] = (u + a) / (u - a)),
        this.cameraL.projectionMatrix.copy(ga),
        (a = -o * t.aspect - s),
        (u = o * t.aspect - s),
        (ga.elements[0] = (2 * t.near) / (u - a)),
        (ga.elements[8] = (u + a) / (u - a)),
        this.cameraR.projectionMatrix.copy(ga);
    }
    this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(BA),
      this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(zA);
  }
}
class oM {
  constructor(e = !0) {
    (this.autoStart = e),
      (this.startTime = 0),
      (this.oldTime = 0),
      (this.elapsedTime = 0),
      (this.running = !1);
  }
  start() {
    (this.startTime = VA()),
      (this.oldTime = this.startTime),
      (this.elapsedTime = 0),
      (this.running = !0);
  }
  stop() {
    this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running) return this.start(), 0;
    if (this.running) {
      const t = VA();
      (e = (t - this.oldTime) / 1e3),
        (this.oldTime = t),
        (this.elapsedTime += e);
    }
    return e;
  }
}
function VA() {
  return (typeof performance > "u" ? Date : performance).now();
}
const va = new U(),
  HA = new hi(),
  $7 = new U(),
  ya = new U();
class J7 extends Ft {
  constructor() {
    super(),
      (this.type = "AudioListener"),
      (this.context = sM.getContext()),
      (this.gain = this.context.createGain()),
      this.gain.connect(this.context.destination),
      (this.filter = null),
      (this.timeDelta = 0),
      (this._clock = new oM());
  }
  getInput() {
    return this.gain;
  }
  removeFilter() {
    return (
      this.filter !== null &&
        (this.gain.disconnect(this.filter),
        this.filter.disconnect(this.context.destination),
        this.gain.connect(this.context.destination),
        (this.filter = null)),
      this
    );
  }
  getFilter() {
    return this.filter;
  }
  setFilter(e) {
    return (
      this.filter !== null
        ? (this.gain.disconnect(this.filter),
          this.filter.disconnect(this.context.destination))
        : this.gain.disconnect(this.context.destination),
      (this.filter = e),
      this.gain.connect(this.filter),
      this.filter.connect(this.context.destination),
      this
    );
  }
  getMasterVolume() {
    return this.gain.gain.value;
  }
  setMasterVolume(e) {
    return (
      this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this
    );
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e);
    const t = this.context.listener,
      i = this.up;
    if (
      ((this.timeDelta = this._clock.getDelta()),
      this.matrixWorld.decompose(va, HA, $7),
      ya.set(0, 0, -1).applyQuaternion(HA),
      t.positionX)
    ) {
      const r = this.context.currentTime + this.timeDelta;
      t.positionX.linearRampToValueAtTime(va.x, r),
        t.positionY.linearRampToValueAtTime(va.y, r),
        t.positionZ.linearRampToValueAtTime(va.z, r),
        t.forwardX.linearRampToValueAtTime(ya.x, r),
        t.forwardY.linearRampToValueAtTime(ya.y, r),
        t.forwardZ.linearRampToValueAtTime(ya.z, r),
        t.upX.linearRampToValueAtTime(i.x, r),
        t.upY.linearRampToValueAtTime(i.y, r),
        t.upZ.linearRampToValueAtTime(i.z, r);
    } else
      t.setPosition(va.x, va.y, va.z),
        t.setOrientation(ya.x, ya.y, ya.z, i.x, i.y, i.z);
  }
}
class CI extends Ft {
  constructor(e) {
    super(),
      (this.type = "Audio"),
      (this.listener = e),
      (this.context = e.context),
      (this.gain = this.context.createGain()),
      this.gain.connect(e.getInput()),
      (this.autoplay = !1),
      (this.buffer = null),
      (this.detune = 0),
      (this.loop = !1),
      (this.loopStart = 0),
      (this.loopEnd = 0),
      (this.offset = 0),
      (this.duration = void 0),
      (this.playbackRate = 1),
      (this.isPlaying = !1),
      (this.hasPlaybackControl = !0),
      (this.source = null),
      (this.sourceType = "empty"),
      (this._startedAt = 0),
      (this._progress = 0),
      (this._connected = !1),
      (this.filters = []);
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "audioNode"),
      (this.source = e),
      this.connect(),
      this
    );
  }
  setMediaElementSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "mediaNode"),
      (this.source = this.context.createMediaElementSource(e)),
      this.connect(),
      this
    );
  }
  setMediaStreamSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "mediaStreamNode"),
      (this.source = this.context.createMediaStreamSource(e)),
      this.connect(),
      this
    );
  }
  setBuffer(e) {
    return (
      (this.buffer = e),
      (this.sourceType = "buffer"),
      this.autoplay && this.play(),
      this
    );
  }
  play(e = 0) {
    if (this.isPlaying === !0) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + e;
    const t = this.context.createBufferSource();
    return (
      (t.buffer = this.buffer),
      (t.loop = this.loop),
      (t.loopStart = this.loopStart),
      (t.loopEnd = this.loopEnd),
      (t.onended = this.onEnded.bind(this)),
      t.start(this._startedAt, this._progress + this.offset, this.duration),
      (this.isPlaying = !0),
      (this.source = t),
      this.setDetune(this.detune),
      this.setPlaybackRate(this.playbackRate),
      this.connect()
    );
  }
  pause() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      this.isPlaying === !0 &&
        ((this._progress +=
          Math.max(this.context.currentTime - this._startedAt, 0) *
          this.playbackRate),
        this.loop === !0 &&
          (this._progress =
            this._progress % (this.duration || this.buffer.duration)),
        this.source.stop(),
        (this.source.onended = null),
        (this.isPlaying = !1)),
      this
    );
  }
  stop() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this._progress = 0),
      this.source !== null &&
        (this.source.stop(), (this.source.onended = null)),
      (this.isPlaying = !1),
      this
    );
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let e = 1, t = this.filters.length; e < t; e++)
        this.filters[e - 1].connect(this.filters[e]);
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else this.source.connect(this.getOutput());
    return (this._connected = !0), this;
  }
  disconnect() {
    if (this._connected !== !1) {
      if (this.filters.length > 0) {
        this.source.disconnect(this.filters[0]);
        for (let e = 1, t = this.filters.length; e < t; e++)
          this.filters[e - 1].disconnect(this.filters[e]);
        this.filters[this.filters.length - 1].disconnect(this.getOutput());
      } else this.source.disconnect(this.getOutput());
      return (this._connected = !1), this;
    }
  }
  getFilters() {
    return this.filters;
  }
  setFilters(e) {
    return (
      e || (e = []),
      this._connected === !0
        ? (this.disconnect(), (this.filters = e.slice()), this.connect())
        : (this.filters = e.slice()),
      this
    );
  }
  setDetune(e) {
    if (((this.detune = e), this.source.detune !== void 0))
      return (
        this.isPlaying === !0 &&
          this.source.detune.setTargetAtTime(
            this.detune,
            this.context.currentTime,
            0.01
          ),
        this
      );
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(e) {
    return this.setFilters(e ? [e] : []);
  }
  setPlaybackRate(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this.playbackRate = e),
      this.isPlaying === !0 &&
        this.source.playbackRate.setTargetAtTime(
          this.playbackRate,
          this.context.currentTime,
          0.01
        ),
      this
    );
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    this.isPlaying = !1;
  }
  getLoop() {
    return this.hasPlaybackControl === !1
      ? (console.warn("THREE.Audio: this Audio has no playback control."), !1)
      : this.loop;
  }
  setLoop(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this.loop = e),
      this.isPlaying === !0 && (this.source.loop = this.loop),
      this
    );
  }
  setLoopStart(e) {
    return (this.loopStart = e), this;
  }
  setLoopEnd(e) {
    return (this.loopEnd = e), this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(e) {
    return (
      this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this
    );
  }
}
const xa = new U(),
  GA = new hi(),
  eW = new U(),
  _a = new U();
class tW extends CI {
  constructor(e) {
    super(e),
      (this.panner = this.context.createPanner()),
      (this.panner.panningModel = "HRTF"),
      this.panner.connect(this.gain);
  }
  connect() {
    super.connect(), this.panner.connect(this.gain);
  }
  disconnect() {
    super.disconnect(), this.panner.disconnect(this.gain);
  }
  getOutput() {
    return this.panner;
  }
  getRefDistance() {
    return this.panner.refDistance;
  }
  setRefDistance(e) {
    return (this.panner.refDistance = e), this;
  }
  getRolloffFactor() {
    return this.panner.rolloffFactor;
  }
  setRolloffFactor(e) {
    return (this.panner.rolloffFactor = e), this;
  }
  getDistanceModel() {
    return this.panner.distanceModel;
  }
  setDistanceModel(e) {
    return (this.panner.distanceModel = e), this;
  }
  getMaxDistance() {
    return this.panner.maxDistance;
  }
  setMaxDistance(e) {
    return (this.panner.maxDistance = e), this;
  }
  setDirectionalCone(e, t, i) {
    return (
      (this.panner.coneInnerAngle = e),
      (this.panner.coneOuterAngle = t),
      (this.panner.coneOuterGain = i),
      this
    );
  }
  updateMatrixWorld(e) {
    if (
      (super.updateMatrixWorld(e),
      this.hasPlaybackControl === !0 && this.isPlaying === !1)
    )
      return;
    this.matrixWorld.decompose(xa, GA, eW), _a.set(0, 0, 1).applyQuaternion(GA);
    const t = this.panner;
    if (t.positionX) {
      const i = this.context.currentTime + this.listener.timeDelta;
      t.positionX.linearRampToValueAtTime(xa.x, i),
        t.positionY.linearRampToValueAtTime(xa.y, i),
        t.positionZ.linearRampToValueAtTime(xa.z, i),
        t.orientationX.linearRampToValueAtTime(_a.x, i),
        t.orientationY.linearRampToValueAtTime(_a.y, i),
        t.orientationZ.linearRampToValueAtTime(_a.z, i);
    } else t.setPosition(xa.x, xa.y, xa.z), t.setOrientation(_a.x, _a.y, _a.z);
  }
}
class nW {
  constructor(e, t = 2048) {
    (this.analyser = e.context.createAnalyser()),
      (this.analyser.fftSize = t),
      (this.data = new Uint8Array(this.analyser.frequencyBinCount)),
      e.getOutput().connect(this.analyser);
  }
  getFrequencyData() {
    return this.analyser.getByteFrequencyData(this.data), this.data;
  }
  getAverageFrequency() {
    let e = 0;
    const t = this.getFrequencyData();
    for (let i = 0; i < t.length; i++) e += t[i];
    return e / t.length;
  }
}
class PI {
  constructor(e, t, i) {
    (this.binding = e), (this.valueSize = i);
    let r, s, o;
    switch (t) {
      case "quaternion":
        (r = this._slerp),
          (s = this._slerpAdditive),
          (o = this._setAdditiveIdentityQuaternion),
          (this.buffer = new Float64Array(i * 6)),
          (this._workIndex = 5);
        break;
      case "string":
      case "bool":
        (r = this._select),
          (s = this._select),
          (o = this._setAdditiveIdentityOther),
          (this.buffer = new Array(i * 5));
        break;
      default:
        (r = this._lerp),
          (s = this._lerpAdditive),
          (o = this._setAdditiveIdentityNumeric),
          (this.buffer = new Float64Array(i * 5));
    }
    (this._mixBufferRegion = r),
      (this._mixBufferRegionAdditive = s),
      (this._setIdentity = o),
      (this._origIndex = 3),
      (this._addIndex = 4),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0),
      (this.useCount = 0),
      (this.referenceCount = 0);
  }
  accumulate(e, t) {
    const i = this.buffer,
      r = this.valueSize,
      s = e * r + r;
    let o = this.cumulativeWeight;
    if (o === 0) {
      for (let a = 0; a !== r; ++a) i[s + a] = i[a];
      o = t;
    } else {
      o += t;
      const a = t / o;
      this._mixBufferRegion(i, s, 0, a, r);
    }
    this.cumulativeWeight = o;
  }
  accumulateAdditive(e) {
    const t = this.buffer,
      i = this.valueSize,
      r = i * this._addIndex;
    this.cumulativeWeightAdditive === 0 && this._setIdentity(),
      this._mixBufferRegionAdditive(t, r, 0, e, i),
      (this.cumulativeWeightAdditive += e);
  }
  apply(e) {
    const t = this.valueSize,
      i = this.buffer,
      r = e * t + t,
      s = this.cumulativeWeight,
      o = this.cumulativeWeightAdditive,
      a = this.binding;
    if (
      ((this.cumulativeWeight = 0), (this.cumulativeWeightAdditive = 0), s < 1)
    ) {
      const u = t * this._origIndex;
      this._mixBufferRegion(i, r, u, 1 - s, t);
    }
    o > 0 && this._mixBufferRegionAdditive(i, r, this._addIndex * t, 1, t);
    for (let u = t, f = t + t; u !== f; ++u)
      if (i[u] !== i[u + t]) {
        a.setValue(i, r);
        break;
      }
  }
  saveOriginalState() {
    const e = this.binding,
      t = this.buffer,
      i = this.valueSize,
      r = i * this._origIndex;
    e.getValue(t, r);
    for (let s = i, o = r; s !== o; ++s) t[s] = t[r + (s % i)];
    this._setIdentity(),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0);
  }
  restoreOriginalState() {
    const e = this.valueSize * 3;
    this.binding.setValue(this.buffer, e);
  }
  _setAdditiveIdentityNumeric() {
    const e = this._addIndex * this.valueSize,
      t = e + this.valueSize;
    for (let i = e; i < t; i++) this.buffer[i] = 0;
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric(),
      (this.buffer[this._addIndex * this.valueSize + 3] = 1);
  }
  _setAdditiveIdentityOther() {
    const e = this._origIndex * this.valueSize,
      t = this._addIndex * this.valueSize;
    for (let i = 0; i < this.valueSize; i++)
      this.buffer[t + i] = this.buffer[e + i];
  }
  _select(e, t, i, r, s) {
    if (r >= 0.5) for (let o = 0; o !== s; ++o) e[t + o] = e[i + o];
  }
  _slerp(e, t, i, r) {
    hi.slerpFlat(e, t, e, t, e, i, r);
  }
  _slerpAdditive(e, t, i, r, s) {
    const o = this._workIndex * s;
    hi.multiplyQuaternionsFlat(e, o, e, t, e, i),
      hi.slerpFlat(e, t, e, t, e, o, r);
  }
  _lerp(e, t, i, r, s) {
    const o = 1 - r;
    for (let a = 0; a !== s; ++a) {
      const u = t + a;
      e[u] = e[u] * o + e[i + a] * r;
    }
  }
  _lerpAdditive(e, t, i, r, s) {
    for (let o = 0; o !== s; ++o) {
      const a = t + o;
      e[a] = e[a] + e[i + o] * r;
    }
  }
}
const aM = "\\[\\]\\.:\\/",
  iW = new RegExp("[" + aM + "]", "g"),
  lM = "[^" + aM + "]",
  rW = "[^" + aM.replace("\\.", "") + "]",
  sW = /((?:WC+[\/:])*)/.source.replace("WC", lM),
  oW = /(WCOD+)?/.source.replace("WCOD", rW),
  aW = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", lM),
  lW = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", lM),
  uW = new RegExp("^" + sW + oW + aW + lW + "$"),
  cW = ["material", "materials", "bones", "map"];
class fW {
  constructor(e, t, i) {
    const r = i || Nt.parseTrackName(t);
    (this._targetGroup = e), (this._bindings = e.subscribe_(t, r));
  }
  getValue(e, t) {
    this.bind();
    const i = this._targetGroup.nCachedObjects_,
      r = this._bindings[i];
    r !== void 0 && r.getValue(e, t);
  }
  setValue(e, t) {
    const i = this._bindings;
    for (let r = this._targetGroup.nCachedObjects_, s = i.length; r !== s; ++r)
      i[r].setValue(e, t);
  }
  bind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)
      e[t].bind();
  }
  unbind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)
      e[t].unbind();
  }
}
class Nt {
  constructor(e, t, i) {
    (this.path = t),
      (this.parsedPath = i || Nt.parseTrackName(t)),
      (this.node = Nt.findNode(e, this.parsedPath.nodeName)),
      (this.rootNode = e),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
  static create(e, t, i) {
    return e && e.isAnimationObjectGroup
      ? new Nt.Composite(e, t, i)
      : new Nt(e, t, i);
  }
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, "_").replace(iW, "");
  }
  static parseTrackName(e) {
    const t = uW.exec(e);
    if (t === null)
      throw new Error("PropertyBinding: Cannot parse trackName: " + e);
    const i = {
        nodeName: t[2],
        objectName: t[3],
        objectIndex: t[4],
        propertyName: t[5],
        propertyIndex: t[6],
      },
      r = i.nodeName && i.nodeName.lastIndexOf(".");
    if (r !== void 0 && r !== -1) {
      const s = i.nodeName.substring(r + 1);
      cW.indexOf(s) !== -1 &&
        ((i.nodeName = i.nodeName.substring(0, r)), (i.objectName = s));
    }
    if (i.propertyName === null || i.propertyName.length === 0)
      throw new Error(
        "PropertyBinding: can not parse propertyName from trackName: " + e
      );
    return i;
  }
  static findNode(e, t) {
    if (
      t === void 0 ||
      t === "" ||
      t === "." ||
      t === -1 ||
      t === e.name ||
      t === e.uuid
    )
      return e;
    if (e.skeleton) {
      const i = e.skeleton.getBoneByName(t);
      if (i !== void 0) return i;
    }
    if (e.children) {
      const i = function (s) {
          for (let o = 0; o < s.length; o++) {
            const a = s[o];
            if (a.name === t || a.uuid === t) return a;
            const u = i(a.children);
            if (u) return u;
          }
          return null;
        },
        r = i(e.children);
      if (r) return r;
    }
    return null;
  }
  _getValue_unavailable() {}
  _setValue_unavailable() {}
  _getValue_direct(e, t) {
    e[t] = this.targetObject[this.propertyName];
  }
  _getValue_array(e, t) {
    const i = this.resolvedProperty;
    for (let r = 0, s = i.length; r !== s; ++r) e[t++] = i[r];
  }
  _getValue_arrayElement(e, t) {
    e[t] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(e, t) {
    this.resolvedProperty.toArray(e, t);
  }
  _setValue_direct(e, t) {
    this.targetObject[this.propertyName] = e[t];
  }
  _setValue_direct_setNeedsUpdate(e, t) {
    (this.targetObject[this.propertyName] = e[t]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
    (this.targetObject[this.propertyName] = e[t]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_array(e, t) {
    const i = this.resolvedProperty;
    for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[t++];
  }
  _setValue_array_setNeedsUpdate(e, t) {
    const i = this.resolvedProperty;
    for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[t++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
    const i = this.resolvedProperty;
    for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[t++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _setValue_arrayElement(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t];
  }
  _setValue_arrayElement_setNeedsUpdate(e, t) {
    (this.resolvedProperty[this.propertyIndex] = e[t]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
    (this.resolvedProperty[this.propertyIndex] = e[t]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_fromArray(e, t) {
    this.resolvedProperty.fromArray(e, t);
  }
  _setValue_fromArray_setNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), (this.targetObject.needsUpdate = !0);
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _getValue_unbound(e, t) {
    this.bind(), this.getValue(e, t);
  }
  _setValue_unbound(e, t) {
    this.bind(), this.setValue(e, t);
  }
  bind() {
    let e = this.node;
    const t = this.parsedPath,
      i = t.objectName,
      r = t.propertyName;
    let s = t.propertyIndex;
    if (
      (e || ((e = Nt.findNode(this.rootNode, t.nodeName)), (this.node = e)),
      (this.getValue = this._getValue_unavailable),
      (this.setValue = this._setValue_unavailable),
      !e)
    ) {
      console.warn(
        "THREE.PropertyBinding: No target node found for track: " +
          this.path +
          "."
      );
      return;
    }
    if (i) {
      let f = t.objectIndex;
      switch (i) {
        case "materials":
          if (!e.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this
            );
            return;
          }
          if (!e.material.materials) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
              this
            );
            return;
          }
          e = e.material.materials;
          break;
        case "bones":
          if (!e.skeleton) {
            console.error(
              "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
              this
            );
            return;
          }
          e = e.skeleton.bones;
          for (let h = 0; h < e.length; h++)
            if (e[h].name === f) {
              f = h;
              break;
            }
          break;
        case "map":
          if ("map" in e) {
            e = e.map;
            break;
          }
          if (!e.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this
            );
            return;
          }
          if (!e.material.map) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",
              this
            );
            return;
          }
          e = e.material.map;
          break;
        default:
          if (e[i] === void 0) {
            console.error(
              "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
              this
            );
            return;
          }
          e = e[i];
      }
      if (f !== void 0) {
        if (e[f] === void 0) {
          console.error(
            "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
            this,
            e
          );
          return;
        }
        e = e[f];
      }
    }
    const o = e[r];
    if (o === void 0) {
      const f = t.nodeName;
      console.error(
        "THREE.PropertyBinding: Trying to update property for track: " +
          f +
          "." +
          r +
          " but it wasn't found.",
        e
      );
      return;
    }
    let a = this.Versioning.None;
    (this.targetObject = e),
      e.needsUpdate !== void 0
        ? (a = this.Versioning.NeedsUpdate)
        : e.matrixWorldNeedsUpdate !== void 0 &&
          (a = this.Versioning.MatrixWorldNeedsUpdate);
    let u = this.BindingType.Direct;
    if (s !== void 0) {
      if (r === "morphTargetInfluences") {
        if (!e.geometry) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
            this
          );
          return;
        }
        if (!e.geometry.morphAttributes) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
            this
          );
          return;
        }
        e.morphTargetDictionary[s] !== void 0 &&
          (s = e.morphTargetDictionary[s]);
      }
      (u = this.BindingType.ArrayElement),
        (this.resolvedProperty = o),
        (this.propertyIndex = s);
    } else
      o.fromArray !== void 0 && o.toArray !== void 0
        ? ((u = this.BindingType.HasFromToArray), (this.resolvedProperty = o))
        : Array.isArray(o)
        ? ((u = this.BindingType.EntireArray), (this.resolvedProperty = o))
        : (this.propertyName = r);
    (this.getValue = this.GetterByBindingType[u]),
      (this.setValue = this.SetterByBindingTypeAndVersioning[u][a]);
  }
  unbind() {
    (this.node = null),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
}
Nt.Composite = fW;
Nt.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3,
};
Nt.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2,
};
Nt.prototype.GetterByBindingType = [
  Nt.prototype._getValue_direct,
  Nt.prototype._getValue_array,
  Nt.prototype._getValue_arrayElement,
  Nt.prototype._getValue_toArray,
];
Nt.prototype.SetterByBindingTypeAndVersioning = [
  [
    Nt.prototype._setValue_direct,
    Nt.prototype._setValue_direct_setNeedsUpdate,
    Nt.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
  ],
  [
    Nt.prototype._setValue_array,
    Nt.prototype._setValue_array_setNeedsUpdate,
    Nt.prototype._setValue_array_setMatrixWorldNeedsUpdate,
  ],
  [
    Nt.prototype._setValue_arrayElement,
    Nt.prototype._setValue_arrayElement_setNeedsUpdate,
    Nt.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
  ],
  [
    Nt.prototype._setValue_fromArray,
    Nt.prototype._setValue_fromArray_setNeedsUpdate,
    Nt.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
  ],
];
class hW {
  constructor() {
    (this.isAnimationObjectGroup = !0),
      (this.uuid = er()),
      (this._objects = Array.prototype.slice.call(arguments)),
      (this.nCachedObjects_ = 0);
    const e = {};
    this._indicesByUUID = e;
    for (let i = 0, r = arguments.length; i !== r; ++i)
      e[arguments[i].uuid] = i;
    (this._paths = []),
      (this._parsedPaths = []),
      (this._bindings = []),
      (this._bindingsIndicesByPath = {});
    const t = this;
    this.stats = {
      objects: {
        get total() {
          return t._objects.length;
        },
        get inUse() {
          return this.total - t.nCachedObjects_;
        },
      },
      get bindingsPerObject() {
        return t._bindings.length;
      },
    };
  }
  add() {
    const e = this._objects,
      t = this._indicesByUUID,
      i = this._paths,
      r = this._parsedPaths,
      s = this._bindings,
      o = s.length;
    let a,
      u = e.length,
      f = this.nCachedObjects_;
    for (let h = 0, d = arguments.length; h !== d; ++h) {
      const p = arguments[h],
        m = p.uuid;
      let y = t[m];
      if (y === void 0) {
        (y = u++), (t[m] = y), e.push(p);
        for (let w = 0, S = o; w !== S; ++w) s[w].push(new Nt(p, i[w], r[w]));
      } else if (y < f) {
        a = e[y];
        const w = --f,
          S = e[w];
        (t[S.uuid] = y), (e[y] = S), (t[m] = w), (e[w] = p);
        for (let v = 0, M = o; v !== M; ++v) {
          const _ = s[v],
            T = _[w];
          let P = _[y];
          (_[y] = T), P === void 0 && (P = new Nt(p, i[v], r[v])), (_[w] = P);
        }
      } else
        e[y] !== a &&
          console.error(
            "THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes."
          );
    }
    this.nCachedObjects_ = f;
  }
  remove() {
    const e = this._objects,
      t = this._indicesByUUID,
      i = this._bindings,
      r = i.length;
    let s = this.nCachedObjects_;
    for (let o = 0, a = arguments.length; o !== a; ++o) {
      const u = arguments[o],
        f = u.uuid,
        h = t[f];
      if (h !== void 0 && h >= s) {
        const d = s++,
          p = e[d];
        (t[p.uuid] = h), (e[h] = p), (t[f] = d), (e[d] = u);
        for (let m = 0, y = r; m !== y; ++m) {
          const w = i[m],
            S = w[d],
            v = w[h];
          (w[h] = S), (w[d] = v);
        }
      }
    }
    this.nCachedObjects_ = s;
  }
  uncache() {
    const e = this._objects,
      t = this._indicesByUUID,
      i = this._bindings,
      r = i.length;
    let s = this.nCachedObjects_,
      o = e.length;
    for (let a = 0, u = arguments.length; a !== u; ++a) {
      const f = arguments[a],
        h = f.uuid,
        d = t[h];
      if (d !== void 0)
        if ((delete t[h], d < s)) {
          const p = --s,
            m = e[p],
            y = --o,
            w = e[y];
          (t[m.uuid] = d), (e[d] = m), (t[w.uuid] = p), (e[p] = w), e.pop();
          for (let S = 0, v = r; S !== v; ++S) {
            const M = i[S],
              _ = M[p],
              T = M[y];
            (M[d] = _), (M[p] = T), M.pop();
          }
        } else {
          const p = --o,
            m = e[p];
          p > 0 && (t[m.uuid] = d), (e[d] = m), e.pop();
          for (let y = 0, w = r; y !== w; ++y) {
            const S = i[y];
            (S[d] = S[p]), S.pop();
          }
        }
    }
    this.nCachedObjects_ = s;
  }
  subscribe_(e, t) {
    const i = this._bindingsIndicesByPath;
    let r = i[e];
    const s = this._bindings;
    if (r !== void 0) return s[r];
    const o = this._paths,
      a = this._parsedPaths,
      u = this._objects,
      f = u.length,
      h = this.nCachedObjects_,
      d = new Array(f);
    (r = s.length), (i[e] = r), o.push(e), a.push(t), s.push(d);
    for (let p = h, m = u.length; p !== m; ++p) {
      const y = u[p];
      d[p] = new Nt(y, e, t);
    }
    return d;
  }
  unsubscribe_(e) {
    const t = this._bindingsIndicesByPath,
      i = t[e];
    if (i !== void 0) {
      const r = this._paths,
        s = this._parsedPaths,
        o = this._bindings,
        a = o.length - 1,
        u = o[a],
        f = e[a];
      (t[f] = i),
        (o[i] = u),
        o.pop(),
        (s[i] = s[a]),
        s.pop(),
        (r[i] = r[a]),
        r.pop();
    }
  }
}
class RI {
  constructor(e, t, i = null, r = t.blendMode) {
    (this._mixer = e),
      (this._clip = t),
      (this._localRoot = i),
      (this.blendMode = r);
    const s = t.tracks,
      o = s.length,
      a = new Array(o),
      u = { endingStart: Da, endingEnd: Da };
    for (let f = 0; f !== o; ++f) {
      const h = s[f].createInterpolant(null);
      (a[f] = h), (h.settings = u);
    }
    (this._interpolantSettings = u),
      (this._interpolants = a),
      (this._propertyBindings = new Array(o)),
      (this._cacheIndex = null),
      (this._byClipCacheIndex = null),
      (this._timeScaleInterpolant = null),
      (this._weightInterpolant = null),
      (this.loop = cL),
      (this._loopCount = -1),
      (this._startTime = null),
      (this.time = 0),
      (this.timeScale = 1),
      (this._effectiveTimeScale = 1),
      (this.weight = 1),
      (this._effectiveWeight = 1),
      (this.repetitions = 1 / 0),
      (this.paused = !1),
      (this.enabled = !0),
      (this.clampWhenFinished = !1),
      (this.zeroSlopeAtStart = !0),
      (this.zeroSlopeAtEnd = !0);
  }
  play() {
    return this._mixer._activateAction(this), this;
  }
  stop() {
    return this._mixer._deactivateAction(this), this.reset();
  }
  reset() {
    return (
      (this.paused = !1),
      (this.enabled = !0),
      (this.time = 0),
      (this._loopCount = -1),
      (this._startTime = null),
      this.stopFading().stopWarping()
    );
  }
  isRunning() {
    return (
      this.enabled &&
      !this.paused &&
      this.timeScale !== 0 &&
      this._startTime === null &&
      this._mixer._isActiveAction(this)
    );
  }
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(e) {
    return (this._startTime = e), this;
  }
  setLoop(e, t) {
    return (this.loop = e), (this.repetitions = t), this;
  }
  setEffectiveWeight(e) {
    return (
      (this.weight = e),
      (this._effectiveWeight = this.enabled ? e : 0),
      this.stopFading()
    );
  }
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(e) {
    return this._scheduleFading(e, 0, 1);
  }
  fadeOut(e) {
    return this._scheduleFading(e, 1, 0);
  }
  crossFadeFrom(e, t, i) {
    if ((e.fadeOut(t), this.fadeIn(t), i)) {
      const r = this._clip.duration,
        s = e._clip.duration,
        o = s / r,
        a = r / s;
      e.warp(1, o, t), this.warp(a, 1, t);
    }
    return this;
  }
  crossFadeTo(e, t, i) {
    return e.crossFadeFrom(this, t, i);
  }
  stopFading() {
    const e = this._weightInterpolant;
    return (
      e !== null &&
        ((this._weightInterpolant = null),
        this._mixer._takeBackControlInterpolant(e)),
      this
    );
  }
  setEffectiveTimeScale(e) {
    return (
      (this.timeScale = e),
      (this._effectiveTimeScale = this.paused ? 0 : e),
      this.stopWarping()
    );
  }
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(e) {
    return (this.timeScale = this._clip.duration / e), this.stopWarping();
  }
  syncWith(e) {
    return (
      (this.time = e.time), (this.timeScale = e.timeScale), this.stopWarping()
    );
  }
  halt(e) {
    return this.warp(this._effectiveTimeScale, 0, e);
  }
  warp(e, t, i) {
    const r = this._mixer,
      s = r.time,
      o = this.timeScale;
    let a = this._timeScaleInterpolant;
    a === null &&
      ((a = r._lendControlInterpolant()), (this._timeScaleInterpolant = a));
    const u = a.parameterPositions,
      f = a.sampleValues;
    return (u[0] = s), (u[1] = s + i), (f[0] = e / o), (f[1] = t / o), this;
  }
  stopWarping() {
    const e = this._timeScaleInterpolant;
    return (
      e !== null &&
        ((this._timeScaleInterpolant = null),
        this._mixer._takeBackControlInterpolant(e)),
      this
    );
  }
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  _update(e, t, i, r) {
    if (!this.enabled) {
      this._updateWeight(e);
      return;
    }
    const s = this._startTime;
    if (s !== null) {
      const u = (e - s) * i;
      u < 0 || i === 0 ? (t = 0) : ((this._startTime = null), (t = i * u));
    }
    t *= this._updateTimeScale(e);
    const o = this._updateTime(t),
      a = this._updateWeight(e);
    if (a > 0) {
      const u = this._interpolants,
        f = this._propertyBindings;
      switch (this.blendMode) {
        case PS:
          for (let h = 0, d = u.length; h !== d; ++h)
            u[h].evaluate(o), f[h].accumulateAdditive(a);
          break;
        case zg:
        default:
          for (let h = 0, d = u.length; h !== d; ++h)
            u[h].evaluate(o), f[h].accumulate(r, a);
      }
    }
  }
  _updateWeight(e) {
    let t = 0;
    if (this.enabled) {
      t = this.weight;
      const i = this._weightInterpolant;
      if (i !== null) {
        const r = i.evaluate(e)[0];
        (t *= r),
          e > i.parameterPositions[1] &&
            (this.stopFading(), r === 0 && (this.enabled = !1));
      }
    }
    return (this._effectiveWeight = t), t;
  }
  _updateTimeScale(e) {
    let t = 0;
    if (!this.paused) {
      t = this.timeScale;
      const i = this._timeScaleInterpolant;
      if (i !== null) {
        const r = i.evaluate(e)[0];
        (t *= r),
          e > i.parameterPositions[1] &&
            (this.stopWarping(),
            t === 0 ? (this.paused = !0) : (this.timeScale = t));
      }
    }
    return (this._effectiveTimeScale = t), t;
  }
  _updateTime(e) {
    const t = this._clip.duration,
      i = this.loop;
    let r = this.time + e,
      s = this._loopCount;
    const o = i === fL;
    if (e === 0) return s === -1 ? r : o && (s & 1) === 1 ? t - r : r;
    if (i === uL) {
      s === -1 && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
      e: {
        if (r >= t) r = t;
        else if (r < 0) r = 0;
        else {
          this.time = r;
          break e;
        }
        this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
          (this.time = r),
          this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: e < 0 ? -1 : 1,
          });
      }
    } else {
      if (
        (s === -1 &&
          (e >= 0
            ? ((s = 0), this._setEndings(!0, this.repetitions === 0, o))
            : this._setEndings(this.repetitions === 0, !0, o)),
        r >= t || r < 0)
      ) {
        const a = Math.floor(r / t);
        (r -= t * a), (s += Math.abs(a));
        const u = this.repetitions - s;
        if (u <= 0)
          this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
            (r = e > 0 ? t : 0),
            (this.time = r),
            this._mixer.dispatchEvent({
              type: "finished",
              action: this,
              direction: e > 0 ? 1 : -1,
            });
        else {
          if (u === 1) {
            const f = e < 0;
            this._setEndings(f, !f, o);
          } else this._setEndings(!1, !1, o);
          (this._loopCount = s),
            (this.time = r),
            this._mixer.dispatchEvent({
              type: "loop",
              action: this,
              loopDelta: a,
            });
        }
      } else this.time = r;
      if (o && (s & 1) === 1) return t - r;
    }
    return r;
  }
  _setEndings(e, t, i) {
    const r = this._interpolantSettings;
    i
      ? ((r.endingStart = Oa), (r.endingEnd = Oa))
      : (e
          ? (r.endingStart = this.zeroSlopeAtStart ? Oa : Da)
          : (r.endingStart = Ff),
        t ? (r.endingEnd = this.zeroSlopeAtEnd ? Oa : Da) : (r.endingEnd = Ff));
  }
  _scheduleFading(e, t, i) {
    const r = this._mixer,
      s = r.time;
    let o = this._weightInterpolant;
    o === null &&
      ((o = r._lendControlInterpolant()), (this._weightInterpolant = o));
    const a = o.parameterPositions,
      u = o.sampleValues;
    return (a[0] = s), (u[0] = t), (a[1] = s + e), (u[1] = i), this;
  }
}
const dW = new Float32Array(1);
class pW extends Zs {
  constructor(e) {
    super(),
      (this._root = e),
      this._initMemoryManager(),
      (this._accuIndex = 0),
      (this.time = 0),
      (this.timeScale = 1);
  }
  _bindAction(e, t) {
    const i = e._localRoot || this._root,
      r = e._clip.tracks,
      s = r.length,
      o = e._propertyBindings,
      a = e._interpolants,
      u = i.uuid,
      f = this._bindingsByRootAndName;
    let h = f[u];
    h === void 0 && ((h = {}), (f[u] = h));
    for (let d = 0; d !== s; ++d) {
      const p = r[d],
        m = p.name;
      let y = h[m];
      if (y !== void 0) ++y.referenceCount, (o[d] = y);
      else {
        if (((y = o[d]), y !== void 0)) {
          y._cacheIndex === null &&
            (++y.referenceCount, this._addInactiveBinding(y, u, m));
          continue;
        }
        const w = t && t._propertyBindings[d].binding.parsedPath;
        (y = new PI(Nt.create(i, m, w), p.ValueTypeName, p.getValueSize())),
          ++y.referenceCount,
          this._addInactiveBinding(y, u, m),
          (o[d] = y);
      }
      a[d].resultBuffer = y.buffer;
    }
  }
  _activateAction(e) {
    if (!this._isActiveAction(e)) {
      if (e._cacheIndex === null) {
        const i = (e._localRoot || this._root).uuid,
          r = e._clip.uuid,
          s = this._actionsByClip[r];
        this._bindAction(e, s && s.knownActions[0]),
          this._addInactiveAction(e, r, i);
      }
      const t = e._propertyBindings;
      for (let i = 0, r = t.length; i !== r; ++i) {
        const s = t[i];
        s.useCount++ === 0 && (this._lendBinding(s), s.saveOriginalState());
      }
      this._lendAction(e);
    }
  }
  _deactivateAction(e) {
    if (this._isActiveAction(e)) {
      const t = e._propertyBindings;
      for (let i = 0, r = t.length; i !== r; ++i) {
        const s = t[i];
        --s.useCount === 0 &&
          (s.restoreOriginalState(), this._takeBackBinding(s));
      }
      this._takeBackAction(e);
    }
  }
  _initMemoryManager() {
    (this._actions = []),
      (this._nActiveActions = 0),
      (this._actionsByClip = {}),
      (this._bindings = []),
      (this._nActiveBindings = 0),
      (this._bindingsByRootAndName = {}),
      (this._controlInterpolants = []),
      (this._nActiveControlInterpolants = 0);
    const e = this;
    this.stats = {
      actions: {
        get total() {
          return e._actions.length;
        },
        get inUse() {
          return e._nActiveActions;
        },
      },
      bindings: {
        get total() {
          return e._bindings.length;
        },
        get inUse() {
          return e._nActiveBindings;
        },
      },
      controlInterpolants: {
        get total() {
          return e._controlInterpolants.length;
        },
        get inUse() {
          return e._nActiveControlInterpolants;
        },
      },
    };
  }
  _isActiveAction(e) {
    const t = e._cacheIndex;
    return t !== null && t < this._nActiveActions;
  }
  _addInactiveAction(e, t, i) {
    const r = this._actions,
      s = this._actionsByClip;
    let o = s[t];
    if (o === void 0)
      (o = { knownActions: [e], actionByRoot: {} }),
        (e._byClipCacheIndex = 0),
        (s[t] = o);
    else {
      const a = o.knownActions;
      (e._byClipCacheIndex = a.length), a.push(e);
    }
    (e._cacheIndex = r.length), r.push(e), (o.actionByRoot[i] = e);
  }
  _removeInactiveAction(e) {
    const t = this._actions,
      i = t[t.length - 1],
      r = e._cacheIndex;
    (i._cacheIndex = r), (t[r] = i), t.pop(), (e._cacheIndex = null);
    const s = e._clip.uuid,
      o = this._actionsByClip,
      a = o[s],
      u = a.knownActions,
      f = u[u.length - 1],
      h = e._byClipCacheIndex;
    (f._byClipCacheIndex = h),
      (u[h] = f),
      u.pop(),
      (e._byClipCacheIndex = null);
    const d = a.actionByRoot,
      p = (e._localRoot || this._root).uuid;
    delete d[p],
      u.length === 0 && delete o[s],
      this._removeInactiveBindingsForAction(e);
  }
  _removeInactiveBindingsForAction(e) {
    const t = e._propertyBindings;
    for (let i = 0, r = t.length; i !== r; ++i) {
      const s = t[i];
      --s.referenceCount === 0 && this._removeInactiveBinding(s);
    }
  }
  _lendAction(e) {
    const t = this._actions,
      i = e._cacheIndex,
      r = this._nActiveActions++,
      s = t[r];
    (e._cacheIndex = r), (t[r] = e), (s._cacheIndex = i), (t[i] = s);
  }
  _takeBackAction(e) {
    const t = this._actions,
      i = e._cacheIndex,
      r = --this._nActiveActions,
      s = t[r];
    (e._cacheIndex = r), (t[r] = e), (s._cacheIndex = i), (t[i] = s);
  }
  _addInactiveBinding(e, t, i) {
    const r = this._bindingsByRootAndName,
      s = this._bindings;
    let o = r[t];
    o === void 0 && ((o = {}), (r[t] = o)),
      (o[i] = e),
      (e._cacheIndex = s.length),
      s.push(e);
  }
  _removeInactiveBinding(e) {
    const t = this._bindings,
      i = e.binding,
      r = i.rootNode.uuid,
      s = i.path,
      o = this._bindingsByRootAndName,
      a = o[r],
      u = t[t.length - 1],
      f = e._cacheIndex;
    (u._cacheIndex = f),
      (t[f] = u),
      t.pop(),
      delete a[s],
      Object.keys(a).length === 0 && delete o[r];
  }
  _lendBinding(e) {
    const t = this._bindings,
      i = e._cacheIndex,
      r = this._nActiveBindings++,
      s = t[r];
    (e._cacheIndex = r), (t[r] = e), (s._cacheIndex = i), (t[i] = s);
  }
  _takeBackBinding(e) {
    const t = this._bindings,
      i = e._cacheIndex,
      r = --this._nActiveBindings,
      s = t[r];
    (e._cacheIndex = r), (t[r] = e), (s._cacheIndex = i), (t[i] = s);
  }
  _lendControlInterpolant() {
    const e = this._controlInterpolants,
      t = this._nActiveControlInterpolants++;
    let i = e[t];
    return (
      i === void 0 &&
        ((i = new tM(new Float32Array(2), new Float32Array(2), 1, dW)),
        (i.__cacheIndex = t),
        (e[t] = i)),
      i
    );
  }
  _takeBackControlInterpolant(e) {
    const t = this._controlInterpolants,
      i = e.__cacheIndex,
      r = --this._nActiveControlInterpolants,
      s = t[r];
    (e.__cacheIndex = r), (t[r] = e), (s.__cacheIndex = i), (t[i] = s);
  }
  clipAction(e, t, i) {
    const r = t || this._root,
      s = r.uuid;
    let o = typeof e == "string" ? Kf.findByName(r, e) : e;
    const a = o !== null ? o.uuid : e,
      u = this._actionsByClip[a];
    let f = null;
    if (
      (i === void 0 && (o !== null ? (i = o.blendMode) : (i = zg)),
      u !== void 0)
    ) {
      const d = u.actionByRoot[s];
      if (d !== void 0 && d.blendMode === i) return d;
      (f = u.knownActions[0]), o === null && (o = f._clip);
    }
    if (o === null) return null;
    const h = new RI(this, o, t, i);
    return this._bindAction(h, f), this._addInactiveAction(h, a, s), h;
  }
  existingAction(e, t) {
    const i = t || this._root,
      r = i.uuid,
      s = typeof e == "string" ? Kf.findByName(i, e) : e,
      o = s ? s.uuid : e,
      a = this._actionsByClip[o];
    return (a !== void 0 && a.actionByRoot[r]) || null;
  }
  stopAllAction() {
    const e = this._actions,
      t = this._nActiveActions;
    for (let i = t - 1; i >= 0; --i) e[i].stop();
    return this;
  }
  update(e) {
    e *= this.timeScale;
    const t = this._actions,
      i = this._nActiveActions,
      r = (this.time += e),
      s = Math.sign(e),
      o = (this._accuIndex ^= 1);
    for (let f = 0; f !== i; ++f) t[f]._update(r, e, s, o);
    const a = this._bindings,
      u = this._nActiveBindings;
    for (let f = 0; f !== u; ++f) a[f].apply(o);
    return this;
  }
  setTime(e) {
    this.time = 0;
    for (let t = 0; t < this._actions.length; t++) this._actions[t].time = 0;
    return this.update(e);
  }
  getRoot() {
    return this._root;
  }
  uncacheClip(e) {
    const t = this._actions,
      i = e.uuid,
      r = this._actionsByClip,
      s = r[i];
    if (s !== void 0) {
      const o = s.knownActions;
      for (let a = 0, u = o.length; a !== u; ++a) {
        const f = o[a];
        this._deactivateAction(f);
        const h = f._cacheIndex,
          d = t[t.length - 1];
        (f._cacheIndex = null),
          (f._byClipCacheIndex = null),
          (d._cacheIndex = h),
          (t[h] = d),
          t.pop(),
          this._removeInactiveBindingsForAction(f);
      }
      delete r[i];
    }
  }
  uncacheRoot(e) {
    const t = e.uuid,
      i = this._actionsByClip;
    for (const o in i) {
      const a = i[o].actionByRoot,
        u = a[t];
      u !== void 0 &&
        (this._deactivateAction(u), this._removeInactiveAction(u));
    }
    const r = this._bindingsByRootAndName,
      s = r[t];
    if (s !== void 0)
      for (const o in s) {
        const a = s[o];
        a.restoreOriginalState(), this._removeInactiveBinding(a);
      }
  }
  uncacheAction(e, t) {
    const i = this.existingAction(e, t);
    i !== null && (this._deactivateAction(i), this._removeInactiveAction(i));
  }
}
class uM {
  constructor(e) {
    this.value = e;
  }
  clone() {
    return new uM(
      this.value.clone === void 0 ? this.value : this.value.clone()
    );
  }
}
let mW = 0;
class gW extends Zs {
  constructor() {
    super(),
      (this.isUniformsGroup = !0),
      Object.defineProperty(this, "id", { value: mW++ }),
      (this.name = ""),
      (this.usage = Hf),
      (this.uniforms = []);
  }
  add(e) {
    return this.uniforms.push(e), this;
  }
  remove(e) {
    const t = this.uniforms.indexOf(e);
    return t !== -1 && this.uniforms.splice(t, 1), this;
  }
  setName(e) {
    return (this.name = e), this;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  dispose() {
    return this.dispatchEvent({ type: "dispose" }), this;
  }
  copy(e) {
    (this.name = e.name), (this.usage = e.usage);
    const t = e.uniforms;
    this.uniforms.length = 0;
    for (let i = 0, r = t.length; i < r; i++) {
      const s = Array.isArray(t[i]) ? t[i] : [t[i]];
      for (let o = 0; o < s.length; o++) this.uniforms.push(s[o].clone());
    }
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class vW extends jg {
  constructor(e, t, i = 1) {
    super(e, t),
      (this.isInstancedInterleavedBuffer = !0),
      (this.meshPerAttribute = i);
  }
  copy(e) {
    return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this;
  }
  clone(e) {
    const t = super.clone(e);
    return (t.meshPerAttribute = this.meshPerAttribute), t;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.isInstancedInterleavedBuffer = !0),
      (t.meshPerAttribute = this.meshPerAttribute),
      t
    );
  }
}
class yW {
  constructor(e, t, i, r, s) {
    (this.isGLBufferAttribute = !0),
      (this.name = ""),
      (this.buffer = e),
      (this.type = t),
      (this.itemSize = i),
      (this.elementSize = r),
      (this.count = s),
      (this.version = 0);
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setBuffer(e) {
    return (this.buffer = e), this;
  }
  setType(e, t) {
    return (this.type = e), (this.elementSize = t), this;
  }
  setItemSize(e) {
    return (this.itemSize = e), this;
  }
  setCount(e) {
    return (this.count = e), this;
  }
}
class LI {
  constructor(e, t, i = 0, r = 1 / 0) {
    (this.ray = new rl(e, t)),
      (this.near = i),
      (this.far = r),
      (this.camera = null),
      (this.layers = new Ga()),
      (this.params = {
        Mesh: {},
        Line: { threshold: 1 },
        LOD: {},
        Points: { threshold: 1 },
        Sprite: {},
      });
  }
  set(e, t) {
    this.ray.set(e, t);
  }
  setFromCamera(e, t) {
    t.isPerspectiveCamera
      ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
        this.ray.direction
          .set(e.x, e.y, 0.5)
          .unproject(t)
          .sub(this.ray.origin)
          .normalize(),
        (this.camera = t))
      : t.isOrthographicCamera
      ? (this.ray.origin
          .set(e.x, e.y, (t.near + t.far) / (t.near - t.far))
          .unproject(t),
        this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld),
        (this.camera = t))
      : console.error("THREE.Raycaster: Unsupported camera type: " + t.type);
  }
  intersectObject(e, t = !0, i = []) {
    return j_(e, this, i, t), i.sort(WA), i;
  }
  intersectObjects(e, t = !0, i = []) {
    for (let r = 0, s = e.length; r < s; r++) j_(e[r], this, i, t);
    return i.sort(WA), i;
  }
}
function WA(n, e) {
  return n.distance - e.distance;
}
function j_(n, e, t, i) {
  if ((n.layers.test(e.layers) && n.raycast(e, t), i === !0)) {
    const r = n.children;
    for (let s = 0, o = r.length; s < o; s++) j_(r[s], e, t, !0);
  }
}
class ig {
  constructor(e = 1, t = 0, i = 0) {
    return (this.radius = e), (this.phi = t), (this.theta = i), this;
  }
  set(e, t, i) {
    return (this.radius = e), (this.phi = t), (this.theta = i), this;
  }
  copy(e) {
    return (
      (this.radius = e.radius), (this.phi = e.phi), (this.theta = e.theta), this
    );
  }
  makeSafe() {
    return (
      (this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi))), this
    );
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, i) {
    return (
      (this.radius = Math.sqrt(e * e + t * t + i * i)),
      this.radius === 0
        ? ((this.theta = 0), (this.phi = 0))
        : ((this.theta = Math.atan2(e, i)),
          (this.phi = Math.acos(vn(t / this.radius, -1, 1)))),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class xW {
  constructor(e = 1, t = 0, i = 0) {
    return (this.radius = e), (this.theta = t), (this.y = i), this;
  }
  set(e, t, i) {
    return (this.radius = e), (this.theta = t), (this.y = i), this;
  }
  copy(e) {
    return (
      (this.radius = e.radius), (this.theta = e.theta), (this.y = e.y), this
    );
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, i) {
    return (
      (this.radius = Math.sqrt(e * e + i * i)),
      (this.theta = Math.atan2(e, i)),
      (this.y = t),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const jA = new de();
class _W {
  constructor(e = new de(1 / 0, 1 / 0), t = new de(-1 / 0, -1 / 0)) {
    (this.isBox2 = !0), (this.min = e), (this.max = t);
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, i = e.length; t < i; t++) this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const i = jA.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = 1 / 0),
      (this.max.x = this.max.y = -1 / 0),
      this
    );
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  containsPoint(e) {
    return !(
      e.x < this.min.x ||
      e.x > this.max.x ||
      e.y < this.min.y ||
      e.y > this.max.y
    );
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y
    );
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y)
    );
  }
  intersectsBox(e) {
    return !(
      e.max.x < this.min.x ||
      e.min.x > this.max.x ||
      e.max.y < this.min.y ||
      e.min.y > this.max.y
    );
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, jA).distanceTo(e);
  }
  intersect(e) {
    return (
      this.min.max(e.min),
      this.max.min(e.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const XA = new U(),
  kp = new U();
class SW {
  constructor(e = new U(), t = new U()) {
    (this.start = e), (this.end = t);
  }
  set(e, t) {
    return this.start.copy(e), this.end.copy(t), this;
  }
  copy(e) {
    return this.start.copy(e.start), this.end.copy(e.end), this;
  }
  getCenter(e) {
    return e.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(e) {
    return e.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(e, t) {
    return this.delta(t).multiplyScalar(e).add(this.start);
  }
  closestPointToPointParameter(e, t) {
    XA.subVectors(e, this.start), kp.subVectors(this.end, this.start);
    const i = kp.dot(kp);
    let s = kp.dot(XA) / i;
    return t && (s = vn(s, 0, 1)), s;
  }
  closestPointToPoint(e, t, i) {
    const r = this.closestPointToPointParameter(e, t);
    return this.delta(i).multiplyScalar(r).add(this.start);
  }
  applyMatrix4(e) {
    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
  }
  equals(e) {
    return e.start.equals(this.start) && e.end.equals(this.end);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const YA = new U();
class MW extends Ft {
  constructor(e, t) {
    super(),
      (this.light = e),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = t),
      (this.type = "SpotLightHelper");
    const i = new Tt(),
      r = [
        0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1,
        0, 0, 0, 0, -1, 1,
      ];
    for (let o = 0, a = 1, u = 32; o < u; o++, a++) {
      const f = (o / u) * Math.PI * 2,
        h = (a / u) * Math.PI * 2;
      r.push(Math.cos(f), Math.sin(f), 1, Math.cos(h), Math.sin(h), 1);
    }
    i.setAttribute("position", new Ze(r, 3));
    const s = new Pi({ fog: !1, toneMapped: !1 });
    (this.cone = new ps(i, s)), this.add(this.cone), this.update();
  }
  dispose() {
    this.cone.geometry.dispose(), this.cone.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.light.target.updateWorldMatrix(!0, !1);
    const e = this.light.distance ? this.light.distance : 1e3,
      t = e * Math.tan(this.light.angle);
    this.cone.scale.set(t, t, e),
      YA.setFromMatrixPosition(this.light.target.matrixWorld),
      this.cone.lookAt(YA),
      this.color !== void 0
        ? this.cone.material.color.set(this.color)
        : this.cone.material.color.copy(this.light.color);
  }
}
const mo = new U(),
  Fp = new dt(),
  By = new dt();
class wW extends ps {
  constructor(e) {
    const t = II(e),
      i = new Tt(),
      r = [],
      s = [],
      o = new Be(0, 0, 1),
      a = new Be(0, 1, 0);
    for (let f = 0; f < t.length; f++) {
      const h = t[f];
      h.parent &&
        h.parent.isBone &&
        (r.push(0, 0, 0),
        r.push(0, 0, 0),
        s.push(o.r, o.g, o.b),
        s.push(a.r, a.g, a.b));
    }
    i.setAttribute("position", new Ze(r, 3)),
      i.setAttribute("color", new Ze(s, 3));
    const u = new Pi({
      vertexColors: !0,
      depthTest: !1,
      depthWrite: !1,
      toneMapped: !1,
      transparent: !0,
    });
    super(i, u),
      (this.isSkeletonHelper = !0),
      (this.type = "SkeletonHelper"),
      (this.root = e),
      (this.bones = t),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1);
  }
  updateMatrixWorld(e) {
    const t = this.bones,
      i = this.geometry,
      r = i.getAttribute("position");
    By.copy(this.root.matrixWorld).invert();
    for (let s = 0, o = 0; s < t.length; s++) {
      const a = t[s];
      a.parent &&
        a.parent.isBone &&
        (Fp.multiplyMatrices(By, a.matrixWorld),
        mo.setFromMatrixPosition(Fp),
        r.setXYZ(o, mo.x, mo.y, mo.z),
        Fp.multiplyMatrices(By, a.parent.matrixWorld),
        mo.setFromMatrixPosition(Fp),
        r.setXYZ(o + 1, mo.x, mo.y, mo.z),
        (o += 2));
    }
    (i.getAttribute("position").needsUpdate = !0), super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function II(n) {
  const e = [];
  n.isBone === !0 && e.push(n);
  for (let t = 0; t < n.children.length; t++)
    e.push.apply(e, II(n.children[t]));
  return e;
}
class EW extends Un {
  constructor(e, t, i) {
    const r = new Th(t, 4, 2),
      s = new Qo({ wireframe: !0, fog: !1, toneMapped: !1 });
    super(r, s),
      (this.light = e),
      (this.color = i),
      (this.type = "PointLightHelper"),
      (this.matrix = this.light.matrixWorld),
      (this.matrixAutoUpdate = !1),
      this.update();
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.color !== void 0
        ? this.material.color.set(this.color)
        : this.material.color.copy(this.light.color);
  }
}
const TW = new U(),
  qA = new Be(),
  ZA = new Be();
class AW extends Ft {
  constructor(e, t, i) {
    super(),
      (this.light = e),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = i),
      (this.type = "HemisphereLightHelper");
    const r = new Eh(t);
    r.rotateY(Math.PI * 0.5),
      (this.material = new Qo({ wireframe: !0, fog: !1, toneMapped: !1 })),
      this.color === void 0 && (this.material.vertexColors = !0);
    const s = r.getAttribute("position"),
      o = new Float32Array(s.count * 3);
    r.setAttribute("color", new Ht(o, 3)),
      this.add(new Un(r, this.material)),
      this.update();
  }
  dispose() {
    this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
  update() {
    const e = this.children[0];
    if (this.color !== void 0) this.material.color.set(this.color);
    else {
      const t = e.geometry.getAttribute("color");
      qA.copy(this.light.color), ZA.copy(this.light.groundColor);
      for (let i = 0, r = t.count; i < r; i++) {
        const s = i < r / 2 ? qA : ZA;
        t.setXYZ(i, s.r, s.g, s.b);
      }
      t.needsUpdate = !0;
    }
    this.light.updateWorldMatrix(!0, !1),
      e.lookAt(TW.setFromMatrixPosition(this.light.matrixWorld).negate());
  }
}
class bW extends ps {
  constructor(e = 10, t = 10, i = 4473924, r = 8947848) {
    (i = new Be(i)), (r = new Be(r));
    const s = t / 2,
      o = e / t,
      a = e / 2,
      u = [],
      f = [];
    for (let p = 0, m = 0, y = -a; p <= t; p++, y += o) {
      u.push(-a, 0, y, a, 0, y), u.push(y, 0, -a, y, 0, a);
      const w = p === s ? i : r;
      w.toArray(f, m),
        (m += 3),
        w.toArray(f, m),
        (m += 3),
        w.toArray(f, m),
        (m += 3),
        w.toArray(f, m),
        (m += 3);
    }
    const h = new Tt();
    h.setAttribute("position", new Ze(u, 3)),
      h.setAttribute("color", new Ze(f, 3));
    const d = new Pi({ vertexColors: !0, toneMapped: !1 });
    super(h, d), (this.type = "GridHelper");
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class CW extends ps {
  constructor(e = 10, t = 16, i = 8, r = 64, s = 4473924, o = 8947848) {
    (s = new Be(s)), (o = new Be(o));
    const a = [],
      u = [];
    if (t > 1)
      for (let d = 0; d < t; d++) {
        const p = (d / t) * (Math.PI * 2),
          m = Math.sin(p) * e,
          y = Math.cos(p) * e;
        a.push(0, 0, 0), a.push(m, 0, y);
        const w = d & 1 ? s : o;
        u.push(w.r, w.g, w.b), u.push(w.r, w.g, w.b);
      }
    for (let d = 0; d < i; d++) {
      const p = d & 1 ? s : o,
        m = e - (e / i) * d;
      for (let y = 0; y < r; y++) {
        let w = (y / r) * (Math.PI * 2),
          S = Math.sin(w) * m,
          v = Math.cos(w) * m;
        a.push(S, 0, v),
          u.push(p.r, p.g, p.b),
          (w = ((y + 1) / r) * (Math.PI * 2)),
          (S = Math.sin(w) * m),
          (v = Math.cos(w) * m),
          a.push(S, 0, v),
          u.push(p.r, p.g, p.b);
      }
    }
    const f = new Tt();
    f.setAttribute("position", new Ze(a, 3)),
      f.setAttribute("color", new Ze(u, 3));
    const h = new Pi({ vertexColors: !0, toneMapped: !1 });
    super(f, h), (this.type = "PolarGridHelper");
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
const KA = new U(),
  zp = new U(),
  QA = new U();
class PW extends Ft {
  constructor(e, t, i) {
    super(),
      (this.light = e),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = i),
      (this.type = "DirectionalLightHelper"),
      t === void 0 && (t = 1);
    let r = new Tt();
    r.setAttribute(
      "position",
      new Ze([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3)
    );
    const s = new Pi({ fog: !1, toneMapped: !1 });
    (this.lightPlane = new jo(r, s)),
      this.add(this.lightPlane),
      (r = new Tt()),
      r.setAttribute("position", new Ze([0, 0, 0, 0, 0, 1], 3)),
      (this.targetLine = new jo(r, s)),
      this.add(this.targetLine),
      this.update();
  }
  dispose() {
    this.lightPlane.geometry.dispose(),
      this.lightPlane.material.dispose(),
      this.targetLine.geometry.dispose(),
      this.targetLine.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.light.target.updateWorldMatrix(!0, !1),
      KA.setFromMatrixPosition(this.light.matrixWorld),
      zp.setFromMatrixPosition(this.light.target.matrixWorld),
      QA.subVectors(zp, KA),
      this.lightPlane.lookAt(zp),
      this.color !== void 0
        ? (this.lightPlane.material.color.set(this.color),
          this.targetLine.material.color.set(this.color))
        : (this.lightPlane.material.color.copy(this.light.color),
          this.targetLine.material.color.copy(this.light.color)),
      this.targetLine.lookAt(zp),
      (this.targetLine.scale.z = QA.length());
  }
}
const Bp = new U(),
  mn = new xh();
class RW extends ps {
  constructor(e) {
    const t = new Tt(),
      i = new Pi({ color: 16777215, vertexColors: !0, toneMapped: !1 }),
      r = [],
      s = [],
      o = {};
    a("n1", "n2"),
      a("n2", "n4"),
      a("n4", "n3"),
      a("n3", "n1"),
      a("f1", "f2"),
      a("f2", "f4"),
      a("f4", "f3"),
      a("f3", "f1"),
      a("n1", "f1"),
      a("n2", "f2"),
      a("n3", "f3"),
      a("n4", "f4"),
      a("p", "n1"),
      a("p", "n2"),
      a("p", "n3"),
      a("p", "n4"),
      a("u1", "u2"),
      a("u2", "u3"),
      a("u3", "u1"),
      a("c", "t"),
      a("p", "c"),
      a("cn1", "cn2"),
      a("cn3", "cn4"),
      a("cf1", "cf2"),
      a("cf3", "cf4");
    function a(y, w) {
      u(y), u(w);
    }
    function u(y) {
      r.push(0, 0, 0),
        s.push(0, 0, 0),
        o[y] === void 0 && (o[y] = []),
        o[y].push(r.length / 3 - 1);
    }
    t.setAttribute("position", new Ze(r, 3)),
      t.setAttribute("color", new Ze(s, 3)),
      super(t, i),
      (this.type = "CameraHelper"),
      (this.camera = e),
      this.camera.updateProjectionMatrix &&
        this.camera.updateProjectionMatrix(),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.pointMap = o),
      this.update();
    const f = new Be(16755200),
      h = new Be(16711680),
      d = new Be(43775),
      p = new Be(16777215),
      m = new Be(3355443);
    this.setColors(f, h, d, p, m);
  }
  setColors(e, t, i, r, s) {
    const a = this.geometry.getAttribute("color");
    a.setXYZ(0, e.r, e.g, e.b),
      a.setXYZ(1, e.r, e.g, e.b),
      a.setXYZ(2, e.r, e.g, e.b),
      a.setXYZ(3, e.r, e.g, e.b),
      a.setXYZ(4, e.r, e.g, e.b),
      a.setXYZ(5, e.r, e.g, e.b),
      a.setXYZ(6, e.r, e.g, e.b),
      a.setXYZ(7, e.r, e.g, e.b),
      a.setXYZ(8, e.r, e.g, e.b),
      a.setXYZ(9, e.r, e.g, e.b),
      a.setXYZ(10, e.r, e.g, e.b),
      a.setXYZ(11, e.r, e.g, e.b),
      a.setXYZ(12, e.r, e.g, e.b),
      a.setXYZ(13, e.r, e.g, e.b),
      a.setXYZ(14, e.r, e.g, e.b),
      a.setXYZ(15, e.r, e.g, e.b),
      a.setXYZ(16, e.r, e.g, e.b),
      a.setXYZ(17, e.r, e.g, e.b),
      a.setXYZ(18, e.r, e.g, e.b),
      a.setXYZ(19, e.r, e.g, e.b),
      a.setXYZ(20, e.r, e.g, e.b),
      a.setXYZ(21, e.r, e.g, e.b),
      a.setXYZ(22, e.r, e.g, e.b),
      a.setXYZ(23, e.r, e.g, e.b),
      a.setXYZ(24, t.r, t.g, t.b),
      a.setXYZ(25, t.r, t.g, t.b),
      a.setXYZ(26, t.r, t.g, t.b),
      a.setXYZ(27, t.r, t.g, t.b),
      a.setXYZ(28, t.r, t.g, t.b),
      a.setXYZ(29, t.r, t.g, t.b),
      a.setXYZ(30, t.r, t.g, t.b),
      a.setXYZ(31, t.r, t.g, t.b),
      a.setXYZ(32, i.r, i.g, i.b),
      a.setXYZ(33, i.r, i.g, i.b),
      a.setXYZ(34, i.r, i.g, i.b),
      a.setXYZ(35, i.r, i.g, i.b),
      a.setXYZ(36, i.r, i.g, i.b),
      a.setXYZ(37, i.r, i.g, i.b),
      a.setXYZ(38, r.r, r.g, r.b),
      a.setXYZ(39, r.r, r.g, r.b),
      a.setXYZ(40, s.r, s.g, s.b),
      a.setXYZ(41, s.r, s.g, s.b),
      a.setXYZ(42, s.r, s.g, s.b),
      a.setXYZ(43, s.r, s.g, s.b),
      a.setXYZ(44, s.r, s.g, s.b),
      a.setXYZ(45, s.r, s.g, s.b),
      a.setXYZ(46, s.r, s.g, s.b),
      a.setXYZ(47, s.r, s.g, s.b),
      a.setXYZ(48, s.r, s.g, s.b),
      a.setXYZ(49, s.r, s.g, s.b),
      (a.needsUpdate = !0);
  }
  update() {
    const e = this.geometry,
      t = this.pointMap,
      i = 1,
      r = 1;
    mn.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
      _n("c", t, e, mn, 0, 0, -1),
      _n("t", t, e, mn, 0, 0, 1),
      _n("n1", t, e, mn, -i, -r, -1),
      _n("n2", t, e, mn, i, -r, -1),
      _n("n3", t, e, mn, -i, r, -1),
      _n("n4", t, e, mn, i, r, -1),
      _n("f1", t, e, mn, -i, -r, 1),
      _n("f2", t, e, mn, i, -r, 1),
      _n("f3", t, e, mn, -i, r, 1),
      _n("f4", t, e, mn, i, r, 1),
      _n("u1", t, e, mn, i * 0.7, r * 1.1, -1),
      _n("u2", t, e, mn, -i * 0.7, r * 1.1, -1),
      _n("u3", t, e, mn, 0, r * 2, -1),
      _n("cf1", t, e, mn, -i, 0, 1),
      _n("cf2", t, e, mn, i, 0, 1),
      _n("cf3", t, e, mn, 0, -r, 1),
      _n("cf4", t, e, mn, 0, r, 1),
      _n("cn1", t, e, mn, -i, 0, -1),
      _n("cn2", t, e, mn, i, 0, -1),
      _n("cn3", t, e, mn, 0, -r, -1),
      _n("cn4", t, e, mn, 0, r, -1),
      (e.getAttribute("position").needsUpdate = !0);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function _n(n, e, t, i, r, s, o) {
  Bp.set(r, s, o).unproject(i);
  const a = e[n];
  if (a !== void 0) {
    const u = t.getAttribute("position");
    for (let f = 0, h = a.length; f < h; f++) u.setXYZ(a[f], Bp.x, Bp.y, Bp.z);
  }
}
const Vp = new Ai();
class LW extends ps {
  constructor(e, t = 16776960) {
    const i = new Uint16Array([
        0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
      ]),
      r = new Float32Array(8 * 3),
      s = new Tt();
    s.setIndex(new Ht(i, 1)),
      s.setAttribute("position", new Ht(r, 3)),
      super(s, new Pi({ color: t, toneMapped: !1 })),
      (this.object = e),
      (this.type = "BoxHelper"),
      (this.matrixAutoUpdate = !1),
      this.update();
  }
  update(e) {
    if (
      (e !== void 0 &&
        console.warn("THREE.BoxHelper: .update() has no longer arguments."),
      this.object !== void 0 && Vp.setFromObject(this.object),
      Vp.isEmpty())
    )
      return;
    const t = Vp.min,
      i = Vp.max,
      r = this.geometry.attributes.position,
      s = r.array;
    (s[0] = i.x),
      (s[1] = i.y),
      (s[2] = i.z),
      (s[3] = t.x),
      (s[4] = i.y),
      (s[5] = i.z),
      (s[6] = t.x),
      (s[7] = t.y),
      (s[8] = i.z),
      (s[9] = i.x),
      (s[10] = t.y),
      (s[11] = i.z),
      (s[12] = i.x),
      (s[13] = i.y),
      (s[14] = t.z),
      (s[15] = t.x),
      (s[16] = i.y),
      (s[17] = t.z),
      (s[18] = t.x),
      (s[19] = t.y),
      (s[20] = t.z),
      (s[21] = i.x),
      (s[22] = t.y),
      (s[23] = t.z),
      (r.needsUpdate = !0),
      this.geometry.computeBoundingSphere();
  }
  setFromObject(e) {
    return (this.object = e), this.update(), this;
  }
  copy(e, t) {
    return super.copy(e, t), (this.object = e.object), this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class IW extends ps {
  constructor(e, t = 16776960) {
    const i = new Uint16Array([
        0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
      ]),
      r = [
        1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1,
        1, -1, -1,
      ],
      s = new Tt();
    s.setIndex(new Ht(i, 1)),
      s.setAttribute("position", new Ze(r, 3)),
      super(s, new Pi({ color: t, toneMapped: !1 })),
      (this.box = e),
      (this.type = "Box3Helper"),
      this.geometry.computeBoundingSphere();
  }
  updateMatrixWorld(e) {
    const t = this.box;
    t.isEmpty() ||
      (t.getCenter(this.position),
      t.getSize(this.scale),
      this.scale.multiplyScalar(0.5),
      super.updateMatrixWorld(e));
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class NW extends jo {
  constructor(e, t = 1, i = 16776960) {
    const r = i,
      s = [
        1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0,
        1, 1, 0,
      ],
      o = new Tt();
    o.setAttribute("position", new Ze(s, 3)),
      o.computeBoundingSphere(),
      super(o, new Pi({ color: r, toneMapped: !1 })),
      (this.type = "PlaneHelper"),
      (this.plane = e),
      (this.size = t);
    const a = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0],
      u = new Tt();
    u.setAttribute("position", new Ze(a, 3)),
      u.computeBoundingSphere(),
      this.add(
        new Un(
          u,
          new Qo({
            color: r,
            opacity: 0.2,
            transparent: !0,
            depthWrite: !1,
            toneMapped: !1,
          })
        )
      );
  }
  updateMatrixWorld(e) {
    this.position.set(0, 0, 0),
      this.scale.set(0.5 * this.size, 0.5 * this.size, 1),
      this.lookAt(this.plane.normal),
      this.translateZ(-this.plane.constant),
      super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(),
      this.material.dispose(),
      this.children[0].geometry.dispose(),
      this.children[0].material.dispose();
  }
}
const $A = new U();
let Hp, Vy;
class DW extends Ft {
  constructor(
    e = new U(0, 0, 1),
    t = new U(0, 0, 0),
    i = 1,
    r = 16776960,
    s = i * 0.2,
    o = s * 0.2
  ) {
    super(),
      (this.type = "ArrowHelper"),
      Hp === void 0 &&
        ((Hp = new Tt()),
        Hp.setAttribute("position", new Ze([0, 0, 0, 0, 1, 0], 3)),
        (Vy = new Yu(0, 0.5, 1, 5, 1)),
        Vy.translate(0, -0.5, 0)),
      this.position.copy(t),
      (this.line = new jo(Hp, new Pi({ color: r, toneMapped: !1 }))),
      (this.line.matrixAutoUpdate = !1),
      this.add(this.line),
      (this.cone = new Un(Vy, new Qo({ color: r, toneMapped: !1 }))),
      (this.cone.matrixAutoUpdate = !1),
      this.add(this.cone),
      this.setDirection(e),
      this.setLength(i, s, o);
  }
  setDirection(e) {
    if (e.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
    else if (e.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
    else {
      $A.set(e.z, 0, -e.x).normalize();
      const t = Math.acos(e.y);
      this.quaternion.setFromAxisAngle($A, t);
    }
  }
  setLength(e, t = e * 0.2, i = t * 0.2) {
    this.line.scale.set(1, Math.max(1e-4, e - t), 1),
      this.line.updateMatrix(),
      this.cone.scale.set(i, t, i),
      (this.cone.position.y = e),
      this.cone.updateMatrix();
  }
  setColor(e) {
    this.line.material.color.set(e), this.cone.material.color.set(e);
  }
  copy(e) {
    return (
      super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this
    );
  }
  dispose() {
    this.line.geometry.dispose(),
      this.line.material.dispose(),
      this.cone.geometry.dispose(),
      this.cone.material.dispose();
  }
}
class OW extends ps {
  constructor(e = 1) {
    const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
      i = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1],
      r = new Tt();
    r.setAttribute("position", new Ze(t, 3)),
      r.setAttribute("color", new Ze(i, 3));
    const s = new Pi({ vertexColors: !0, toneMapped: !1 });
    super(r, s), (this.type = "AxesHelper");
  }
  setColors(e, t, i) {
    const r = new Be(),
      s = this.geometry.attributes.color.array;
    return (
      r.set(e),
      r.toArray(s, 0),
      r.toArray(s, 3),
      r.set(t),
      r.toArray(s, 6),
      r.toArray(s, 9),
      r.set(i),
      r.toArray(s, 12),
      r.toArray(s, 15),
      (this.geometry.attributes.color.needsUpdate = !0),
      this
    );
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class UW {
  constructor() {
    (this.type = "ShapePath"),
      (this.color = new Be()),
      (this.subPaths = []),
      (this.currentPath = null);
  }
  moveTo(e, t) {
    return (
      (this.currentPath = new Wf()),
      this.subPaths.push(this.currentPath),
      this.currentPath.moveTo(e, t),
      this
    );
  }
  lineTo(e, t) {
    return this.currentPath.lineTo(e, t), this;
  }
  quadraticCurveTo(e, t, i, r) {
    return this.currentPath.quadraticCurveTo(e, t, i, r), this;
  }
  bezierCurveTo(e, t, i, r, s, o) {
    return this.currentPath.bezierCurveTo(e, t, i, r, s, o), this;
  }
  splineThru(e) {
    return this.currentPath.splineThru(e), this;
  }
  toShapes(e) {
    function t(v) {
      const M = [];
      for (let _ = 0, T = v.length; _ < T; _++) {
        const P = v[_],
          b = new ja();
        (b.curves = P.curves), M.push(b);
      }
      return M;
    }
    function i(v, M) {
      const _ = M.length;
      let T = !1;
      for (let P = _ - 1, b = 0; b < _; P = b++) {
        let L = M[P],
          N = M[b],
          C = N.x - L.x,
          R = N.y - L.y;
        if (Math.abs(R) > Number.EPSILON) {
          if (
            (R < 0 && ((L = M[b]), (C = -C), (N = M[P]), (R = -R)),
            v.y < L.y || v.y > N.y)
          )
            continue;
          if (v.y === L.y) {
            if (v.x === L.x) return !0;
          } else {
            const B = R * (v.x - L.x) - C * (v.y - L.y);
            if (B === 0) return !0;
            if (B < 0) continue;
            T = !T;
          }
        } else {
          if (v.y !== L.y) continue;
          if ((N.x <= v.x && v.x <= L.x) || (L.x <= v.x && v.x <= N.x))
            return !0;
        }
      }
      return T;
    }
    const r = fs.isClockWise,
      s = this.subPaths;
    if (s.length === 0) return [];
    let o, a, u;
    const f = [];
    if (s.length === 1)
      return (a = s[0]), (u = new ja()), (u.curves = a.curves), f.push(u), f;
    let h = !r(s[0].getPoints());
    h = e ? !h : h;
    const d = [],
      p = [];
    let m = [],
      y = 0,
      w;
    (p[y] = void 0), (m[y] = []);
    for (let v = 0, M = s.length; v < M; v++)
      (a = s[v]),
        (w = a.getPoints()),
        (o = r(w)),
        (o = e ? !o : o),
        o
          ? (!h && p[y] && y++,
            (p[y] = { s: new ja(), p: w }),
            (p[y].s.curves = a.curves),
            h && y++,
            (m[y] = []))
          : m[y].push({ h: a, p: w[0] });
    if (!p[0]) return t(s);
    if (p.length > 1) {
      let v = !1,
        M = 0;
      for (let _ = 0, T = p.length; _ < T; _++) d[_] = [];
      for (let _ = 0, T = p.length; _ < T; _++) {
        const P = m[_];
        for (let b = 0; b < P.length; b++) {
          const L = P[b];
          let N = !0;
          for (let C = 0; C < p.length; C++)
            i(L.p, p[C].p) &&
              (_ !== C && M++, N ? ((N = !1), d[C].push(L)) : (v = !0));
          N && d[_].push(L);
        }
      }
      M > 0 && v === !1 && (m = d);
    }
    let S;
    for (let v = 0, M = p.length; v < M; v++) {
      (u = p[v].s), f.push(u), (S = m[v]);
      for (let _ = 0, T = S.length; _ < T; _++) u.holes.push(S[_].h);
    }
    return f;
  }
}
typeof __THREE_DEVTOOLS__ < "u" &&
  __THREE_DEVTOOLS__.dispatchEvent(
    new CustomEvent("register", { detail: { revision: mh } })
  );
typeof window < "u" &&
  (window.__THREE__
    ? console.warn("WARNING: Multiple instances of Three.js being imported.")
    : (window.__THREE__ = mh));
const kW = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      ACESFilmicToneMapping: _S,
      AddEquation: wo,
      AddOperation: qR,
      AdditiveAnimationBlendMode: PS,
      AdditiveBlending: Km,
      AgXToneMapping: JR,
      AlphaFormat: iL,
      AlwaysCompare: SL,
      AlwaysDepth: VR,
      AlwaysStencilFunc: O_,
      AmbientLight: MI,
      AnimationAction: RI,
      AnimationClip: Kf,
      AnimationLoader: z7,
      AnimationMixer: pW,
      AnimationObjectGroup: hW,
      AnimationUtils: O7,
      ArcCurve: qL,
      ArrayCamera: FL,
      ArrowHelper: DW,
      AttachedBindMode: u_,
      Audio: CI,
      AudioAnalyser: nW,
      AudioContext: sM,
      AudioListener: J7,
      AudioLoader: K7,
      AxesHelper: OW,
      BackSide: Ti,
      BasicDepthPacking: hL,
      BasicShadowMap: wR,
      BatchedMesh: jL,
      Bone: WS,
      BooleanKeyframeTrack: ol,
      Box2: _W,
      Box3: Ai,
      Box3Helper: IW,
      BoxGeometry: sl,
      BoxHelper: LW,
      BufferAttribute: Ht,
      BufferGeometry: Tt,
      BufferGeometryLoader: bI,
      ByteType: tL,
      Cache: Os,
      Camera: xh,
      CameraHelper: RW,
      CanvasTexture: s7,
      CapsuleGeometry: Zg,
      CatmullRomCurve3: ZL,
      CineonToneMapping: QR,
      CircleGeometry: Kg,
      ClampToEdgeWrapping: fi,
      Clock: oM,
      Color: Be,
      ColorKeyframeTrack: nM,
      ColorManagement: zt,
      CompressedArrayTexture: i7,
      CompressedCubeTexture: r7,
      CompressedTexture: Yg,
      CompressedTextureLoader: B7,
      ConeGeometry: Qg,
      ConstantAlphaFactor: FR,
      ConstantColorFactor: UR,
      CubeCamera: PL,
      CubeReflectionMapping: Xs,
      CubeRefractionMapping: Go,
      CubeTexture: _h,
      CubeTextureLoader: V7,
      CubeUVReflectionMapping: ju,
      CubicBezierCurve: YS,
      CubicBezierCurve3: KL,
      CubicInterpolant: pI,
      CullFaceBack: r_,
      CullFaceFront: MR,
      CullFaceFrontBack: YB,
      CullFaceNone: SR,
      Curve: Gr,
      CurvePath: $L,
      CustomBlending: ER,
      CustomToneMapping: $R,
      CylinderGeometry: Yu,
      Cylindrical: xW,
      Data3DTexture: DS,
      DataArrayTexture: Vg,
      DataTexture: Wa,
      DataTextureLoader: H7,
      DataUtils: nV,
      DecrementStencilOp: s6,
      DecrementWrapStencilOp: a6,
      DefaultLoadingManager: vI,
      DepthFormat: Uo,
      DepthStencilFormat: Qa,
      DepthTexture: FS,
      DetachedBindMode: eL,
      DirectionalLight: SI,
      DirectionalLightHelper: PW,
      DiscreteInterpolant: mI,
      DisplayP3ColorSpace: Bg,
      DodecahedronGeometry: $g,
      DoubleSide: rs,
      DstAlphaFactor: LR,
      DstColorFactor: NR,
      DynamicCopyUsage: M6,
      DynamicDrawUsage: g6,
      DynamicReadUsage: x6,
      EdgesGeometry: JL,
      EllipseCurve: qg,
      EqualCompare: vL,
      EqualDepth: GR,
      EqualStencilFunc: f6,
      EquirectangularReflectionMapping: If,
      EquirectangularRefractionMapping: Nf,
      Euler: yh,
      EventDispatcher: Zs,
      ExtrudeGeometry: ev,
      FileLoader: Ys,
      Float16BufferAttribute: lV,
      Float32BufferAttribute: Ze,
      Float64BufferAttribute: uV,
      FloatType: Ur,
      Fog: Wg,
      FogExp2: Gg,
      FramebufferTexture: n7,
      FrontSide: js,
      Frustum: Sh,
      GLBufferAttribute: yW,
      GLSL1: E6,
      GLSL3: U_,
      GreaterCompare: yL,
      GreaterDepth: jR,
      GreaterEqualCompare: _L,
      GreaterEqualDepth: WR,
      GreaterEqualStencilFunc: m6,
      GreaterStencilFunc: d6,
      GridHelper: bW,
      Group: gu,
      HalfFloatType: Ou,
      HemisphereLight: yI,
      HemisphereLightHelper: AW,
      IcosahedronGeometry: tv,
      ImageBitmapLoader: Z7,
      ImageLoader: Qf,
      ImageUtils: NS,
      IncrementStencilOp: r6,
      IncrementWrapStencilOp: o6,
      InstancedBufferAttribute: zu,
      InstancedBufferGeometry: AI,
      InstancedInterleavedBuffer: vW,
      InstancedMesh: WL,
      Int16BufferAttribute: oV,
      Int32BufferAttribute: aV,
      Int8BufferAttribute: iV,
      IntType: MS,
      InterleavedBuffer: jg,
      InterleavedBufferAttribute: $a,
      Interpolant: Ah,
      InterpolateDiscrete: Uf,
      InterpolateLinear: kf,
      InterpolateSmooth: hm,
      InvertStencilOp: l6,
      KeepStencilOp: ba,
      KeyframeTrack: Wr,
      LOD: HL,
      LatheGeometry: wh,
      Layers: Ga,
      LessCompare: gL,
      LessDepth: HR,
      LessEqualCompare: LS,
      LessEqualDepth: Lf,
      LessEqualStencilFunc: h6,
      LessStencilFunc: c6,
      Light: Jo,
      LightProbe: TI,
      Line: jo,
      Line3: SW,
      LineBasicMaterial: Pi,
      LineCurve: qS,
      LineCurve3: QL,
      LineDashedMaterial: fI,
      LineLoop: XL,
      LineSegments: ps,
      LinearDisplayP3ColorSpace: vh,
      LinearEncoding: RS,
      LinearFilter: wn,
      LinearInterpolant: tM,
      LinearMipMapLinearFilter: $B,
      LinearMipMapNearestFilter: QB,
      LinearMipmapLinearFilter: Wo,
      LinearMipmapNearestFilter: SS,
      LinearSRGBColorSpace: hs,
      LinearToneMapping: ZR,
      LinearTransfer: zf,
      Loader: Hi,
      LoaderUtils: W_,
      LoadingManager: iM,
      LoopOnce: uL,
      LoopPingPong: fL,
      LoopRepeat: cL,
      LuminanceAlphaFormat: sL,
      LuminanceFormat: rL,
      MOUSE: Ta,
      Material: gi,
      MaterialLoader: lv,
      MathUtils: ML,
      Matrix3: Et,
      Matrix4: dt,
      MaxEquation: l_,
      Mesh: Un,
      MeshBasicMaterial: Qo,
      MeshDepthMaterial: zS,
      MeshDistanceMaterial: BS,
      MeshLambertMaterial: uI,
      MeshMatcapMaterial: cI,
      MeshNormalMaterial: lI,
      MeshPhongMaterial: oI,
      MeshPhysicalMaterial: JS,
      MeshStandardMaterial: $S,
      MeshToonMaterial: aI,
      MinEquation: a_,
      MirroredRepeatWrapping: Of,
      MixOperation: YR,
      MultiplyBlending: o_,
      MultiplyOperation: gh,
      NearestFilter: Sn,
      NearestMipMapLinearFilter: KB,
      NearestMipMapNearestFilter: ZB,
      NearestMipmapLinearFilter: of,
      NearestMipmapNearestFilter: Jm,
      NeverCompare: mL,
      NeverDepth: BR,
      NeverStencilFunc: u6,
      NoBlending: zs,
      NoColorSpace: Qi,
      NoToneMapping: us,
      NormalAnimationBlendMode: zg,
      NormalBlending: Va,
      NotEqualCompare: xL,
      NotEqualDepth: XR,
      NotEqualStencilFunc: p6,
      NumberKeyframeTrack: qf,
      Object3D: Ft,
      ObjectLoader: Y7,
      ObjectSpaceNormalMap: pL,
      OctahedronGeometry: Eh,
      OneFactor: CR,
      OneMinusConstantAlphaFactor: zR,
      OneMinusConstantColorFactor: kR,
      OneMinusDstAlphaFactor: IR,
      OneMinusDstColorFactor: DR,
      OneMinusSrcAlphaFactor: $m,
      OneMinusSrcColorFactor: RR,
      OrthographicCamera: Fo,
      P3Primaries: Vf,
      PCFShadowMap: Ug,
      PCFSoftShadowMap: sf,
      PMREMGenerator: F_,
      Path: Wf,
      PerspectiveCamera: En,
      Plane: Ps,
      PlaneGeometry: Mh,
      PlaneHelper: NW,
      PointLight: _I,
      PointLightHelper: EW,
      Points: YL,
      PointsMaterial: jS,
      PolarGridHelper: CW,
      PolyhedronGeometry: $o,
      PositionalAudio: tW,
      PropertyBinding: Nt,
      PropertyMixer: PI,
      QuadraticBezierCurve: ZS,
      QuadraticBezierCurve3: KS,
      Quaternion: hi,
      QuaternionKeyframeTrack: qu,
      QuaternionLinearInterpolant: gI,
      RED_GREEN_RGTC2_Format: N_,
      RED_RGTC1_Format: lL,
      REVISION: mh,
      RGBADepthPacking: dL,
      RGBAFormat: wi,
      RGBAIntegerFormat: bS,
      RGBA_ASTC_10x10_Format: b_,
      RGBA_ASTC_10x5_Format: E_,
      RGBA_ASTC_10x6_Format: T_,
      RGBA_ASTC_10x8_Format: A_,
      RGBA_ASTC_12x10_Format: C_,
      RGBA_ASTC_12x12_Format: P_,
      RGBA_ASTC_4x4_Format: g_,
      RGBA_ASTC_5x4_Format: v_,
      RGBA_ASTC_5x5_Format: y_,
      RGBA_ASTC_6x5_Format: x_,
      RGBA_ASTC_6x6_Format: __,
      RGBA_ASTC_8x5_Format: S_,
      RGBA_ASTC_8x6_Format: M_,
      RGBA_ASTC_8x8_Format: w_,
      RGBA_BPTC_Format: fm,
      RGBA_ETC2_EAC_Format: m_,
      RGBA_PVRTC_2BPPV1_Format: d_,
      RGBA_PVRTC_4BPPV1_Format: h_,
      RGBA_S3TC_DXT1_Format: lm,
      RGBA_S3TC_DXT3_Format: um,
      RGBA_S3TC_DXT5_Format: cm,
      RGB_BPTC_SIGNED_Format: R_,
      RGB_BPTC_UNSIGNED_Format: L_,
      RGB_ETC1_Format: CS,
      RGB_ETC2_Format: p_,
      RGB_PVRTC_2BPPV1_Format: f_,
      RGB_PVRTC_4BPPV1_Format: c_,
      RGB_S3TC_DXT1_Format: am,
      RGFormat: aL,
      RGIntegerFormat: AS,
      RawShaderMaterial: sI,
      Ray: rl,
      Raycaster: LI,
      Rec709Primaries: Bf,
      RectAreaLight: wI,
      RedFormat: oL,
      RedIntegerFormat: TS,
      ReinhardToneMapping: KR,
      RenderTarget: TL,
      RepeatWrapping: Df,
      ReplaceStencilOp: i6,
      ReverseSubtractEquation: AR,
      RingGeometry: nv,
      SIGNED_RED_GREEN_RGTC2_Format: D_,
      SIGNED_RED_RGTC1_Format: I_,
      SRGBColorSpace: Dn,
      SRGBTransfer: jt,
      Scene: HS,
      ShaderChunk: St,
      ShaderLib: Or,
      ShaderMaterial: Hr,
      ShadowMaterial: rI,
      Shape: ja,
      ShapeGeometry: iv,
      ShapePath: UW,
      ShapeUtils: fs,
      ShortType: nL,
      Skeleton: Xg,
      SkeletonHelper: wW,
      SkinnedMesh: GL,
      Source: Ua,
      Sphere: di,
      SphereGeometry: Th,
      Spherical: ig,
      SphericalHarmonics3: EI,
      SplineCurve: QS,
      SpotLight: xI,
      SpotLightHelper: MW,
      Sprite: VL,
      SpriteMaterial: GS,
      SrcAlphaFactor: Qm,
      SrcAlphaSaturateFactor: OR,
      SrcColorFactor: PR,
      StaticCopyUsage: S6,
      StaticDrawUsage: Hf,
      StaticReadUsage: y6,
      StereoCamera: Q7,
      StreamCopyUsage: w6,
      StreamDrawUsage: v6,
      StreamReadUsage: _6,
      StringKeyframeTrack: al,
      SubtractEquation: TR,
      SubtractiveBlending: s_,
      TOUCH: Aa,
      TangentSpaceNormalMap: Ko,
      TetrahedronGeometry: rv,
      Texture: An,
      TextureLoader: G7,
      TorusGeometry: sv,
      TorusKnotGeometry: ov,
      Triangle: Oi,
      TriangleFanDrawMode: t6,
      TriangleStripDrawMode: e6,
      TrianglesDrawMode: JB,
      TubeGeometry: av,
      TwoPassDoubleSide: qB,
      UVMapping: kg,
      Uint16BufferAttribute: OS,
      Uint32BufferAttribute: US,
      Uint8BufferAttribute: rV,
      Uint8ClampedBufferAttribute: sV,
      Uniform: uM,
      UniformsGroup: gW,
      UniformsLib: Re,
      UniformsUtils: CL,
      UnsignedByteType: cs,
      UnsignedInt248Type: Oo,
      UnsignedIntType: Ds,
      UnsignedShort4444Type: wS,
      UnsignedShort5551Type: ES,
      UnsignedShortType: Fg,
      VSMShadowMap: Ir,
      Vector2: de,
      Vector3: U,
      Vector4: Bt,
      VectorKeyframeTrack: Zf,
      VideoTexture: t7,
      WebGL1Renderer: zL,
      WebGL3DRenderTarget: W6,
      WebGLArrayRenderTarget: G6,
      WebGLCoordinateSystem: kr,
      WebGLCubeRenderTarget: RL,
      WebGLMultipleRenderTargets: j6,
      WebGLRenderTarget: Vr,
      WebGLRenderer: VS,
      WebGLUtils: kL,
      WebGPUCoordinateSystem: Uu,
      WireframeGeometry: iI,
      WrapAroundEnding: Ff,
      ZeroCurvatureEnding: Da,
      ZeroFactor: bR,
      ZeroSlopeEnding: Oa,
      ZeroStencilOp: n6,
      _SRGBAFormat: eg,
      createCanvasElement: EL,
      sRGBEncoding: ko,
    },
    Symbol.toStringTag,
    { value: "Module" }
  )
);
var NI = { exports: {} },
  ll = {};
/**
 * @license React
 * react-reconciler-constants.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ ll.ConcurrentRoot = 1;
ll.ContinuousEventPriority = 4;
ll.DefaultEventPriority = 16;
ll.DiscreteEventPriority = 1;
ll.IdleEventPriority = 536870912;
ll.LegacyRoot = 0;
NI.exports = ll;
var yu = NI.exports;
function FW(n) {
  let e;
  const t = new Set(),
    i = (f, h) => {
      const d = typeof f == "function" ? f(e) : f;
      if (d !== e) {
        const p = e;
        (e = h ? d : Object.assign({}, e, d)), t.forEach((m) => m(e, p));
      }
    },
    r = () => e,
    s = (f, h = r, d = Object.is) => {
      console.warn(
        "[DEPRECATED] Please use `subscribeWithSelector` middleware"
      );
      let p = h(e);
      function m() {
        const y = h(e);
        if (!d(p, y)) {
          const w = p;
          f((p = y), w);
        }
      }
      return t.add(m), () => t.delete(m);
    },
    u = {
      setState: i,
      getState: r,
      subscribe: (f, h, d) =>
        h || d ? s(f, h, d) : (t.add(f), () => t.delete(f)),
      destroy: () => t.clear(),
    };
  return (e = n(i, r, u)), u;
}
const zW =
    typeof window > "u" ||
    !window.navigator ||
    /ServerSideRendering|^Deno\//.test(window.navigator.userAgent),
  JA = zW ? se.useEffect : se.useLayoutEffect;
function BW(n) {
  const e = typeof n == "function" ? FW(n) : n,
    t = (i = e.getState, r = Object.is) => {
      const [, s] = se.useReducer((S) => S + 1, 0),
        o = e.getState(),
        a = se.useRef(o),
        u = se.useRef(i),
        f = se.useRef(r),
        h = se.useRef(!1),
        d = se.useRef();
      d.current === void 0 && (d.current = i(o));
      let p,
        m = !1;
      (a.current !== o || u.current !== i || f.current !== r || h.current) &&
        ((p = i(o)), (m = !r(d.current, p))),
        JA(() => {
          m && (d.current = p),
            (a.current = o),
            (u.current = i),
            (f.current = r),
            (h.current = !1);
        });
      const y = se.useRef(o);
      JA(() => {
        const S = () => {
            try {
              const M = e.getState(),
                _ = u.current(M);
              f.current(d.current, _) ||
                ((a.current = M), (d.current = _), s());
            } catch {
              (h.current = !0), s();
            }
          },
          v = e.subscribe(S);
        return e.getState() !== y.current && S(), v;
      }, []);
      const w = m ? p : d.current;
      return se.useDebugValue(w), w;
    };
  return (
    Object.assign(t, e),
    (t[Symbol.iterator] = function () {
      console.warn(
        "[useStore, api] = create() is deprecated and will be removed in v4"
      );
      const i = [t, e];
      return {
        next() {
          const r = i.length <= 0;
          return { value: i.shift(), done: r };
        },
      };
    }),
    t
  );
}
var DI = { exports: {} },
  OI = { exports: {} },
  UI = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ (function (n) {
  function e(k, G) {
    var W = k.length;
    k.push(G);
    e: for (; 0 < W; ) {
      var Y = (W - 1) >>> 1,
        ie = k[Y];
      if (0 < r(ie, G)) (k[Y] = G), (k[W] = ie), (W = Y);
      else break e;
    }
  }
  function t(k) {
    return k.length === 0 ? null : k[0];
  }
  function i(k) {
    if (k.length === 0) return null;
    var G = k[0],
      W = k.pop();
    if (W !== G) {
      k[0] = W;
      e: for (var Y = 0, ie = k.length, J = ie >>> 1; Y < J; ) {
        var he = 2 * (Y + 1) - 1,
          Ee = k[he],
          be = he + 1,
          Pe = k[be];
        if (0 > r(Ee, W))
          be < ie && 0 > r(Pe, Ee)
            ? ((k[Y] = Pe), (k[be] = W), (Y = be))
            : ((k[Y] = Ee), (k[he] = W), (Y = he));
        else if (be < ie && 0 > r(Pe, W)) (k[Y] = Pe), (k[be] = W), (Y = be);
        else break e;
      }
    }
    return G;
  }
  function r(k, G) {
    var W = k.sortIndex - G.sortIndex;
    return W !== 0 ? W : k.id - G.id;
  }
  if (typeof performance == "object" && typeof performance.now == "function") {
    var s = performance;
    n.unstable_now = function () {
      return s.now();
    };
  } else {
    var o = Date,
      a = o.now();
    n.unstable_now = function () {
      return o.now() - a;
    };
  }
  var u = [],
    f = [],
    h = 1,
    d = null,
    p = 3,
    m = !1,
    y = !1,
    w = !1,
    S = typeof setTimeout == "function" ? setTimeout : null,
    v = typeof clearTimeout == "function" ? clearTimeout : null,
    M = typeof setImmediate < "u" ? setImmediate : null;
  typeof navigator < "u" &&
    navigator.scheduling !== void 0 &&
    navigator.scheduling.isInputPending !== void 0 &&
    navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function _(k) {
    for (var G = t(f); G !== null; ) {
      if (G.callback === null) i(f);
      else if (G.startTime <= k)
        i(f), (G.sortIndex = G.expirationTime), e(u, G);
      else break;
      G = t(f);
    }
  }
  function T(k) {
    if (((w = !1), _(k), !y))
      if (t(u) !== null) (y = !0), $(P);
      else {
        var G = t(f);
        G !== null && ce(T, G.startTime - k);
      }
  }
  function P(k, G) {
    (y = !1), w && ((w = !1), v(N), (N = -1)), (m = !0);
    var W = p;
    try {
      for (
        _(G), d = t(u);
        d !== null && (!(d.expirationTime > G) || (k && !B()));

      ) {
        var Y = d.callback;
        if (typeof Y == "function") {
          (d.callback = null), (p = d.priorityLevel);
          var ie = Y(d.expirationTime <= G);
          (G = n.unstable_now()),
            typeof ie == "function" ? (d.callback = ie) : d === t(u) && i(u),
            _(G);
        } else i(u);
        d = t(u);
      }
      if (d !== null) var J = !0;
      else {
        var he = t(f);
        he !== null && ce(T, he.startTime - G), (J = !1);
      }
      return J;
    } finally {
      (d = null), (p = W), (m = !1);
    }
  }
  var b = !1,
    L = null,
    N = -1,
    C = 5,
    R = -1;
  function B() {
    return !(n.unstable_now() - R < C);
  }
  function Z() {
    if (L !== null) {
      var k = n.unstable_now();
      R = k;
      var G = !0;
      try {
        G = L(!0, k);
      } finally {
        G ? ae() : ((b = !1), (L = null));
      }
    } else b = !1;
  }
  var ae;
  if (typeof M == "function")
    ae = function () {
      M(Z);
    };
  else if (typeof MessageChannel < "u") {
    var V = new MessageChannel(),
      Q = V.port2;
    (V.port1.onmessage = Z),
      (ae = function () {
        Q.postMessage(null);
      });
  } else
    ae = function () {
      S(Z, 0);
    };
  function $(k) {
    (L = k), b || ((b = !0), ae());
  }
  function ce(k, G) {
    N = S(function () {
      k(n.unstable_now());
    }, G);
  }
  (n.unstable_IdlePriority = 5),
    (n.unstable_ImmediatePriority = 1),
    (n.unstable_LowPriority = 4),
    (n.unstable_NormalPriority = 3),
    (n.unstable_Profiling = null),
    (n.unstable_UserBlockingPriority = 2),
    (n.unstable_cancelCallback = function (k) {
      k.callback = null;
    }),
    (n.unstable_continueExecution = function () {
      y || m || ((y = !0), $(P));
    }),
    (n.unstable_forceFrameRate = function (k) {
      0 > k || 125 < k
        ? console.error(
            "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
          )
        : (C = 0 < k ? Math.floor(1e3 / k) : 5);
    }),
    (n.unstable_getCurrentPriorityLevel = function () {
      return p;
    }),
    (n.unstable_getFirstCallbackNode = function () {
      return t(u);
    }),
    (n.unstable_next = function (k) {
      switch (p) {
        case 1:
        case 2:
        case 3:
          var G = 3;
          break;
        default:
          G = p;
      }
      var W = p;
      p = G;
      try {
        return k();
      } finally {
        p = W;
      }
    }),
    (n.unstable_pauseExecution = function () {}),
    (n.unstable_requestPaint = function () {}),
    (n.unstable_runWithPriority = function (k, G) {
      switch (k) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          k = 3;
      }
      var W = p;
      p = k;
      try {
        return G();
      } finally {
        p = W;
      }
    }),
    (n.unstable_scheduleCallback = function (k, G, W) {
      var Y = n.unstable_now();
      switch (
        (typeof W == "object" && W !== null
          ? ((W = W.delay), (W = typeof W == "number" && 0 < W ? Y + W : Y))
          : (W = Y),
        k)
      ) {
        case 1:
          var ie = -1;
          break;
        case 2:
          ie = 250;
          break;
        case 5:
          ie = 1073741823;
          break;
        case 4:
          ie = 1e4;
          break;
        default:
          ie = 5e3;
      }
      return (
        (ie = W + ie),
        (k = {
          id: h++,
          callback: G,
          priorityLevel: k,
          startTime: W,
          expirationTime: ie,
          sortIndex: -1,
        }),
        W > Y
          ? ((k.sortIndex = W),
            e(f, k),
            t(u) === null &&
              k === t(f) &&
              (w ? (v(N), (N = -1)) : (w = !0), ce(T, W - Y)))
          : ((k.sortIndex = ie), e(u, k), y || m || ((y = !0), $(P))),
        k
      );
    }),
    (n.unstable_shouldYield = B),
    (n.unstable_wrapCallback = function (k) {
      var G = p;
      return function () {
        var W = p;
        p = G;
        try {
          return k.apply(this, arguments);
        } finally {
          p = W;
        }
      };
    });
})(UI);
OI.exports = UI;
var X_ = OI.exports;
/**
 * @license React
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var VW = function (e) {
  var t = {},
    i = se,
    r = X_,
    s = Object.assign;
  function o(l) {
    for (
      var c = "https://reactjs.org/docs/error-decoder.html?invariant=" + l,
        g = 1;
      g < arguments.length;
      g++
    )
      c += "&args[]=" + encodeURIComponent(arguments[g]);
    return (
      "Minified React error #" +
      l +
      "; visit " +
      c +
      " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    );
  }
  var a = i.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
    u = Symbol.for("react.element"),
    f = Symbol.for("react.portal"),
    h = Symbol.for("react.fragment"),
    d = Symbol.for("react.strict_mode"),
    p = Symbol.for("react.profiler"),
    m = Symbol.for("react.provider"),
    y = Symbol.for("react.context"),
    w = Symbol.for("react.forward_ref"),
    S = Symbol.for("react.suspense"),
    v = Symbol.for("react.suspense_list"),
    M = Symbol.for("react.memo"),
    _ = Symbol.for("react.lazy"),
    T = Symbol.for("react.offscreen"),
    P = Symbol.iterator;
  function b(l) {
    return l === null || typeof l != "object"
      ? null
      : ((l = (P && l[P]) || l["@@iterator"]),
        typeof l == "function" ? l : null);
  }
  function L(l) {
    if (l == null) return null;
    if (typeof l == "function") return l.displayName || l.name || null;
    if (typeof l == "string") return l;
    switch (l) {
      case h:
        return "Fragment";
      case f:
        return "Portal";
      case p:
        return "Profiler";
      case d:
        return "StrictMode";
      case S:
        return "Suspense";
      case v:
        return "SuspenseList";
    }
    if (typeof l == "object")
      switch (l.$$typeof) {
        case y:
          return (l.displayName || "Context") + ".Consumer";
        case m:
          return (l._context.displayName || "Context") + ".Provider";
        case w:
          var c = l.render;
          return (
            (l = l.displayName),
            l ||
              ((l = c.displayName || c.name || ""),
              (l = l !== "" ? "ForwardRef(" + l + ")" : "ForwardRef")),
            l
          );
        case M:
          return (
            (c = l.displayName || null), c !== null ? c : L(l.type) || "Memo"
          );
        case _:
          (c = l._payload), (l = l._init);
          try {
            return L(l(c));
          } catch {}
      }
    return null;
  }
  function N(l) {
    var c = l.type;
    switch (l.tag) {
      case 24:
        return "Cache";
      case 9:
        return (c.displayName || "Context") + ".Consumer";
      case 10:
        return (c._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return (
          (l = c.render),
          (l = l.displayName || l.name || ""),
          c.displayName || (l !== "" ? "ForwardRef(" + l + ")" : "ForwardRef")
        );
      case 7:
        return "Fragment";
      case 5:
        return c;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return L(c);
      case 8:
        return c === d ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof c == "function") return c.displayName || c.name || null;
        if (typeof c == "string") return c;
    }
    return null;
  }
  function C(l) {
    var c = l,
      g = l;
    if (l.alternate) for (; c.return; ) c = c.return;
    else {
      l = c;
      do (c = l), c.flags & 4098 && (g = c.return), (l = c.return);
      while (l);
    }
    return c.tag === 3 ? g : null;
  }
  function R(l) {
    if (C(l) !== l) throw Error(o(188));
  }
  function B(l) {
    var c = l.alternate;
    if (!c) {
      if (((c = C(l)), c === null)) throw Error(o(188));
      return c !== l ? null : l;
    }
    for (var g = l, x = c; ; ) {
      var E = g.return;
      if (E === null) break;
      var A = E.alternate;
      if (A === null) {
        if (((x = E.return), x !== null)) {
          g = x;
          continue;
        }
        break;
      }
      if (E.child === A.child) {
        for (A = E.child; A; ) {
          if (A === g) return R(E), l;
          if (A === x) return R(E), c;
          A = A.sibling;
        }
        throw Error(o(188));
      }
      if (g.return !== x.return) (g = E), (x = A);
      else {
        for (var F = !1, q = E.child; q; ) {
          if (q === g) {
            (F = !0), (g = E), (x = A);
            break;
          }
          if (q === x) {
            (F = !0), (x = E), (g = A);
            break;
          }
          q = q.sibling;
        }
        if (!F) {
          for (q = A.child; q; ) {
            if (q === g) {
              (F = !0), (g = A), (x = E);
              break;
            }
            if (q === x) {
              (F = !0), (x = A), (g = E);
              break;
            }
            q = q.sibling;
          }
          if (!F) throw Error(o(189));
        }
      }
      if (g.alternate !== x) throw Error(o(190));
    }
    if (g.tag !== 3) throw Error(o(188));
    return g.stateNode.current === g ? l : c;
  }
  function Z(l) {
    return (l = B(l)), l !== null ? ae(l) : null;
  }
  function ae(l) {
    if (l.tag === 5 || l.tag === 6) return l;
    for (l = l.child; l !== null; ) {
      var c = ae(l);
      if (c !== null) return c;
      l = l.sibling;
    }
    return null;
  }
  function V(l) {
    if (l.tag === 5 || l.tag === 6) return l;
    for (l = l.child; l !== null; ) {
      if (l.tag !== 4) {
        var c = V(l);
        if (c !== null) return c;
      }
      l = l.sibling;
    }
    return null;
  }
  var Q = Array.isArray,
    $ = e.getPublicInstance,
    ce = e.getRootHostContext,
    k = e.getChildHostContext,
    G = e.prepareForCommit,
    W = e.resetAfterCommit,
    Y = e.createInstance,
    ie = e.appendInitialChild,
    J = e.finalizeInitialChildren,
    he = e.prepareUpdate,
    Ee = e.shouldSetTextContent,
    be = e.createTextInstance,
    Pe = e.scheduleTimeout,
    it = e.cancelTimeout,
    rt = e.noTimeout,
    Ve = e.isPrimaryRenderer,
    We = e.supportsMutation,
    H = e.supportsPersistence,
    Me = e.supportsHydration,
    pe = e.getInstanceFromNode,
    Te = e.preparePortalMount,
    me = e.getCurrentEventPriority,
    Ke = e.detachDeletedInstance,
    Ne = e.supportsMicrotasks,
    D = e.scheduleMicrotask,
    I = e.supportsTestSelectors,
    te = e.findFiberRoot,
    xe = e.getBoundingRect,
    ye = e.getTextContent,
    ge = e.isHiddenSubtree,
    Ye = e.matchAccessibilityRole,
    Le = e.setFocusIfFocusable,
    Fe = e.setupIntersectionObserver,
    tt = e.appendChild,
    mt = e.appendChildToContainer,
    _e = e.commitTextUpdate,
    Rt = e.commitMount,
    _t = e.commitUpdate,
    ht = e.insertBefore,
    et = e.insertInContainerBefore,
    He = e.removeChild,
    j = e.removeChildFromContainer,
    ve = e.resetTextContent,
    ke = e.hideInstance,
    Oe = e.hideTextInstance,
    Se = e.unhideInstance,
    X = e.unhideTextInstance,
    Ce = e.clearContainer,
    Ie = e.cloneInstance,
    st = e.createContainerChildSet,
    qe = e.appendChildToContainerChildSet,
    Ct = e.finalizeContainerChildren,
    Lt = e.replaceContainerChildren,
    Gt = e.cloneHiddenInstance,
    Jt = e.cloneHiddenTextInstance,
    It = e.canHydrateInstance,
    Yn = e.canHydrateTextInstance,
    sr = e.canHydrateSuspenseInstance,
    Zu = e.isSuspenseInstancePending,
    Ku = e.isSuspenseInstanceFallback,
    ul = e.registerSuspenseInstanceRetry,
    Ks = e.getNextHydratableSibling,
    cl = e.getFirstHydratableChild,
    Ph = e.getFirstHydratableChildWithinContainer,
    Rh = e.getFirstHydratableChildWithinSuspenseInstance,
    uv = e.hydrateInstance,
    cv = e.hydrateTextInstance,
    fv = e.hydrateSuspenseInstance,
    O = e.getNextHydratableInstanceAfterSuspenseInstance,
    ee = e.commitHydratedContainer,
    oe = e.commitHydratedSuspenseInstance,
    le = e.clearSuspenseBoundary,
    re = e.clearSuspenseBoundaryFromContainer,
    ze = e.shouldDeleteUnhydratedTailInstances,
    $e = e.didNotMatchHydratedContainerTextInstance,
    lt = e.didNotMatchHydratedTextInstance,
    ut;
  function gt(l) {
    if (ut === void 0)
      try {
        throw Error();
      } catch (g) {
        var c = g.stack.trim().match(/\n( *(at )?)/);
        ut = (c && c[1]) || "";
      }
    return (
      `
` +
      ut +
      l
    );
  }
  var pt = !1;
  function vt(l, c) {
    if (!l || pt) return "";
    pt = !0;
    var g = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (c)
        if (
          ((c = function () {
            throw Error();
          }),
          Object.defineProperty(c.prototype, "props", {
            set: function () {
              throw Error();
            },
          }),
          typeof Reflect == "object" && Reflect.construct)
        ) {
          try {
            Reflect.construct(c, []);
          } catch (Ae) {
            var x = Ae;
          }
          Reflect.construct(l, [], c);
        } else {
          try {
            c.call();
          } catch (Ae) {
            x = Ae;
          }
          l.call(c.prototype);
        }
      else {
        try {
          throw Error();
        } catch (Ae) {
          x = Ae;
        }
        l();
      }
    } catch (Ae) {
      if (Ae && x && typeof Ae.stack == "string") {
        for (
          var E = Ae.stack.split(`
`),
            A = x.stack.split(`
`),
            F = E.length - 1,
            q = A.length - 1;
          1 <= F && 0 <= q && E[F] !== A[q];

        )
          q--;
        for (; 1 <= F && 0 <= q; F--, q--)
          if (E[F] !== A[q]) {
            if (F !== 1 || q !== 1)
              do
                if ((F--, q--, 0 > q || E[F] !== A[q])) {
                  var fe =
                    `
` + E[F].replace(" at new ", " at ");
                  return (
                    l.displayName &&
                      fe.includes("<anonymous>") &&
                      (fe = fe.replace("<anonymous>", l.displayName)),
                    fe
                  );
                }
              while (1 <= F && 0 <= q);
            break;
          }
      }
    } finally {
      (pt = !1), (Error.prepareStackTrace = g);
    }
    return (l = l ? l.displayName || l.name : "") ? gt(l) : "";
  }
  var rn = Object.prototype.hasOwnProperty,
    qn = [],
    Yt = -1;
  function zn(l) {
    return { current: l };
  }
  function ct(l) {
    0 > Yt || ((l.current = qn[Yt]), (qn[Yt] = null), Yt--);
  }
  function je(l, c) {
    Yt++, (qn[Yt] = l.current), (l.current = c);
  }
  var or = {},
    At = zn(or),
    dn = zn(!1),
    jr = or;
  function ar(l, c) {
    var g = l.type.contextTypes;
    if (!g) return or;
    var x = l.stateNode;
    if (x && x.__reactInternalMemoizedUnmaskedChildContext === c)
      return x.__reactInternalMemoizedMaskedChildContext;
    var E = {},
      A;
    for (A in g) E[A] = c[A];
    return (
      x &&
        ((l = l.stateNode),
        (l.__reactInternalMemoizedUnmaskedChildContext = c),
        (l.__reactInternalMemoizedMaskedChildContext = E)),
      E
    );
  }
  function Bn(l) {
    return (l = l.childContextTypes), l != null;
  }
  function yn() {
    ct(dn), ct(At);
  }
  function Xr(l, c, g) {
    if (At.current !== or) throw Error(o(168));
    je(At, c), je(dn, g);
  }
  function fl(l, c, g) {
    var x = l.stateNode;
    if (((c = c.childContextTypes), typeof x.getChildContext != "function"))
      return g;
    x = x.getChildContext();
    for (var E in x) if (!(E in c)) throw Error(o(108, N(l) || "Unknown", E));
    return s({}, g, x);
  }
  function Zn(l) {
    return (
      (l =
        ((l = l.stateNode) && l.__reactInternalMemoizedMergedChildContext) ||
        or),
      (jr = At.current),
      je(At, l),
      je(dn, dn.current),
      !0
    );
  }
  function hl(l, c, g) {
    var x = l.stateNode;
    if (!x) throw Error(o(169));
    g
      ? ((l = fl(l, c, jr)),
        (x.__reactInternalMemoizedMergedChildContext = l),
        ct(dn),
        ct(At),
        je(At, l))
      : ct(dn),
      je(dn, g);
  }
  var Gi = Math.clz32 ? Math.clz32 : eN,
    Lh = Math.log,
    JI = Math.LN2;
  function eN(l) {
    return (l >>>= 0), l === 0 ? 32 : (31 - ((Lh(l) / JI) | 0)) | 0;
  }
  var Ih = 64,
    Nh = 4194304;
  function Qu(l) {
    switch (l & -l) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return l & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return l & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return l;
    }
  }
  function Dh(l, c) {
    var g = l.pendingLanes;
    if (g === 0) return 0;
    var x = 0,
      E = l.suspendedLanes,
      A = l.pingedLanes,
      F = g & 268435455;
    if (F !== 0) {
      var q = F & ~E;
      q !== 0 ? (x = Qu(q)) : ((A &= F), A !== 0 && (x = Qu(A)));
    } else (F = g & ~E), F !== 0 ? (x = Qu(F)) : A !== 0 && (x = Qu(A));
    if (x === 0) return 0;
    if (
      c !== 0 &&
      c !== x &&
      !(c & E) &&
      ((E = x & -x), (A = c & -c), E >= A || (E === 16 && (A & 4194240) !== 0))
    )
      return c;
    if ((x & 4 && (x |= g & 16), (c = l.entangledLanes), c !== 0))
      for (l = l.entanglements, c &= x; 0 < c; )
        (g = 31 - Gi(c)), (E = 1 << g), (x |= l[g]), (c &= ~E);
    return x;
  }
  function tN(l, c) {
    switch (l) {
      case 1:
      case 2:
      case 4:
        return c + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return c + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function nN(l, c) {
    for (
      var g = l.suspendedLanes,
        x = l.pingedLanes,
        E = l.expirationTimes,
        A = l.pendingLanes;
      0 < A;

    ) {
      var F = 31 - Gi(A),
        q = 1 << F,
        fe = E[F];
      fe === -1
        ? (!(q & g) || q & x) && (E[F] = tN(q, c))
        : fe <= c && (l.expiredLanes |= q),
        (A &= ~q);
    }
  }
  function hv(l) {
    return (
      (l = l.pendingLanes & -1073741825),
      l !== 0 ? l : l & 1073741824 ? 1073741824 : 0
    );
  }
  function dv(l) {
    for (var c = [], g = 0; 31 > g; g++) c.push(l);
    return c;
  }
  function $u(l, c, g) {
    (l.pendingLanes |= c),
      c !== 536870912 && ((l.suspendedLanes = 0), (l.pingedLanes = 0)),
      (l = l.eventTimes),
      (c = 31 - Gi(c)),
      (l[c] = g);
  }
  function iN(l, c) {
    var g = l.pendingLanes & ~c;
    (l.pendingLanes = c),
      (l.suspendedLanes = 0),
      (l.pingedLanes = 0),
      (l.expiredLanes &= c),
      (l.mutableReadLanes &= c),
      (l.entangledLanes &= c),
      (c = l.entanglements);
    var x = l.eventTimes;
    for (l = l.expirationTimes; 0 < g; ) {
      var E = 31 - Gi(g),
        A = 1 << E;
      (c[E] = 0), (x[E] = -1), (l[E] = -1), (g &= ~A);
    }
  }
  function pv(l, c) {
    var g = (l.entangledLanes |= c);
    for (l = l.entanglements; g; ) {
      var x = 31 - Gi(g),
        E = 1 << x;
      (E & c) | (l[x] & c) && (l[x] |= c), (g &= ~E);
    }
  }
  var Ot = 0;
  function hM(l) {
    return (
      (l &= -l), 1 < l ? (4 < l ? (l & 268435455 ? 16 : 536870912) : 4) : 1
    );
  }
  var mv = r.unstable_scheduleCallback,
    dM = r.unstable_cancelCallback,
    rN = r.unstable_shouldYield,
    sN = r.unstable_requestPaint,
    Vn = r.unstable_now,
    gv = r.unstable_ImmediatePriority,
    oN = r.unstable_UserBlockingPriority,
    vv = r.unstable_NormalPriority,
    aN = r.unstable_IdlePriority,
    Oh = null,
    Yr = null;
  function lN(l) {
    if (Yr && typeof Yr.onCommitFiberRoot == "function")
      try {
        Yr.onCommitFiberRoot(Oh, l, void 0, (l.current.flags & 128) === 128);
      } catch {}
  }
  function uN(l, c) {
    return (l === c && (l !== 0 || 1 / l === 1 / c)) || (l !== l && c !== c);
  }
  var qr = typeof Object.is == "function" ? Object.is : uN,
    ms = null,
    Uh = !1,
    yv = !1;
  function pM(l) {
    ms === null ? (ms = [l]) : ms.push(l);
  }
  function cN(l) {
    (Uh = !0), pM(l);
  }
  function Zr() {
    if (!yv && ms !== null) {
      yv = !0;
      var l = 0,
        c = Ot;
      try {
        var g = ms;
        for (Ot = 1; l < g.length; l++) {
          var x = g[l];
          do x = x(!0);
          while (x !== null);
        }
        (ms = null), (Uh = !1);
      } catch (E) {
        throw (ms !== null && (ms = ms.slice(l + 1)), mv(gv, Zr), E);
      } finally {
        (Ot = c), (yv = !1);
      }
    }
    return null;
  }
  var fN = a.ReactCurrentBatchConfig;
  function kh(l, c) {
    if (qr(l, c)) return !0;
    if (
      typeof l != "object" ||
      l === null ||
      typeof c != "object" ||
      c === null
    )
      return !1;
    var g = Object.keys(l),
      x = Object.keys(c);
    if (g.length !== x.length) return !1;
    for (x = 0; x < g.length; x++) {
      var E = g[x];
      if (!rn.call(c, E) || !qr(l[E], c[E])) return !1;
    }
    return !0;
  }
  function hN(l) {
    switch (l.tag) {
      case 5:
        return gt(l.type);
      case 16:
        return gt("Lazy");
      case 13:
        return gt("Suspense");
      case 19:
        return gt("SuspenseList");
      case 0:
      case 2:
      case 15:
        return (l = vt(l.type, !1)), l;
      case 11:
        return (l = vt(l.type.render, !1)), l;
      case 1:
        return (l = vt(l.type, !0)), l;
      default:
        return "";
    }
  }
  function Tr(l, c) {
    if (l && l.defaultProps) {
      (c = s({}, c)), (l = l.defaultProps);
      for (var g in l) c[g] === void 0 && (c[g] = l[g]);
      return c;
    }
    return c;
  }
  var Fh = zn(null),
    zh = null,
    dl = null,
    xv = null;
  function _v() {
    xv = dl = zh = null;
  }
  function mM(l, c, g) {
    Ve
      ? (je(Fh, c._currentValue), (c._currentValue = g))
      : (je(Fh, c._currentValue2), (c._currentValue2 = g));
  }
  function Sv(l) {
    var c = Fh.current;
    ct(Fh), Ve ? (l._currentValue = c) : (l._currentValue2 = c);
  }
  function Mv(l, c, g) {
    for (; l !== null; ) {
      var x = l.alternate;
      if (
        ((l.childLanes & c) !== c
          ? ((l.childLanes |= c), x !== null && (x.childLanes |= c))
          : x !== null && (x.childLanes & c) !== c && (x.childLanes |= c),
        l === g)
      )
        break;
      l = l.return;
    }
  }
  function pl(l, c) {
    (zh = l),
      (xv = dl = null),
      (l = l.dependencies),
      l !== null &&
        l.firstContext !== null &&
        (l.lanes & c && (Xi = !0), (l.firstContext = null));
  }
  function lr(l) {
    var c = Ve ? l._currentValue : l._currentValue2;
    if (xv !== l)
      if (((l = { context: l, memoizedValue: c, next: null }), dl === null)) {
        if (zh === null) throw Error(o(308));
        (dl = l), (zh.dependencies = { lanes: 0, firstContext: l });
      } else dl = dl.next = l;
    return c;
  }
  var Kr = null,
    Qs = !1;
  function wv(l) {
    l.updateQueue = {
      baseState: l.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: { pending: null, interleaved: null, lanes: 0 },
      effects: null,
    };
  }
  function gM(l, c) {
    (l = l.updateQueue),
      c.updateQueue === l &&
        (c.updateQueue = {
          baseState: l.baseState,
          firstBaseUpdate: l.firstBaseUpdate,
          lastBaseUpdate: l.lastBaseUpdate,
          shared: l.shared,
          effects: l.effects,
        });
  }
  function gs(l, c) {
    return {
      eventTime: l,
      lane: c,
      tag: 0,
      payload: null,
      callback: null,
      next: null,
    };
  }
  function $s(l, c) {
    var g = l.updateQueue;
    g !== null &&
      ((g = g.shared),
      bn !== null && l.mode & 1 && !(bt & 2)
        ? ((l = g.interleaved),
          l === null
            ? ((c.next = c), Kr === null ? (Kr = [g]) : Kr.push(g))
            : ((c.next = l.next), (l.next = c)),
          (g.interleaved = c))
        : ((l = g.pending),
          l === null ? (c.next = c) : ((c.next = l.next), (l.next = c)),
          (g.pending = c)));
  }
  function Bh(l, c, g) {
    if (
      ((c = c.updateQueue), c !== null && ((c = c.shared), (g & 4194240) !== 0))
    ) {
      var x = c.lanes;
      (x &= l.pendingLanes), (g |= x), (c.lanes = g), pv(l, g);
    }
  }
  function vM(l, c) {
    var g = l.updateQueue,
      x = l.alternate;
    if (x !== null && ((x = x.updateQueue), g === x)) {
      var E = null,
        A = null;
      if (((g = g.firstBaseUpdate), g !== null)) {
        do {
          var F = {
            eventTime: g.eventTime,
            lane: g.lane,
            tag: g.tag,
            payload: g.payload,
            callback: g.callback,
            next: null,
          };
          A === null ? (E = A = F) : (A = A.next = F), (g = g.next);
        } while (g !== null);
        A === null ? (E = A = c) : (A = A.next = c);
      } else E = A = c;
      (g = {
        baseState: x.baseState,
        firstBaseUpdate: E,
        lastBaseUpdate: A,
        shared: x.shared,
        effects: x.effects,
      }),
        (l.updateQueue = g);
      return;
    }
    (l = g.lastBaseUpdate),
      l === null ? (g.firstBaseUpdate = c) : (l.next = c),
      (g.lastBaseUpdate = c);
  }
  function Vh(l, c, g, x) {
    var E = l.updateQueue;
    Qs = !1;
    var A = E.firstBaseUpdate,
      F = E.lastBaseUpdate,
      q = E.shared.pending;
    if (q !== null) {
      E.shared.pending = null;
      var fe = q,
        Ae = fe.next;
      (fe.next = null), F === null ? (A = Ae) : (F.next = Ae), (F = fe);
      var Xe = l.alternate;
      Xe !== null &&
        ((Xe = Xe.updateQueue),
        (q = Xe.lastBaseUpdate),
        q !== F &&
          (q === null ? (Xe.firstBaseUpdate = Ae) : (q.next = Ae),
          (Xe.lastBaseUpdate = fe)));
    }
    if (A !== null) {
      var yt = E.baseState;
      (F = 0), (Xe = Ae = fe = null), (q = A);
      do {
        var ot = q.lane,
          Wt = q.eventTime;
        if ((x & ot) === ot) {
          Xe !== null &&
            (Xe = Xe.next =
              {
                eventTime: Wt,
                lane: 0,
                tag: q.tag,
                payload: q.payload,
                callback: q.callback,
                next: null,
              });
          e: {
            var Je = l,
              ii = q;
            switch (((ot = c), (Wt = g), ii.tag)) {
              case 1:
                if (((Je = ii.payload), typeof Je == "function")) {
                  yt = Je.call(Wt, yt, ot);
                  break e;
                }
                yt = Je;
                break e;
              case 3:
                Je.flags = (Je.flags & -65537) | 128;
              case 0:
                if (
                  ((Je = ii.payload),
                  (ot = typeof Je == "function" ? Je.call(Wt, yt, ot) : Je),
                  ot == null)
                )
                  break e;
                yt = s({}, yt, ot);
                break e;
              case 2:
                Qs = !0;
            }
          }
          q.callback !== null &&
            q.lane !== 0 &&
            ((l.flags |= 64),
            (ot = E.effects),
            ot === null ? (E.effects = [q]) : ot.push(q));
        } else
          (Wt = {
            eventTime: Wt,
            lane: ot,
            tag: q.tag,
            payload: q.payload,
            callback: q.callback,
            next: null,
          }),
            Xe === null ? ((Ae = Xe = Wt), (fe = yt)) : (Xe = Xe.next = Wt),
            (F |= ot);
        if (((q = q.next), q === null)) {
          if (((q = E.shared.pending), q === null)) break;
          (ot = q),
            (q = ot.next),
            (ot.next = null),
            (E.lastBaseUpdate = ot),
            (E.shared.pending = null);
        }
      } while (!0);
      if (
        (Xe === null && (fe = yt),
        (E.baseState = fe),
        (E.firstBaseUpdate = Ae),
        (E.lastBaseUpdate = Xe),
        (c = E.shared.interleaved),
        c !== null)
      ) {
        E = c;
        do (F |= E.lane), (E = E.next);
        while (E !== c);
      } else A === null && (E.shared.lanes = 0);
      (wl |= F), (l.lanes = F), (l.memoizedState = yt);
    }
  }
  function yM(l, c, g) {
    if (((l = c.effects), (c.effects = null), l !== null))
      for (c = 0; c < l.length; c++) {
        var x = l[c],
          E = x.callback;
        if (E !== null) {
          if (((x.callback = null), (x = g), typeof E != "function"))
            throw Error(o(191, E));
          E.call(x);
        }
      }
  }
  var xM = new i.Component().refs;
  function Ev(l, c, g, x) {
    (c = l.memoizedState),
      (g = g(x, c)),
      (g = g == null ? c : s({}, c, g)),
      (l.memoizedState = g),
      l.lanes === 0 && (l.updateQueue.baseState = g);
  }
  var Hh = {
    isMounted: function (l) {
      return (l = l._reactInternals) ? C(l) === l : !1;
    },
    enqueueSetState: function (l, c, g) {
      l = l._reactInternals;
      var x = yi(),
        E = to(l),
        A = gs(x, E);
      (A.payload = c),
        g != null && (A.callback = g),
        $s(l, A),
        (c = dr(l, E, x)),
        c !== null && Bh(c, l, E);
    },
    enqueueReplaceState: function (l, c, g) {
      l = l._reactInternals;
      var x = yi(),
        E = to(l),
        A = gs(x, E);
      (A.tag = 1),
        (A.payload = c),
        g != null && (A.callback = g),
        $s(l, A),
        (c = dr(l, E, x)),
        c !== null && Bh(c, l, E);
    },
    enqueueForceUpdate: function (l, c) {
      l = l._reactInternals;
      var g = yi(),
        x = to(l),
        E = gs(g, x);
      (E.tag = 2),
        c != null && (E.callback = c),
        $s(l, E),
        (c = dr(l, x, g)),
        c !== null && Bh(c, l, x);
    },
  };
  function _M(l, c, g, x, E, A, F) {
    return (
      (l = l.stateNode),
      typeof l.shouldComponentUpdate == "function"
        ? l.shouldComponentUpdate(x, A, F)
        : c.prototype && c.prototype.isPureReactComponent
        ? !kh(g, x) || !kh(E, A)
        : !0
    );
  }
  function SM(l, c, g) {
    var x = !1,
      E = or,
      A = c.contextType;
    return (
      typeof A == "object" && A !== null
        ? (A = lr(A))
        : ((E = Bn(c) ? jr : At.current),
          (x = c.contextTypes),
          (A = (x = x != null) ? ar(l, E) : or)),
      (c = new c(g, A)),
      (l.memoizedState =
        c.state !== null && c.state !== void 0 ? c.state : null),
      (c.updater = Hh),
      (l.stateNode = c),
      (c._reactInternals = l),
      x &&
        ((l = l.stateNode),
        (l.__reactInternalMemoizedUnmaskedChildContext = E),
        (l.__reactInternalMemoizedMaskedChildContext = A)),
      c
    );
  }
  function MM(l, c, g, x) {
    (l = c.state),
      typeof c.componentWillReceiveProps == "function" &&
        c.componentWillReceiveProps(g, x),
      typeof c.UNSAFE_componentWillReceiveProps == "function" &&
        c.UNSAFE_componentWillReceiveProps(g, x),
      c.state !== l && Hh.enqueueReplaceState(c, c.state, null);
  }
  function Tv(l, c, g, x) {
    var E = l.stateNode;
    (E.props = g), (E.state = l.memoizedState), (E.refs = xM), wv(l);
    var A = c.contextType;
    typeof A == "object" && A !== null
      ? (E.context = lr(A))
      : ((A = Bn(c) ? jr : At.current), (E.context = ar(l, A))),
      (E.state = l.memoizedState),
      (A = c.getDerivedStateFromProps),
      typeof A == "function" && (Ev(l, c, A, g), (E.state = l.memoizedState)),
      typeof c.getDerivedStateFromProps == "function" ||
        typeof E.getSnapshotBeforeUpdate == "function" ||
        (typeof E.UNSAFE_componentWillMount != "function" &&
          typeof E.componentWillMount != "function") ||
        ((c = E.state),
        typeof E.componentWillMount == "function" && E.componentWillMount(),
        typeof E.UNSAFE_componentWillMount == "function" &&
          E.UNSAFE_componentWillMount(),
        c !== E.state && Hh.enqueueReplaceState(E, E.state, null),
        Vh(l, g, E, x),
        (E.state = l.memoizedState)),
      typeof E.componentDidMount == "function" && (l.flags |= 4194308);
  }
  var ml = [],
    gl = 0,
    Gh = null,
    Wh = 0,
    ur = [],
    cr = 0,
    ea = null,
    vs = 1,
    ys = "";
  function ta(l, c) {
    (ml[gl++] = Wh), (ml[gl++] = Gh), (Gh = l), (Wh = c);
  }
  function wM(l, c, g) {
    (ur[cr++] = vs), (ur[cr++] = ys), (ur[cr++] = ea), (ea = l);
    var x = vs;
    l = ys;
    var E = 32 - Gi(x) - 1;
    (x &= ~(1 << E)), (g += 1);
    var A = 32 - Gi(c) + E;
    if (30 < A) {
      var F = E - (E % 5);
      (A = (x & ((1 << F) - 1)).toString(32)),
        (x >>= F),
        (E -= F),
        (vs = (1 << (32 - Gi(c) + E)) | (g << E) | x),
        (ys = A + l);
    } else (vs = (1 << A) | (g << E) | x), (ys = l);
  }
  function Av(l) {
    l.return !== null && (ta(l, 1), wM(l, 1, 0));
  }
  function bv(l) {
    for (; l === Gh; )
      (Gh = ml[--gl]), (ml[gl] = null), (Wh = ml[--gl]), (ml[gl] = null);
    for (; l === ea; )
      (ea = ur[--cr]),
        (ur[cr] = null),
        (ys = ur[--cr]),
        (ur[cr] = null),
        (vs = ur[--cr]),
        (ur[cr] = null);
  }
  var Wi = null,
    ji = null,
    en = !1,
    Ju = !1,
    Ar = null;
  function EM(l, c) {
    var g = pr(5, null, null, 0);
    (g.elementType = "DELETED"),
      (g.stateNode = c),
      (g.return = l),
      (c = l.deletions),
      c === null ? ((l.deletions = [g]), (l.flags |= 16)) : c.push(g);
  }
  function TM(l, c) {
    switch (l.tag) {
      case 5:
        return (
          (c = It(c, l.type, l.pendingProps)),
          c !== null ? ((l.stateNode = c), (Wi = l), (ji = cl(c)), !0) : !1
        );
      case 6:
        return (
          (c = Yn(c, l.pendingProps)),
          c !== null ? ((l.stateNode = c), (Wi = l), (ji = null), !0) : !1
        );
      case 13:
        if (((c = sr(c)), c !== null)) {
          var g = ea !== null ? { id: vs, overflow: ys } : null;
          return (
            (l.memoizedState = {
              dehydrated: c,
              treeContext: g,
              retryLane: 1073741824,
            }),
            (g = pr(18, null, null, 0)),
            (g.stateNode = c),
            (g.return = l),
            (l.child = g),
            (Wi = l),
            (ji = null),
            !0
          );
        }
        return !1;
      default:
        return !1;
    }
  }
  function Cv(l) {
    return (l.mode & 1) !== 0 && (l.flags & 128) === 0;
  }
  function Pv(l) {
    if (en) {
      var c = ji;
      if (c) {
        var g = c;
        if (!TM(l, c)) {
          if (Cv(l)) throw Error(o(418));
          c = Ks(g);
          var x = Wi;
          c && TM(l, c)
            ? EM(x, g)
            : ((l.flags = (l.flags & -4097) | 2), (en = !1), (Wi = l));
        }
      } else {
        if (Cv(l)) throw Error(o(418));
        (l.flags = (l.flags & -4097) | 2), (en = !1), (Wi = l);
      }
    }
  }
  function AM(l) {
    for (
      l = l.return;
      l !== null && l.tag !== 5 && l.tag !== 3 && l.tag !== 13;

    )
      l = l.return;
    Wi = l;
  }
  function ec(l) {
    if (!Me || l !== Wi) return !1;
    if (!en) return AM(l), (en = !0), !1;
    if (
      l.tag !== 3 &&
      (l.tag !== 5 || (ze(l.type) && !Ee(l.type, l.memoizedProps)))
    ) {
      var c = ji;
      if (c) {
        if (Cv(l)) {
          for (l = ji; l; ) l = Ks(l);
          throw Error(o(418));
        }
        for (; c; ) EM(l, c), (c = Ks(c));
      }
    }
    if ((AM(l), l.tag === 13)) {
      if (!Me) throw Error(o(316));
      if (((l = l.memoizedState), (l = l !== null ? l.dehydrated : null), !l))
        throw Error(o(317));
      ji = O(l);
    } else ji = Wi ? Ks(l.stateNode) : null;
    return !0;
  }
  function vl() {
    Me && ((ji = Wi = null), (Ju = en = !1));
  }
  function Rv(l) {
    Ar === null ? (Ar = [l]) : Ar.push(l);
  }
  function tc(l, c, g) {
    if (
      ((l = g.ref),
      l !== null && typeof l != "function" && typeof l != "object")
    ) {
      if (g._owner) {
        if (((g = g._owner), g)) {
          if (g.tag !== 1) throw Error(o(309));
          var x = g.stateNode;
        }
        if (!x) throw Error(o(147, l));
        var E = x,
          A = "" + l;
        return c !== null &&
          c.ref !== null &&
          typeof c.ref == "function" &&
          c.ref._stringRef === A
          ? c.ref
          : ((c = function (F) {
              var q = E.refs;
              q === xM && (q = E.refs = {}),
                F === null ? delete q[A] : (q[A] = F);
            }),
            (c._stringRef = A),
            c);
      }
      if (typeof l != "string") throw Error(o(284));
      if (!g._owner) throw Error(o(290, l));
    }
    return l;
  }
  function jh(l, c) {
    throw (
      ((l = Object.prototype.toString.call(c)),
      Error(
        o(
          31,
          l === "[object Object]"
            ? "object with keys {" + Object.keys(c).join(", ") + "}"
            : l
        )
      ))
    );
  }
  function bM(l) {
    var c = l._init;
    return c(l._payload);
  }
  function CM(l) {
    function c(ne, K) {
      if (l) {
        var ue = ne.deletions;
        ue === null ? ((ne.deletions = [K]), (ne.flags |= 16)) : ue.push(K);
      }
    }
    function g(ne, K) {
      if (!l) return null;
      for (; K !== null; ) c(ne, K), (K = K.sibling);
      return null;
    }
    function x(ne, K) {
      for (ne = new Map(); K !== null; )
        K.key !== null ? ne.set(K.key, K) : ne.set(K.index, K), (K = K.sibling);
      return ne;
    }
    function E(ne, K) {
      return (ne = io(ne, K)), (ne.index = 0), (ne.sibling = null), ne;
    }
    function A(ne, K, ue) {
      return (
        (ne.index = ue),
        l
          ? ((ue = ne.alternate),
            ue !== null
              ? ((ue = ue.index), ue < K ? ((ne.flags |= 2), K) : ue)
              : ((ne.flags |= 2), K))
          : ((ne.flags |= 1048576), K)
      );
    }
    function F(ne) {
      return l && ne.alternate === null && (ne.flags |= 2), ne;
    }
    function q(ne, K, ue, Ue) {
      return K === null || K.tag !== 6
        ? ((K = d0(ue, ne.mode, Ue)), (K.return = ne), K)
        : ((K = E(K, ue)), (K.return = ne), K);
    }
    function fe(ne, K, ue, Ue) {
      var Qe = ue.type;
      return Qe === h
        ? Xe(ne, K, ue.props.children, Ue, ue.key)
        : K !== null &&
          (K.elementType === Qe ||
            (typeof Qe == "object" &&
              Qe !== null &&
              Qe.$$typeof === _ &&
              bM(Qe) === K.type))
        ? ((Ue = E(K, ue.props)),
          (Ue.ref = tc(ne, K, ue)),
          (Ue.return = ne),
          Ue)
        : ((Ue = Md(ue.type, ue.key, ue.props, null, ne.mode, Ue)),
          (Ue.ref = tc(ne, K, ue)),
          (Ue.return = ne),
          Ue);
    }
    function Ae(ne, K, ue, Ue) {
      return K === null ||
        K.tag !== 4 ||
        K.stateNode.containerInfo !== ue.containerInfo ||
        K.stateNode.implementation !== ue.implementation
        ? ((K = p0(ue, ne.mode, Ue)), (K.return = ne), K)
        : ((K = E(K, ue.children || [])), (K.return = ne), K);
    }
    function Xe(ne, K, ue, Ue, Qe) {
      return K === null || K.tag !== 7
        ? ((K = la(ue, ne.mode, Ue, Qe)), (K.return = ne), K)
        : ((K = E(K, ue)), (K.return = ne), K);
    }
    function yt(ne, K, ue) {
      if ((typeof K == "string" && K !== "") || typeof K == "number")
        return (K = d0("" + K, ne.mode, ue)), (K.return = ne), K;
      if (typeof K == "object" && K !== null) {
        switch (K.$$typeof) {
          case u:
            return (
              (ue = Md(K.type, K.key, K.props, null, ne.mode, ue)),
              (ue.ref = tc(ne, null, K)),
              (ue.return = ne),
              ue
            );
          case f:
            return (K = p0(K, ne.mode, ue)), (K.return = ne), K;
          case _:
            var Ue = K._init;
            return yt(ne, Ue(K._payload), ue);
        }
        if (Q(K) || b(K))
          return (K = la(K, ne.mode, ue, null)), (K.return = ne), K;
        jh(ne, K);
      }
      return null;
    }
    function ot(ne, K, ue, Ue) {
      var Qe = K !== null ? K.key : null;
      if ((typeof ue == "string" && ue !== "") || typeof ue == "number")
        return Qe !== null ? null : q(ne, K, "" + ue, Ue);
      if (typeof ue == "object" && ue !== null) {
        switch (ue.$$typeof) {
          case u:
            return ue.key === Qe ? fe(ne, K, ue, Ue) : null;
          case f:
            return ue.key === Qe ? Ae(ne, K, ue, Ue) : null;
          case _:
            return (Qe = ue._init), ot(ne, K, Qe(ue._payload), Ue);
        }
        if (Q(ue) || b(ue)) return Qe !== null ? null : Xe(ne, K, ue, Ue, null);
        jh(ne, ue);
      }
      return null;
    }
    function Wt(ne, K, ue, Ue, Qe) {
      if ((typeof Ue == "string" && Ue !== "") || typeof Ue == "number")
        return (ne = ne.get(ue) || null), q(K, ne, "" + Ue, Qe);
      if (typeof Ue == "object" && Ue !== null) {
        switch (Ue.$$typeof) {
          case u:
            return (
              (ne = ne.get(Ue.key === null ? ue : Ue.key) || null),
              fe(K, ne, Ue, Qe)
            );
          case f:
            return (
              (ne = ne.get(Ue.key === null ? ue : Ue.key) || null),
              Ae(K, ne, Ue, Qe)
            );
          case _:
            var wt = Ue._init;
            return Wt(ne, K, ue, wt(Ue._payload), Qe);
        }
        if (Q(Ue) || b(Ue))
          return (ne = ne.get(ue) || null), Xe(K, ne, Ue, Qe, null);
        jh(K, Ue);
      }
      return null;
    }
    function Je(ne, K, ue, Ue) {
      for (
        var Qe = null, wt = null, xt = K, Ut = (K = 0), Gn = null;
        xt !== null && Ut < ue.length;
        Ut++
      ) {
        xt.index > Ut ? ((Gn = xt), (xt = null)) : (Gn = xt.sibling);
        var kt = ot(ne, xt, ue[Ut], Ue);
        if (kt === null) {
          xt === null && (xt = Gn);
          break;
        }
        l && xt && kt.alternate === null && c(ne, xt),
          (K = A(kt, K, Ut)),
          wt === null ? (Qe = kt) : (wt.sibling = kt),
          (wt = kt),
          (xt = Gn);
      }
      if (Ut === ue.length) return g(ne, xt), en && ta(ne, Ut), Qe;
      if (xt === null) {
        for (; Ut < ue.length; Ut++)
          (xt = yt(ne, ue[Ut], Ue)),
            xt !== null &&
              ((K = A(xt, K, Ut)),
              wt === null ? (Qe = xt) : (wt.sibling = xt),
              (wt = xt));
        return en && ta(ne, Ut), Qe;
      }
      for (xt = x(ne, xt); Ut < ue.length; Ut++)
        (Gn = Wt(xt, ne, Ut, ue[Ut], Ue)),
          Gn !== null &&
            (l &&
              Gn.alternate !== null &&
              xt.delete(Gn.key === null ? Ut : Gn.key),
            (K = A(Gn, K, Ut)),
            wt === null ? (Qe = Gn) : (wt.sibling = Gn),
            (wt = Gn));
      return (
        l &&
          xt.forEach(function (ro) {
            return c(ne, ro);
          }),
        en && ta(ne, Ut),
        Qe
      );
    }
    function ii(ne, K, ue, Ue) {
      var Qe = b(ue);
      if (typeof Qe != "function") throw Error(o(150));
      if (((ue = Qe.call(ue)), ue == null)) throw Error(o(151));
      for (
        var wt = (Qe = null), xt = K, Ut = (K = 0), Gn = null, kt = ue.next();
        xt !== null && !kt.done;
        Ut++, kt = ue.next()
      ) {
        xt.index > Ut ? ((Gn = xt), (xt = null)) : (Gn = xt.sibling);
        var ro = ot(ne, xt, kt.value, Ue);
        if (ro === null) {
          xt === null && (xt = Gn);
          break;
        }
        l && xt && ro.alternate === null && c(ne, xt),
          (K = A(ro, K, Ut)),
          wt === null ? (Qe = ro) : (wt.sibling = ro),
          (wt = ro),
          (xt = Gn);
      }
      if (kt.done) return g(ne, xt), en && ta(ne, Ut), Qe;
      if (xt === null) {
        for (; !kt.done; Ut++, kt = ue.next())
          (kt = yt(ne, kt.value, Ue)),
            kt !== null &&
              ((K = A(kt, K, Ut)),
              wt === null ? (Qe = kt) : (wt.sibling = kt),
              (wt = kt));
        return en && ta(ne, Ut), Qe;
      }
      for (xt = x(ne, xt); !kt.done; Ut++, kt = ue.next())
        (kt = Wt(xt, ne, Ut, kt.value, Ue)),
          kt !== null &&
            (l &&
              kt.alternate !== null &&
              xt.delete(kt.key === null ? Ut : kt.key),
            (K = A(kt, K, Ut)),
            wt === null ? (Qe = kt) : (wt.sibling = kt),
            (wt = kt));
      return (
        l &&
          xt.forEach(function (HN) {
            return c(ne, HN);
          }),
        en && ta(ne, Ut),
        Qe
      );
    }
    function mr(ne, K, ue, Ue) {
      if (
        (typeof ue == "object" &&
          ue !== null &&
          ue.type === h &&
          ue.key === null &&
          (ue = ue.props.children),
        typeof ue == "object" && ue !== null)
      ) {
        switch (ue.$$typeof) {
          case u:
            e: {
              for (var Qe = ue.key, wt = K; wt !== null; ) {
                if (wt.key === Qe) {
                  if (((Qe = ue.type), Qe === h)) {
                    if (wt.tag === 7) {
                      g(ne, wt.sibling),
                        (K = E(wt, ue.props.children)),
                        (K.return = ne),
                        (ne = K);
                      break e;
                    }
                  } else if (
                    wt.elementType === Qe ||
                    (typeof Qe == "object" &&
                      Qe !== null &&
                      Qe.$$typeof === _ &&
                      bM(Qe) === wt.type)
                  ) {
                    g(ne, wt.sibling),
                      (K = E(wt, ue.props)),
                      (K.ref = tc(ne, wt, ue)),
                      (K.return = ne),
                      (ne = K);
                    break e;
                  }
                  g(ne, wt);
                  break;
                } else c(ne, wt);
                wt = wt.sibling;
              }
              ue.type === h
                ? ((K = la(ue.props.children, ne.mode, Ue, ue.key)),
                  (K.return = ne),
                  (ne = K))
                : ((Ue = Md(ue.type, ue.key, ue.props, null, ne.mode, Ue)),
                  (Ue.ref = tc(ne, K, ue)),
                  (Ue.return = ne),
                  (ne = Ue));
            }
            return F(ne);
          case f:
            e: {
              for (wt = ue.key; K !== null; ) {
                if (K.key === wt)
                  if (
                    K.tag === 4 &&
                    K.stateNode.containerInfo === ue.containerInfo &&
                    K.stateNode.implementation === ue.implementation
                  ) {
                    g(ne, K.sibling),
                      (K = E(K, ue.children || [])),
                      (K.return = ne),
                      (ne = K);
                    break e;
                  } else {
                    g(ne, K);
                    break;
                  }
                else c(ne, K);
                K = K.sibling;
              }
              (K = p0(ue, ne.mode, Ue)), (K.return = ne), (ne = K);
            }
            return F(ne);
          case _:
            return (wt = ue._init), mr(ne, K, wt(ue._payload), Ue);
        }
        if (Q(ue)) return Je(ne, K, ue, Ue);
        if (b(ue)) return ii(ne, K, ue, Ue);
        jh(ne, ue);
      }
      return (typeof ue == "string" && ue !== "") || typeof ue == "number"
        ? ((ue = "" + ue),
          K !== null && K.tag === 6
            ? (g(ne, K.sibling), (K = E(K, ue)), (K.return = ne), (ne = K))
            : (g(ne, K), (K = d0(ue, ne.mode, Ue)), (K.return = ne), (ne = K)),
          F(ne))
        : g(ne, K);
    }
    return mr;
  }
  var yl = CM(!0),
    PM = CM(!1),
    nc = {},
    fr = zn(nc),
    ic = zn(nc),
    xl = zn(nc);
  function Qr(l) {
    if (l === nc) throw Error(o(174));
    return l;
  }
  function Lv(l, c) {
    je(xl, c), je(ic, l), je(fr, nc), (l = ce(c)), ct(fr), je(fr, l);
  }
  function _l() {
    ct(fr), ct(ic), ct(xl);
  }
  function RM(l) {
    var c = Qr(xl.current),
      g = Qr(fr.current);
    (c = k(g, l.type, c)), g !== c && (je(ic, l), je(fr, c));
  }
  function Iv(l) {
    ic.current === l && (ct(fr), ct(ic));
  }
  var sn = zn(0);
  function Xh(l) {
    for (var c = l; c !== null; ) {
      if (c.tag === 13) {
        var g = c.memoizedState;
        if (g !== null && ((g = g.dehydrated), g === null || Zu(g) || Ku(g)))
          return c;
      } else if (c.tag === 19 && c.memoizedProps.revealOrder !== void 0) {
        if (c.flags & 128) return c;
      } else if (c.child !== null) {
        (c.child.return = c), (c = c.child);
        continue;
      }
      if (c === l) break;
      for (; c.sibling === null; ) {
        if (c.return === null || c.return === l) return null;
        c = c.return;
      }
      (c.sibling.return = c.return), (c = c.sibling);
    }
    return null;
  }
  var Nv = [];
  function Dv() {
    for (var l = 0; l < Nv.length; l++) {
      var c = Nv[l];
      Ve
        ? (c._workInProgressVersionPrimary = null)
        : (c._workInProgressVersionSecondary = null);
    }
    Nv.length = 0;
  }
  var Yh = a.ReactCurrentDispatcher,
    hr = a.ReactCurrentBatchConfig,
    Sl = 0,
    pn = null,
    ei = null,
    Hn = null,
    qh = !1,
    rc = !1,
    sc = 0,
    dN = 0;
  function ti() {
    throw Error(o(321));
  }
  function Ov(l, c) {
    if (c === null) return !1;
    for (var g = 0; g < c.length && g < l.length; g++)
      if (!qr(l[g], c[g])) return !1;
    return !0;
  }
  function Uv(l, c, g, x, E, A) {
    if (
      ((Sl = A),
      (pn = c),
      (c.memoizedState = null),
      (c.updateQueue = null),
      (c.lanes = 0),
      (Yh.current = l === null || l.memoizedState === null ? vN : yN),
      (l = g(x, E)),
      rc)
    ) {
      A = 0;
      do {
        if (((rc = !1), (sc = 0), 25 <= A)) throw Error(o(301));
        (A += 1),
          (Hn = ei = null),
          (c.updateQueue = null),
          (Yh.current = xN),
          (l = g(x, E));
      } while (rc);
    }
    if (
      ((Yh.current = Jh),
      (c = ei !== null && ei.next !== null),
      (Sl = 0),
      (Hn = ei = pn = null),
      (qh = !1),
      c)
    )
      throw Error(o(300));
    return l;
  }
  function kv() {
    var l = sc !== 0;
    return (sc = 0), l;
  }
  function xs() {
    var l = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null,
    };
    return Hn === null ? (pn.memoizedState = Hn = l) : (Hn = Hn.next = l), Hn;
  }
  function $r() {
    if (ei === null) {
      var l = pn.alternate;
      l = l !== null ? l.memoizedState : null;
    } else l = ei.next;
    var c = Hn === null ? pn.memoizedState : Hn.next;
    if (c !== null) (Hn = c), (ei = l);
    else {
      if (l === null) throw Error(o(310));
      (ei = l),
        (l = {
          memoizedState: ei.memoizedState,
          baseState: ei.baseState,
          baseQueue: ei.baseQueue,
          queue: ei.queue,
          next: null,
        }),
        Hn === null ? (pn.memoizedState = Hn = l) : (Hn = Hn.next = l);
    }
    return Hn;
  }
  function na(l, c) {
    return typeof c == "function" ? c(l) : c;
  }
  function Zh(l) {
    var c = $r(),
      g = c.queue;
    if (g === null) throw Error(o(311));
    g.lastRenderedReducer = l;
    var x = ei,
      E = x.baseQueue,
      A = g.pending;
    if (A !== null) {
      if (E !== null) {
        var F = E.next;
        (E.next = A.next), (A.next = F);
      }
      (x.baseQueue = E = A), (g.pending = null);
    }
    if (E !== null) {
      (A = E.next), (x = x.baseState);
      var q = (F = null),
        fe = null,
        Ae = A;
      do {
        var Xe = Ae.lane;
        if ((Sl & Xe) === Xe)
          fe !== null &&
            (fe = fe.next =
              {
                lane: 0,
                action: Ae.action,
                hasEagerState: Ae.hasEagerState,
                eagerState: Ae.eagerState,
                next: null,
              }),
            (x = Ae.hasEagerState ? Ae.eagerState : l(x, Ae.action));
        else {
          var yt = {
            lane: Xe,
            action: Ae.action,
            hasEagerState: Ae.hasEagerState,
            eagerState: Ae.eagerState,
            next: null,
          };
          fe === null ? ((q = fe = yt), (F = x)) : (fe = fe.next = yt),
            (pn.lanes |= Xe),
            (wl |= Xe);
        }
        Ae = Ae.next;
      } while (Ae !== null && Ae !== A);
      fe === null ? (F = x) : (fe.next = q),
        qr(x, c.memoizedState) || (Xi = !0),
        (c.memoizedState = x),
        (c.baseState = F),
        (c.baseQueue = fe),
        (g.lastRenderedState = x);
    }
    if (((l = g.interleaved), l !== null)) {
      E = l;
      do (A = E.lane), (pn.lanes |= A), (wl |= A), (E = E.next);
      while (E !== l);
    } else E === null && (g.lanes = 0);
    return [c.memoizedState, g.dispatch];
  }
  function Kh(l) {
    var c = $r(),
      g = c.queue;
    if (g === null) throw Error(o(311));
    g.lastRenderedReducer = l;
    var x = g.dispatch,
      E = g.pending,
      A = c.memoizedState;
    if (E !== null) {
      g.pending = null;
      var F = (E = E.next);
      do (A = l(A, F.action)), (F = F.next);
      while (F !== E);
      qr(A, c.memoizedState) || (Xi = !0),
        (c.memoizedState = A),
        c.baseQueue === null && (c.baseState = A),
        (g.lastRenderedState = A);
    }
    return [A, x];
  }
  function LM() {}
  function IM(l, c) {
    var g = pn,
      x = $r(),
      E = c(),
      A = !qr(x.memoizedState, E);
    if (
      (A && ((x.memoizedState = E), (Xi = !0)),
      (x = x.queue),
      ac(OM.bind(null, g, x, l), [l]),
      x.getSnapshot !== c || A || (Hn !== null && Hn.memoizedState.tag & 1))
    ) {
      if (
        ((g.flags |= 2048),
        oc(9, DM.bind(null, g, x, E, c), void 0, null),
        bn === null)
      )
        throw Error(o(349));
      Sl & 30 || NM(g, c, E);
    }
    return E;
  }
  function NM(l, c, g) {
    (l.flags |= 16384),
      (l = { getSnapshot: c, value: g }),
      (c = pn.updateQueue),
      c === null
        ? ((c = { lastEffect: null, stores: null }),
          (pn.updateQueue = c),
          (c.stores = [l]))
        : ((g = c.stores), g === null ? (c.stores = [l]) : g.push(l));
  }
  function DM(l, c, g, x) {
    (c.value = g), (c.getSnapshot = x), UM(c) && dr(l, 1, -1);
  }
  function OM(l, c, g) {
    return g(function () {
      UM(c) && dr(l, 1, -1);
    });
  }
  function UM(l) {
    var c = l.getSnapshot;
    l = l.value;
    try {
      var g = c();
      return !qr(l, g);
    } catch {
      return !0;
    }
  }
  function Fv(l) {
    var c = xs();
    return (
      typeof l == "function" && (l = l()),
      (c.memoizedState = c.baseState = l),
      (l = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: na,
        lastRenderedState: l,
      }),
      (c.queue = l),
      (l = l.dispatch = gN.bind(null, pn, l)),
      [c.memoizedState, l]
    );
  }
  function oc(l, c, g, x) {
    return (
      (l = { tag: l, create: c, destroy: g, deps: x, next: null }),
      (c = pn.updateQueue),
      c === null
        ? ((c = { lastEffect: null, stores: null }),
          (pn.updateQueue = c),
          (c.lastEffect = l.next = l))
        : ((g = c.lastEffect),
          g === null
            ? (c.lastEffect = l.next = l)
            : ((x = g.next), (g.next = l), (l.next = x), (c.lastEffect = l))),
      l
    );
  }
  function kM() {
    return $r().memoizedState;
  }
  function Qh(l, c, g, x) {
    var E = xs();
    (pn.flags |= l),
      (E.memoizedState = oc(1 | c, g, void 0, x === void 0 ? null : x));
  }
  function $h(l, c, g, x) {
    var E = $r();
    x = x === void 0 ? null : x;
    var A = void 0;
    if (ei !== null) {
      var F = ei.memoizedState;
      if (((A = F.destroy), x !== null && Ov(x, F.deps))) {
        E.memoizedState = oc(c, g, A, x);
        return;
      }
    }
    (pn.flags |= l), (E.memoizedState = oc(1 | c, g, A, x));
  }
  function zv(l, c) {
    return Qh(8390656, 8, l, c);
  }
  function ac(l, c) {
    return $h(2048, 8, l, c);
  }
  function FM(l, c) {
    return $h(4, 2, l, c);
  }
  function zM(l, c) {
    return $h(4, 4, l, c);
  }
  function BM(l, c) {
    if (typeof c == "function")
      return (
        (l = l()),
        c(l),
        function () {
          c(null);
        }
      );
    if (c != null)
      return (
        (l = l()),
        (c.current = l),
        function () {
          c.current = null;
        }
      );
  }
  function VM(l, c, g) {
    return (
      (g = g != null ? g.concat([l]) : null), $h(4, 4, BM.bind(null, c, l), g)
    );
  }
  function Bv() {}
  function HM(l, c) {
    var g = $r();
    c = c === void 0 ? null : c;
    var x = g.memoizedState;
    return x !== null && c !== null && Ov(c, x[1])
      ? x[0]
      : ((g.memoizedState = [l, c]), l);
  }
  function GM(l, c) {
    var g = $r();
    c = c === void 0 ? null : c;
    var x = g.memoizedState;
    return x !== null && c !== null && Ov(c, x[1])
      ? x[0]
      : ((l = l()), (g.memoizedState = [l, c]), l);
  }
  function pN(l, c) {
    var g = Ot;
    (Ot = g !== 0 && 4 > g ? g : 4), l(!0);
    var x = hr.transition;
    hr.transition = {};
    try {
      l(!1), c();
    } finally {
      (Ot = g), (hr.transition = x);
    }
  }
  function WM() {
    return $r().memoizedState;
  }
  function mN(l, c, g) {
    var x = to(l);
    (g = {
      lane: x,
      action: g,
      hasEagerState: !1,
      eagerState: null,
      next: null,
    }),
      jM(l)
        ? XM(c, g)
        : (YM(l, c, g),
          (g = yi()),
          (l = dr(l, x, g)),
          l !== null && qM(l, c, x));
  }
  function gN(l, c, g) {
    var x = to(l),
      E = {
        lane: x,
        action: g,
        hasEagerState: !1,
        eagerState: null,
        next: null,
      };
    if (jM(l)) XM(c, E);
    else {
      YM(l, c, E);
      var A = l.alternate;
      if (
        l.lanes === 0 &&
        (A === null || A.lanes === 0) &&
        ((A = c.lastRenderedReducer), A !== null)
      )
        try {
          var F = c.lastRenderedState,
            q = A(F, g);
          if (((E.hasEagerState = !0), (E.eagerState = q), qr(q, F))) return;
        } catch {
        } finally {
        }
      (g = yi()), (l = dr(l, x, g)), l !== null && qM(l, c, x);
    }
  }
  function jM(l) {
    var c = l.alternate;
    return l === pn || (c !== null && c === pn);
  }
  function XM(l, c) {
    rc = qh = !0;
    var g = l.pending;
    g === null ? (c.next = c) : ((c.next = g.next), (g.next = c)),
      (l.pending = c);
  }
  function YM(l, c, g) {
    bn !== null && l.mode & 1 && !(bt & 2)
      ? ((l = c.interleaved),
        l === null
          ? ((g.next = g), Kr === null ? (Kr = [c]) : Kr.push(c))
          : ((g.next = l.next), (l.next = g)),
        (c.interleaved = g))
      : ((l = c.pending),
        l === null ? (g.next = g) : ((g.next = l.next), (l.next = g)),
        (c.pending = g));
  }
  function qM(l, c, g) {
    if (g & 4194240) {
      var x = c.lanes;
      (x &= l.pendingLanes), (g |= x), (c.lanes = g), pv(l, g);
    }
  }
  var Jh = {
      readContext: lr,
      useCallback: ti,
      useContext: ti,
      useEffect: ti,
      useImperativeHandle: ti,
      useInsertionEffect: ti,
      useLayoutEffect: ti,
      useMemo: ti,
      useReducer: ti,
      useRef: ti,
      useState: ti,
      useDebugValue: ti,
      useDeferredValue: ti,
      useTransition: ti,
      useMutableSource: ti,
      useSyncExternalStore: ti,
      useId: ti,
      unstable_isNewReconciler: !1,
    },
    vN = {
      readContext: lr,
      useCallback: function (l, c) {
        return (xs().memoizedState = [l, c === void 0 ? null : c]), l;
      },
      useContext: lr,
      useEffect: zv,
      useImperativeHandle: function (l, c, g) {
        return (
          (g = g != null ? g.concat([l]) : null),
          Qh(4194308, 4, BM.bind(null, c, l), g)
        );
      },
      useLayoutEffect: function (l, c) {
        return Qh(4194308, 4, l, c);
      },
      useInsertionEffect: function (l, c) {
        return Qh(4, 2, l, c);
      },
      useMemo: function (l, c) {
        var g = xs();
        return (
          (c = c === void 0 ? null : c),
          (l = l()),
          (g.memoizedState = [l, c]),
          l
        );
      },
      useReducer: function (l, c, g) {
        var x = xs();
        return (
          (c = g !== void 0 ? g(c) : c),
          (x.memoizedState = x.baseState = c),
          (l = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: l,
            lastRenderedState: c,
          }),
          (x.queue = l),
          (l = l.dispatch = mN.bind(null, pn, l)),
          [x.memoizedState, l]
        );
      },
      useRef: function (l) {
        var c = xs();
        return (l = { current: l }), (c.memoizedState = l);
      },
      useState: Fv,
      useDebugValue: Bv,
      useDeferredValue: function (l) {
        var c = Fv(l),
          g = c[0],
          x = c[1];
        return (
          zv(
            function () {
              var E = hr.transition;
              hr.transition = {};
              try {
                x(l);
              } finally {
                hr.transition = E;
              }
            },
            [l]
          ),
          g
        );
      },
      useTransition: function () {
        var l = Fv(!1),
          c = l[0];
        return (l = pN.bind(null, l[1])), (xs().memoizedState = l), [c, l];
      },
      useMutableSource: function () {},
      useSyncExternalStore: function (l, c, g) {
        var x = pn,
          E = xs();
        if (en) {
          if (g === void 0) throw Error(o(407));
          g = g();
        } else {
          if (((g = c()), bn === null)) throw Error(o(349));
          Sl & 30 || NM(x, c, g);
        }
        E.memoizedState = g;
        var A = { value: g, getSnapshot: c };
        return (
          (E.queue = A),
          zv(OM.bind(null, x, A, l), [l]),
          (x.flags |= 2048),
          oc(9, DM.bind(null, x, A, g, c), void 0, null),
          g
        );
      },
      useId: function () {
        var l = xs(),
          c = bn.identifierPrefix;
        if (en) {
          var g = ys,
            x = vs;
          (g = (x & ~(1 << (32 - Gi(x) - 1))).toString(32) + g),
            (c = ":" + c + "R" + g),
            (g = sc++),
            0 < g && (c += "H" + g.toString(32)),
            (c += ":");
        } else (g = dN++), (c = ":" + c + "r" + g.toString(32) + ":");
        return (l.memoizedState = c);
      },
      unstable_isNewReconciler: !1,
    },
    yN = {
      readContext: lr,
      useCallback: HM,
      useContext: lr,
      useEffect: ac,
      useImperativeHandle: VM,
      useInsertionEffect: FM,
      useLayoutEffect: zM,
      useMemo: GM,
      useReducer: Zh,
      useRef: kM,
      useState: function () {
        return Zh(na);
      },
      useDebugValue: Bv,
      useDeferredValue: function (l) {
        var c = Zh(na),
          g = c[0],
          x = c[1];
        return (
          ac(
            function () {
              var E = hr.transition;
              hr.transition = {};
              try {
                x(l);
              } finally {
                hr.transition = E;
              }
            },
            [l]
          ),
          g
        );
      },
      useTransition: function () {
        var l = Zh(na)[0],
          c = $r().memoizedState;
        return [l, c];
      },
      useMutableSource: LM,
      useSyncExternalStore: IM,
      useId: WM,
      unstable_isNewReconciler: !1,
    },
    xN = {
      readContext: lr,
      useCallback: HM,
      useContext: lr,
      useEffect: ac,
      useImperativeHandle: VM,
      useInsertionEffect: FM,
      useLayoutEffect: zM,
      useMemo: GM,
      useReducer: Kh,
      useRef: kM,
      useState: function () {
        return Kh(na);
      },
      useDebugValue: Bv,
      useDeferredValue: function (l) {
        var c = Kh(na),
          g = c[0],
          x = c[1];
        return (
          ac(
            function () {
              var E = hr.transition;
              hr.transition = {};
              try {
                x(l);
              } finally {
                hr.transition = E;
              }
            },
            [l]
          ),
          g
        );
      },
      useTransition: function () {
        var l = Kh(na)[0],
          c = $r().memoizedState;
        return [l, c];
      },
      useMutableSource: LM,
      useSyncExternalStore: IM,
      useId: WM,
      unstable_isNewReconciler: !1,
    };
  function Vv(l, c) {
    try {
      var g = "",
        x = c;
      do (g += hN(x)), (x = x.return);
      while (x);
      var E = g;
    } catch (A) {
      E =
        `
Error generating stack: ` +
        A.message +
        `
` +
        A.stack;
    }
    return { value: l, source: c, stack: E };
  }
  function Hv(l, c) {
    try {
      console.error(c.value);
    } catch (g) {
      setTimeout(function () {
        throw g;
      });
    }
  }
  var _N = typeof WeakMap == "function" ? WeakMap : Map;
  function ZM(l, c, g) {
    (g = gs(-1, g)), (g.tag = 3), (g.payload = { element: null });
    var x = c.value;
    return (
      (g.callback = function () {
        md || ((md = !0), (o0 = x)), Hv(l, c);
      }),
      g
    );
  }
  function KM(l, c, g) {
    (g = gs(-1, g)), (g.tag = 3);
    var x = l.type.getDerivedStateFromError;
    if (typeof x == "function") {
      var E = c.value;
      (g.payload = function () {
        return x(E);
      }),
        (g.callback = function () {
          Hv(l, c);
        });
    }
    var A = l.stateNode;
    return (
      A !== null &&
        typeof A.componentDidCatch == "function" &&
        (g.callback = function () {
          Hv(l, c),
            typeof x != "function" &&
              (Js === null ? (Js = new Set([this])) : Js.add(this));
          var F = c.stack;
          this.componentDidCatch(c.value, {
            componentStack: F !== null ? F : "",
          });
        }),
      g
    );
  }
  function QM(l, c, g) {
    var x = l.pingCache;
    if (x === null) {
      x = l.pingCache = new _N();
      var E = new Set();
      x.set(c, E);
    } else (E = x.get(c)), E === void 0 && ((E = new Set()), x.set(c, E));
    E.has(g) || (E.add(g), (l = DN.bind(null, l, c, g)), c.then(l, l));
  }
  function $M(l) {
    do {
      var c;
      if (
        ((c = l.tag === 13) &&
          ((c = l.memoizedState),
          (c = c !== null ? c.dehydrated !== null : !0)),
        c)
      )
        return l;
      l = l.return;
    } while (l !== null);
    return null;
  }
  function JM(l, c, g, x, E) {
    return l.mode & 1
      ? ((l.flags |= 65536), (l.lanes = E), l)
      : (l === c
          ? (l.flags |= 65536)
          : ((l.flags |= 128),
            (g.flags |= 131072),
            (g.flags &= -52805),
            g.tag === 1 &&
              (g.alternate === null
                ? (g.tag = 17)
                : ((c = gs(-1, 1)), (c.tag = 2), $s(g, c))),
            (g.lanes |= 1)),
        l);
  }
  function Jr(l) {
    l.flags |= 4;
  }
  function ew(l, c) {
    if (l !== null && l.child === c.child) return !0;
    if (c.flags & 16) return !1;
    for (l = c.child; l !== null; ) {
      if (l.flags & 12854 || l.subtreeFlags & 12854) return !1;
      l = l.sibling;
    }
    return !0;
  }
  var lc, uc, ed, td;
  if (We)
    (lc = function (l, c) {
      for (var g = c.child; g !== null; ) {
        if (g.tag === 5 || g.tag === 6) ie(l, g.stateNode);
        else if (g.tag !== 4 && g.child !== null) {
          (g.child.return = g), (g = g.child);
          continue;
        }
        if (g === c) break;
        for (; g.sibling === null; ) {
          if (g.return === null || g.return === c) return;
          g = g.return;
        }
        (g.sibling.return = g.return), (g = g.sibling);
      }
    }),
      (uc = function () {}),
      (ed = function (l, c, g, x, E) {
        if (((l = l.memoizedProps), l !== x)) {
          var A = c.stateNode,
            F = Qr(fr.current);
          (g = he(A, g, l, x, E, F)), (c.updateQueue = g) && Jr(c);
        }
      }),
      (td = function (l, c, g, x) {
        g !== x && Jr(c);
      });
  else if (H) {
    lc = function (l, c, g, x) {
      for (var E = c.child; E !== null; ) {
        if (E.tag === 5) {
          var A = E.stateNode;
          g && x && (A = Gt(A, E.type, E.memoizedProps, E)), ie(l, A);
        } else if (E.tag === 6)
          (A = E.stateNode),
            g && x && (A = Jt(A, E.memoizedProps, E)),
            ie(l, A);
        else if (E.tag !== 4) {
          if (E.tag === 22 && E.memoizedState !== null)
            (A = E.child), A !== null && (A.return = E), lc(l, E, !0, !0);
          else if (E.child !== null) {
            (E.child.return = E), (E = E.child);
            continue;
          }
        }
        if (E === c) break;
        for (; E.sibling === null; ) {
          if (E.return === null || E.return === c) return;
          E = E.return;
        }
        (E.sibling.return = E.return), (E = E.sibling);
      }
    };
    var tw = function (l, c, g, x) {
      for (var E = c.child; E !== null; ) {
        if (E.tag === 5) {
          var A = E.stateNode;
          g && x && (A = Gt(A, E.type, E.memoizedProps, E)), qe(l, A);
        } else if (E.tag === 6)
          (A = E.stateNode),
            g && x && (A = Jt(A, E.memoizedProps, E)),
            qe(l, A);
        else if (E.tag !== 4) {
          if (E.tag === 22 && E.memoizedState !== null)
            (A = E.child), A !== null && (A.return = E), tw(l, E, !0, !0);
          else if (E.child !== null) {
            (E.child.return = E), (E = E.child);
            continue;
          }
        }
        if (E === c) break;
        for (; E.sibling === null; ) {
          if (E.return === null || E.return === c) return;
          E = E.return;
        }
        (E.sibling.return = E.return), (E = E.sibling);
      }
    };
    (uc = function (l, c) {
      var g = c.stateNode;
      if (!ew(l, c)) {
        l = g.containerInfo;
        var x = st(l);
        tw(x, c, !1, !1), (g.pendingChildren = x), Jr(c), Ct(l, x);
      }
    }),
      (ed = function (l, c, g, x, E) {
        var A = l.stateNode,
          F = l.memoizedProps;
        if ((l = ew(l, c)) && F === x) c.stateNode = A;
        else {
          var q = c.stateNode,
            fe = Qr(fr.current),
            Ae = null;
          F !== x && (Ae = he(q, g, F, x, E, fe)),
            l && Ae === null
              ? (c.stateNode = A)
              : ((A = Ie(A, Ae, g, F, x, c, l, q)),
                J(A, g, x, E, fe) && Jr(c),
                (c.stateNode = A),
                l ? Jr(c) : lc(A, c, !1, !1));
        }
      }),
      (td = function (l, c, g, x) {
        g !== x
          ? ((l = Qr(xl.current)),
            (g = Qr(fr.current)),
            (c.stateNode = be(x, l, g, c)),
            Jr(c))
          : (c.stateNode = l.stateNode);
      });
  } else (uc = function () {}), (ed = function () {}), (td = function () {});
  function cc(l, c) {
    if (!en)
      switch (l.tailMode) {
        case "hidden":
          c = l.tail;
          for (var g = null; c !== null; )
            c.alternate !== null && (g = c), (c = c.sibling);
          g === null ? (l.tail = null) : (g.sibling = null);
          break;
        case "collapsed":
          g = l.tail;
          for (var x = null; g !== null; )
            g.alternate !== null && (x = g), (g = g.sibling);
          x === null
            ? c || l.tail === null
              ? (l.tail = null)
              : (l.tail.sibling = null)
            : (x.sibling = null);
      }
  }
  function ni(l) {
    var c = l.alternate !== null && l.alternate.child === l.child,
      g = 0,
      x = 0;
    if (c)
      for (var E = l.child; E !== null; )
        (g |= E.lanes | E.childLanes),
          (x |= E.subtreeFlags & 14680064),
          (x |= E.flags & 14680064),
          (E.return = l),
          (E = E.sibling);
    else
      for (E = l.child; E !== null; )
        (g |= E.lanes | E.childLanes),
          (x |= E.subtreeFlags),
          (x |= E.flags),
          (E.return = l),
          (E = E.sibling);
    return (l.subtreeFlags |= x), (l.childLanes = g), c;
  }
  function SN(l, c, g) {
    var x = c.pendingProps;
    switch ((bv(c), c.tag)) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return ni(c), null;
      case 1:
        return Bn(c.type) && yn(), ni(c), null;
      case 3:
        return (
          (x = c.stateNode),
          _l(),
          ct(dn),
          ct(At),
          Dv(),
          x.pendingContext &&
            ((x.context = x.pendingContext), (x.pendingContext = null)),
          (l === null || l.child === null) &&
            (ec(c)
              ? Jr(c)
              : l === null ||
                (l.memoizedState.isDehydrated && !(c.flags & 256)) ||
                ((c.flags |= 1024), Ar !== null && (u0(Ar), (Ar = null)))),
          uc(l, c),
          ni(c),
          null
        );
      case 5:
        Iv(c), (g = Qr(xl.current));
        var E = c.type;
        if (l !== null && c.stateNode != null)
          ed(l, c, E, x, g),
            l.ref !== c.ref && ((c.flags |= 512), (c.flags |= 2097152));
        else {
          if (!x) {
            if (c.stateNode === null) throw Error(o(166));
            return ni(c), null;
          }
          if (((l = Qr(fr.current)), ec(c))) {
            if (!Me) throw Error(o(175));
            (l = uv(c.stateNode, c.type, c.memoizedProps, g, l, c, !Ju)),
              (c.updateQueue = l),
              l !== null && Jr(c);
          } else {
            var A = Y(E, x, g, l, c);
            lc(A, c, !1, !1), (c.stateNode = A), J(A, E, x, g, l) && Jr(c);
          }
          c.ref !== null && ((c.flags |= 512), (c.flags |= 2097152));
        }
        return ni(c), null;
      case 6:
        if (l && c.stateNode != null) td(l, c, l.memoizedProps, x);
        else {
          if (typeof x != "string" && c.stateNode === null) throw Error(o(166));
          if (((l = Qr(xl.current)), (g = Qr(fr.current)), ec(c))) {
            if (!Me) throw Error(o(176));
            if (
              ((l = c.stateNode),
              (x = c.memoizedProps),
              (g = cv(l, x, c, !Ju)) && ((E = Wi), E !== null))
            )
              switch (((A = (E.mode & 1) !== 0), E.tag)) {
                case 3:
                  $e(E.stateNode.containerInfo, l, x, A);
                  break;
                case 5:
                  lt(E.type, E.memoizedProps, E.stateNode, l, x, A);
              }
            g && Jr(c);
          } else c.stateNode = be(x, l, g, c);
        }
        return ni(c), null;
      case 13:
        if (
          (ct(sn),
          (x = c.memoizedState),
          en && ji !== null && c.mode & 1 && !(c.flags & 128))
        ) {
          for (l = ji; l; ) l = Ks(l);
          return vl(), (c.flags |= 98560), c;
        }
        if (x !== null && x.dehydrated !== null) {
          if (((x = ec(c)), l === null)) {
            if (!x) throw Error(o(318));
            if (!Me) throw Error(o(344));
            if (
              ((l = c.memoizedState),
              (l = l !== null ? l.dehydrated : null),
              !l)
            )
              throw Error(o(317));
            fv(l, c);
          } else
            vl(), !(c.flags & 128) && (c.memoizedState = null), (c.flags |= 4);
          return ni(c), null;
        }
        return (
          Ar !== null && (u0(Ar), (Ar = null)),
          c.flags & 128
            ? ((c.lanes = g), c)
            : ((x = x !== null),
              (g = !1),
              l === null ? ec(c) : (g = l.memoizedState !== null),
              x &&
                !g &&
                ((c.child.flags |= 8192),
                c.mode & 1 &&
                  (l === null || sn.current & 1 ? In === 0 && (In = 3) : f0())),
              c.updateQueue !== null && (c.flags |= 4),
              ni(c),
              null)
        );
      case 4:
        return (
          _l(),
          uc(l, c),
          l === null && Te(c.stateNode.containerInfo),
          ni(c),
          null
        );
      case 10:
        return Sv(c.type._context), ni(c), null;
      case 17:
        return Bn(c.type) && yn(), ni(c), null;
      case 19:
        if ((ct(sn), (E = c.memoizedState), E === null)) return ni(c), null;
        if (((x = (c.flags & 128) !== 0), (A = E.rendering), A === null))
          if (x) cc(E, !1);
          else {
            if (In !== 0 || (l !== null && l.flags & 128))
              for (l = c.child; l !== null; ) {
                if (((A = Xh(l)), A !== null)) {
                  for (
                    c.flags |= 128,
                      cc(E, !1),
                      l = A.updateQueue,
                      l !== null && ((c.updateQueue = l), (c.flags |= 4)),
                      c.subtreeFlags = 0,
                      l = g,
                      x = c.child;
                    x !== null;

                  )
                    (g = x),
                      (E = l),
                      (g.flags &= 14680066),
                      (A = g.alternate),
                      A === null
                        ? ((g.childLanes = 0),
                          (g.lanes = E),
                          (g.child = null),
                          (g.subtreeFlags = 0),
                          (g.memoizedProps = null),
                          (g.memoizedState = null),
                          (g.updateQueue = null),
                          (g.dependencies = null),
                          (g.stateNode = null))
                        : ((g.childLanes = A.childLanes),
                          (g.lanes = A.lanes),
                          (g.child = A.child),
                          (g.subtreeFlags = 0),
                          (g.deletions = null),
                          (g.memoizedProps = A.memoizedProps),
                          (g.memoizedState = A.memoizedState),
                          (g.updateQueue = A.updateQueue),
                          (g.type = A.type),
                          (E = A.dependencies),
                          (g.dependencies =
                            E === null
                              ? null
                              : {
                                  lanes: E.lanes,
                                  firstContext: E.firstContext,
                                })),
                      (x = x.sibling);
                  return je(sn, (sn.current & 1) | 2), c.child;
                }
                l = l.sibling;
              }
            E.tail !== null &&
              Vn() > s0 &&
              ((c.flags |= 128), (x = !0), cc(E, !1), (c.lanes = 4194304));
          }
        else {
          if (!x)
            if (((l = Xh(A)), l !== null)) {
              if (
                ((c.flags |= 128),
                (x = !0),
                (l = l.updateQueue),
                l !== null && ((c.updateQueue = l), (c.flags |= 4)),
                cc(E, !0),
                E.tail === null &&
                  E.tailMode === "hidden" &&
                  !A.alternate &&
                  !en)
              )
                return ni(c), null;
            } else
              2 * Vn() - E.renderingStartTime > s0 &&
                g !== 1073741824 &&
                ((c.flags |= 128), (x = !0), cc(E, !1), (c.lanes = 4194304));
          E.isBackwards
            ? ((A.sibling = c.child), (c.child = A))
            : ((l = E.last),
              l !== null ? (l.sibling = A) : (c.child = A),
              (E.last = A));
        }
        return E.tail !== null
          ? ((c = E.tail),
            (E.rendering = c),
            (E.tail = c.sibling),
            (E.renderingStartTime = Vn()),
            (c.sibling = null),
            (l = sn.current),
            je(sn, x ? (l & 1) | 2 : l & 1),
            c)
          : (ni(c), null);
      case 22:
      case 23:
        return (
          c0(),
          (x = c.memoizedState !== null),
          l !== null && (l.memoizedState !== null) !== x && (c.flags |= 8192),
          x && c.mode & 1
            ? Yi & 1073741824 &&
              (ni(c), We && c.subtreeFlags & 6 && (c.flags |= 8192))
            : ni(c),
          null
        );
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(o(156, c.tag));
  }
  var MN = a.ReactCurrentOwner,
    Xi = !1;
  function vi(l, c, g, x) {
    c.child = l === null ? PM(c, null, g, x) : yl(c, l.child, g, x);
  }
  function nw(l, c, g, x, E) {
    g = g.render;
    var A = c.ref;
    return (
      pl(c, E),
      (x = Uv(l, c, g, x, A, E)),
      (g = kv()),
      l !== null && !Xi
        ? ((c.updateQueue = l.updateQueue),
          (c.flags &= -2053),
          (l.lanes &= ~E),
          _s(l, c, E))
        : (en && g && Av(c), (c.flags |= 1), vi(l, c, x, E), c.child)
    );
  }
  function iw(l, c, g, x, E) {
    if (l === null) {
      var A = g.type;
      return typeof A == "function" &&
        !h0(A) &&
        A.defaultProps === void 0 &&
        g.compare === null &&
        g.defaultProps === void 0
        ? ((c.tag = 15), (c.type = A), rw(l, c, A, x, E))
        : ((l = Md(g.type, null, x, c, c.mode, E)),
          (l.ref = c.ref),
          (l.return = c),
          (c.child = l));
    }
    if (((A = l.child), !(l.lanes & E))) {
      var F = A.memoizedProps;
      if (
        ((g = g.compare), (g = g !== null ? g : kh), g(F, x) && l.ref === c.ref)
      )
        return _s(l, c, E);
    }
    return (
      (c.flags |= 1),
      (l = io(A, x)),
      (l.ref = c.ref),
      (l.return = c),
      (c.child = l)
    );
  }
  function rw(l, c, g, x, E) {
    if (l !== null && kh(l.memoizedProps, x) && l.ref === c.ref)
      if (((Xi = !1), (l.lanes & E) !== 0)) l.flags & 131072 && (Xi = !0);
      else return (c.lanes = l.lanes), _s(l, c, E);
    return Gv(l, c, g, x, E);
  }
  function sw(l, c, g) {
    var x = c.pendingProps,
      E = x.children,
      A = l !== null ? l.memoizedState : null;
    if (x.mode === "hidden")
      if (!(c.mode & 1))
        (c.memoizedState = { baseLanes: 0, cachePool: null }),
          je(Ml, Yi),
          (Yi |= g);
      else if (g & 1073741824)
        (c.memoizedState = { baseLanes: 0, cachePool: null }),
          (x = A !== null ? A.baseLanes : g),
          je(Ml, Yi),
          (Yi |= x);
      else
        return (
          (l = A !== null ? A.baseLanes | g : g),
          (c.lanes = c.childLanes = 1073741824),
          (c.memoizedState = { baseLanes: l, cachePool: null }),
          (c.updateQueue = null),
          je(Ml, Yi),
          (Yi |= l),
          null
        );
    else
      A !== null ? ((x = A.baseLanes | g), (c.memoizedState = null)) : (x = g),
        je(Ml, Yi),
        (Yi |= x);
    return vi(l, c, E, g), c.child;
  }
  function ow(l, c) {
    var g = c.ref;
    ((l === null && g !== null) || (l !== null && l.ref !== g)) &&
      ((c.flags |= 512), (c.flags |= 2097152));
  }
  function Gv(l, c, g, x, E) {
    var A = Bn(g) ? jr : At.current;
    return (
      (A = ar(c, A)),
      pl(c, E),
      (g = Uv(l, c, g, x, A, E)),
      (x = kv()),
      l !== null && !Xi
        ? ((c.updateQueue = l.updateQueue),
          (c.flags &= -2053),
          (l.lanes &= ~E),
          _s(l, c, E))
        : (en && x && Av(c), (c.flags |= 1), vi(l, c, g, E), c.child)
    );
  }
  function aw(l, c, g, x, E) {
    if (Bn(g)) {
      var A = !0;
      Zn(c);
    } else A = !1;
    if ((pl(c, E), c.stateNode === null))
      l !== null &&
        ((l.alternate = null), (c.alternate = null), (c.flags |= 2)),
        SM(c, g, x),
        Tv(c, g, x, E),
        (x = !0);
    else if (l === null) {
      var F = c.stateNode,
        q = c.memoizedProps;
      F.props = q;
      var fe = F.context,
        Ae = g.contextType;
      typeof Ae == "object" && Ae !== null
        ? (Ae = lr(Ae))
        : ((Ae = Bn(g) ? jr : At.current), (Ae = ar(c, Ae)));
      var Xe = g.getDerivedStateFromProps,
        yt =
          typeof Xe == "function" ||
          typeof F.getSnapshotBeforeUpdate == "function";
      yt ||
        (typeof F.UNSAFE_componentWillReceiveProps != "function" &&
          typeof F.componentWillReceiveProps != "function") ||
        ((q !== x || fe !== Ae) && MM(c, F, x, Ae)),
        (Qs = !1);
      var ot = c.memoizedState;
      (F.state = ot),
        Vh(c, x, F, E),
        (fe = c.memoizedState),
        q !== x || ot !== fe || dn.current || Qs
          ? (typeof Xe == "function" &&
              (Ev(c, g, Xe, x), (fe = c.memoizedState)),
            (q = Qs || _M(c, g, q, x, ot, fe, Ae))
              ? (yt ||
                  (typeof F.UNSAFE_componentWillMount != "function" &&
                    typeof F.componentWillMount != "function") ||
                  (typeof F.componentWillMount == "function" &&
                    F.componentWillMount(),
                  typeof F.UNSAFE_componentWillMount == "function" &&
                    F.UNSAFE_componentWillMount()),
                typeof F.componentDidMount == "function" &&
                  (c.flags |= 4194308))
              : (typeof F.componentDidMount == "function" &&
                  (c.flags |= 4194308),
                (c.memoizedProps = x),
                (c.memoizedState = fe)),
            (F.props = x),
            (F.state = fe),
            (F.context = Ae),
            (x = q))
          : (typeof F.componentDidMount == "function" && (c.flags |= 4194308),
            (x = !1));
    } else {
      (F = c.stateNode),
        gM(l, c),
        (q = c.memoizedProps),
        (Ae = c.type === c.elementType ? q : Tr(c.type, q)),
        (F.props = Ae),
        (yt = c.pendingProps),
        (ot = F.context),
        (fe = g.contextType),
        typeof fe == "object" && fe !== null
          ? (fe = lr(fe))
          : ((fe = Bn(g) ? jr : At.current), (fe = ar(c, fe)));
      var Wt = g.getDerivedStateFromProps;
      (Xe =
        typeof Wt == "function" ||
        typeof F.getSnapshotBeforeUpdate == "function") ||
        (typeof F.UNSAFE_componentWillReceiveProps != "function" &&
          typeof F.componentWillReceiveProps != "function") ||
        ((q !== yt || ot !== fe) && MM(c, F, x, fe)),
        (Qs = !1),
        (ot = c.memoizedState),
        (F.state = ot),
        Vh(c, x, F, E);
      var Je = c.memoizedState;
      q !== yt || ot !== Je || dn.current || Qs
        ? (typeof Wt == "function" && (Ev(c, g, Wt, x), (Je = c.memoizedState)),
          (Ae = Qs || _M(c, g, Ae, x, ot, Je, fe) || !1)
            ? (Xe ||
                (typeof F.UNSAFE_componentWillUpdate != "function" &&
                  typeof F.componentWillUpdate != "function") ||
                (typeof F.componentWillUpdate == "function" &&
                  F.componentWillUpdate(x, Je, fe),
                typeof F.UNSAFE_componentWillUpdate == "function" &&
                  F.UNSAFE_componentWillUpdate(x, Je, fe)),
              typeof F.componentDidUpdate == "function" && (c.flags |= 4),
              typeof F.getSnapshotBeforeUpdate == "function" &&
                (c.flags |= 1024))
            : (typeof F.componentDidUpdate != "function" ||
                (q === l.memoizedProps && ot === l.memoizedState) ||
                (c.flags |= 4),
              typeof F.getSnapshotBeforeUpdate != "function" ||
                (q === l.memoizedProps && ot === l.memoizedState) ||
                (c.flags |= 1024),
              (c.memoizedProps = x),
              (c.memoizedState = Je)),
          (F.props = x),
          (F.state = Je),
          (F.context = fe),
          (x = Ae))
        : (typeof F.componentDidUpdate != "function" ||
            (q === l.memoizedProps && ot === l.memoizedState) ||
            (c.flags |= 4),
          typeof F.getSnapshotBeforeUpdate != "function" ||
            (q === l.memoizedProps && ot === l.memoizedState) ||
            (c.flags |= 1024),
          (x = !1));
    }
    return Wv(l, c, g, x, A, E);
  }
  function Wv(l, c, g, x, E, A) {
    ow(l, c);
    var F = (c.flags & 128) !== 0;
    if (!x && !F) return E && hl(c, g, !1), _s(l, c, A);
    (x = c.stateNode), (MN.current = c);
    var q =
      F && typeof g.getDerivedStateFromError != "function" ? null : x.render();
    return (
      (c.flags |= 1),
      l !== null && F
        ? ((c.child = yl(c, l.child, null, A)), (c.child = yl(c, null, q, A)))
        : vi(l, c, q, A),
      (c.memoizedState = x.state),
      E && hl(c, g, !0),
      c.child
    );
  }
  function lw(l) {
    var c = l.stateNode;
    c.pendingContext
      ? Xr(l, c.pendingContext, c.pendingContext !== c.context)
      : c.context && Xr(l, c.context, !1),
      Lv(l, c.containerInfo);
  }
  function uw(l, c, g, x, E) {
    return vl(), Rv(E), (c.flags |= 256), vi(l, c, g, x), c.child;
  }
  var nd = { dehydrated: null, treeContext: null, retryLane: 0 };
  function id(l) {
    return { baseLanes: l, cachePool: null };
  }
  function cw(l, c, g) {
    var x = c.pendingProps,
      E = sn.current,
      A = !1,
      F = (c.flags & 128) !== 0,
      q;
    if (
      ((q = F) ||
        (q = l !== null && l.memoizedState === null ? !1 : (E & 2) !== 0),
      q
        ? ((A = !0), (c.flags &= -129))
        : (l === null || l.memoizedState !== null) && (E |= 1),
      je(sn, E & 1),
      l === null)
    )
      return (
        Pv(c),
        (l = c.memoizedState),
        l !== null && ((l = l.dehydrated), l !== null)
          ? (c.mode & 1
              ? Ku(l)
                ? (c.lanes = 8)
                : (c.lanes = 1073741824)
              : (c.lanes = 1),
            null)
          : ((E = x.children),
            (l = x.fallback),
            A
              ? ((x = c.mode),
                (A = c.child),
                (E = { mode: "hidden", children: E }),
                !(x & 1) && A !== null
                  ? ((A.childLanes = 0), (A.pendingProps = E))
                  : (A = wd(E, x, 0, null)),
                (l = la(l, x, g, null)),
                (A.return = c),
                (l.return = c),
                (A.sibling = l),
                (c.child = A),
                (c.child.memoizedState = id(g)),
                (c.memoizedState = nd),
                l)
              : jv(c, E))
      );
    if (((E = l.memoizedState), E !== null)) {
      if (((q = E.dehydrated), q !== null)) {
        if (F)
          return c.flags & 256
            ? ((c.flags &= -257), rd(l, c, g, Error(o(422))))
            : c.memoizedState !== null
            ? ((c.child = l.child), (c.flags |= 128), null)
            : ((A = x.fallback),
              (E = c.mode),
              (x = wd({ mode: "visible", children: x.children }, E, 0, null)),
              (A = la(A, E, g, null)),
              (A.flags |= 2),
              (x.return = c),
              (A.return = c),
              (x.sibling = A),
              (c.child = x),
              c.mode & 1 && yl(c, l.child, null, g),
              (c.child.memoizedState = id(g)),
              (c.memoizedState = nd),
              A);
        if (!(c.mode & 1)) c = rd(l, c, g, null);
        else if (Ku(q)) c = rd(l, c, g, Error(o(419)));
        else if (((x = (g & l.childLanes) !== 0), Xi || x)) {
          if (((x = bn), x !== null)) {
            switch (g & -g) {
              case 4:
                A = 2;
                break;
              case 16:
                A = 8;
                break;
              case 64:
              case 128:
              case 256:
              case 512:
              case 1024:
              case 2048:
              case 4096:
              case 8192:
              case 16384:
              case 32768:
              case 65536:
              case 131072:
              case 262144:
              case 524288:
              case 1048576:
              case 2097152:
              case 4194304:
              case 8388608:
              case 16777216:
              case 33554432:
              case 67108864:
                A = 32;
                break;
              case 536870912:
                A = 268435456;
                break;
              default:
                A = 0;
            }
            (x = A & (x.suspendedLanes | g) ? 0 : A),
              x !== 0 && x !== E.retryLane && ((E.retryLane = x), dr(l, x, -1));
          }
          f0(), (c = rd(l, c, g, Error(o(421))));
        } else
          Zu(q)
            ? ((c.flags |= 128),
              (c.child = l.child),
              (c = ON.bind(null, l)),
              ul(q, c),
              (c = null))
            : ((g = E.treeContext),
              Me &&
                ((ji = Rh(q)),
                (Wi = c),
                (en = !0),
                (Ar = null),
                (Ju = !1),
                g !== null &&
                  ((ur[cr++] = vs),
                  (ur[cr++] = ys),
                  (ur[cr++] = ea),
                  (vs = g.id),
                  (ys = g.overflow),
                  (ea = c))),
              (c = jv(c, c.pendingProps.children)),
              (c.flags |= 4096));
        return c;
      }
      return A
        ? ((x = hw(l, c, x.children, x.fallback, g)),
          (A = c.child),
          (E = l.child.memoizedState),
          (A.memoizedState =
            E === null
              ? id(g)
              : { baseLanes: E.baseLanes | g, cachePool: null }),
          (A.childLanes = l.childLanes & ~g),
          (c.memoizedState = nd),
          x)
        : ((g = fw(l, c, x.children, g)), (c.memoizedState = null), g);
    }
    return A
      ? ((x = hw(l, c, x.children, x.fallback, g)),
        (A = c.child),
        (E = l.child.memoizedState),
        (A.memoizedState =
          E === null ? id(g) : { baseLanes: E.baseLanes | g, cachePool: null }),
        (A.childLanes = l.childLanes & ~g),
        (c.memoizedState = nd),
        x)
      : ((g = fw(l, c, x.children, g)), (c.memoizedState = null), g);
  }
  function jv(l, c) {
    return (
      (c = wd({ mode: "visible", children: c }, l.mode, 0, null)),
      (c.return = l),
      (l.child = c)
    );
  }
  function fw(l, c, g, x) {
    var E = l.child;
    return (
      (l = E.sibling),
      (g = io(E, { mode: "visible", children: g })),
      !(c.mode & 1) && (g.lanes = x),
      (g.return = c),
      (g.sibling = null),
      l !== null &&
        ((x = c.deletions),
        x === null ? ((c.deletions = [l]), (c.flags |= 16)) : x.push(l)),
      (c.child = g)
    );
  }
  function hw(l, c, g, x, E) {
    var A = c.mode;
    l = l.child;
    var F = l.sibling,
      q = { mode: "hidden", children: g };
    return (
      !(A & 1) && c.child !== l
        ? ((g = c.child),
          (g.childLanes = 0),
          (g.pendingProps = q),
          (c.deletions = null))
        : ((g = io(l, q)), (g.subtreeFlags = l.subtreeFlags & 14680064)),
      F !== null ? (x = io(F, x)) : ((x = la(x, A, E, null)), (x.flags |= 2)),
      (x.return = c),
      (g.return = c),
      (g.sibling = x),
      (c.child = g),
      x
    );
  }
  function rd(l, c, g, x) {
    return (
      x !== null && Rv(x),
      yl(c, l.child, null, g),
      (l = jv(c, c.pendingProps.children)),
      (l.flags |= 2),
      (c.memoizedState = null),
      l
    );
  }
  function dw(l, c, g) {
    l.lanes |= c;
    var x = l.alternate;
    x !== null && (x.lanes |= c), Mv(l.return, c, g);
  }
  function Xv(l, c, g, x, E) {
    var A = l.memoizedState;
    A === null
      ? (l.memoizedState = {
          isBackwards: c,
          rendering: null,
          renderingStartTime: 0,
          last: x,
          tail: g,
          tailMode: E,
        })
      : ((A.isBackwards = c),
        (A.rendering = null),
        (A.renderingStartTime = 0),
        (A.last = x),
        (A.tail = g),
        (A.tailMode = E));
  }
  function pw(l, c, g) {
    var x = c.pendingProps,
      E = x.revealOrder,
      A = x.tail;
    if ((vi(l, c, x.children, g), (x = sn.current), x & 2))
      (x = (x & 1) | 2), (c.flags |= 128);
    else {
      if (l !== null && l.flags & 128)
        e: for (l = c.child; l !== null; ) {
          if (l.tag === 13) l.memoizedState !== null && dw(l, g, c);
          else if (l.tag === 19) dw(l, g, c);
          else if (l.child !== null) {
            (l.child.return = l), (l = l.child);
            continue;
          }
          if (l === c) break e;
          for (; l.sibling === null; ) {
            if (l.return === null || l.return === c) break e;
            l = l.return;
          }
          (l.sibling.return = l.return), (l = l.sibling);
        }
      x &= 1;
    }
    if ((je(sn, x), !(c.mode & 1))) c.memoizedState = null;
    else
      switch (E) {
        case "forwards":
          for (g = c.child, E = null; g !== null; )
            (l = g.alternate),
              l !== null && Xh(l) === null && (E = g),
              (g = g.sibling);
          (g = E),
            g === null
              ? ((E = c.child), (c.child = null))
              : ((E = g.sibling), (g.sibling = null)),
            Xv(c, !1, E, g, A);
          break;
        case "backwards":
          for (g = null, E = c.child, c.child = null; E !== null; ) {
            if (((l = E.alternate), l !== null && Xh(l) === null)) {
              c.child = E;
              break;
            }
            (l = E.sibling), (E.sibling = g), (g = E), (E = l);
          }
          Xv(c, !0, g, null, A);
          break;
        case "together":
          Xv(c, !1, null, null, void 0);
          break;
        default:
          c.memoizedState = null;
      }
    return c.child;
  }
  function _s(l, c, g) {
    if (
      (l !== null && (c.dependencies = l.dependencies),
      (wl |= c.lanes),
      !(g & c.childLanes))
    )
      return null;
    if (l !== null && c.child !== l.child) throw Error(o(153));
    if (c.child !== null) {
      for (
        l = c.child, g = io(l, l.pendingProps), c.child = g, g.return = c;
        l.sibling !== null;

      )
        (l = l.sibling),
          (g = g.sibling = io(l, l.pendingProps)),
          (g.return = c);
      g.sibling = null;
    }
    return c.child;
  }
  function wN(l, c, g) {
    switch (c.tag) {
      case 3:
        lw(c), vl();
        break;
      case 5:
        RM(c);
        break;
      case 1:
        Bn(c.type) && Zn(c);
        break;
      case 4:
        Lv(c, c.stateNode.containerInfo);
        break;
      case 10:
        mM(c, c.type._context, c.memoizedProps.value);
        break;
      case 13:
        var x = c.memoizedState;
        if (x !== null)
          return x.dehydrated !== null
            ? (je(sn, sn.current & 1), (c.flags |= 128), null)
            : g & c.child.childLanes
            ? cw(l, c, g)
            : (je(sn, sn.current & 1),
              (l = _s(l, c, g)),
              l !== null ? l.sibling : null);
        je(sn, sn.current & 1);
        break;
      case 19:
        if (((x = (g & c.childLanes) !== 0), l.flags & 128)) {
          if (x) return pw(l, c, g);
          c.flags |= 128;
        }
        var E = c.memoizedState;
        if (
          (E !== null &&
            ((E.rendering = null), (E.tail = null), (E.lastEffect = null)),
          je(sn, sn.current),
          x)
        )
          break;
        return null;
      case 22:
      case 23:
        return (c.lanes = 0), sw(l, c, g);
    }
    return _s(l, c, g);
  }
  function EN(l, c) {
    switch ((bv(c), c.tag)) {
      case 1:
        return (
          Bn(c.type) && yn(),
          (l = c.flags),
          l & 65536 ? ((c.flags = (l & -65537) | 128), c) : null
        );
      case 3:
        return (
          _l(),
          ct(dn),
          ct(At),
          Dv(),
          (l = c.flags),
          l & 65536 && !(l & 128) ? ((c.flags = (l & -65537) | 128), c) : null
        );
      case 5:
        return Iv(c), null;
      case 13:
        if (
          (ct(sn), (l = c.memoizedState), l !== null && l.dehydrated !== null)
        ) {
          if (c.alternate === null) throw Error(o(340));
          vl();
        }
        return (
          (l = c.flags), l & 65536 ? ((c.flags = (l & -65537) | 128), c) : null
        );
      case 19:
        return ct(sn), null;
      case 4:
        return _l(), null;
      case 10:
        return Sv(c.type._context), null;
      case 22:
      case 23:
        return c0(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var sd = !1,
    ia = !1,
    TN = typeof WeakSet == "function" ? WeakSet : Set,
    De = null;
  function od(l, c) {
    var g = l.ref;
    if (g !== null)
      if (typeof g == "function")
        try {
          g(null);
        } catch (x) {
          Ii(l, c, x);
        }
      else g.current = null;
  }
  function Yv(l, c, g) {
    try {
      g();
    } catch (x) {
      Ii(l, c, x);
    }
  }
  var mw = !1;
  function AN(l, c) {
    for (G(l.containerInfo), De = c; De !== null; )
      if (
        ((l = De), (c = l.child), (l.subtreeFlags & 1028) !== 0 && c !== null)
      )
        (c.return = l), (De = c);
      else
        for (; De !== null; ) {
          l = De;
          try {
            var g = l.alternate;
            if (l.flags & 1024)
              switch (l.tag) {
                case 0:
                case 11:
                case 15:
                  break;
                case 1:
                  if (g !== null) {
                    var x = g.memoizedProps,
                      E = g.memoizedState,
                      A = l.stateNode,
                      F = A.getSnapshotBeforeUpdate(
                        l.elementType === l.type ? x : Tr(l.type, x),
                        E
                      );
                    A.__reactInternalSnapshotBeforeUpdate = F;
                  }
                  break;
                case 3:
                  We && Ce(l.stateNode.containerInfo);
                  break;
                case 5:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  throw Error(o(163));
              }
          } catch (q) {
            Ii(l, l.return, q);
          }
          if (((c = l.sibling), c !== null)) {
            (c.return = l.return), (De = c);
            break;
          }
          De = l.return;
        }
    return (g = mw), (mw = !1), g;
  }
  function ra(l, c, g) {
    var x = c.updateQueue;
    if (((x = x !== null ? x.lastEffect : null), x !== null)) {
      var E = (x = x.next);
      do {
        if ((E.tag & l) === l) {
          var A = E.destroy;
          (E.destroy = void 0), A !== void 0 && Yv(c, g, A);
        }
        E = E.next;
      } while (E !== x);
    }
  }
  function fc(l, c) {
    if (
      ((c = c.updateQueue), (c = c !== null ? c.lastEffect : null), c !== null)
    ) {
      var g = (c = c.next);
      do {
        if ((g.tag & l) === l) {
          var x = g.create;
          g.destroy = x();
        }
        g = g.next;
      } while (g !== c);
    }
  }
  function qv(l) {
    var c = l.ref;
    if (c !== null) {
      var g = l.stateNode;
      switch (l.tag) {
        case 5:
          l = $(g);
          break;
        default:
          l = g;
      }
      typeof c == "function" ? c(l) : (c.current = l);
    }
  }
  function gw(l, c, g) {
    if (Yr && typeof Yr.onCommitFiberUnmount == "function")
      try {
        Yr.onCommitFiberUnmount(Oh, c);
      } catch {}
    switch (c.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if (
          ((l = c.updateQueue), l !== null && ((l = l.lastEffect), l !== null))
        ) {
          var x = (l = l.next);
          do {
            var E = x,
              A = E.destroy;
            (E = E.tag),
              A !== void 0 && (E & 2 || E & 4) && Yv(c, g, A),
              (x = x.next);
          } while (x !== l);
        }
        break;
      case 1:
        if (
          (od(c, g),
          (l = c.stateNode),
          typeof l.componentWillUnmount == "function")
        )
          try {
            (l.props = c.memoizedProps),
              (l.state = c.memoizedState),
              l.componentWillUnmount();
          } catch (F) {
            Ii(c, g, F);
          }
        break;
      case 5:
        od(c, g);
        break;
      case 4:
        We
          ? Mw(l, c, g)
          : H && H && ((c = c.stateNode.containerInfo), (g = st(c)), Lt(c, g));
    }
  }
  function vw(l, c, g) {
    for (var x = c; ; )
      if ((gw(l, x, g), x.child === null || (We && x.tag === 4))) {
        if (x === c) break;
        for (; x.sibling === null; ) {
          if (x.return === null || x.return === c) return;
          x = x.return;
        }
        (x.sibling.return = x.return), (x = x.sibling);
      } else (x.child.return = x), (x = x.child);
  }
  function yw(l) {
    var c = l.alternate;
    c !== null && ((l.alternate = null), yw(c)),
      (l.child = null),
      (l.deletions = null),
      (l.sibling = null),
      l.tag === 5 && ((c = l.stateNode), c !== null && Ke(c)),
      (l.stateNode = null),
      (l.return = null),
      (l.dependencies = null),
      (l.memoizedProps = null),
      (l.memoizedState = null),
      (l.pendingProps = null),
      (l.stateNode = null),
      (l.updateQueue = null);
  }
  function xw(l) {
    return l.tag === 5 || l.tag === 3 || l.tag === 4;
  }
  function _w(l) {
    e: for (;;) {
      for (; l.sibling === null; ) {
        if (l.return === null || xw(l.return)) return null;
        l = l.return;
      }
      for (
        l.sibling.return = l.return, l = l.sibling;
        l.tag !== 5 && l.tag !== 6 && l.tag !== 18;

      ) {
        if (l.flags & 2 || l.child === null || l.tag === 4) continue e;
        (l.child.return = l), (l = l.child);
      }
      if (!(l.flags & 2)) return l.stateNode;
    }
  }
  function Sw(l) {
    if (We) {
      e: {
        for (var c = l.return; c !== null; ) {
          if (xw(c)) break e;
          c = c.return;
        }
        throw Error(o(160));
      }
      var g = c;
      switch (g.tag) {
        case 5:
          (c = g.stateNode),
            g.flags & 32 && (ve(c), (g.flags &= -33)),
            (g = _w(l)),
            Kv(l, g, c);
          break;
        case 3:
        case 4:
          (c = g.stateNode.containerInfo), (g = _w(l)), Zv(l, g, c);
          break;
        default:
          throw Error(o(161));
      }
    }
  }
  function Zv(l, c, g) {
    var x = l.tag;
    if (x === 5 || x === 6) (l = l.stateNode), c ? et(g, l, c) : mt(g, l);
    else if (x !== 4 && ((l = l.child), l !== null))
      for (Zv(l, c, g), l = l.sibling; l !== null; )
        Zv(l, c, g), (l = l.sibling);
  }
  function Kv(l, c, g) {
    var x = l.tag;
    if (x === 5 || x === 6) (l = l.stateNode), c ? ht(g, l, c) : tt(g, l);
    else if (x !== 4 && ((l = l.child), l !== null))
      for (Kv(l, c, g), l = l.sibling; l !== null; )
        Kv(l, c, g), (l = l.sibling);
  }
  function Mw(l, c, g) {
    for (var x = c, E = !1, A, F; ; ) {
      if (!E) {
        E = x.return;
        e: for (;;) {
          if (E === null) throw Error(o(160));
          switch (((A = E.stateNode), E.tag)) {
            case 5:
              F = !1;
              break e;
            case 3:
              (A = A.containerInfo), (F = !0);
              break e;
            case 4:
              (A = A.containerInfo), (F = !0);
              break e;
          }
          E = E.return;
        }
        E = !0;
      }
      if (x.tag === 5 || x.tag === 6)
        vw(l, x, g), F ? j(A, x.stateNode) : He(A, x.stateNode);
      else if (x.tag === 18) F ? re(A, x.stateNode) : le(A, x.stateNode);
      else if (x.tag === 4) {
        if (x.child !== null) {
          (A = x.stateNode.containerInfo),
            (F = !0),
            (x.child.return = x),
            (x = x.child);
          continue;
        }
      } else if ((gw(l, x, g), x.child !== null)) {
        (x.child.return = x), (x = x.child);
        continue;
      }
      if (x === c) break;
      for (; x.sibling === null; ) {
        if (x.return === null || x.return === c) return;
        (x = x.return), x.tag === 4 && (E = !1);
      }
      (x.sibling.return = x.return), (x = x.sibling);
    }
  }
  function Qv(l, c) {
    if (We) {
      switch (c.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          ra(3, c, c.return), fc(3, c), ra(5, c, c.return);
          return;
        case 1:
          return;
        case 5:
          var g = c.stateNode;
          if (g != null) {
            var x = c.memoizedProps;
            l = l !== null ? l.memoizedProps : x;
            var E = c.type,
              A = c.updateQueue;
            (c.updateQueue = null), A !== null && _t(g, A, E, l, x, c);
          }
          return;
        case 6:
          if (c.stateNode === null) throw Error(o(162));
          (g = c.memoizedProps),
            _e(c.stateNode, l !== null ? l.memoizedProps : g, g);
          return;
        case 3:
          Me &&
            l !== null &&
            l.memoizedState.isDehydrated &&
            ee(c.stateNode.containerInfo);
          return;
        case 12:
          return;
        case 13:
          ad(c);
          return;
        case 19:
          ad(c);
          return;
        case 17:
          return;
      }
      throw Error(o(163));
    }
    switch (c.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        ra(3, c, c.return), fc(3, c), ra(5, c, c.return);
        return;
      case 12:
        return;
      case 13:
        ad(c);
        return;
      case 19:
        ad(c);
        return;
      case 3:
        Me &&
          l !== null &&
          l.memoizedState.isDehydrated &&
          ee(c.stateNode.containerInfo);
        break;
      case 22:
      case 23:
        return;
    }
    e: if (H) {
      switch (c.tag) {
        case 1:
        case 5:
        case 6:
          break e;
        case 3:
        case 4:
          (c = c.stateNode), Lt(c.containerInfo, c.pendingChildren);
          break e;
      }
      throw Error(o(163));
    }
  }
  function ad(l) {
    var c = l.updateQueue;
    if (c !== null) {
      l.updateQueue = null;
      var g = l.stateNode;
      g === null && (g = l.stateNode = new TN()),
        c.forEach(function (x) {
          var E = UN.bind(null, l, x);
          g.has(x) || (g.add(x), x.then(E, E));
        });
    }
  }
  function bN(l, c) {
    for (De = c; De !== null; ) {
      c = De;
      var g = c.deletions;
      if (g !== null)
        for (var x = 0; x < g.length; x++) {
          var E = g[x];
          try {
            var A = l;
            We ? Mw(A, E, c) : vw(A, E, c);
            var F = E.alternate;
            F !== null && (F.return = null), (E.return = null);
          } catch (Qe) {
            Ii(E, c, Qe);
          }
        }
      if (((g = c.child), c.subtreeFlags & 12854 && g !== null))
        (g.return = c), (De = g);
      else
        for (; De !== null; ) {
          c = De;
          try {
            var q = c.flags;
            if ((q & 32 && We && ve(c.stateNode), q & 512)) {
              var fe = c.alternate;
              if (fe !== null) {
                var Ae = fe.ref;
                Ae !== null &&
                  (typeof Ae == "function" ? Ae(null) : (Ae.current = null));
              }
            }
            if (q & 8192)
              switch (c.tag) {
                case 13:
                  if (c.memoizedState !== null) {
                    var Xe = c.alternate;
                    (Xe === null || Xe.memoizedState === null) && (r0 = Vn());
                  }
                  break;
                case 22:
                  var yt = c.memoizedState !== null,
                    ot = c.alternate,
                    Wt = ot !== null && ot.memoizedState !== null;
                  if (((g = c), We)) {
                    e: if (((x = g), (E = yt), (A = null), We))
                      for (var Je = x; ; ) {
                        if (Je.tag === 5) {
                          if (A === null) {
                            A = Je;
                            var ii = Je.stateNode;
                            E ? ke(ii) : Se(Je.stateNode, Je.memoizedProps);
                          }
                        } else if (Je.tag === 6) {
                          if (A === null) {
                            var mr = Je.stateNode;
                            E ? Oe(mr) : X(mr, Je.memoizedProps);
                          }
                        } else if (
                          ((Je.tag !== 22 && Je.tag !== 23) ||
                            Je.memoizedState === null ||
                            Je === x) &&
                          Je.child !== null
                        ) {
                          (Je.child.return = Je), (Je = Je.child);
                          continue;
                        }
                        if (Je === x) break;
                        for (; Je.sibling === null; ) {
                          if (Je.return === null || Je.return === x) break e;
                          A === Je && (A = null), (Je = Je.return);
                        }
                        A === Je && (A = null),
                          (Je.sibling.return = Je.return),
                          (Je = Je.sibling);
                      }
                  }
                  if (yt && !Wt && g.mode & 1) {
                    De = g;
                    for (var ne = g.child; ne !== null; ) {
                      for (g = De = ne; De !== null; ) {
                        x = De;
                        var K = x.child;
                        switch (x.tag) {
                          case 0:
                          case 11:
                          case 14:
                          case 15:
                            ra(4, x, x.return);
                            break;
                          case 1:
                            od(x, x.return);
                            var ue = x.stateNode;
                            if (typeof ue.componentWillUnmount == "function") {
                              var Ue = x.return;
                              try {
                                (ue.props = x.memoizedProps),
                                  (ue.state = x.memoizedState),
                                  ue.componentWillUnmount();
                              } catch (Qe) {
                                Ii(x, Ue, Qe);
                              }
                            }
                            break;
                          case 5:
                            od(x, x.return);
                            break;
                          case 22:
                            if (x.memoizedState !== null) {
                              Tw(g);
                              continue;
                            }
                        }
                        K !== null ? ((K.return = x), (De = K)) : Tw(g);
                      }
                      ne = ne.sibling;
                    }
                  }
              }
            switch (q & 4102) {
              case 2:
                Sw(c), (c.flags &= -3);
                break;
              case 6:
                Sw(c), (c.flags &= -3), Qv(c.alternate, c);
                break;
              case 4096:
                c.flags &= -4097;
                break;
              case 4100:
                (c.flags &= -4097), Qv(c.alternate, c);
                break;
              case 4:
                Qv(c.alternate, c);
            }
          } catch (Qe) {
            Ii(c, c.return, Qe);
          }
          if (((g = c.sibling), g !== null)) {
            (g.return = c.return), (De = g);
            break;
          }
          De = c.return;
        }
    }
  }
  function CN(l, c, g) {
    (De = l), ww(l);
  }
  function ww(l, c, g) {
    for (var x = (l.mode & 1) !== 0; De !== null; ) {
      var E = De,
        A = E.child;
      if (E.tag === 22 && x) {
        var F = E.memoizedState !== null || sd;
        if (!F) {
          var q = E.alternate,
            fe = (q !== null && q.memoizedState !== null) || ia;
          q = sd;
          var Ae = ia;
          if (((sd = F), (ia = fe) && !Ae))
            for (De = E; De !== null; )
              (F = De),
                (fe = F.child),
                F.tag === 22 && F.memoizedState !== null
                  ? Aw(E)
                  : fe !== null
                  ? ((fe.return = F), (De = fe))
                  : Aw(E);
          for (; A !== null; ) (De = A), ww(A), (A = A.sibling);
          (De = E), (sd = q), (ia = Ae);
        }
        Ew(l);
      } else
        E.subtreeFlags & 8772 && A !== null
          ? ((A.return = E), (De = A))
          : Ew(l);
    }
  }
  function Ew(l) {
    for (; De !== null; ) {
      var c = De;
      if (c.flags & 8772) {
        var g = c.alternate;
        try {
          if (c.flags & 8772)
            switch (c.tag) {
              case 0:
              case 11:
              case 15:
                ia || fc(5, c);
                break;
              case 1:
                var x = c.stateNode;
                if (c.flags & 4 && !ia)
                  if (g === null) x.componentDidMount();
                  else {
                    var E =
                      c.elementType === c.type
                        ? g.memoizedProps
                        : Tr(c.type, g.memoizedProps);
                    x.componentDidUpdate(
                      E,
                      g.memoizedState,
                      x.__reactInternalSnapshotBeforeUpdate
                    );
                  }
                var A = c.updateQueue;
                A !== null && yM(c, A, x);
                break;
              case 3:
                var F = c.updateQueue;
                if (F !== null) {
                  if (((g = null), c.child !== null))
                    switch (c.child.tag) {
                      case 5:
                        g = $(c.child.stateNode);
                        break;
                      case 1:
                        g = c.child.stateNode;
                    }
                  yM(c, F, g);
                }
                break;
              case 5:
                var q = c.stateNode;
                g === null && c.flags & 4 && Rt(q, c.type, c.memoizedProps, c);
                break;
              case 6:
                break;
              case 4:
                break;
              case 12:
                break;
              case 13:
                if (Me && c.memoizedState === null) {
                  var fe = c.alternate;
                  if (fe !== null) {
                    var Ae = fe.memoizedState;
                    if (Ae !== null) {
                      var Xe = Ae.dehydrated;
                      Xe !== null && oe(Xe);
                    }
                  }
                }
                break;
              case 19:
              case 17:
              case 21:
              case 22:
              case 23:
                break;
              default:
                throw Error(o(163));
            }
          ia || (c.flags & 512 && qv(c));
        } catch (yt) {
          Ii(c, c.return, yt);
        }
      }
      if (c === l) {
        De = null;
        break;
      }
      if (((g = c.sibling), g !== null)) {
        (g.return = c.return), (De = g);
        break;
      }
      De = c.return;
    }
  }
  function Tw(l) {
    for (; De !== null; ) {
      var c = De;
      if (c === l) {
        De = null;
        break;
      }
      var g = c.sibling;
      if (g !== null) {
        (g.return = c.return), (De = g);
        break;
      }
      De = c.return;
    }
  }
  function Aw(l) {
    for (; De !== null; ) {
      var c = De;
      try {
        switch (c.tag) {
          case 0:
          case 11:
          case 15:
            var g = c.return;
            try {
              fc(4, c);
            } catch (fe) {
              Ii(c, g, fe);
            }
            break;
          case 1:
            var x = c.stateNode;
            if (typeof x.componentDidMount == "function") {
              var E = c.return;
              try {
                x.componentDidMount();
              } catch (fe) {
                Ii(c, E, fe);
              }
            }
            var A = c.return;
            try {
              qv(c);
            } catch (fe) {
              Ii(c, A, fe);
            }
            break;
          case 5:
            var F = c.return;
            try {
              qv(c);
            } catch (fe) {
              Ii(c, F, fe);
            }
        }
      } catch (fe) {
        Ii(c, c.return, fe);
      }
      if (c === l) {
        De = null;
        break;
      }
      var q = c.sibling;
      if (q !== null) {
        (q.return = c.return), (De = q);
        break;
      }
      De = c.return;
    }
  }
  var ld = 0,
    ud = 1,
    cd = 2,
    fd = 3,
    hd = 4;
  if (typeof Symbol == "function" && Symbol.for) {
    var hc = Symbol.for;
    (ld = hc("selector.component")),
      (ud = hc("selector.has_pseudo_class")),
      (cd = hc("selector.role")),
      (fd = hc("selector.test_id")),
      (hd = hc("selector.text"));
  }
  function $v(l) {
    var c = pe(l);
    if (c != null) {
      if (typeof c.memoizedProps["data-testname"] != "string")
        throw Error(o(364));
      return c;
    }
    if (((l = te(l)), l === null)) throw Error(o(362));
    return l.stateNode.current;
  }
  function Jv(l, c) {
    switch (c.$$typeof) {
      case ld:
        if (l.type === c.value) return !0;
        break;
      case ud:
        e: {
          (c = c.value), (l = [l, 0]);
          for (var g = 0; g < l.length; ) {
            var x = l[g++],
              E = l[g++],
              A = c[E];
            if (x.tag !== 5 || !ge(x)) {
              for (; A != null && Jv(x, A); ) E++, (A = c[E]);
              if (E === c.length) {
                c = !0;
                break e;
              } else
                for (x = x.child; x !== null; ) l.push(x, E), (x = x.sibling);
            }
          }
          c = !1;
        }
        return c;
      case cd:
        if (l.tag === 5 && Ye(l.stateNode, c.value)) return !0;
        break;
      case hd:
        if (
          (l.tag === 5 || l.tag === 6) &&
          ((l = ye(l)), l !== null && 0 <= l.indexOf(c.value))
        )
          return !0;
        break;
      case fd:
        if (
          l.tag === 5 &&
          ((l = l.memoizedProps["data-testname"]),
          typeof l == "string" && l.toLowerCase() === c.value.toLowerCase())
        )
          return !0;
        break;
      default:
        throw Error(o(365));
    }
    return !1;
  }
  function e0(l) {
    switch (l.$$typeof) {
      case ld:
        return "<" + (L(l.value) || "Unknown") + ">";
      case ud:
        return ":has(" + (e0(l) || "") + ")";
      case cd:
        return '[role="' + l.value + '"]';
      case hd:
        return '"' + l.value + '"';
      case fd:
        return '[data-testname="' + l.value + '"]';
      default:
        throw Error(o(365));
    }
  }
  function bw(l, c) {
    var g = [];
    l = [l, 0];
    for (var x = 0; x < l.length; ) {
      var E = l[x++],
        A = l[x++],
        F = c[A];
      if (E.tag !== 5 || !ge(E)) {
        for (; F != null && Jv(E, F); ) A++, (F = c[A]);
        if (A === c.length) g.push(E);
        else for (E = E.child; E !== null; ) l.push(E, A), (E = E.sibling);
      }
    }
    return g;
  }
  function t0(l, c) {
    if (!I) throw Error(o(363));
    (l = $v(l)), (l = bw(l, c)), (c = []), (l = Array.from(l));
    for (var g = 0; g < l.length; ) {
      var x = l[g++];
      if (x.tag === 5) ge(x) || c.push(x.stateNode);
      else for (x = x.child; x !== null; ) l.push(x), (x = x.sibling);
    }
    return c;
  }
  var PN = Math.ceil,
    dd = a.ReactCurrentDispatcher,
    n0 = a.ReactCurrentOwner,
    xn = a.ReactCurrentBatchConfig,
    bt = 0,
    bn = null,
    Cn = null,
    Kn = 0,
    Yi = 0,
    Ml = zn(0),
    In = 0,
    dc = null,
    wl = 0,
    pd = 0,
    i0 = 0,
    pc = null,
    Ri = null,
    r0 = 0,
    s0 = 1 / 0;
  function El() {
    s0 = Vn() + 500;
  }
  var md = !1,
    o0 = null,
    Js = null,
    gd = !1,
    eo = null,
    vd = 0,
    mc = 0,
    a0 = null,
    yd = -1,
    xd = 0;
  function yi() {
    return bt & 6 ? Vn() : yd !== -1 ? yd : (yd = Vn());
  }
  function to(l) {
    return l.mode & 1
      ? bt & 2 && Kn !== 0
        ? Kn & -Kn
        : fN.transition !== null
        ? (xd === 0 &&
            ((l = Ih), (Ih <<= 1), !(Ih & 4194240) && (Ih = 64), (xd = l)),
          xd)
        : ((l = Ot), l !== 0 ? l : me())
      : 1;
  }
  function dr(l, c, g) {
    if (50 < mc) throw ((mc = 0), (a0 = null), Error(o(185)));
    var x = _d(l, c);
    return x === null
      ? null
      : ($u(x, c, g),
        (!(bt & 2) || x !== bn) &&
          (x === bn && (!(bt & 2) && (pd |= c), In === 4 && no(x, Kn)),
          Li(x, g),
          c === 1 && bt === 0 && !(l.mode & 1) && (El(), Uh && Zr())),
        x);
  }
  function _d(l, c) {
    l.lanes |= c;
    var g = l.alternate;
    for (g !== null && (g.lanes |= c), g = l, l = l.return; l !== null; )
      (l.childLanes |= c),
        (g = l.alternate),
        g !== null && (g.childLanes |= c),
        (g = l),
        (l = l.return);
    return g.tag === 3 ? g.stateNode : null;
  }
  function Li(l, c) {
    var g = l.callbackNode;
    nN(l, c);
    var x = Dh(l, l === bn ? Kn : 0);
    if (x === 0)
      g !== null && dM(g), (l.callbackNode = null), (l.callbackPriority = 0);
    else if (((c = x & -x), l.callbackPriority !== c)) {
      if ((g != null && dM(g), c === 1))
        l.tag === 0 ? cN(Pw.bind(null, l)) : pM(Pw.bind(null, l)),
          Ne
            ? D(function () {
                bt === 0 && Zr();
              })
            : mv(gv, Zr),
          (g = null);
      else {
        switch (hM(x)) {
          case 1:
            g = gv;
            break;
          case 4:
            g = oN;
            break;
          case 16:
            g = vv;
            break;
          case 536870912:
            g = aN;
            break;
          default:
            g = vv;
        }
        g = Fw(g, Cw.bind(null, l));
      }
      (l.callbackPriority = c), (l.callbackNode = g);
    }
  }
  function Cw(l, c) {
    if (((yd = -1), (xd = 0), bt & 6)) throw Error(o(327));
    var g = l.callbackNode;
    if (aa() && l.callbackNode !== g) return null;
    var x = Dh(l, l === bn ? Kn : 0);
    if (x === 0) return null;
    if (x & 30 || x & l.expiredLanes || c) c = Sd(l, x);
    else {
      c = x;
      var E = bt;
      bt |= 2;
      var A = Iw();
      (bn !== l || Kn !== c) && (El(), sa(l, c));
      do
        try {
          IN();
          break;
        } catch (q) {
          Lw(l, q);
        }
      while (!0);
      _v(),
        (dd.current = A),
        (bt = E),
        Cn !== null ? (c = 0) : ((bn = null), (Kn = 0), (c = In));
    }
    if (c !== 0) {
      if (
        (c === 2 && ((E = hv(l)), E !== 0 && ((x = E), (c = l0(l, E)))),
        c === 1)
      )
        throw ((g = dc), sa(l, 0), no(l, x), Li(l, Vn()), g);
      if (c === 6) no(l, x);
      else {
        if (
          ((E = l.current.alternate),
          !(x & 30) &&
            !RN(E) &&
            ((c = Sd(l, x)),
            c === 2 && ((A = hv(l)), A !== 0 && ((x = A), (c = l0(l, A)))),
            c === 1))
        )
          throw ((g = dc), sa(l, 0), no(l, x), Li(l, Vn()), g);
        switch (((l.finishedWork = E), (l.finishedLanes = x), c)) {
          case 0:
          case 1:
            throw Error(o(345));
          case 2:
            oa(l, Ri);
            break;
          case 3:
            if (
              (no(l, x),
              (x & 130023424) === x && ((c = r0 + 500 - Vn()), 10 < c))
            ) {
              if (Dh(l, 0) !== 0) break;
              if (((E = l.suspendedLanes), (E & x) !== x)) {
                yi(), (l.pingedLanes |= l.suspendedLanes & E);
                break;
              }
              l.timeoutHandle = Pe(oa.bind(null, l, Ri), c);
              break;
            }
            oa(l, Ri);
            break;
          case 4:
            if ((no(l, x), (x & 4194240) === x)) break;
            for (c = l.eventTimes, E = -1; 0 < x; ) {
              var F = 31 - Gi(x);
              (A = 1 << F), (F = c[F]), F > E && (E = F), (x &= ~A);
            }
            if (
              ((x = E),
              (x = Vn() - x),
              (x =
                (120 > x
                  ? 120
                  : 480 > x
                  ? 480
                  : 1080 > x
                  ? 1080
                  : 1920 > x
                  ? 1920
                  : 3e3 > x
                  ? 3e3
                  : 4320 > x
                  ? 4320
                  : 1960 * PN(x / 1960)) - x),
              10 < x)
            ) {
              l.timeoutHandle = Pe(oa.bind(null, l, Ri), x);
              break;
            }
            oa(l, Ri);
            break;
          case 5:
            oa(l, Ri);
            break;
          default:
            throw Error(o(329));
        }
      }
    }
    return Li(l, Vn()), l.callbackNode === g ? Cw.bind(null, l) : null;
  }
  function l0(l, c) {
    var g = pc;
    return (
      l.current.memoizedState.isDehydrated && (sa(l, c).flags |= 256),
      (l = Sd(l, c)),
      l !== 2 && ((c = Ri), (Ri = g), c !== null && u0(c)),
      l
    );
  }
  function u0(l) {
    Ri === null ? (Ri = l) : Ri.push.apply(Ri, l);
  }
  function RN(l) {
    for (var c = l; ; ) {
      if (c.flags & 16384) {
        var g = c.updateQueue;
        if (g !== null && ((g = g.stores), g !== null))
          for (var x = 0; x < g.length; x++) {
            var E = g[x],
              A = E.getSnapshot;
            E = E.value;
            try {
              if (!qr(A(), E)) return !1;
            } catch {
              return !1;
            }
          }
      }
      if (((g = c.child), c.subtreeFlags & 16384 && g !== null))
        (g.return = c), (c = g);
      else {
        if (c === l) break;
        for (; c.sibling === null; ) {
          if (c.return === null || c.return === l) return !0;
          c = c.return;
        }
        (c.sibling.return = c.return), (c = c.sibling);
      }
    }
    return !0;
  }
  function no(l, c) {
    for (
      c &= ~i0,
        c &= ~pd,
        l.suspendedLanes |= c,
        l.pingedLanes &= ~c,
        l = l.expirationTimes;
      0 < c;

    ) {
      var g = 31 - Gi(c),
        x = 1 << g;
      (l[g] = -1), (c &= ~x);
    }
  }
  function Pw(l) {
    if (bt & 6) throw Error(o(327));
    aa();
    var c = Dh(l, 0);
    if (!(c & 1)) return Li(l, Vn()), null;
    var g = Sd(l, c);
    if (l.tag !== 0 && g === 2) {
      var x = hv(l);
      x !== 0 && ((c = x), (g = l0(l, x)));
    }
    if (g === 1) throw ((g = dc), sa(l, 0), no(l, c), Li(l, Vn()), g);
    if (g === 6) throw Error(o(345));
    return (
      (l.finishedWork = l.current.alternate),
      (l.finishedLanes = c),
      oa(l, Ri),
      Li(l, Vn()),
      null
    );
  }
  function Rw(l) {
    eo !== null && eo.tag === 0 && !(bt & 6) && aa();
    var c = bt;
    bt |= 1;
    var g = xn.transition,
      x = Ot;
    try {
      if (((xn.transition = null), (Ot = 1), l)) return l();
    } finally {
      (Ot = x), (xn.transition = g), (bt = c), !(bt & 6) && Zr();
    }
  }
  function c0() {
    (Yi = Ml.current), ct(Ml);
  }
  function sa(l, c) {
    (l.finishedWork = null), (l.finishedLanes = 0);
    var g = l.timeoutHandle;
    if ((g !== rt && ((l.timeoutHandle = rt), it(g)), Cn !== null))
      for (g = Cn.return; g !== null; ) {
        var x = g;
        switch ((bv(x), x.tag)) {
          case 1:
            (x = x.type.childContextTypes), x != null && yn();
            break;
          case 3:
            _l(), ct(dn), ct(At), Dv();
            break;
          case 5:
            Iv(x);
            break;
          case 4:
            _l();
            break;
          case 13:
            ct(sn);
            break;
          case 19:
            ct(sn);
            break;
          case 10:
            Sv(x.type._context);
            break;
          case 22:
          case 23:
            c0();
        }
        g = g.return;
      }
    if (
      ((bn = l),
      (Cn = l = io(l.current, null)),
      (Kn = Yi = c),
      (In = 0),
      (dc = null),
      (i0 = pd = wl = 0),
      (Ri = pc = null),
      Kr !== null)
    ) {
      for (c = 0; c < Kr.length; c++)
        if (((g = Kr[c]), (x = g.interleaved), x !== null)) {
          g.interleaved = null;
          var E = x.next,
            A = g.pending;
          if (A !== null) {
            var F = A.next;
            (A.next = E), (x.next = F);
          }
          g.pending = x;
        }
      Kr = null;
    }
    return l;
  }
  function Lw(l, c) {
    do {
      var g = Cn;
      try {
        if ((_v(), (Yh.current = Jh), qh)) {
          for (var x = pn.memoizedState; x !== null; ) {
            var E = x.queue;
            E !== null && (E.pending = null), (x = x.next);
          }
          qh = !1;
        }
        if (
          ((Sl = 0),
          (Hn = ei = pn = null),
          (rc = !1),
          (sc = 0),
          (n0.current = null),
          g === null || g.return === null)
        ) {
          (In = 1), (dc = c), (Cn = null);
          break;
        }
        e: {
          var A = l,
            F = g.return,
            q = g,
            fe = c;
          if (
            ((c = Kn),
            (q.flags |= 32768),
            fe !== null &&
              typeof fe == "object" &&
              typeof fe.then == "function")
          ) {
            var Ae = fe,
              Xe = q,
              yt = Xe.tag;
            if (!(Xe.mode & 1) && (yt === 0 || yt === 11 || yt === 15)) {
              var ot = Xe.alternate;
              ot
                ? ((Xe.updateQueue = ot.updateQueue),
                  (Xe.memoizedState = ot.memoizedState),
                  (Xe.lanes = ot.lanes))
                : ((Xe.updateQueue = null), (Xe.memoizedState = null));
            }
            var Wt = $M(F);
            if (Wt !== null) {
              (Wt.flags &= -257),
                JM(Wt, F, q, A, c),
                Wt.mode & 1 && QM(A, Ae, c),
                (c = Wt),
                (fe = Ae);
              var Je = c.updateQueue;
              if (Je === null) {
                var ii = new Set();
                ii.add(fe), (c.updateQueue = ii);
              } else Je.add(fe);
              break e;
            } else {
              if (!(c & 1)) {
                QM(A, Ae, c), f0();
                break e;
              }
              fe = Error(o(426));
            }
          } else if (en && q.mode & 1) {
            var mr = $M(F);
            if (mr !== null) {
              !(mr.flags & 65536) && (mr.flags |= 256),
                JM(mr, F, q, A, c),
                Rv(fe);
              break e;
            }
          }
          (A = fe),
            In !== 4 && (In = 2),
            pc === null ? (pc = [A]) : pc.push(A),
            (fe = Vv(fe, q)),
            (q = F);
          do {
            switch (q.tag) {
              case 3:
                (q.flags |= 65536), (c &= -c), (q.lanes |= c);
                var ne = ZM(q, fe, c);
                vM(q, ne);
                break e;
              case 1:
                A = fe;
                var K = q.type,
                  ue = q.stateNode;
                if (
                  !(q.flags & 128) &&
                  (typeof K.getDerivedStateFromError == "function" ||
                    (ue !== null &&
                      typeof ue.componentDidCatch == "function" &&
                      (Js === null || !Js.has(ue))))
                ) {
                  (q.flags |= 65536), (c &= -c), (q.lanes |= c);
                  var Ue = KM(q, A, c);
                  vM(q, Ue);
                  break e;
                }
            }
            q = q.return;
          } while (q !== null);
        }
        Dw(g);
      } catch (Qe) {
        (c = Qe), Cn === g && g !== null && (Cn = g = g.return);
        continue;
      }
      break;
    } while (!0);
  }
  function Iw() {
    var l = dd.current;
    return (dd.current = Jh), l === null ? Jh : l;
  }
  function f0() {
    (In === 0 || In === 3 || In === 2) && (In = 4),
      bn === null || (!(wl & 268435455) && !(pd & 268435455)) || no(bn, Kn);
  }
  function Sd(l, c) {
    var g = bt;
    bt |= 2;
    var x = Iw();
    (bn === l && Kn === c) || sa(l, c);
    do
      try {
        LN();
        break;
      } catch (E) {
        Lw(l, E);
      }
    while (!0);
    if ((_v(), (bt = g), (dd.current = x), Cn !== null)) throw Error(o(261));
    return (bn = null), (Kn = 0), In;
  }
  function LN() {
    for (; Cn !== null; ) Nw(Cn);
  }
  function IN() {
    for (; Cn !== null && !rN(); ) Nw(Cn);
  }
  function Nw(l) {
    var c = kw(l.alternate, l, Yi);
    (l.memoizedProps = l.pendingProps),
      c === null ? Dw(l) : (Cn = c),
      (n0.current = null);
  }
  function Dw(l) {
    var c = l;
    do {
      var g = c.alternate;
      if (((l = c.return), c.flags & 32768)) {
        if (((g = EN(g, c)), g !== null)) {
          (g.flags &= 32767), (Cn = g);
          return;
        }
        if (l !== null)
          (l.flags |= 32768), (l.subtreeFlags = 0), (l.deletions = null);
        else {
          (In = 6), (Cn = null);
          return;
        }
      } else if (((g = SN(g, c, Yi)), g !== null)) {
        Cn = g;
        return;
      }
      if (((c = c.sibling), c !== null)) {
        Cn = c;
        return;
      }
      Cn = c = l;
    } while (c !== null);
    In === 0 && (In = 5);
  }
  function oa(l, c) {
    var g = Ot,
      x = xn.transition;
    try {
      (xn.transition = null), (Ot = 1), NN(l, c, g);
    } finally {
      (xn.transition = x), (Ot = g);
    }
    return null;
  }
  function NN(l, c, g) {
    do aa();
    while (eo !== null);
    if (bt & 6) throw Error(o(327));
    var x = l.finishedWork,
      E = l.finishedLanes;
    if (x === null) return null;
    if (((l.finishedWork = null), (l.finishedLanes = 0), x === l.current))
      throw Error(o(177));
    (l.callbackNode = null), (l.callbackPriority = 0);
    var A = x.lanes | x.childLanes;
    if (
      (iN(l, A),
      l === bn && ((Cn = bn = null), (Kn = 0)),
      (!(x.subtreeFlags & 2064) && !(x.flags & 2064)) ||
        gd ||
        ((gd = !0),
        Fw(vv, function () {
          return aa(), null;
        })),
      (A = (x.flags & 15990) !== 0),
      x.subtreeFlags & 15990 || A)
    ) {
      (A = xn.transition), (xn.transition = null);
      var F = Ot;
      Ot = 1;
      var q = bt;
      (bt |= 4),
        (n0.current = null),
        AN(l, x),
        bN(l, x),
        W(l.containerInfo),
        (l.current = x),
        CN(x),
        sN(),
        (bt = q),
        (Ot = F),
        (xn.transition = A);
    } else l.current = x;
    if (
      (gd && ((gd = !1), (eo = l), (vd = E)),
      (A = l.pendingLanes),
      A === 0 && (Js = null),
      lN(x.stateNode),
      Li(l, Vn()),
      c !== null)
    )
      for (g = l.onRecoverableError, x = 0; x < c.length; x++) g(c[x]);
    if (md) throw ((md = !1), (l = o0), (o0 = null), l);
    return (
      vd & 1 && l.tag !== 0 && aa(),
      (A = l.pendingLanes),
      A & 1 ? (l === a0 ? mc++ : ((mc = 0), (a0 = l))) : (mc = 0),
      Zr(),
      null
    );
  }
  function aa() {
    if (eo !== null) {
      var l = hM(vd),
        c = xn.transition,
        g = Ot;
      try {
        if (((xn.transition = null), (Ot = 16 > l ? 16 : l), eo === null))
          var x = !1;
        else {
          if (((l = eo), (eo = null), (vd = 0), bt & 6)) throw Error(o(331));
          var E = bt;
          for (bt |= 4, De = l.current; De !== null; ) {
            var A = De,
              F = A.child;
            if (De.flags & 16) {
              var q = A.deletions;
              if (q !== null) {
                for (var fe = 0; fe < q.length; fe++) {
                  var Ae = q[fe];
                  for (De = Ae; De !== null; ) {
                    var Xe = De;
                    switch (Xe.tag) {
                      case 0:
                      case 11:
                      case 15:
                        ra(8, Xe, A);
                    }
                    var yt = Xe.child;
                    if (yt !== null) (yt.return = Xe), (De = yt);
                    else
                      for (; De !== null; ) {
                        Xe = De;
                        var ot = Xe.sibling,
                          Wt = Xe.return;
                        if ((yw(Xe), Xe === Ae)) {
                          De = null;
                          break;
                        }
                        if (ot !== null) {
                          (ot.return = Wt), (De = ot);
                          break;
                        }
                        De = Wt;
                      }
                  }
                }
                var Je = A.alternate;
                if (Je !== null) {
                  var ii = Je.child;
                  if (ii !== null) {
                    Je.child = null;
                    do {
                      var mr = ii.sibling;
                      (ii.sibling = null), (ii = mr);
                    } while (ii !== null);
                  }
                }
                De = A;
              }
            }
            if (A.subtreeFlags & 2064 && F !== null) (F.return = A), (De = F);
            else
              e: for (; De !== null; ) {
                if (((A = De), A.flags & 2048))
                  switch (A.tag) {
                    case 0:
                    case 11:
                    case 15:
                      ra(9, A, A.return);
                  }
                var ne = A.sibling;
                if (ne !== null) {
                  (ne.return = A.return), (De = ne);
                  break e;
                }
                De = A.return;
              }
          }
          var K = l.current;
          for (De = K; De !== null; ) {
            F = De;
            var ue = F.child;
            if (F.subtreeFlags & 2064 && ue !== null)
              (ue.return = F), (De = ue);
            else
              e: for (F = K; De !== null; ) {
                if (((q = De), q.flags & 2048))
                  try {
                    switch (q.tag) {
                      case 0:
                      case 11:
                      case 15:
                        fc(9, q);
                    }
                  } catch (Qe) {
                    Ii(q, q.return, Qe);
                  }
                if (q === F) {
                  De = null;
                  break e;
                }
                var Ue = q.sibling;
                if (Ue !== null) {
                  (Ue.return = q.return), (De = Ue);
                  break e;
                }
                De = q.return;
              }
          }
          if (
            ((bt = E),
            Zr(),
            Yr && typeof Yr.onPostCommitFiberRoot == "function")
          )
            try {
              Yr.onPostCommitFiberRoot(Oh, l);
            } catch {}
          x = !0;
        }
        return x;
      } finally {
        (Ot = g), (xn.transition = c);
      }
    }
    return !1;
  }
  function Ow(l, c, g) {
    (c = Vv(g, c)),
      (c = ZM(l, c, 1)),
      $s(l, c),
      (c = yi()),
      (l = _d(l, 1)),
      l !== null && ($u(l, 1, c), Li(l, c));
  }
  function Ii(l, c, g) {
    if (l.tag === 3) Ow(l, l, g);
    else
      for (; c !== null; ) {
        if (c.tag === 3) {
          Ow(c, l, g);
          break;
        } else if (c.tag === 1) {
          var x = c.stateNode;
          if (
            typeof c.type.getDerivedStateFromError == "function" ||
            (typeof x.componentDidCatch == "function" &&
              (Js === null || !Js.has(x)))
          ) {
            (l = Vv(g, l)),
              (l = KM(c, l, 1)),
              $s(c, l),
              (l = yi()),
              (c = _d(c, 1)),
              c !== null && ($u(c, 1, l), Li(c, l));
            break;
          }
        }
        c = c.return;
      }
  }
  function DN(l, c, g) {
    var x = l.pingCache;
    x !== null && x.delete(c),
      (c = yi()),
      (l.pingedLanes |= l.suspendedLanes & g),
      bn === l &&
        (Kn & g) === g &&
        (In === 4 || (In === 3 && (Kn & 130023424) === Kn && 500 > Vn() - r0)
          ? sa(l, 0)
          : (i0 |= g)),
      Li(l, c);
  }
  function Uw(l, c) {
    c === 0 &&
      (l.mode & 1
        ? ((c = Nh), (Nh <<= 1), !(Nh & 130023424) && (Nh = 4194304))
        : (c = 1));
    var g = yi();
    (l = _d(l, c)), l !== null && ($u(l, c, g), Li(l, g));
  }
  function ON(l) {
    var c = l.memoizedState,
      g = 0;
    c !== null && (g = c.retryLane), Uw(l, g);
  }
  function UN(l, c) {
    var g = 0;
    switch (l.tag) {
      case 13:
        var x = l.stateNode,
          E = l.memoizedState;
        E !== null && (g = E.retryLane);
        break;
      case 19:
        x = l.stateNode;
        break;
      default:
        throw Error(o(314));
    }
    x !== null && x.delete(c), Uw(l, g);
  }
  var kw;
  kw = function (l, c, g) {
    if (l !== null)
      if (l.memoizedProps !== c.pendingProps || dn.current) Xi = !0;
      else {
        if (!(l.lanes & g) && !(c.flags & 128)) return (Xi = !1), wN(l, c, g);
        Xi = !!(l.flags & 131072);
      }
    else (Xi = !1), en && c.flags & 1048576 && wM(c, Wh, c.index);
    switch (((c.lanes = 0), c.tag)) {
      case 2:
        var x = c.type;
        l !== null &&
          ((l.alternate = null), (c.alternate = null), (c.flags |= 2)),
          (l = c.pendingProps);
        var E = ar(c, At.current);
        pl(c, g), (E = Uv(null, c, x, l, E, g));
        var A = kv();
        return (
          (c.flags |= 1),
          typeof E == "object" &&
          E !== null &&
          typeof E.render == "function" &&
          E.$$typeof === void 0
            ? ((c.tag = 1),
              (c.memoizedState = null),
              (c.updateQueue = null),
              Bn(x) ? ((A = !0), Zn(c)) : (A = !1),
              (c.memoizedState =
                E.state !== null && E.state !== void 0 ? E.state : null),
              wv(c),
              (E.updater = Hh),
              (c.stateNode = E),
              (E._reactInternals = c),
              Tv(c, x, l, g),
              (c = Wv(null, c, x, !0, A, g)))
            : ((c.tag = 0), en && A && Av(c), vi(null, c, E, g), (c = c.child)),
          c
        );
      case 16:
        x = c.elementType;
        e: {
          switch (
            (l !== null &&
              ((l.alternate = null), (c.alternate = null), (c.flags |= 2)),
            (l = c.pendingProps),
            (E = x._init),
            (x = E(x._payload)),
            (c.type = x),
            (E = c.tag = FN(x)),
            (l = Tr(x, l)),
            E)
          ) {
            case 0:
              c = Gv(null, c, x, l, g);
              break e;
            case 1:
              c = aw(null, c, x, l, g);
              break e;
            case 11:
              c = nw(null, c, x, l, g);
              break e;
            case 14:
              c = iw(null, c, x, Tr(x.type, l), g);
              break e;
          }
          throw Error(o(306, x, ""));
        }
        return c;
      case 0:
        return (
          (x = c.type),
          (E = c.pendingProps),
          (E = c.elementType === x ? E : Tr(x, E)),
          Gv(l, c, x, E, g)
        );
      case 1:
        return (
          (x = c.type),
          (E = c.pendingProps),
          (E = c.elementType === x ? E : Tr(x, E)),
          aw(l, c, x, E, g)
        );
      case 3:
        e: {
          if ((lw(c), l === null)) throw Error(o(387));
          (x = c.pendingProps),
            (A = c.memoizedState),
            (E = A.element),
            gM(l, c),
            Vh(c, x, null, g);
          var F = c.memoizedState;
          if (((x = F.element), Me && A.isDehydrated))
            if (
              ((A = {
                element: x,
                isDehydrated: !1,
                cache: F.cache,
                transitions: F.transitions,
              }),
              (c.updateQueue.baseState = A),
              (c.memoizedState = A),
              c.flags & 256)
            ) {
              (E = Error(o(423))), (c = uw(l, c, x, g, E));
              break e;
            } else if (x !== E) {
              (E = Error(o(424))), (c = uw(l, c, x, g, E));
              break e;
            } else
              for (
                Me &&
                  ((ji = Ph(c.stateNode.containerInfo)),
                  (Wi = c),
                  (en = !0),
                  (Ar = null),
                  (Ju = !1)),
                  g = PM(c, null, x, g),
                  c.child = g;
                g;

              )
                (g.flags = (g.flags & -3) | 4096), (g = g.sibling);
          else {
            if ((vl(), x === E)) {
              c = _s(l, c, g);
              break e;
            }
            vi(l, c, x, g);
          }
          c = c.child;
        }
        return c;
      case 5:
        return (
          RM(c),
          l === null && Pv(c),
          (x = c.type),
          (E = c.pendingProps),
          (A = l !== null ? l.memoizedProps : null),
          (F = E.children),
          Ee(x, E) ? (F = null) : A !== null && Ee(x, A) && (c.flags |= 32),
          ow(l, c),
          vi(l, c, F, g),
          c.child
        );
      case 6:
        return l === null && Pv(c), null;
      case 13:
        return cw(l, c, g);
      case 4:
        return (
          Lv(c, c.stateNode.containerInfo),
          (x = c.pendingProps),
          l === null ? (c.child = yl(c, null, x, g)) : vi(l, c, x, g),
          c.child
        );
      case 11:
        return (
          (x = c.type),
          (E = c.pendingProps),
          (E = c.elementType === x ? E : Tr(x, E)),
          nw(l, c, x, E, g)
        );
      case 7:
        return vi(l, c, c.pendingProps, g), c.child;
      case 8:
        return vi(l, c, c.pendingProps.children, g), c.child;
      case 12:
        return vi(l, c, c.pendingProps.children, g), c.child;
      case 10:
        e: {
          if (
            ((x = c.type._context),
            (E = c.pendingProps),
            (A = c.memoizedProps),
            (F = E.value),
            mM(c, x, F),
            A !== null)
          )
            if (qr(A.value, F)) {
              if (A.children === E.children && !dn.current) {
                c = _s(l, c, g);
                break e;
              }
            } else
              for (A = c.child, A !== null && (A.return = c); A !== null; ) {
                var q = A.dependencies;
                if (q !== null) {
                  F = A.child;
                  for (var fe = q.firstContext; fe !== null; ) {
                    if (fe.context === x) {
                      if (A.tag === 1) {
                        (fe = gs(-1, g & -g)), (fe.tag = 2);
                        var Ae = A.updateQueue;
                        if (Ae !== null) {
                          Ae = Ae.shared;
                          var Xe = Ae.pending;
                          Xe === null
                            ? (fe.next = fe)
                            : ((fe.next = Xe.next), (Xe.next = fe)),
                            (Ae.pending = fe);
                        }
                      }
                      (A.lanes |= g),
                        (fe = A.alternate),
                        fe !== null && (fe.lanes |= g),
                        Mv(A.return, g, c),
                        (q.lanes |= g);
                      break;
                    }
                    fe = fe.next;
                  }
                } else if (A.tag === 10) F = A.type === c.type ? null : A.child;
                else if (A.tag === 18) {
                  if (((F = A.return), F === null)) throw Error(o(341));
                  (F.lanes |= g),
                    (q = F.alternate),
                    q !== null && (q.lanes |= g),
                    Mv(F, g, c),
                    (F = A.sibling);
                } else F = A.child;
                if (F !== null) F.return = A;
                else
                  for (F = A; F !== null; ) {
                    if (F === c) {
                      F = null;
                      break;
                    }
                    if (((A = F.sibling), A !== null)) {
                      (A.return = F.return), (F = A);
                      break;
                    }
                    F = F.return;
                  }
                A = F;
              }
          vi(l, c, E.children, g), (c = c.child);
        }
        return c;
      case 9:
        return (
          (E = c.type),
          (x = c.pendingProps.children),
          pl(c, g),
          (E = lr(E)),
          (x = x(E)),
          (c.flags |= 1),
          vi(l, c, x, g),
          c.child
        );
      case 14:
        return (
          (x = c.type),
          (E = Tr(x, c.pendingProps)),
          (E = Tr(x.type, E)),
          iw(l, c, x, E, g)
        );
      case 15:
        return rw(l, c, c.type, c.pendingProps, g);
      case 17:
        return (
          (x = c.type),
          (E = c.pendingProps),
          (E = c.elementType === x ? E : Tr(x, E)),
          l !== null &&
            ((l.alternate = null), (c.alternate = null), (c.flags |= 2)),
          (c.tag = 1),
          Bn(x) ? ((l = !0), Zn(c)) : (l = !1),
          pl(c, g),
          SM(c, x, E),
          Tv(c, x, E, g),
          Wv(null, c, x, !0, l, g)
        );
      case 19:
        return pw(l, c, g);
      case 22:
        return sw(l, c, g);
    }
    throw Error(o(156, c.tag));
  };
  function Fw(l, c) {
    return mv(l, c);
  }
  function kN(l, c, g, x) {
    (this.tag = l),
      (this.key = g),
      (this.sibling =
        this.child =
        this.return =
        this.stateNode =
        this.type =
        this.elementType =
          null),
      (this.index = 0),
      (this.ref = null),
      (this.pendingProps = c),
      (this.dependencies =
        this.memoizedState =
        this.updateQueue =
        this.memoizedProps =
          null),
      (this.mode = x),
      (this.subtreeFlags = this.flags = 0),
      (this.deletions = null),
      (this.childLanes = this.lanes = 0),
      (this.alternate = null);
  }
  function pr(l, c, g, x) {
    return new kN(l, c, g, x);
  }
  function h0(l) {
    return (l = l.prototype), !(!l || !l.isReactComponent);
  }
  function FN(l) {
    if (typeof l == "function") return h0(l) ? 1 : 0;
    if (l != null) {
      if (((l = l.$$typeof), l === w)) return 11;
      if (l === M) return 14;
    }
    return 2;
  }
  function io(l, c) {
    var g = l.alternate;
    return (
      g === null
        ? ((g = pr(l.tag, c, l.key, l.mode)),
          (g.elementType = l.elementType),
          (g.type = l.type),
          (g.stateNode = l.stateNode),
          (g.alternate = l),
          (l.alternate = g))
        : ((g.pendingProps = c),
          (g.type = l.type),
          (g.flags = 0),
          (g.subtreeFlags = 0),
          (g.deletions = null)),
      (g.flags = l.flags & 14680064),
      (g.childLanes = l.childLanes),
      (g.lanes = l.lanes),
      (g.child = l.child),
      (g.memoizedProps = l.memoizedProps),
      (g.memoizedState = l.memoizedState),
      (g.updateQueue = l.updateQueue),
      (c = l.dependencies),
      (g.dependencies =
        c === null ? null : { lanes: c.lanes, firstContext: c.firstContext }),
      (g.sibling = l.sibling),
      (g.index = l.index),
      (g.ref = l.ref),
      g
    );
  }
  function Md(l, c, g, x, E, A) {
    var F = 2;
    if (((x = l), typeof l == "function")) h0(l) && (F = 1);
    else if (typeof l == "string") F = 5;
    else
      e: switch (l) {
        case h:
          return la(g.children, E, A, c);
        case d:
          (F = 8), (E |= 8);
          break;
        case p:
          return (
            (l = pr(12, g, c, E | 2)), (l.elementType = p), (l.lanes = A), l
          );
        case S:
          return (l = pr(13, g, c, E)), (l.elementType = S), (l.lanes = A), l;
        case v:
          return (l = pr(19, g, c, E)), (l.elementType = v), (l.lanes = A), l;
        case T:
          return wd(g, E, A, c);
        default:
          if (typeof l == "object" && l !== null)
            switch (l.$$typeof) {
              case m:
                F = 10;
                break e;
              case y:
                F = 9;
                break e;
              case w:
                F = 11;
                break e;
              case M:
                F = 14;
                break e;
              case _:
                (F = 16), (x = null);
                break e;
            }
          throw Error(o(130, l == null ? l : typeof l, ""));
      }
    return (
      (c = pr(F, g, c, E)), (c.elementType = l), (c.type = x), (c.lanes = A), c
    );
  }
  function la(l, c, g, x) {
    return (l = pr(7, l, x, c)), (l.lanes = g), l;
  }
  function wd(l, c, g, x) {
    return (
      (l = pr(22, l, x, c)),
      (l.elementType = T),
      (l.lanes = g),
      (l.stateNode = {}),
      l
    );
  }
  function d0(l, c, g) {
    return (l = pr(6, l, null, c)), (l.lanes = g), l;
  }
  function p0(l, c, g) {
    return (
      (c = pr(4, l.children !== null ? l.children : [], l.key, c)),
      (c.lanes = g),
      (c.stateNode = {
        containerInfo: l.containerInfo,
        pendingChildren: null,
        implementation: l.implementation,
      }),
      c
    );
  }
  function zN(l, c, g, x, E) {
    (this.tag = c),
      (this.containerInfo = l),
      (this.finishedWork =
        this.pingCache =
        this.current =
        this.pendingChildren =
          null),
      (this.timeoutHandle = rt),
      (this.callbackNode = this.pendingContext = this.context = null),
      (this.callbackPriority = 0),
      (this.eventTimes = dv(0)),
      (this.expirationTimes = dv(-1)),
      (this.entangledLanes =
        this.finishedLanes =
        this.mutableReadLanes =
        this.expiredLanes =
        this.pingedLanes =
        this.suspendedLanes =
        this.pendingLanes =
          0),
      (this.entanglements = dv(0)),
      (this.identifierPrefix = x),
      (this.onRecoverableError = E),
      Me && (this.mutableSourceEagerHydrationData = null);
  }
  function zw(l, c, g, x, E, A, F, q, fe) {
    return (
      (l = new zN(l, c, g, q, fe)),
      c === 1 ? ((c = 1), A === !0 && (c |= 8)) : (c = 0),
      (A = pr(3, null, null, c)),
      (l.current = A),
      (A.stateNode = l),
      (A.memoizedState = {
        element: x,
        isDehydrated: g,
        cache: null,
        transitions: null,
      }),
      wv(A),
      l
    );
  }
  function Bw(l) {
    if (!l) return or;
    l = l._reactInternals;
    e: {
      if (C(l) !== l || l.tag !== 1) throw Error(o(170));
      var c = l;
      do {
        switch (c.tag) {
          case 3:
            c = c.stateNode.context;
            break e;
          case 1:
            if (Bn(c.type)) {
              c = c.stateNode.__reactInternalMemoizedMergedChildContext;
              break e;
            }
        }
        c = c.return;
      } while (c !== null);
      throw Error(o(171));
    }
    if (l.tag === 1) {
      var g = l.type;
      if (Bn(g)) return fl(l, g, c);
    }
    return c;
  }
  function Vw(l) {
    var c = l._reactInternals;
    if (c === void 0)
      throw typeof l.render == "function"
        ? Error(o(188))
        : ((l = Object.keys(l).join(",")), Error(o(268, l)));
    return (l = Z(c)), l === null ? null : l.stateNode;
  }
  function Hw(l, c) {
    if (((l = l.memoizedState), l !== null && l.dehydrated !== null)) {
      var g = l.retryLane;
      l.retryLane = g !== 0 && g < c ? g : c;
    }
  }
  function m0(l, c) {
    Hw(l, c), (l = l.alternate) && Hw(l, c);
  }
  function BN(l) {
    return (l = Z(l)), l === null ? null : l.stateNode;
  }
  function VN() {
    return null;
  }
  return (
    (t.attemptContinuousHydration = function (l) {
      if (l.tag === 13) {
        var c = yi();
        dr(l, 134217728, c), m0(l, 134217728);
      }
    }),
    (t.attemptHydrationAtCurrentPriority = function (l) {
      if (l.tag === 13) {
        var c = yi(),
          g = to(l);
        dr(l, g, c), m0(l, g);
      }
    }),
    (t.attemptSynchronousHydration = function (l) {
      switch (l.tag) {
        case 3:
          var c = l.stateNode;
          if (c.current.memoizedState.isDehydrated) {
            var g = Qu(c.pendingLanes);
            g !== 0 && (pv(c, g | 1), Li(c, Vn()), !(bt & 6) && (El(), Zr()));
          }
          break;
        case 13:
          var x = yi();
          Rw(function () {
            return dr(l, 1, x);
          }),
            m0(l, 1);
      }
    }),
    (t.batchedUpdates = function (l, c) {
      var g = bt;
      bt |= 1;
      try {
        return l(c);
      } finally {
        (bt = g), bt === 0 && (El(), Uh && Zr());
      }
    }),
    (t.createComponentSelector = function (l) {
      return { $$typeof: ld, value: l };
    }),
    (t.createContainer = function (l, c, g, x, E, A, F) {
      return zw(l, c, !1, null, g, x, E, A, F);
    }),
    (t.createHasPseudoClassSelector = function (l) {
      return { $$typeof: ud, value: l };
    }),
    (t.createHydrationContainer = function (l, c, g, x, E, A, F, q, fe) {
      return (
        (l = zw(g, x, !0, l, E, A, F, q, fe)),
        (l.context = Bw(null)),
        (g = l.current),
        (x = yi()),
        (E = to(g)),
        (A = gs(x, E)),
        (A.callback = c ?? null),
        $s(g, A),
        (l.current.lanes = E),
        $u(l, E, x),
        Li(l, x),
        l
      );
    }),
    (t.createPortal = function (l, c, g) {
      var x =
        3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
      return {
        $$typeof: f,
        key: x == null ? null : "" + x,
        children: l,
        containerInfo: c,
        implementation: g,
      };
    }),
    (t.createRoleSelector = function (l) {
      return { $$typeof: cd, value: l };
    }),
    (t.createTestNameSelector = function (l) {
      return { $$typeof: fd, value: l };
    }),
    (t.createTextSelector = function (l) {
      return { $$typeof: hd, value: l };
    }),
    (t.deferredUpdates = function (l) {
      var c = Ot,
        g = xn.transition;
      try {
        return (xn.transition = null), (Ot = 16), l();
      } finally {
        (Ot = c), (xn.transition = g);
      }
    }),
    (t.discreteUpdates = function (l, c, g, x, E) {
      var A = Ot,
        F = xn.transition;
      try {
        return (xn.transition = null), (Ot = 1), l(c, g, x, E);
      } finally {
        (Ot = A), (xn.transition = F), bt === 0 && El();
      }
    }),
    (t.findAllNodes = t0),
    (t.findBoundingRects = function (l, c) {
      if (!I) throw Error(o(363));
      (c = t0(l, c)), (l = []);
      for (var g = 0; g < c.length; g++) l.push(xe(c[g]));
      for (c = l.length - 1; 0 < c; c--) {
        g = l[c];
        for (
          var x = g.x, E = x + g.width, A = g.y, F = A + g.height, q = c - 1;
          0 <= q;
          q--
        )
          if (c !== q) {
            var fe = l[q],
              Ae = fe.x,
              Xe = Ae + fe.width,
              yt = fe.y,
              ot = yt + fe.height;
            if (x >= Ae && A >= yt && E <= Xe && F <= ot) {
              l.splice(c, 1);
              break;
            } else if (x !== Ae || g.width !== fe.width || ot < A || yt > F) {
              if (!(A !== yt || g.height !== fe.height || Xe < x || Ae > E)) {
                Ae > x && ((fe.width += Ae - x), (fe.x = x)),
                  Xe < E && (fe.width = E - Ae),
                  l.splice(c, 1);
                break;
              }
            } else {
              yt > A && ((fe.height += yt - A), (fe.y = A)),
                ot < F && (fe.height = F - yt),
                l.splice(c, 1);
              break;
            }
          }
      }
      return l;
    }),
    (t.findHostInstance = Vw),
    (t.findHostInstanceWithNoPortals = function (l) {
      return (
        (l = B(l)),
        (l = l !== null ? V(l) : null),
        l === null ? null : l.stateNode
      );
    }),
    (t.findHostInstanceWithWarning = function (l) {
      return Vw(l);
    }),
    (t.flushControlled = function (l) {
      var c = bt;
      bt |= 1;
      var g = xn.transition,
        x = Ot;
      try {
        (xn.transition = null), (Ot = 1), l();
      } finally {
        (Ot = x), (xn.transition = g), (bt = c), bt === 0 && (El(), Zr());
      }
    }),
    (t.flushPassiveEffects = aa),
    (t.flushSync = Rw),
    (t.focusWithin = function (l, c) {
      if (!I) throw Error(o(363));
      for (l = $v(l), c = bw(l, c), c = Array.from(c), l = 0; l < c.length; ) {
        var g = c[l++];
        if (!ge(g)) {
          if (g.tag === 5 && Le(g.stateNode)) return !0;
          for (g = g.child; g !== null; ) c.push(g), (g = g.sibling);
        }
      }
      return !1;
    }),
    (t.getCurrentUpdatePriority = function () {
      return Ot;
    }),
    (t.getFindAllNodesFailureDescription = function (l, c) {
      if (!I) throw Error(o(363));
      var g = 0,
        x = [];
      l = [$v(l), 0];
      for (var E = 0; E < l.length; ) {
        var A = l[E++],
          F = l[E++],
          q = c[F];
        if (
          (A.tag !== 5 || !ge(A)) &&
          (Jv(A, q) && (x.push(e0(q)), F++, F > g && (g = F)), F < c.length)
        )
          for (A = A.child; A !== null; ) l.push(A, F), (A = A.sibling);
      }
      if (g < c.length) {
        for (l = []; g < c.length; g++) l.push(e0(c[g]));
        return (
          `findAllNodes was able to match part of the selector:
  ` +
          (x.join(" > ") +
            `

No matching component was found for:
  `) +
          l.join(" > ")
        );
      }
      return null;
    }),
    (t.getPublicRootInstance = function (l) {
      if (((l = l.current), !l.child)) return null;
      switch (l.child.tag) {
        case 5:
          return $(l.child.stateNode);
        default:
          return l.child.stateNode;
      }
    }),
    (t.injectIntoDevTools = function (l) {
      if (
        ((l = {
          bundleType: l.bundleType,
          version: l.version,
          rendererPackageName: l.rendererPackageName,
          rendererConfig: l.rendererConfig,
          overrideHookState: null,
          overrideHookStateDeletePath: null,
          overrideHookStateRenamePath: null,
          overrideProps: null,
          overridePropsDeletePath: null,
          overridePropsRenamePath: null,
          setErrorHandler: null,
          setSuspenseHandler: null,
          scheduleUpdate: null,
          currentDispatcherRef: a.ReactCurrentDispatcher,
          findHostInstanceByFiber: BN,
          findFiberByHostInstance: l.findFiberByHostInstance || VN,
          findHostInstancesForRefresh: null,
          scheduleRefresh: null,
          scheduleRoot: null,
          setRefreshHandler: null,
          getCurrentFiber: null,
          reconcilerVersion: "18.0.0-fc46dba67-20220329",
        }),
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
      )
        l = !1;
      else {
        var c = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (c.isDisabled || !c.supportsFiber) l = !0;
        else {
          try {
            (Oh = c.inject(l)), (Yr = c);
          } catch {}
          l = !!c.checkDCE;
        }
      }
      return l;
    }),
    (t.isAlreadyRendering = function () {
      return !1;
    }),
    (t.observeVisibleRects = function (l, c, g, x) {
      if (!I) throw Error(o(363));
      l = t0(l, c);
      var E = Fe(l, g, x).disconnect;
      return {
        disconnect: function () {
          E();
        },
      };
    }),
    (t.registerMutableSourceForHydration = function (l, c) {
      var g = c._getVersion;
      (g = g(c._source)),
        l.mutableSourceEagerHydrationData == null
          ? (l.mutableSourceEagerHydrationData = [c, g])
          : l.mutableSourceEagerHydrationData.push(c, g);
    }),
    (t.runWithPriority = function (l, c) {
      var g = Ot;
      try {
        return (Ot = l), c();
      } finally {
        Ot = g;
      }
    }),
    (t.shouldError = function () {
      return null;
    }),
    (t.shouldSuspend = function () {
      return !1;
    }),
    (t.updateContainer = function (l, c, g, x) {
      var E = c.current,
        A = yi(),
        F = to(E);
      return (
        (g = Bw(g)),
        c.context === null ? (c.context = g) : (c.pendingContext = g),
        (c = gs(A, F)),
        (c.payload = { element: l }),
        (x = x === void 0 ? null : x),
        x !== null && (c.callback = x),
        $s(E, c),
        (l = dr(E, F, A)),
        l !== null && Bh(l, E, F),
        F
      );
    }),
    t
  );
};
DI.exports = VW;
var HW = DI.exports;
const GW = gb(HW),
  cM = {},
  WW = (n) => void Object.assign(cM, n);
function jW(n, e) {
  function t(h, { args: d = [], attach: p, ...m }, y) {
    let w = `${h[0].toUpperCase()}${h.slice(1)}`,
      S;
    if (h === "primitive") {
      if (m.object === void 0)
        throw new Error("R3F: Primitives without 'object' are invalid!");
      const v = m.object;
      S = Zl(v, { type: h, root: y, attach: p, primitive: !0 });
    } else {
      const v = cM[w];
      if (!v)
        throw new Error(
          `R3F: ${w} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`
        );
      if (!Array.isArray(d))
        throw new Error("R3F: The args prop must be an array!");
      S = Zl(new v(...d), {
        type: h,
        root: y,
        attach: p,
        memoizedProps: { args: d },
      });
    }
    return (
      S.__r3f.attach === void 0 &&
        (S.isBufferGeometry
          ? (S.__r3f.attach = "geometry")
          : S.isMaterial && (S.__r3f.attach = "material")),
      w !== "inject" && Wy(S, m),
      S
    );
  }
  function i(h, d) {
    let p = !1;
    if (d) {
      var m, y;
      (m = d.__r3f) != null && m.attach
        ? Gy(h, d, d.__r3f.attach)
        : d.isObject3D && h.isObject3D && (h.add(d), (p = !0)),
        p || (y = h.__r3f) == null || y.objects.push(d),
        d.__r3f || Zl(d, {}),
        (d.__r3f.parent = h),
        q_(d),
        Kl(d);
    }
  }
  function r(h, d, p) {
    let m = !1;
    if (d) {
      var y, w;
      if ((y = d.__r3f) != null && y.attach) Gy(h, d, d.__r3f.attach);
      else if (d.isObject3D && h.isObject3D) {
        (d.parent = h),
          d.dispatchEvent({ type: "added" }),
          h.dispatchEvent({ type: "childadded", child: d });
        const S = h.children.filter((M) => M !== d),
          v = S.indexOf(p);
        (h.children = [...S.slice(0, v), d, ...S.slice(v)]), (m = !0);
      }
      m || (w = h.__r3f) == null || w.objects.push(d),
        d.__r3f || Zl(d, {}),
        (d.__r3f.parent = h),
        q_(d),
        Kl(d);
    }
  }
  function s(h, d, p = !1) {
    h && [...h].forEach((m) => o(d, m, p));
  }
  function o(h, d, p) {
    if (d) {
      var m, y, w;
      if (
        (d.__r3f && (d.__r3f.parent = null),
        (m = h.__r3f) != null &&
          m.objects &&
          (h.__r3f.objects = h.__r3f.objects.filter((T) => T !== d)),
        (y = d.__r3f) != null && y.attach)
      )
        rb(h, d, d.__r3f.attach);
      else if (d.isObject3D && h.isObject3D) {
        var S;
        h.remove(d), (S = d.__r3f) != null && S.root && $W(pm(d), d);
      }
      const M = (w = d.__r3f) == null ? void 0 : w.primitive,
        _ = !M && (p === void 0 ? d.dispose !== null : p);
      if (!M) {
        var v;
        s((v = d.__r3f) == null ? void 0 : v.objects, d, _),
          s(d.children, d, _);
      }
      if ((delete d.__r3f, _ && d.dispose && d.type !== "Scene")) {
        const T = () => {
          try {
            d.dispose();
          } catch {}
        };
        typeof IS_REACT_ACT_ENVIRONMENT > "u"
          ? X_.unstable_scheduleCallback(X_.unstable_IdlePriority, T)
          : T();
      }
      Kl(h);
    }
  }
  function a(h, d, p, m) {
    var y;
    const w = (y = h.__r3f) == null ? void 0 : y.parent;
    if (!w) return;
    const S = t(d, p, h.__r3f.root);
    if (h.children) {
      for (const v of h.children) v.__r3f && i(S, v);
      h.children = h.children.filter((v) => !v.__r3f);
    }
    h.__r3f.objects.forEach((v) => i(S, v)),
      (h.__r3f.objects = []),
      h.__r3f.autoRemovedBeforeAppend || o(w, h),
      S.parent && (S.__r3f.autoRemovedBeforeAppend = !0),
      i(w, S),
      S.raycast &&
        S.__r3f.eventCount &&
        pm(S).getState().internal.interaction.push(S),
      [m, m.alternate].forEach((v) => {
        v !== null &&
          ((v.stateNode = S),
          v.ref &&
            (typeof v.ref == "function" ? v.ref(S) : (v.ref.current = S)));
      });
  }
  const u = () => {};
  return {
    reconciler: GW({
      createInstance: t,
      removeChild: o,
      appendChild: i,
      appendInitialChild: i,
      insertBefore: r,
      supportsMutation: !0,
      isPrimaryRenderer: !1,
      supportsPersistence: !1,
      supportsHydration: !1,
      noTimeout: -1,
      appendChildToContainer: (h, d) => {
        if (!d) return;
        const p = h.getState().scene;
        p.__r3f && ((p.__r3f.root = h), i(p, d));
      },
      removeChildFromContainer: (h, d) => {
        d && o(h.getState().scene, d);
      },
      insertInContainerBefore: (h, d, p) => {
        if (!d || !p) return;
        const m = h.getState().scene;
        m.__r3f && r(m, d, p);
      },
      getRootHostContext: () => null,
      getChildHostContext: (h) => h,
      finalizeInitialChildren(h) {
        var d;
        return !!((d = h == null ? void 0 : h.__r3f) != null ? d : {}).handlers;
      },
      prepareUpdate(h, d, p, m) {
        var y;
        if (
          ((y = h == null ? void 0 : h.__r3f) != null ? y : {}).primitive &&
          m.object &&
          m.object !== h
        )
          return [!0];
        {
          const { args: S = [], children: v, ...M } = m,
            { args: _ = [], children: T, ...P } = p;
          if (!Array.isArray(S))
            throw new Error("R3F: the args prop must be an array!");
          if (S.some((L, N) => L !== _[N])) return [!0];
          const b = GI(h, M, P, !0);
          return b.changes.length ? [!1, b] : null;
        }
      },
      commitUpdate(h, [d, p], m, y, w, S) {
        d ? a(h, m, w, S) : Wy(h, p);
      },
      commitMount(h, d, p, m) {
        var y;
        const w = (y = h.__r3f) != null ? y : {};
        h.raycast &&
          w.handlers &&
          w.eventCount &&
          pm(h).getState().internal.interaction.push(h);
      },
      getPublicInstance: (h) => h,
      prepareForCommit: () => null,
      preparePortalMount: (h) => Zl(h.getState().scene),
      resetAfterCommit: () => {},
      shouldSetTextContent: () => !1,
      clearContainer: () => !1,
      hideInstance(h) {
        var d;
        const { attach: p, parent: m } = (d = h.__r3f) != null ? d : {};
        p && m && rb(m, h, p), h.isObject3D && (h.visible = !1), Kl(h);
      },
      unhideInstance(h, d) {
        var p;
        const { attach: m, parent: y } = (p = h.__r3f) != null ? p : {};
        m && y && Gy(y, h, m),
          ((h.isObject3D && d.visible == null) || d.visible) &&
            (h.visible = !0),
          Kl(h);
      },
      createTextInstance: u,
      hideTextInstance: u,
      unhideTextInstance: u,
      getCurrentEventPriority: () => (e ? e() : yu.DefaultEventPriority),
      beforeActiveInstanceBlur: () => {},
      afterActiveInstanceBlur: () => {},
      detachDeletedInstance: () => {},
      now:
        typeof performance < "u" && Kt.fun(performance.now)
          ? performance.now
          : Kt.fun(Date.now)
          ? Date.now
          : () => 0,
      scheduleTimeout: Kt.fun(setTimeout) ? setTimeout : void 0,
      cancelTimeout: Kt.fun(clearTimeout) ? clearTimeout : void 0,
    }),
    applyProps: Wy,
  };
}
var eb, tb;
const Hy = (n) => "colorSpace" in n || "outputColorSpace" in n,
  kI = () => {
    var n;
    return (n = cM.ColorManagement) != null ? n : null;
  },
  FI = (n) => n && n.isOrthographicCamera,
  XW = (n) => n && n.hasOwnProperty("current"),
  bh =
    typeof window < "u" &&
    (((eb = window.document) != null && eb.createElement) ||
      ((tb = window.navigator) == null ? void 0 : tb.product) === "ReactNative")
      ? se.useLayoutEffect
      : se.useEffect;
function zI(n) {
  const e = se.useRef(n);
  return bh(() => void (e.current = n), [n]), e;
}
function YW({ set: n }) {
  return bh(() => (n(new Promise(() => null)), () => n(!1)), [n]), null;
}
class BI extends se.Component {
  constructor(...e) {
    super(...e), (this.state = { error: !1 });
  }
  componentDidCatch(e) {
    this.props.set(e);
  }
  render() {
    return this.state.error ? null : this.props.children;
  }
}
BI.getDerivedStateFromError = () => ({ error: !0 });
const VI = "__default",
  nb = new Map(),
  qW = (n) => n && !!n.memoized && !!n.changes;
function HI(n) {
  var e;
  const t =
    typeof window < "u" ? ((e = window.devicePixelRatio) != null ? e : 2) : 1;
  return Array.isArray(n) ? Math.min(Math.max(n[0], t), n[1]) : n;
}
const kc = (n) => {
  var e;
  return (e = n.__r3f) == null ? void 0 : e.root.getState();
};
function pm(n) {
  let e = n.__r3f.root;
  for (; e.getState().previousRoot; ) e = e.getState().previousRoot;
  return e;
}
const Kt = {
  obj: (n) => n === Object(n) && !Kt.arr(n) && typeof n != "function",
  fun: (n) => typeof n == "function",
  str: (n) => typeof n == "string",
  num: (n) => typeof n == "number",
  boo: (n) => typeof n == "boolean",
  und: (n) => n === void 0,
  arr: (n) => Array.isArray(n),
  equ(
    n,
    e,
    { arrays: t = "shallow", objects: i = "reference", strict: r = !0 } = {}
  ) {
    if (typeof n != typeof e || !!n != !!e) return !1;
    if (Kt.str(n) || Kt.num(n) || Kt.boo(n)) return n === e;
    const s = Kt.obj(n);
    if (s && i === "reference") return n === e;
    const o = Kt.arr(n);
    if (o && t === "reference") return n === e;
    if ((o || s) && n === e) return !0;
    let a;
    for (a in n) if (!(a in e)) return !1;
    if (s && t === "shallow" && i === "shallow") {
      for (a in r ? e : n)
        if (!Kt.equ(n[a], e[a], { strict: r, objects: "reference" })) return !1;
    } else for (a in r ? e : n) if (n[a] !== e[a]) return !1;
    if (Kt.und(a)) {
      if (
        (o && n.length === 0 && e.length === 0) ||
        (s && Object.keys(n).length === 0 && Object.keys(e).length === 0)
      )
        return !0;
      if (n !== e) return !1;
    }
    return !0;
  },
};
function ZW(n) {
  n.dispose && n.type !== "Scene" && n.dispose();
  for (const e in n) e.dispose == null || e.dispose(), delete n[e];
}
function Zl(n, e) {
  const t = n;
  return (
    (t.__r3f = {
      type: "",
      root: null,
      previousAttach: null,
      memoizedProps: {},
      eventCount: 0,
      handlers: {},
      objects: [],
      parent: null,
      ...e,
    }),
    n
  );
}
function Y_(n, e) {
  let t = n;
  if (e.includes("-")) {
    const i = e.split("-"),
      r = i.pop();
    return (t = i.reduce((s, o) => s[o], n)), { target: t, key: r };
  } else return { target: t, key: e };
}
const ib = /-\d+$/;
function Gy(n, e, t) {
  if (Kt.str(t)) {
    if (ib.test(t)) {
      const s = t.replace(ib, ""),
        { target: o, key: a } = Y_(n, s);
      Array.isArray(o[a]) || (o[a] = []);
    }
    const { target: i, key: r } = Y_(n, t);
    (e.__r3f.previousAttach = i[r]), (i[r] = e);
  } else e.__r3f.previousAttach = t(n, e);
}
function rb(n, e, t) {
  var i, r;
  if (Kt.str(t)) {
    const { target: s, key: o } = Y_(n, t),
      a = e.__r3f.previousAttach;
    a === void 0 ? delete s[o] : (s[o] = a);
  } else
    (i = e.__r3f) == null || i.previousAttach == null || i.previousAttach(n, e);
  (r = e.__r3f) == null || delete r.previousAttach;
}
function GI(
  n,
  { children: e, key: t, ref: i, ...r },
  { children: s, key: o, ref: a, ...u } = {},
  f = !1
) {
  const h = n.__r3f,
    d = Object.entries(r),
    p = [];
  if (f) {
    const y = Object.keys(u);
    for (let w = 0; w < y.length; w++)
      r.hasOwnProperty(y[w]) || d.unshift([y[w], VI + "remove"]);
  }
  d.forEach(([y, w]) => {
    var S;
    if (
      ((S = n.__r3f) != null && S.primitive && y === "object") ||
      Kt.equ(w, u[y])
    )
      return;
    if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(y))
      return p.push([y, w, !0, []]);
    let v = [];
    y.includes("-") && (v = y.split("-")), p.push([y, w, !1, v]);
    for (const M in r) {
      const _ = r[M];
      M.startsWith(`${y}-`) && p.push([M, _, !1, M.split("-")]);
    }
  });
  const m = { ...r };
  return (
    h != null &&
      h.memoizedProps &&
      h != null &&
      h.memoizedProps.args &&
      (m.args = h.memoizedProps.args),
    h != null &&
      h.memoizedProps &&
      h != null &&
      h.memoizedProps.attach &&
      (m.attach = h.memoizedProps.attach),
    { memoized: m, changes: p }
  );
}
function Wy(n, e) {
  var t;
  const i = n.__r3f,
    r = i == null ? void 0 : i.root,
    s = r == null || r.getState == null ? void 0 : r.getState(),
    { memoized: o, changes: a } = qW(e) ? e : GI(n, e),
    u = i == null ? void 0 : i.eventCount;
  n.__r3f && (n.__r3f.memoizedProps = o);
  for (let p = 0; p < a.length; p++) {
    let [m, y, w, S] = a[p];
    if (Hy(n)) {
      const T = "srgb",
        P = "srgb-linear";
      m === "encoding"
        ? ((m = "colorSpace"), (y = y === 3001 ? T : P))
        : m === "outputEncoding" &&
          ((m = "outputColorSpace"), (y = y === 3001 ? T : P));
    }
    let v = n,
      M = v[m];
    if (S.length && ((M = S.reduce((_, T) => _[T], n)), !(M && M.set))) {
      const [_, ...T] = S.reverse();
      (v = T.reverse().reduce((P, b) => P[b], n)), (m = _);
    }
    if (y === VI + "remove")
      if (v.constructor) {
        let _ = nb.get(v.constructor);
        _ || ((_ = new v.constructor()), nb.set(v.constructor, _)), (y = _[m]);
      } else y = 0;
    if (w && i)
      y ? (i.handlers[m] = y) : delete i.handlers[m],
        (i.eventCount = Object.keys(i.handlers).length);
    else if (M && M.set && (M.copy || M instanceof Ga)) {
      if (Array.isArray(y)) M.fromArray ? M.fromArray(y) : M.set(...y);
      else if (M.copy && y && y.constructor && M.constructor === y.constructor)
        M.copy(y);
      else if (y !== void 0) {
        var f;
        const _ = (f = M) == null ? void 0 : f.isColor;
        !_ && M.setScalar
          ? M.setScalar(y)
          : M instanceof Ga && y instanceof Ga
          ? (M.mask = y.mask)
          : M.set(y),
          !kI() && s && !s.linear && _ && M.convertSRGBToLinear();
      }
    } else {
      var h;
      if (
        ((v[m] = y),
        (h = v[m]) != null &&
          h.isTexture &&
          v[m].format === wi &&
          v[m].type === cs &&
          s)
      ) {
        const _ = v[m];
        Hy(_) && Hy(s.gl)
          ? (_.colorSpace = s.gl.outputColorSpace)
          : (_.encoding = s.gl.outputEncoding);
      }
    }
    Kl(n);
  }
  if (i && i.parent && n.raycast && u !== i.eventCount) {
    const p = pm(n).getState().internal,
      m = p.interaction.indexOf(n);
    m > -1 && p.interaction.splice(m, 1), i.eventCount && p.interaction.push(n);
  }
  return (
    !(a.length === 1 && a[0][0] === "onUpdate") &&
      a.length &&
      (t = n.__r3f) != null &&
      t.parent &&
      q_(n),
    n
  );
}
function Kl(n) {
  var e, t;
  const i =
    (e = n.__r3f) == null || (t = e.root) == null || t.getState == null
      ? void 0
      : t.getState();
  i && i.internal.frames === 0 && i.invalidate();
}
function q_(n) {
  n.onUpdate == null || n.onUpdate(n);
}
function KW(n, e) {
  n.manual ||
    (FI(n)
      ? ((n.left = e.width / -2),
        (n.right = e.width / 2),
        (n.top = e.height / 2),
        (n.bottom = e.height / -2))
      : (n.aspect = e.width / e.height),
    n.updateProjectionMatrix(),
    n.updateMatrixWorld());
}
function Gp(n) {
  return (n.eventObject || n.object).uuid + "/" + n.index + n.instanceId;
}
function QW() {
  var n;
  const e = (typeof self < "u" && self) || (typeof window < "u" && window);
  if (!e) return yu.DefaultEventPriority;
  switch ((n = e.event) == null ? void 0 : n.type) {
    case "click":
    case "contextmenu":
    case "dblclick":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
      return yu.DiscreteEventPriority;
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "pointerenter":
    case "pointerleave":
    case "wheel":
      return yu.ContinuousEventPriority;
    default:
      return yu.DefaultEventPriority;
  }
}
function WI(n, e, t, i) {
  const r = t.get(e);
  r &&
    (t.delete(e),
    t.size === 0 && (n.delete(i), r.target.releasePointerCapture(i)));
}
function $W(n, e) {
  const { internal: t } = n.getState();
  (t.interaction = t.interaction.filter((i) => i !== e)),
    (t.initialHits = t.initialHits.filter((i) => i !== e)),
    t.hovered.forEach((i, r) => {
      (i.eventObject === e || i.object === e) && t.hovered.delete(r);
    }),
    t.capturedMap.forEach((i, r) => {
      WI(t.capturedMap, e, i, r);
    });
}
function JW(n) {
  function e(u) {
    const { internal: f } = n.getState(),
      h = u.offsetX - f.initialClick[0],
      d = u.offsetY - f.initialClick[1];
    return Math.round(Math.sqrt(h * h + d * d));
  }
  function t(u) {
    return u.filter((f) =>
      ["Move", "Over", "Enter", "Out", "Leave"].some((h) => {
        var d;
        return (d = f.__r3f) == null ? void 0 : d.handlers["onPointer" + h];
      })
    );
  }
  function i(u, f) {
    const h = n.getState(),
      d = new Set(),
      p = [],
      m = f ? f(h.internal.interaction) : h.internal.interaction;
    for (let v = 0; v < m.length; v++) {
      const M = kc(m[v]);
      M && (M.raycaster.camera = void 0);
    }
    h.previousRoot || h.events.compute == null || h.events.compute(u, h);
    function y(v) {
      const M = kc(v);
      if (!M || !M.events.enabled || M.raycaster.camera === null) return [];
      if (M.raycaster.camera === void 0) {
        var _;
        M.events.compute == null ||
          M.events.compute(
            u,
            M,
            (_ = M.previousRoot) == null ? void 0 : _.getState()
          ),
          M.raycaster.camera === void 0 && (M.raycaster.camera = null);
      }
      return M.raycaster.camera ? M.raycaster.intersectObject(v, !0) : [];
    }
    let w = m
      .flatMap(y)
      .sort((v, M) => {
        const _ = kc(v.object),
          T = kc(M.object);
        return !_ || !T
          ? v.distance - M.distance
          : T.events.priority - _.events.priority || v.distance - M.distance;
      })
      .filter((v) => {
        const M = Gp(v);
        return d.has(M) ? !1 : (d.add(M), !0);
      });
    h.events.filter && (w = h.events.filter(w, h));
    for (const v of w) {
      let M = v.object;
      for (; M; ) {
        var S;
        (S = M.__r3f) != null &&
          S.eventCount &&
          p.push({ ...v, eventObject: M }),
          (M = M.parent);
      }
    }
    if ("pointerId" in u && h.internal.capturedMap.has(u.pointerId))
      for (let v of h.internal.capturedMap.get(u.pointerId).values())
        d.has(Gp(v.intersection)) || p.push(v.intersection);
    return p;
  }
  function r(u, f, h, d) {
    const p = n.getState();
    if (u.length) {
      const m = { stopped: !1 };
      for (const y of u) {
        const w = kc(y.object) || p,
          { raycaster: S, pointer: v, camera: M, internal: _ } = w,
          T = new U(v.x, v.y, 0).unproject(M),
          P = (R) => {
            var B, Z;
            return (B =
              (Z = _.capturedMap.get(R)) == null
                ? void 0
                : Z.has(y.eventObject)) != null
              ? B
              : !1;
          },
          b = (R) => {
            const B = { intersection: y, target: f.target };
            _.capturedMap.has(R)
              ? _.capturedMap.get(R).set(y.eventObject, B)
              : _.capturedMap.set(R, new Map([[y.eventObject, B]])),
              f.target.setPointerCapture(R);
          },
          L = (R) => {
            const B = _.capturedMap.get(R);
            B && WI(_.capturedMap, y.eventObject, B, R);
          };
        let N = {};
        for (let R in f) {
          let B = f[R];
          typeof B != "function" && (N[R] = B);
        }
        let C = {
          ...y,
          ...N,
          pointer: v,
          intersections: u,
          stopped: m.stopped,
          delta: h,
          unprojectedPoint: T,
          ray: S.ray,
          camera: M,
          stopPropagation() {
            const R = "pointerId" in f && _.capturedMap.get(f.pointerId);
            if (
              (!R || R.has(y.eventObject)) &&
              ((C.stopped = m.stopped = !0),
              _.hovered.size &&
                Array.from(_.hovered.values()).find(
                  (B) => B.eventObject === y.eventObject
                ))
            ) {
              const B = u.slice(0, u.indexOf(y));
              s([...B, y]);
            }
          },
          target: {
            hasPointerCapture: P,
            setPointerCapture: b,
            releasePointerCapture: L,
          },
          currentTarget: {
            hasPointerCapture: P,
            setPointerCapture: b,
            releasePointerCapture: L,
          },
          nativeEvent: f,
        };
        if ((d(C), m.stopped === !0)) break;
      }
    }
    return u;
  }
  function s(u) {
    const { internal: f } = n.getState();
    for (const h of f.hovered.values())
      if (
        !u.length ||
        !u.find(
          (d) =>
            d.object === h.object &&
            d.index === h.index &&
            d.instanceId === h.instanceId
        )
      ) {
        const p = h.eventObject.__r3f,
          m = p == null ? void 0 : p.handlers;
        if ((f.hovered.delete(Gp(h)), p != null && p.eventCount)) {
          const y = { ...h, intersections: u };
          m.onPointerOut == null || m.onPointerOut(y),
            m.onPointerLeave == null || m.onPointerLeave(y);
        }
      }
  }
  function o(u, f) {
    for (let h = 0; h < f.length; h++) {
      const d = f[h].__r3f;
      d == null ||
        d.handlers.onPointerMissed == null ||
        d.handlers.onPointerMissed(u);
    }
  }
  function a(u) {
    switch (u) {
      case "onPointerLeave":
      case "onPointerCancel":
        return () => s([]);
      case "onLostPointerCapture":
        return (f) => {
          const { internal: h } = n.getState();
          "pointerId" in f &&
            h.capturedMap.has(f.pointerId) &&
            requestAnimationFrame(() => {
              h.capturedMap.has(f.pointerId) &&
                (h.capturedMap.delete(f.pointerId), s([]));
            });
        };
    }
    return function (h) {
      const { onPointerMissed: d, internal: p } = n.getState();
      p.lastEvent.current = h;
      const m = u === "onPointerMove",
        y = u === "onClick" || u === "onContextMenu" || u === "onDoubleClick",
        S = i(h, m ? t : void 0),
        v = y ? e(h) : 0;
      u === "onPointerDown" &&
        ((p.initialClick = [h.offsetX, h.offsetY]),
        (p.initialHits = S.map((_) => _.eventObject))),
        y && !S.length && v <= 2 && (o(h, p.interaction), d && d(h)),
        m && s(S);
      function M(_) {
        const T = _.eventObject,
          P = T.__r3f,
          b = P == null ? void 0 : P.handlers;
        if (P != null && P.eventCount)
          if (m) {
            if (
              b.onPointerOver ||
              b.onPointerEnter ||
              b.onPointerOut ||
              b.onPointerLeave
            ) {
              const L = Gp(_),
                N = p.hovered.get(L);
              N
                ? N.stopped && _.stopPropagation()
                : (p.hovered.set(L, _),
                  b.onPointerOver == null || b.onPointerOver(_),
                  b.onPointerEnter == null || b.onPointerEnter(_));
            }
            b.onPointerMove == null || b.onPointerMove(_);
          } else {
            const L = b[u];
            L
              ? (!y || p.initialHits.includes(T)) &&
                (o(
                  h,
                  p.interaction.filter((N) => !p.initialHits.includes(N))
                ),
                L(_))
              : y &&
                p.initialHits.includes(T) &&
                o(
                  h,
                  p.interaction.filter((N) => !p.initialHits.includes(N))
                );
          }
      }
      r(S, h, v, M);
    };
  }
  return { handlePointer: a };
}
const jI = (n) => !!(n != null && n.render),
  XI = se.createContext(null),
  ej = (n, e) => {
    const t = BW((a, u) => {
        const f = new U(),
          h = new U(),
          d = new U();
        function p(v = u().camera, M = h, _ = u().size) {
          const { width: T, height: P, top: b, left: L } = _,
            N = T / P;
          M.isVector3 ? d.copy(M) : d.set(...M);
          const C = v.getWorldPosition(f).distanceTo(d);
          if (FI(v))
            return {
              width: T / v.zoom,
              height: P / v.zoom,
              top: b,
              left: L,
              factor: 1,
              distance: C,
              aspect: N,
            };
          {
            const R = (v.fov * Math.PI) / 180,
              B = 2 * Math.tan(R / 2) * C,
              Z = B * (T / P);
            return {
              width: Z,
              height: B,
              top: b,
              left: L,
              factor: T / Z,
              distance: C,
              aspect: N,
            };
          }
        }
        let m;
        const y = (v) =>
            a((M) => ({ performance: { ...M.performance, current: v } })),
          w = new de();
        return {
          set: a,
          get: u,
          gl: null,
          camera: null,
          raycaster: null,
          events: { priority: 1, enabled: !0, connected: !1 },
          xr: null,
          scene: null,
          invalidate: (v = 1) => n(u(), v),
          advance: (v, M) => e(v, M, u()),
          legacy: !1,
          linear: !1,
          flat: !1,
          controls: null,
          clock: new oM(),
          pointer: w,
          mouse: w,
          frameloop: "always",
          onPointerMissed: void 0,
          performance: {
            current: 1,
            min: 0.5,
            max: 1,
            debounce: 200,
            regress: () => {
              const v = u();
              m && clearTimeout(m),
                v.performance.current !== v.performance.min &&
                  y(v.performance.min),
                (m = setTimeout(
                  () => y(u().performance.max),
                  v.performance.debounce
                ));
            },
          },
          size: { width: 0, height: 0, top: 0, left: 0, updateStyle: !1 },
          viewport: {
            initialDpr: 0,
            dpr: 0,
            width: 0,
            height: 0,
            top: 0,
            left: 0,
            aspect: 0,
            distance: 0,
            factor: 0,
            getCurrentViewport: p,
          },
          setEvents: (v) => a((M) => ({ ...M, events: { ...M.events, ...v } })),
          setSize: (v, M, _, T, P) => {
            const b = u().camera,
              L = {
                width: v,
                height: M,
                top: T || 0,
                left: P || 0,
                updateStyle: _,
              };
            a((N) => ({ size: L, viewport: { ...N.viewport, ...p(b, h, L) } }));
          },
          setDpr: (v) =>
            a((M) => {
              const _ = HI(v);
              return {
                viewport: {
                  ...M.viewport,
                  dpr: _,
                  initialDpr: M.viewport.initialDpr || _,
                },
              };
            }),
          setFrameloop: (v = "always") => {
            const M = u().clock;
            M.stop(),
              (M.elapsedTime = 0),
              v !== "never" && (M.start(), (M.elapsedTime = 0)),
              a(() => ({ frameloop: v }));
          },
          previousRoot: void 0,
          internal: {
            active: !1,
            priority: 0,
            frames: 0,
            lastEvent: se.createRef(),
            interaction: [],
            hovered: new Map(),
            subscribers: [],
            initialClick: [0, 0],
            initialHits: [],
            capturedMap: new Map(),
            subscribe: (v, M, _) => {
              const T = u().internal;
              return (
                (T.priority = T.priority + (M > 0 ? 1 : 0)),
                T.subscribers.push({ ref: v, priority: M, store: _ }),
                (T.subscribers = T.subscribers.sort(
                  (P, b) => P.priority - b.priority
                )),
                () => {
                  const P = u().internal;
                  P != null &&
                    P.subscribers &&
                    ((P.priority = P.priority - (M > 0 ? 1 : 0)),
                    (P.subscribers = P.subscribers.filter((b) => b.ref !== v)));
                }
              );
            },
          },
        };
      }),
      i = t.getState();
    let r = i.size,
      s = i.viewport.dpr,
      o = i.camera;
    return (
      t.subscribe(() => {
        const { camera: a, size: u, viewport: f, gl: h, set: d } = t.getState();
        if (u.width !== r.width || u.height !== r.height || f.dpr !== s) {
          var p;
          (r = u), (s = f.dpr), KW(a, u), h.setPixelRatio(f.dpr);
          const m =
            (p = u.updateStyle) != null
              ? p
              : typeof HTMLCanvasElement < "u" &&
                h.domElement instanceof HTMLCanvasElement;
          h.setSize(u.width, u.height, m);
        }
        a !== o &&
          ((o = a),
          d((m) => ({
            viewport: { ...m.viewport, ...m.viewport.getCurrentViewport(a) },
          })));
      }),
      t.subscribe((a) => n(a)),
      t
    );
  };
let Wp,
  tj = new Set(),
  nj = new Set(),
  ij = new Set();
function jy(n, e) {
  if (n.size) for (const { callback: t } of n.values()) t(e);
}
function Fc(n, e) {
  switch (n) {
    case "before":
      return jy(tj, e);
    case "after":
      return jy(nj, e);
    case "tail":
      return jy(ij, e);
  }
}
let Xy, Yy;
function qy(n, e, t) {
  let i = e.clock.getDelta();
  for (
    e.frameloop === "never" &&
      typeof n == "number" &&
      ((i = n - e.clock.elapsedTime),
      (e.clock.oldTime = e.clock.elapsedTime),
      (e.clock.elapsedTime = n)),
      Xy = e.internal.subscribers,
      Wp = 0;
    Wp < Xy.length;
    Wp++
  )
    (Yy = Xy[Wp]), Yy.ref.current(Yy.store.getState(), i, t);
  return (
    !e.internal.priority && e.gl.render && e.gl.render(e.scene, e.camera),
    (e.internal.frames = Math.max(0, e.internal.frames - 1)),
    e.frameloop === "always" ? 1 : e.internal.frames
  );
}
function rj(n) {
  let e = !1,
    t = !1,
    i,
    r,
    s;
  function o(f) {
    (r = requestAnimationFrame(o)),
      (e = !0),
      (i = 0),
      Fc("before", f),
      (t = !0);
    for (const d of n.values()) {
      var h;
      (s = d.store.getState()),
        s.internal.active &&
          (s.frameloop === "always" || s.internal.frames > 0) &&
          !((h = s.gl.xr) != null && h.isPresenting) &&
          (i += qy(f, s));
    }
    if (((t = !1), Fc("after", f), i === 0))
      return Fc("tail", f), (e = !1), cancelAnimationFrame(r);
  }
  function a(f, h = 1) {
    var d;
    if (!f) return n.forEach((p) => a(p.store.getState(), h));
    ((d = f.gl.xr) != null && d.isPresenting) ||
      !f.internal.active ||
      f.frameloop === "never" ||
      (h > 1
        ? (f.internal.frames = Math.min(60, f.internal.frames + h))
        : t
        ? (f.internal.frames = 2)
        : (f.internal.frames = 1),
      e || ((e = !0), requestAnimationFrame(o)));
  }
  function u(f, h = !0, d, p) {
    if ((h && Fc("before", f), d)) qy(f, d, p);
    else for (const m of n.values()) qy(f, m.store.getState());
    h && Fc("after", f);
  }
  return { loop: o, invalidate: a, advance: u };
}
function YI() {
  const n = se.useContext(XI);
  if (!n)
    throw new Error("R3F: Hooks can only be used within the Canvas component!");
  return n;
}
function go(n = (t) => t, e) {
  return YI()(n, e);
}
function Ch(n, e = 0) {
  const t = YI(),
    i = t.getState().internal.subscribe,
    r = zI(n);
  return bh(() => i(r, e, t), [e, i, t]), null;
}
const Bu = new Map(),
  { invalidate: sb, advance: ob } = rj(Bu),
  { reconciler: rg, applyProps: Yl } = jW(Bu, QW),
  ql = { objects: "shallow", strict: !1 },
  sj = (n, e) => {
    const t = typeof n == "function" ? n(e) : n;
    return jI(t)
      ? t
      : new VS({
          powerPreference: "high-performance",
          canvas: e,
          antialias: !0,
          alpha: !0,
          ...n,
        });
  };
function oj(n, e) {
  const t = typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement;
  if (e) {
    const { width: i, height: r, top: s, left: o, updateStyle: a = t } = e;
    return { width: i, height: r, top: s, left: o, updateStyle: a };
  } else if (
    typeof HTMLCanvasElement < "u" &&
    n instanceof HTMLCanvasElement &&
    n.parentElement
  ) {
    const {
      width: i,
      height: r,
      top: s,
      left: o,
    } = n.parentElement.getBoundingClientRect();
    return { width: i, height: r, top: s, left: o, updateStyle: t };
  } else if (typeof OffscreenCanvas < "u" && n instanceof OffscreenCanvas)
    return {
      width: n.width,
      height: n.height,
      top: 0,
      left: 0,
      updateStyle: t,
    };
  return { width: 0, height: 0, top: 0, left: 0 };
}
function aj(n) {
  const e = Bu.get(n),
    t = e == null ? void 0 : e.fiber,
    i = e == null ? void 0 : e.store;
  e && console.warn("R3F.createRoot should only be called once!");
  const r = typeof reportError == "function" ? reportError : console.error,
    s = i || ej(sb, ob),
    o =
      t ||
      rg.createContainer(s, yu.ConcurrentRoot, null, !1, null, "", r, null);
  e || Bu.set(n, { fiber: o, store: s });
  let a,
    u = !1,
    f;
  return {
    configure(h = {}) {
      let {
          gl: d,
          size: p,
          scene: m,
          events: y,
          onCreated: w,
          shadows: S = !1,
          linear: v = !1,
          flat: M = !1,
          legacy: _ = !1,
          orthographic: T = !1,
          frameloop: P = "always",
          dpr: b = [1, 2],
          performance: L,
          raycaster: N,
          camera: C,
          onPointerMissed: R,
        } = h,
        B = s.getState(),
        Z = B.gl;
      B.gl || B.set({ gl: (Z = sj(d, n)) });
      let ae = B.raycaster;
      ae || B.set({ raycaster: (ae = new LI()) });
      const { params: V, ...Q } = N || {};
      if (
        (Kt.equ(Q, ae, ql) || Yl(ae, { ...Q }),
        Kt.equ(V, ae.params, ql) || Yl(ae, { params: { ...ae.params, ...V } }),
        !B.camera || (B.camera === f && !Kt.equ(f, C, ql)))
      ) {
        f = C;
        const W = C instanceof xh,
          Y = W
            ? C
            : T
            ? new Fo(0, 0, 0, 0, 0.1, 1e3)
            : new En(75, 0, 0.1, 1e3);
        W ||
          ((Y.position.z = 5),
          C &&
            (Yl(Y, C),
            ("aspect" in C ||
              "left" in C ||
              "right" in C ||
              "bottom" in C ||
              "top" in C) &&
              ((Y.manual = !0), Y.updateProjectionMatrix())),
          !B.camera && !(C != null && C.rotation) && Y.lookAt(0, 0, 0)),
          B.set({ camera: Y }),
          (ae.camera = Y);
      }
      if (!B.scene) {
        let W;
        m != null && m.isScene ? (W = m) : ((W = new HS()), m && Yl(W, m)),
          B.set({ scene: Zl(W) });
      }
      if (!B.xr) {
        var $;
        const W = (J, he) => {
            const Ee = s.getState();
            Ee.frameloop !== "never" && ob(J, !0, Ee, he);
          },
          Y = () => {
            const J = s.getState();
            (J.gl.xr.enabled = J.gl.xr.isPresenting),
              J.gl.xr.setAnimationLoop(J.gl.xr.isPresenting ? W : null),
              J.gl.xr.isPresenting || sb(J);
          },
          ie = {
            connect() {
              const J = s.getState().gl;
              J.xr.addEventListener("sessionstart", Y),
                J.xr.addEventListener("sessionend", Y);
            },
            disconnect() {
              const J = s.getState().gl;
              J.xr.removeEventListener("sessionstart", Y),
                J.xr.removeEventListener("sessionend", Y);
            },
          };
        typeof (($ = Z.xr) == null ? void 0 : $.addEventListener) ==
          "function" && ie.connect(),
          B.set({ xr: ie });
      }
      if (Z.shadowMap) {
        const W = Z.shadowMap.enabled,
          Y = Z.shadowMap.type;
        if (((Z.shadowMap.enabled = !!S), Kt.boo(S))) Z.shadowMap.type = sf;
        else if (Kt.str(S)) {
          var ce;
          const ie = { basic: wR, percentage: Ug, soft: sf, variance: Ir };
          Z.shadowMap.type = (ce = ie[S]) != null ? ce : sf;
        } else Kt.obj(S) && Object.assign(Z.shadowMap, S);
        (W !== Z.shadowMap.enabled || Y !== Z.shadowMap.type) &&
          (Z.shadowMap.needsUpdate = !0);
      }
      const k = kI();
      k &&
        ("enabled" in k
          ? (k.enabled = !_)
          : "legacyMode" in k && (k.legacyMode = _)),
        u ||
          Yl(Z, { outputEncoding: v ? 3e3 : 3001, toneMapping: M ? us : _S }),
        B.legacy !== _ && B.set(() => ({ legacy: _ })),
        B.linear !== v && B.set(() => ({ linear: v })),
        B.flat !== M && B.set(() => ({ flat: M })),
        d && !Kt.fun(d) && !jI(d) && !Kt.equ(d, Z, ql) && Yl(Z, d),
        y && !B.events.handlers && B.set({ events: y(s) });
      const G = oj(n, p);
      return (
        Kt.equ(G, B.size, ql) ||
          B.setSize(G.width, G.height, G.updateStyle, G.top, G.left),
        b && B.viewport.dpr !== HI(b) && B.setDpr(b),
        B.frameloop !== P && B.setFrameloop(P),
        B.onPointerMissed || B.set({ onPointerMissed: R }),
        L &&
          !Kt.equ(L, B.performance, ql) &&
          B.set((W) => ({ performance: { ...W.performance, ...L } })),
        (a = w),
        (u = !0),
        this
      );
    },
    render(h) {
      return (
        u || this.configure(),
        rg.updateContainer(
          z.jsx(lj, { store: s, children: h, onCreated: a, rootElement: n }),
          o,
          null,
          () => {}
        ),
        s
      );
    },
    unmount() {
      qI(n);
    },
  };
}
function lj({ store: n, children: e, onCreated: t, rootElement: i }) {
  return (
    bh(() => {
      const r = n.getState();
      r.set((s) => ({ internal: { ...s.internal, active: !0 } })),
        t && t(r),
        n.getState().events.connected ||
          r.events.connect == null ||
          r.events.connect(i);
    }, []),
    z.jsx(XI.Provider, { value: n, children: e })
  );
}
function qI(n, e) {
  const t = Bu.get(n),
    i = t == null ? void 0 : t.fiber;
  if (i) {
    const r = t == null ? void 0 : t.store.getState();
    r && (r.internal.active = !1),
      rg.updateContainer(null, i, null, () => {
        r &&
          setTimeout(() => {
            try {
              var s, o, a, u;
              r.events.disconnect == null || r.events.disconnect(),
                (s = r.gl) == null ||
                  (o = s.renderLists) == null ||
                  o.dispose == null ||
                  o.dispose(),
                (a = r.gl) == null ||
                  a.forceContextLoss == null ||
                  a.forceContextLoss(),
                (u = r.gl) != null && u.xr && r.xr.disconnect(),
                ZW(r),
                Bu.delete(n);
            } catch {}
          }, 500);
      });
  }
}
rg.injectIntoDevTools({
  bundleType: 0,
  rendererPackageName: "@react-three/fiber",
  version: se.version,
});
const Zy = {
  onClick: ["click", !1],
  onContextMenu: ["contextmenu", !1],
  onDoubleClick: ["dblclick", !1],
  onWheel: ["wheel", !0],
  onPointerDown: ["pointerdown", !0],
  onPointerUp: ["pointerup", !0],
  onPointerLeave: ["pointerleave", !0],
  onPointerMove: ["pointermove", !0],
  onPointerCancel: ["pointercancel", !0],
  onLostPointerCapture: ["lostpointercapture", !0],
};
function uj(n) {
  const { handlePointer: e } = JW(n);
  return {
    priority: 1,
    enabled: !0,
    compute(t, i, r) {
      i.pointer.set(
        (t.offsetX / i.size.width) * 2 - 1,
        -(t.offsetY / i.size.height) * 2 + 1
      ),
        i.raycaster.setFromCamera(i.pointer, i.camera);
    },
    connected: void 0,
    handlers: Object.keys(Zy).reduce((t, i) => ({ ...t, [i]: e(i) }), {}),
    update: () => {
      var t;
      const { events: i, internal: r } = n.getState();
      (t = r.lastEvent) != null &&
        t.current &&
        i.handlers &&
        i.handlers.onPointerMove(r.lastEvent.current);
    },
    connect: (t) => {
      var i;
      const { set: r, events: s } = n.getState();
      s.disconnect == null || s.disconnect(),
        r((o) => ({ events: { ...o.events, connected: t } })),
        Object.entries((i = s.handlers) != null ? i : []).forEach(([o, a]) => {
          const [u, f] = Zy[o];
          t.addEventListener(u, a, { passive: f });
        });
    },
    disconnect: () => {
      const { set: t, events: i } = n.getState();
      if (i.connected) {
        var r;
        Object.entries((r = i.handlers) != null ? r : []).forEach(([s, o]) => {
          if (i && i.connected instanceof HTMLElement) {
            const [a] = Zy[s];
            i.connected.removeEventListener(a, o);
          }
        }),
          t((s) => ({ events: { ...s.events, connected: void 0 } }));
      }
    },
  };
}
function ab(n, e) {
  let t;
  return (...i) => {
    window.clearTimeout(t), (t = window.setTimeout(() => n(...i), e));
  };
}
function cj(
  { debounce: n, scroll: e, polyfill: t, offsetSize: i } = {
    debounce: 0,
    scroll: !1,
    offsetSize: !1,
  }
) {
  const r = t || (typeof window > "u" ? class {} : window.ResizeObserver);
  if (!r)
    throw new Error(
      "This browser does not support ResizeObserver out of the box. See: https://github.com/Oumaima-El-Badraouy/react-spring/react-use-measure/#resize-observer-polyfills"
    );
  const [s, o] = se.useState({
      left: 0,
      top: 0,
      width: 0,
      height: 0,
      bottom: 0,
      right: 0,
      x: 0,
      y: 0,
    }),
    a = se.useRef({
      element: null,
      scrollContainers: null,
      resizeObserver: null,
      lastBounds: s,
      orientationHandler: null,
    }),
    u = n ? (typeof n == "number" ? n : n.scroll) : null,
    f = n ? (typeof n == "number" ? n : n.resize) : null,
    h = se.useRef(!1);
  se.useEffect(() => ((h.current = !0), () => void (h.current = !1)));
  const [d, p, m] = se.useMemo(() => {
    const v = () => {
      if (!a.current.element) return;
      const {
          left: M,
          top: _,
          width: T,
          height: P,
          bottom: b,
          right: L,
          x: N,
          y: C,
        } = a.current.element.getBoundingClientRect(),
        R = {
          left: M,
          top: _,
          width: T,
          height: P,
          bottom: b,
          right: L,
          x: N,
          y: C,
        };
      a.current.element instanceof HTMLElement &&
        i &&
        ((R.height = a.current.element.offsetHeight),
        (R.width = a.current.element.offsetWidth)),
        Object.freeze(R),
        h.current &&
          !pj(a.current.lastBounds, R) &&
          o((a.current.lastBounds = R));
    };
    return [v, f ? ab(v, f) : v, u ? ab(v, u) : v];
  }, [o, i, u, f]);
  function y() {
    a.current.scrollContainers &&
      (a.current.scrollContainers.forEach((v) =>
        v.removeEventListener("scroll", m, !0)
      ),
      (a.current.scrollContainers = null)),
      a.current.resizeObserver &&
        (a.current.resizeObserver.disconnect(),
        (a.current.resizeObserver = null)),
      a.current.orientationHandler &&
        ("orientation" in screen && "removeEventListener" in screen.orientation
          ? screen.orientation.removeEventListener(
              "change",
              a.current.orientationHandler
            )
          : "onorientationchange" in window &&
            window.removeEventListener(
              "orientationchange",
              a.current.orientationHandler
            ));
  }
  function w() {
    a.current.element &&
      ((a.current.resizeObserver = new r(m)),
      a.current.resizeObserver.observe(a.current.element),
      e &&
        a.current.scrollContainers &&
        a.current.scrollContainers.forEach((v) =>
          v.addEventListener("scroll", m, { capture: !0, passive: !0 })
        ),
      (a.current.orientationHandler = () => {
        m();
      }),
      "orientation" in screen && "addEventListener" in screen.orientation
        ? screen.orientation.addEventListener(
            "change",
            a.current.orientationHandler
          )
        : "onorientationchange" in window &&
          window.addEventListener(
            "orientationchange",
            a.current.orientationHandler
          ));
  }
  const S = (v) => {
    !v ||
      v === a.current.element ||
      (y(), (a.current.element = v), (a.current.scrollContainers = ZI(v)), w());
  };
  return (
    hj(m, !!e),
    fj(p),
    se.useEffect(() => {
      y(), w();
    }, [e, m, p]),
    se.useEffect(() => y, []),
    [S, s, d]
  );
}
function fj(n) {
  se.useEffect(() => {
    const e = n;
    return (
      window.addEventListener("resize", e),
      () => void window.removeEventListener("resize", e)
    );
  }, [n]);
}
function hj(n, e) {
  se.useEffect(() => {
    if (e) {
      const t = n;
      return (
        window.addEventListener("scroll", t, { capture: !0, passive: !0 }),
        () => void window.removeEventListener("scroll", t, !0)
      );
    }
  }, [n, e]);
}
function ZI(n) {
  const e = [];
  if (!n || n === document.body) return e;
  const {
    overflow: t,
    overflowX: i,
    overflowY: r,
  } = window.getComputedStyle(n);
  return (
    [t, i, r].some((s) => s === "auto" || s === "scroll") && e.push(n),
    [...e, ...ZI(n.parentElement)]
  );
}
const dj = ["x", "y", "top", "bottom", "left", "right", "width", "height"],
  pj = (n, e) => dj.every((t) => n[t] === e[t]);
var mj = Object.defineProperty,
  gj = Object.defineProperties,
  vj = Object.getOwnPropertyDescriptors,
  lb = Object.getOwnPropertySymbols,
  yj = Object.prototype.hasOwnProperty,
  xj = Object.prototype.propertyIsEnumerable,
  ub = (n, e, t) =>
    e in n
      ? mj(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (n[e] = t),
  cb = (n, e) => {
    for (var t in e || (e = {})) yj.call(e, t) && ub(n, t, e[t]);
    if (lb) for (var t of lb(e)) xj.call(e, t) && ub(n, t, e[t]);
    return n;
  },
  _j = (n, e) => gj(n, vj(e)),
  fb,
  hb;
typeof window < "u" &&
(((fb = window.document) != null && fb.createElement) ||
  ((hb = window.navigator) == null ? void 0 : hb.product) === "ReactNative")
  ? se.useLayoutEffect
  : se.useEffect;
function KI(n, e, t) {
  if (!n) return;
  if (t(n) === !0) return n;
  let i = n.child;
  for (; i; ) {
    const r = KI(i, e, t);
    if (r) return r;
    i = i.sibling;
  }
}
function QI(n) {
  try {
    return Object.defineProperties(n, {
      _currentRenderer: {
        get() {
          return null;
        },
        set() {},
      },
      _currentRenderer2: {
        get() {
          return null;
        },
        set() {},
      },
    });
  } catch {
    return n;
  }
}
const db = console.error;
console.error = function () {
  const n = [...arguments].join("");
  if (n != null && n.startsWith("Warning:") && n.includes("useContext")) {
    console.error = db;
    return;
  }
  return db.apply(this, arguments);
};
const fM = QI(se.createContext(null));
class $I extends se.Component {
  render() {
    return se.createElement(
      fM.Provider,
      { value: this._reactInternals },
      this.props.children
    );
  }
}
function Sj() {
  const n = se.useContext(fM);
  if (n === null)
    throw new Error(
      "its-fine: useFiber must be called within a <FiberProvider />!"
    );
  const e = se.useId();
  return se.useMemo(() => {
    for (const i of [n, n == null ? void 0 : n.alternate]) {
      if (!i) continue;
      const r = KI(i, !1, (s) => {
        let o = s.memoizedState;
        for (; o; ) {
          if (o.memoizedState === e) return !0;
          o = o.next;
        }
      });
      if (r) return r;
    }
  }, [n, e]);
}
function Mj() {
  const n = Sj(),
    [e] = se.useState(() => new Map());
  e.clear();
  let t = n;
  for (; t; ) {
    if (t.type && typeof t.type == "object") {
      const r =
        t.type._context === void 0 && t.type.Provider === t.type
          ? t.type
          : t.type._context;
      r && r !== fM && !e.has(r) && e.set(r, se.useContext(QI(r)));
    }
    t = t.return;
  }
  return e;
}
function wj() {
  const n = Mj();
  return se.useMemo(
    () =>
      Array.from(n.keys()).reduce(
        (e, t) => (i) =>
          se.createElement(
            e,
            null,
            se.createElement(t.Provider, _j(cb({}, i), { value: n.get(t) }))
          ),
        (e) => se.createElement($I, cb({}, e))
      ),
    [n]
  );
}
const Ej = se.forwardRef(function (
    {
      children: e,
      fallback: t,
      resize: i,
      style: r,
      gl: s,
      events: o = uj,
      eventSource: a,
      eventPrefix: u,
      shadows: f,
      linear: h,
      flat: d,
      legacy: p,
      orthographic: m,
      frameloop: y,
      dpr: w,
      performance: S,
      raycaster: v,
      camera: M,
      scene: _,
      onPointerMissed: T,
      onCreated: P,
      ...b
    },
    L
  ) {
    se.useMemo(() => WW(kW), []);
    const N = wj(),
      [C, R] = cj({ scroll: !0, debounce: { scroll: 50, resize: 0 }, ...i }),
      B = se.useRef(null),
      Z = se.useRef(null);
    se.useImperativeHandle(L, () => B.current);
    const ae = zI(T),
      [V, Q] = se.useState(!1),
      [$, ce] = se.useState(!1);
    if (V) throw V;
    if ($) throw $;
    const k = se.useRef(null);
    bh(() => {
      const W = B.current;
      R.width > 0 &&
        R.height > 0 &&
        W &&
        (k.current || (k.current = aj(W)),
        k.current.configure({
          gl: s,
          events: o,
          shadows: f,
          linear: h,
          flat: d,
          legacy: p,
          orthographic: m,
          frameloop: y,
          dpr: w,
          performance: S,
          raycaster: v,
          camera: M,
          scene: _,
          size: R,
          onPointerMissed: (...Y) =>
            ae.current == null ? void 0 : ae.current(...Y),
          onCreated: (Y) => {
            Y.events.connect == null ||
              Y.events.connect(a ? (XW(a) ? a.current : a) : Z.current),
              u &&
                Y.setEvents({
                  compute: (ie, J) => {
                    const he = ie[u + "X"],
                      Ee = ie[u + "Y"];
                    J.pointer.set(
                      (he / J.size.width) * 2 - 1,
                      -(Ee / J.size.height) * 2 + 1
                    ),
                      J.raycaster.setFromCamera(J.pointer, J.camera);
                  },
                }),
              P == null || P(Y);
          },
        }),
        k.current.render(
          z.jsx(N, {
            children: z.jsx(BI, {
              set: ce,
              children: z.jsx(se.Suspense, {
                fallback: z.jsx(YW, { set: Q }),
                children: e ?? null,
              }),
            }),
          })
        ));
    }),
      se.useEffect(() => {
        const W = B.current;
        if (W) return () => qI(W);
      }, []);
    const G = a ? "none" : "auto";
    return z.jsx("div", {
      ref: Z,
      style: {
        position: "relative",
        width: "100%",
        height: "100%",
        overflow: "hidden",
        pointerEvents: G,
        ...r,
      },
      ...b,
      children: z.jsx("div", {
        ref: C,
        style: { width: "100%", height: "100%" },
        children: z.jsx("canvas", {
          ref: B,
          style: { display: "block" },
          children: t,
        }),
      }),
    });
  }),
  Tj = se.forwardRef(function (e, t) {
    return z.jsx($I, { children: z.jsx(Ej, { ...e, ref: t }) });
  });
function $f() {
  return (
    ($f = Object.assign
      ? Object.assign.bind()
      : function (n) {
          for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var i in t) ({}).hasOwnProperty.call(t, i) && (n[i] = t[i]);
          }
          return n;
        }),
    $f.apply(null, arguments)
  );
}
var Aj = Object.defineProperty,
  bj = (n, e, t) =>
    e in n
      ? Aj(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (n[e] = t),
  Cj = (n, e, t) => (bj(n, e + "", t), t);
class Pj {
  constructor() {
    Cj(this, "_listeners");
  }
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const i = this._listeners;
    i[e] === void 0 && (i[e] = []), i[e].indexOf(t) === -1 && i[e].push(t);
  }
  hasEventListener(e, t) {
    if (this._listeners === void 0) return !1;
    const i = this._listeners;
    return i[e] !== void 0 && i[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    if (this._listeners === void 0) return;
    const r = this._listeners[e];
    if (r !== void 0) {
      const s = r.indexOf(t);
      s !== -1 && r.splice(s, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return;
    const i = this._listeners[e.type];
    if (i !== void 0) {
      e.target = this;
      const r = i.slice(0);
      for (let s = 0, o = r.length; s < o; s++) r[s].call(this, e);
      e.target = null;
    }
  }
}
var Rj = Object.defineProperty,
  Lj = (n, e, t) =>
    e in n
      ? Rj(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (n[e] = t),
  at = (n, e, t) => (Lj(n, typeof e != "symbol" ? e + "" : e, t), t);
const jp = new rl(),
  pb = new Ps(),
  Ij = Math.cos(70 * (Math.PI / 180)),
  mb = (n, e) => ((n % e) + e) % e;
let Nj = class extends Pj {
  constructor(e, t) {
    super(),
      at(this, "object"),
      at(this, "domElement"),
      at(this, "enabled", !0),
      at(this, "target", new U()),
      at(this, "minDistance", 0),
      at(this, "maxDistance", 1 / 0),
      at(this, "minZoom", 0),
      at(this, "maxZoom", 1 / 0),
      at(this, "minPolarAngle", 0),
      at(this, "maxPolarAngle", Math.PI),
      at(this, "minAzimuthAngle", -1 / 0),
      at(this, "maxAzimuthAngle", 1 / 0),
      at(this, "enableDamping", !1),
      at(this, "dampingFactor", 0.05),
      at(this, "enableZoom", !0),
      at(this, "zoomSpeed", 1),
      at(this, "enableRotate", !0),
      at(this, "rotateSpeed", 1),
      at(this, "enablePan", !0),
      at(this, "panSpeed", 1),
      at(this, "screenSpacePanning", !0),
      at(this, "keyPanSpeed", 7),
      at(this, "zoomToCursor", !1),
      at(this, "autoRotate", !1),
      at(this, "autoRotateSpeed", 2),
      at(this, "reverseOrbit", !1),
      at(this, "reverseHorizontalOrbit", !1),
      at(this, "reverseVerticalOrbit", !1),
      at(this, "keys", {
        LEFT: "ArrowLeft",
        UP: "ArrowUp",
        RIGHT: "ArrowRight",
        BOTTOM: "ArrowDown",
      }),
      at(this, "mouseButtons", {
        LEFT: Ta.ROTATE,
        MIDDLE: Ta.DOLLY,
        RIGHT: Ta.PAN,
      }),
      at(this, "touches", { ONE: Aa.ROTATE, TWO: Aa.DOLLY_PAN }),
      at(this, "target0"),
      at(this, "position0"),
      at(this, "zoom0"),
      at(this, "_domElementKeyEvents", null),
      at(this, "getPolarAngle"),
      at(this, "getAzimuthalAngle"),
      at(this, "setPolarAngle"),
      at(this, "setAzimuthalAngle"),
      at(this, "getDistance"),
      at(this, "getZoomScale"),
      at(this, "listenToKeyEvents"),
      at(this, "stopListenToKeyEvents"),
      at(this, "saveState"),
      at(this, "reset"),
      at(this, "update"),
      at(this, "connect"),
      at(this, "dispose"),
      at(this, "dollyIn"),
      at(this, "dollyOut"),
      at(this, "getScale"),
      at(this, "setScale"),
      (this.object = e),
      (this.domElement = t),
      (this.target0 = this.target.clone()),
      (this.position0 = this.object.position.clone()),
      (this.zoom0 = this.object.zoom),
      (this.getPolarAngle = () => h.phi),
      (this.getAzimuthalAngle = () => h.theta),
      (this.setPolarAngle = (j) => {
        let ve = mb(j, 2 * Math.PI),
          ke = h.phi;
        ke < 0 && (ke += 2 * Math.PI), ve < 0 && (ve += 2 * Math.PI);
        let Oe = Math.abs(ve - ke);
        2 * Math.PI - Oe < Oe &&
          (ve < ke ? (ve += 2 * Math.PI) : (ke += 2 * Math.PI)),
          (d.phi = ve - ke),
          i.update();
      }),
      (this.setAzimuthalAngle = (j) => {
        let ve = mb(j, 2 * Math.PI),
          ke = h.theta;
        ke < 0 && (ke += 2 * Math.PI), ve < 0 && (ve += 2 * Math.PI);
        let Oe = Math.abs(ve - ke);
        2 * Math.PI - Oe < Oe &&
          (ve < ke ? (ve += 2 * Math.PI) : (ke += 2 * Math.PI)),
          (d.theta = ve - ke),
          i.update();
      }),
      (this.getDistance = () => i.object.position.distanceTo(i.target)),
      (this.listenToKeyEvents = (j) => {
        j.addEventListener("keydown", tt), (this._domElementKeyEvents = j);
      }),
      (this.stopListenToKeyEvents = () => {
        this._domElementKeyEvents.removeEventListener("keydown", tt),
          (this._domElementKeyEvents = null);
      }),
      (this.saveState = () => {
        i.target0.copy(i.target),
          i.position0.copy(i.object.position),
          (i.zoom0 = i.object.zoom);
      }),
      (this.reset = () => {
        i.target.copy(i.target0),
          i.object.position.copy(i.position0),
          (i.object.zoom = i.zoom0),
          i.object.updateProjectionMatrix(),
          i.dispatchEvent(r),
          i.update(),
          (u = a.NONE);
      }),
      (this.update = (() => {
        const j = new U(),
          ve = new U(0, 1, 0),
          ke = new hi().setFromUnitVectors(e.up, ve),
          Oe = ke.clone().invert(),
          Se = new U(),
          X = new hi(),
          Ce = 2 * Math.PI;
        return function () {
          const st = i.object.position;
          ke.setFromUnitVectors(e.up, ve),
            Oe.copy(ke).invert(),
            j.copy(st).sub(i.target),
            j.applyQuaternion(ke),
            h.setFromVector3(j),
            i.autoRotate && u === a.NONE && V(Z()),
            i.enableDamping
              ? ((h.theta += d.theta * i.dampingFactor),
                (h.phi += d.phi * i.dampingFactor))
              : ((h.theta += d.theta), (h.phi += d.phi));
          let qe = i.minAzimuthAngle,
            Ct = i.maxAzimuthAngle;
          isFinite(qe) &&
            isFinite(Ct) &&
            (qe < -Math.PI ? (qe += Ce) : qe > Math.PI && (qe -= Ce),
            Ct < -Math.PI ? (Ct += Ce) : Ct > Math.PI && (Ct -= Ce),
            qe <= Ct
              ? (h.theta = Math.max(qe, Math.min(Ct, h.theta)))
              : (h.theta =
                  h.theta > (qe + Ct) / 2
                    ? Math.max(qe, h.theta)
                    : Math.min(Ct, h.theta))),
            (h.phi = Math.max(
              i.minPolarAngle,
              Math.min(i.maxPolarAngle, h.phi)
            )),
            h.makeSafe(),
            i.enableDamping === !0
              ? i.target.addScaledVector(m, i.dampingFactor)
              : i.target.add(m),
            (i.zoomToCursor && C) || i.object.isOrthographicCamera
              ? (h.radius = J(h.radius))
              : (h.radius = J(h.radius * p)),
            j.setFromSpherical(h),
            j.applyQuaternion(Oe),
            st.copy(i.target).add(j),
            i.object.matrixAutoUpdate || i.object.updateMatrix(),
            i.object.lookAt(i.target),
            i.enableDamping === !0
              ? ((d.theta *= 1 - i.dampingFactor),
                (d.phi *= 1 - i.dampingFactor),
                m.multiplyScalar(1 - i.dampingFactor))
              : (d.set(0, 0, 0), m.set(0, 0, 0));
          let Lt = !1;
          if (i.zoomToCursor && C) {
            let Gt = null;
            if (i.object instanceof En && i.object.isPerspectiveCamera) {
              const Jt = j.length();
              Gt = J(Jt * p);
              const It = Jt - Gt;
              i.object.position.addScaledVector(L, It),
                i.object.updateMatrixWorld();
            } else if (i.object.isOrthographicCamera) {
              const Jt = new U(N.x, N.y, 0);
              Jt.unproject(i.object),
                (i.object.zoom = Math.max(
                  i.minZoom,
                  Math.min(i.maxZoom, i.object.zoom / p)
                )),
                i.object.updateProjectionMatrix(),
                (Lt = !0);
              const It = new U(N.x, N.y, 0);
              It.unproject(i.object),
                i.object.position.sub(It).add(Jt),
                i.object.updateMatrixWorld(),
                (Gt = j.length());
            } else
              console.warn(
                "WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."
              ),
                (i.zoomToCursor = !1);
            Gt !== null &&
              (i.screenSpacePanning
                ? i.target
                    .set(0, 0, -1)
                    .transformDirection(i.object.matrix)
                    .multiplyScalar(Gt)
                    .add(i.object.position)
                : (jp.origin.copy(i.object.position),
                  jp.direction
                    .set(0, 0, -1)
                    .transformDirection(i.object.matrix),
                  Math.abs(i.object.up.dot(jp.direction)) < Ij
                    ? e.lookAt(i.target)
                    : (pb.setFromNormalAndCoplanarPoint(i.object.up, i.target),
                      jp.intersectPlane(pb, i.target))));
          } else
            i.object instanceof Fo &&
              i.object.isOrthographicCamera &&
              ((Lt = p !== 1),
              Lt &&
                ((i.object.zoom = Math.max(
                  i.minZoom,
                  Math.min(i.maxZoom, i.object.zoom / p)
                )),
                i.object.updateProjectionMatrix()));
          return (
            (p = 1),
            (C = !1),
            Lt ||
            Se.distanceToSquared(i.object.position) > f ||
            8 * (1 - X.dot(i.object.quaternion)) > f
              ? (i.dispatchEvent(r),
                Se.copy(i.object.position),
                X.copy(i.object.quaternion),
                (Lt = !1),
                !0)
              : !1
          );
        };
      })()),
      (this.connect = (j) => {
        (i.domElement = j),
          (i.domElement.style.touchAction = "none"),
          i.domElement.addEventListener("contextmenu", Rt),
          i.domElement.addEventListener("pointerdown", xe),
          i.domElement.addEventListener("pointercancel", ge),
          i.domElement.addEventListener("wheel", Fe);
      }),
      (this.dispose = () => {
        var j, ve, ke, Oe, Se, X;
        i.domElement && (i.domElement.style.touchAction = "auto"),
          (j = i.domElement) == null ||
            j.removeEventListener("contextmenu", Rt),
          (ve = i.domElement) == null ||
            ve.removeEventListener("pointerdown", xe),
          (ke = i.domElement) == null ||
            ke.removeEventListener("pointercancel", ge),
          (Oe = i.domElement) == null || Oe.removeEventListener("wheel", Fe),
          (Se = i.domElement) == null ||
            Se.ownerDocument.removeEventListener("pointermove", ye),
          (X = i.domElement) == null ||
            X.ownerDocument.removeEventListener("pointerup", ge),
          i._domElementKeyEvents !== null &&
            i._domElementKeyEvents.removeEventListener("keydown", tt);
      });
    const i = this,
      r = { type: "change" },
      s = { type: "start" },
      o = { type: "end" },
      a = {
        NONE: -1,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2,
        TOUCH_ROTATE: 3,
        TOUCH_PAN: 4,
        TOUCH_DOLLY_PAN: 5,
        TOUCH_DOLLY_ROTATE: 6,
      };
    let u = a.NONE;
    const f = 1e-6,
      h = new ig(),
      d = new ig();
    let p = 1;
    const m = new U(),
      y = new de(),
      w = new de(),
      S = new de(),
      v = new de(),
      M = new de(),
      _ = new de(),
      T = new de(),
      P = new de(),
      b = new de(),
      L = new U(),
      N = new de();
    let C = !1;
    const R = [],
      B = {};
    function Z() {
      return ((2 * Math.PI) / 60 / 60) * i.autoRotateSpeed;
    }
    function ae() {
      return Math.pow(0.95, i.zoomSpeed);
    }
    function V(j) {
      i.reverseOrbit || i.reverseHorizontalOrbit
        ? (d.theta += j)
        : (d.theta -= j);
    }
    function Q(j) {
      i.reverseOrbit || i.reverseVerticalOrbit ? (d.phi += j) : (d.phi -= j);
    }
    const $ = (() => {
        const j = new U();
        return function (ke, Oe) {
          j.setFromMatrixColumn(Oe, 0), j.multiplyScalar(-ke), m.add(j);
        };
      })(),
      ce = (() => {
        const j = new U();
        return function (ke, Oe) {
          i.screenSpacePanning === !0
            ? j.setFromMatrixColumn(Oe, 1)
            : (j.setFromMatrixColumn(Oe, 0), j.crossVectors(i.object.up, j)),
            j.multiplyScalar(ke),
            m.add(j);
        };
      })(),
      k = (() => {
        const j = new U();
        return function (ke, Oe) {
          const Se = i.domElement;
          if (Se && i.object instanceof En && i.object.isPerspectiveCamera) {
            const X = i.object.position;
            j.copy(X).sub(i.target);
            let Ce = j.length();
            (Ce *= Math.tan(((i.object.fov / 2) * Math.PI) / 180)),
              $((2 * ke * Ce) / Se.clientHeight, i.object.matrix),
              ce((2 * Oe * Ce) / Se.clientHeight, i.object.matrix);
          } else
            Se && i.object instanceof Fo && i.object.isOrthographicCamera
              ? ($(
                  (ke * (i.object.right - i.object.left)) /
                    i.object.zoom /
                    Se.clientWidth,
                  i.object.matrix
                ),
                ce(
                  (Oe * (i.object.top - i.object.bottom)) /
                    i.object.zoom /
                    Se.clientHeight,
                  i.object.matrix
                ))
              : (console.warn(
                  "WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."
                ),
                (i.enablePan = !1));
        };
      })();
    function G(j) {
      (i.object instanceof En && i.object.isPerspectiveCamera) ||
      (i.object instanceof Fo && i.object.isOrthographicCamera)
        ? (p = j)
        : (console.warn(
            "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
          ),
          (i.enableZoom = !1));
    }
    function W(j) {
      G(p / j);
    }
    function Y(j) {
      G(p * j);
    }
    function ie(j) {
      if (!i.zoomToCursor || !i.domElement) return;
      C = !0;
      const ve = i.domElement.getBoundingClientRect(),
        ke = j.clientX - ve.left,
        Oe = j.clientY - ve.top,
        Se = ve.width,
        X = ve.height;
      (N.x = (ke / Se) * 2 - 1),
        (N.y = -(Oe / X) * 2 + 1),
        L.set(N.x, N.y, 1)
          .unproject(i.object)
          .sub(i.object.position)
          .normalize();
    }
    function J(j) {
      return Math.max(i.minDistance, Math.min(i.maxDistance, j));
    }
    function he(j) {
      y.set(j.clientX, j.clientY);
    }
    function Ee(j) {
      ie(j), T.set(j.clientX, j.clientY);
    }
    function be(j) {
      v.set(j.clientX, j.clientY);
    }
    function Pe(j) {
      w.set(j.clientX, j.clientY),
        S.subVectors(w, y).multiplyScalar(i.rotateSpeed);
      const ve = i.domElement;
      ve &&
        (V((2 * Math.PI * S.x) / ve.clientHeight),
        Q((2 * Math.PI * S.y) / ve.clientHeight)),
        y.copy(w),
        i.update();
    }
    function it(j) {
      P.set(j.clientX, j.clientY),
        b.subVectors(P, T),
        b.y > 0 ? W(ae()) : b.y < 0 && Y(ae()),
        T.copy(P),
        i.update();
    }
    function rt(j) {
      M.set(j.clientX, j.clientY),
        _.subVectors(M, v).multiplyScalar(i.panSpeed),
        k(_.x, _.y),
        v.copy(M),
        i.update();
    }
    function Ve(j) {
      ie(j), j.deltaY < 0 ? Y(ae()) : j.deltaY > 0 && W(ae()), i.update();
    }
    function We(j) {
      let ve = !1;
      switch (j.code) {
        case i.keys.UP:
          k(0, i.keyPanSpeed), (ve = !0);
          break;
        case i.keys.BOTTOM:
          k(0, -i.keyPanSpeed), (ve = !0);
          break;
        case i.keys.LEFT:
          k(i.keyPanSpeed, 0), (ve = !0);
          break;
        case i.keys.RIGHT:
          k(-i.keyPanSpeed, 0), (ve = !0);
          break;
      }
      ve && (j.preventDefault(), i.update());
    }
    function H() {
      if (R.length == 1) y.set(R[0].pageX, R[0].pageY);
      else {
        const j = 0.5 * (R[0].pageX + R[1].pageX),
          ve = 0.5 * (R[0].pageY + R[1].pageY);
        y.set(j, ve);
      }
    }
    function Me() {
      if (R.length == 1) v.set(R[0].pageX, R[0].pageY);
      else {
        const j = 0.5 * (R[0].pageX + R[1].pageX),
          ve = 0.5 * (R[0].pageY + R[1].pageY);
        v.set(j, ve);
      }
    }
    function pe() {
      const j = R[0].pageX - R[1].pageX,
        ve = R[0].pageY - R[1].pageY,
        ke = Math.sqrt(j * j + ve * ve);
      T.set(0, ke);
    }
    function Te() {
      i.enableZoom && pe(), i.enablePan && Me();
    }
    function me() {
      i.enableZoom && pe(), i.enableRotate && H();
    }
    function Ke(j) {
      if (R.length == 1) w.set(j.pageX, j.pageY);
      else {
        const ke = He(j),
          Oe = 0.5 * (j.pageX + ke.x),
          Se = 0.5 * (j.pageY + ke.y);
        w.set(Oe, Se);
      }
      S.subVectors(w, y).multiplyScalar(i.rotateSpeed);
      const ve = i.domElement;
      ve &&
        (V((2 * Math.PI * S.x) / ve.clientHeight),
        Q((2 * Math.PI * S.y) / ve.clientHeight)),
        y.copy(w);
    }
    function Ne(j) {
      if (R.length == 1) M.set(j.pageX, j.pageY);
      else {
        const ve = He(j),
          ke = 0.5 * (j.pageX + ve.x),
          Oe = 0.5 * (j.pageY + ve.y);
        M.set(ke, Oe);
      }
      _.subVectors(M, v).multiplyScalar(i.panSpeed), k(_.x, _.y), v.copy(M);
    }
    function D(j) {
      const ve = He(j),
        ke = j.pageX - ve.x,
        Oe = j.pageY - ve.y,
        Se = Math.sqrt(ke * ke + Oe * Oe);
      P.set(0, Se),
        b.set(0, Math.pow(P.y / T.y, i.zoomSpeed)),
        W(b.y),
        T.copy(P);
    }
    function I(j) {
      i.enableZoom && D(j), i.enablePan && Ne(j);
    }
    function te(j) {
      i.enableZoom && D(j), i.enableRotate && Ke(j);
    }
    function xe(j) {
      var ve, ke;
      i.enabled !== !1 &&
        (R.length === 0 &&
          ((ve = i.domElement) == null ||
            ve.ownerDocument.addEventListener("pointermove", ye),
          (ke = i.domElement) == null ||
            ke.ownerDocument.addEventListener("pointerup", ge)),
        _t(j),
        j.pointerType === "touch" ? mt(j) : Ye(j));
    }
    function ye(j) {
      i.enabled !== !1 && (j.pointerType === "touch" ? _e(j) : Le(j));
    }
    function ge(j) {
      var ve, ke, Oe;
      ht(j),
        R.length === 0 &&
          ((ve = i.domElement) == null || ve.releasePointerCapture(j.pointerId),
          (ke = i.domElement) == null ||
            ke.ownerDocument.removeEventListener("pointermove", ye),
          (Oe = i.domElement) == null ||
            Oe.ownerDocument.removeEventListener("pointerup", ge)),
        i.dispatchEvent(o),
        (u = a.NONE);
    }
    function Ye(j) {
      let ve;
      switch (j.button) {
        case 0:
          ve = i.mouseButtons.LEFT;
          break;
        case 1:
          ve = i.mouseButtons.MIDDLE;
          break;
        case 2:
          ve = i.mouseButtons.RIGHT;
          break;
        default:
          ve = -1;
      }
      switch (ve) {
        case Ta.DOLLY:
          if (i.enableZoom === !1) return;
          Ee(j), (u = a.DOLLY);
          break;
        case Ta.ROTATE:
          if (j.ctrlKey || j.metaKey || j.shiftKey) {
            if (i.enablePan === !1) return;
            be(j), (u = a.PAN);
          } else {
            if (i.enableRotate === !1) return;
            he(j), (u = a.ROTATE);
          }
          break;
        case Ta.PAN:
          if (j.ctrlKey || j.metaKey || j.shiftKey) {
            if (i.enableRotate === !1) return;
            he(j), (u = a.ROTATE);
          } else {
            if (i.enablePan === !1) return;
            be(j), (u = a.PAN);
          }
          break;
        default:
          u = a.NONE;
      }
      u !== a.NONE && i.dispatchEvent(s);
    }
    function Le(j) {
      if (i.enabled !== !1)
        switch (u) {
          case a.ROTATE:
            if (i.enableRotate === !1) return;
            Pe(j);
            break;
          case a.DOLLY:
            if (i.enableZoom === !1) return;
            it(j);
            break;
          case a.PAN:
            if (i.enablePan === !1) return;
            rt(j);
            break;
        }
    }
    function Fe(j) {
      i.enabled === !1 ||
        i.enableZoom === !1 ||
        (u !== a.NONE && u !== a.ROTATE) ||
        (j.preventDefault(), i.dispatchEvent(s), Ve(j), i.dispatchEvent(o));
    }
    function tt(j) {
      i.enabled === !1 || i.enablePan === !1 || We(j);
    }
    function mt(j) {
      switch ((et(j), R.length)) {
        case 1:
          switch (i.touches.ONE) {
            case Aa.ROTATE:
              if (i.enableRotate === !1) return;
              H(), (u = a.TOUCH_ROTATE);
              break;
            case Aa.PAN:
              if (i.enablePan === !1) return;
              Me(), (u = a.TOUCH_PAN);
              break;
            default:
              u = a.NONE;
          }
          break;
        case 2:
          switch (i.touches.TWO) {
            case Aa.DOLLY_PAN:
              if (i.enableZoom === !1 && i.enablePan === !1) return;
              Te(), (u = a.TOUCH_DOLLY_PAN);
              break;
            case Aa.DOLLY_ROTATE:
              if (i.enableZoom === !1 && i.enableRotate === !1) return;
              me(), (u = a.TOUCH_DOLLY_ROTATE);
              break;
            default:
              u = a.NONE;
          }
          break;
        default:
          u = a.NONE;
      }
      u !== a.NONE && i.dispatchEvent(s);
    }
    function _e(j) {
      switch ((et(j), u)) {
        case a.TOUCH_ROTATE:
          if (i.enableRotate === !1) return;
          Ke(j), i.update();
          break;
        case a.TOUCH_PAN:
          if (i.enablePan === !1) return;
          Ne(j), i.update();
          break;
        case a.TOUCH_DOLLY_PAN:
          if (i.enableZoom === !1 && i.enablePan === !1) return;
          I(j), i.update();
          break;
        case a.TOUCH_DOLLY_ROTATE:
          if (i.enableZoom === !1 && i.enableRotate === !1) return;
          te(j), i.update();
          break;
        default:
          u = a.NONE;
      }
    }
    function Rt(j) {
      i.enabled !== !1 && j.preventDefault();
    }
    function _t(j) {
      R.push(j);
    }
    function ht(j) {
      delete B[j.pointerId];
      for (let ve = 0; ve < R.length; ve++)
        if (R[ve].pointerId == j.pointerId) {
          R.splice(ve, 1);
          return;
        }
    }
    function et(j) {
      let ve = B[j.pointerId];
      ve === void 0 && ((ve = new de()), (B[j.pointerId] = ve)),
        ve.set(j.pageX, j.pageY);
    }
    function He(j) {
      const ve = j.pointerId === R[0].pointerId ? R[1] : R[0];
      return B[ve.pointerId];
    }
    (this.dollyIn = (j = ae()) => {
      Y(j), i.update();
    }),
      (this.dollyOut = (j = ae()) => {
        W(j), i.update();
      }),
      (this.getScale = () => p),
      (this.setScale = (j) => {
        G(j), i.update();
      }),
      (this.getZoomScale = () => ae()),
      t !== void 0 && this.connect(t),
      this.update();
  }
};
const Dj = () => parseInt(mh.replace(/\D+/g, "")),
  Oj = Dj(),
  Uj = se.forwardRef(
    (
      {
        makeDefault: n,
        camera: e,
        regress: t,
        domElement: i,
        enableDamping: r = !0,
        keyEvents: s = !1,
        onChange: o,
        onStart: a,
        onEnd: u,
        ...f
      },
      h
    ) => {
      const d = go((b) => b.invalidate),
        p = go((b) => b.camera),
        m = go((b) => b.gl),
        y = go((b) => b.events),
        w = go((b) => b.setEvents),
        S = go((b) => b.set),
        v = go((b) => b.get),
        M = go((b) => b.performance),
        _ = e || p,
        T = i || y.connected || m.domElement,
        P = se.useMemo(() => new Nj(_), [_]);
      return (
        Ch(() => {
          P.enabled && P.update();
        }, -1),
        se.useEffect(
          () => (
            s && P.connect(s === !0 ? T : s),
            P.connect(T),
            () => void P.dispose()
          ),
          [s, T, t, P, d]
        ),
        se.useEffect(() => {
          const b = (C) => {
              d(), t && M.regress(), o && o(C);
            },
            L = (C) => {
              a && a(C);
            },
            N = (C) => {
              u && u(C);
            };
          return (
            P.addEventListener("change", b),
            P.addEventListener("start", L),
            P.addEventListener("end", N),
            () => {
              P.removeEventListener("start", L),
                P.removeEventListener("end", N),
                P.removeEventListener("change", b);
            }
          );
        }, [o, a, u, P, d, w]),
        se.useEffect(() => {
          if (n) {
            const b = v().controls;
            return S({ controls: P }), () => S({ controls: b });
          }
        }, [n, P]),
        se.createElement(
          "primitive",
          $f({ ref: h, object: P, enableDamping: r }, f)
        )
      );
    }
  );
var kj = `#define GLSLIFY 1
vec3 mod289(vec3 x){return x-floor(x*(1.0/289.0))*289.0;}vec4 mod289(vec4 x){return x-floor(x*(1.0/289.0))*289.0;}vec4 permute(vec4 x){return mod289(((x*34.0)+1.0)*x);}vec4 taylorInvSqrt(vec4 r){return 1.79284291400159-0.85373472095314*r;}float snoise(vec3 v){const vec2 C=vec2(1.0/6.0,1.0/3.0);const vec4 D=vec4(0.0,0.5,1.0,2.0);vec3 i=floor(v+dot(v,C.yyy));vec3 x0=v-i+dot(i,C.xxx);vec3 g=step(x0.yzx,x0.xyz);vec3 l=1.0-g;vec3 i1=min(g.xyz,l.zxy);vec3 i2=max(g.xyz,l.zxy);vec3 x1=x0-i1+C.xxx;vec3 x2=x0-i2+C.yyy;vec3 x3=x0-D.yyy;i=mod289(i);vec4 p=permute(permute(permute(i.z+vec4(0.0,i1.z,i2.z,1.0))+i.y+vec4(0.0,i1.y,i2.y,1.0))+i.x+vec4(0.0,i1.x,i2.x,1.0));float n_=0.142857142857;vec3 ns=n_*D.wyz-D.xzx;vec4 j=p-49.0*floor(p*ns.z*ns.z);vec4 x_=floor(j*ns.z);vec4 y_=floor(j-7.0*x_);vec4 x=x_*ns.x+ns.yyyy;vec4 y=y_*ns.x+ns.yyyy;vec4 h=1.0-abs(x)-abs(y);vec4 b0=vec4(x.xy,y.xy);vec4 b1=vec4(x.zw,y.zw);vec4 s0=floor(b0)*2.0+1.0;vec4 s1=floor(b1)*2.0+1.0;vec4 sh=-step(h,vec4(0.0));vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy;vec4 a1=b1.xzyw+s1.xzyw*sh.zzww;vec3 p0=vec3(a0.xy,h.x);vec3 p1=vec3(a0.zw,h.y);vec3 p2=vec3(a1.xy,h.z);vec3 p3=vec3(a1.zw,h.w);vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));p0*=norm.x;p1*=norm.y;p2*=norm.z;p3*=norm.w;vec4 m=max(0.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.0);m=m*m;return 42.0*dot(m*m,vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3)));}`;
class Fj extends JS {
  constructor(e = {}) {
    super(e),
      this.setValues(e),
      (this._time = { value: 0 }),
      (this._distort = { value: 0.4 }),
      (this._radius = { value: 1 });
  }
  onBeforeCompile(e) {
    (e.uniforms.time = this._time),
      (e.uniforms.radius = this._radius),
      (e.uniforms.distort = this._distort),
      (e.vertexShader = `
      uniform float time;
      uniform float radius;
      uniform float distort;
      ${kj}
      ${e.vertexShader}
    `),
      (e.vertexShader = e.vertexShader.replace(
        "#include <begin_vertex>",
        `
        float updateTime = time / 50.0;
        float noise = snoise(vec3(position / 2.0 + updateTime * 5.0));
        vec3 transformed = vec3(position * (noise * pow(distort, 2.0) + radius));
        `
      ));
  }
  get time() {
    return this._time.value;
  }
  set time(e) {
    this._time.value = e;
  }
  get distort() {
    return this._distort.value;
  }
  set distort(e) {
    this._distort.value = e;
  }
  get radius() {
    return this._radius.value;
  }
  set radius(e) {
    this._radius.value = e;
  }
}
const zj = se.forwardRef(({ speed: n = 1, ...e }, t) => {
  const [i] = se.useState(() => new Fj());
  return (
    Ch((r) => i && (i.time = r.clock.elapsedTime * n)),
    se.createElement(
      "primitive",
      $f({ object: i, ref: t, attach: "material" }, e)
    )
  );
});
function Bj(n, e) {
  const t = n + "Geometry";
  return se.forwardRef(({ args: i, children: r, ...s }, o) => {
    const a = se.useRef(null);
    return (
      se.useImperativeHandle(o, () => a.current),
      se.useLayoutEffect(() => void (e == null ? void 0 : e(a.current))),
      se.createElement(
        "mesh",
        $f({ ref: a }, s),
        se.createElement(t, { attach: "geometry", args: i }),
        r
      )
    );
  });
}
const Vj = Bj("sphere"),
  Hj = se.forwardRef(
    (
      {
        children: n,
        enabled: e = !0,
        speed: t = 1,
        rotationIntensity: i = 1,
        floatIntensity: r = 1,
        floatingRange: s = [-0.1, 0.1],
        autoInvalidate: o = !1,
        ...a
      },
      u
    ) => {
      const f = se.useRef(null);
      se.useImperativeHandle(u, () => f.current, []);
      const h = se.useRef(Math.random() * 1e4);
      return (
        Ch((d) => {
          var p, m;
          if (!e || t === 0) return;
          o && d.invalidate();
          const y = h.current + d.clock.elapsedTime;
          (f.current.rotation.x = (Math.cos((y / 4) * t) / 8) * i),
            (f.current.rotation.y = (Math.sin((y / 4) * t) / 8) * i),
            (f.current.rotation.z = (Math.sin((y / 4) * t) / 20) * i);
          let w = Math.sin((y / 4) * t) / 10;
          (w = ML.mapLinear(
            w,
            -0.1,
            0.1,
            (p = s == null ? void 0 : s[0]) !== null && p !== void 0 ? p : -0.1,
            (m = s == null ? void 0 : s[1]) !== null && m !== void 0 ? m : 0.1
          )),
            (f.current.position.y = w * r),
            f.current.updateMatrix();
        }),
        se.createElement(
          "group",
          a,
          se.createElement("group", { ref: f, matrixAutoUpdate: !1 }, n)
        )
      );
    }
  );
class Gj extends Hr {
  constructor() {
    super({
      uniforms: { time: { value: 0 }, fade: { value: 1 } },
      vertexShader: `
      uniform float time;
      attribute float size;
      varying vec3 vColor;
      void main() {
        vColor = color;
        vec4 mvPosition = modelViewMatrix * vec4(position, 0.5);
        gl_PointSize = size * (30.0 / -mvPosition.z) * (3.0 + sin(time + 100.0));
        gl_Position = projectionMatrix * mvPosition;
      }`,
      fragmentShader: `
      uniform sampler2D pointTexture;
      uniform float fade;
      varying vec3 vColor;
      void main() {
        float opacity = 1.0;
        if (fade == 1.0) {
          float d = distance(gl_PointCoord, vec2(0.5, 0.5));
          opacity = 1.0 / (1.0 + exp(16.0 * (d - 0.25)));
        }
        gl_FragColor = vec4(vColor, opacity);

        #include <tonemapping_fragment>
	      #include <${Oj >= 154 ? "colorspace_fragment" : "encodings_fragment"}>
      }`,
    });
  }
}
const Wj = (n) =>
    new U().setFromSpherical(
      new ig(n, Math.acos(1 - Math.random() * 2), Math.random() * 2 * Math.PI)
    ),
  jj = se.forwardRef(
    (
      {
        radius: n = 100,
        depth: e = 50,
        count: t = 5e3,
        saturation: i = 0,
        factor: r = 4,
        fade: s = !1,
        speed: o = 1,
      },
      a
    ) => {
      const u = se.useRef(),
        [f, h, d] = se.useMemo(() => {
          const m = [],
            y = [],
            w = Array.from(
              { length: t },
              () => (0.5 + 0.5 * Math.random()) * r
            ),
            S = new Be();
          let v = n + e;
          const M = e / t;
          for (let _ = 0; _ < t; _++)
            (v -= M * Math.random()),
              m.push(...Wj(v).toArray()),
              S.setHSL(_ / t, i, 0.9),
              y.push(S.r, S.g, S.b);
          return [
            new Float32Array(m),
            new Float32Array(y),
            new Float32Array(w),
          ];
        }, [t, e, r, n, i]);
      Ch(
        (m) =>
          u.current && (u.current.uniforms.time.value = m.clock.elapsedTime * o)
      );
      const [p] = se.useState(() => new Gj());
      return se.createElement(
        "points",
        { ref: a },
        se.createElement(
          "bufferGeometry",
          null,
          se.createElement("bufferAttribute", {
            attach: "attributes-position",
            args: [f, 3],
          }),
          se.createElement("bufferAttribute", {
            attach: "attributes-color",
            args: [h, 3],
          }),
          se.createElement("bufferAttribute", {
            attach: "attributes-size",
            args: [d, 1],
          })
        ),
        se.createElement("primitive", {
          ref: u,
          object: p,
          attach: "material",
          blending: Km,
          "uniforms-fade-value": s,
          depthWrite: !1,
          transparent: !0,
          vertexColors: !0,
        })
      );
    }
  );
function Xj() {
  const n = se.useRef();
  return (
    Ch((e) => {
      const t = e.clock.getElapsedTime();
      (n.current.rotation.y = t * 0.15),
        (n.current.rotation.x = Math.sin(t * 0.1) * 0.1);
    }),
    z.jsx(Hj, {
      speed: 1.5,
      rotationIntensity: 0.5,
      floatIntensity: 1,
      children: z.jsx(Vj, {
        args: [1.8, 64, 64],
        ref: n,
        scale: 1,
        children: z.jsx(zj, {
          color: "#d4af37",
          attach: "material",
          distort: 0.35,
          speed: 1.8,
          roughness: 0.1,
          metalness: 0.9,
          envMapIntensity: 1,
        }),
      }),
    })
  );
}
function Yj() {
  return z.jsxs(z.Fragment, {
    children: [
      z.jsx(jj, {
        radius: 100,
        depth: 50,
        count: 3e3,
        factor: 4,
        saturation: 0,
        fade: !0,
        speed: 0.5,
      }),
      z.jsx("ambientLight", { intensity: 0.3 }),
      z.jsx("directionalLight", {
        position: [5, 5, 5],
        intensity: 1,
        color: "#d4af37",
      }),
      z.jsx("directionalLight", {
        position: [-5, -5, -5],
        intensity: 0.5,
        color: "#f0d878",
      }),
      z.jsx("pointLight", {
        position: [0, 0, 0],
        intensity: 0.8,
        color: "#d4af37",
      }),
    ],
  });
}
function qj() {
  const n = {
      hidden: { opacity: 0 },
      visible: {
        opacity: 1,
        transition: { staggerChildren: 0.15, delayChildren: 0.3 },
      },
    },
    e = {
      hidden: { opacity: 0, y: 50 },
      visible: {
        opacity: 1,
        y: 0,
        transition: { duration: 0.8, ease: [0.16, 1, 0.3, 1] },
      },
    };
  return z.jsxs("section", {
    id: "hero",
    className: "relative min-h-screen flex items-center overflow-hidden",
    children: [
      z.jsx("div", {
        className: "absolute inset-0 z-0",
        children: z.jsxs(Tj, {
          camera: { position: [0, 0, 5], fov: 45 },
          children: [
            z.jsx(Yj, {}),
            z.jsx(Xj, {}),
            z.jsx(Uj, {
              enableZoom: !1,
              enablePan: !1,
              autoRotate: !0,
              autoRotateSpeed: 0.2,
            }),
          ],
        }),
      }),
      z.jsx("div", {
        className:
          "absolute inset-0 bg-gradient-to-b from-background/50 via-transparent to-background/80 z-0 pointer-events-none",
      }),
      z.jsx(nt.div, {
        variants: n,
        initial: "hidden",
        animate: "visible",
        className: "relative z-10 w-full max-w-7xl mx-auto px-6 md:px-12 py-20",
        children: z.jsxs("div", {
          className: "flex flex-col justify-center min-h-screen pt-20",
          children: [
            z.jsx(nt.div, {
              variants: e,
              className: "mb-6",
              children: z.jsx("span", {
                className:
                  "text-caption font-mono tracking-widest text-accent uppercase",
                children: "Creative Developer",
              }),
            }),
            z.jsxs(nt.h1, {
              variants: e,
              className: "text-display font-display mb-8 leading-tight",
              children: [
                z.jsx("span", {
                  className: "text-gradient-subtle",
                  children: "Crafting",
                }),
                z.jsx("br", {}),
                z.jsx("span", {
                  className: "text-gradient-gold",
                  children: "Digital",
                }),
                z.jsx("br", {}),
                z.jsx("span", {
                  className: "text-text",
                  children: "Experiences",
                }),
              ],
            }),
            z.jsx(nt.p, {
              variants: e,
              className: "text-body max-w-xl mb-12 text-textMuted font-light",
              children:
                "I design and build immersive digital products with a focus on aesthetics, interaction, and thoughtful details. Based in San Francisco.",
            }),
            z.jsxs(nt.div, {
              variants: e,
              className: "flex flex-wrap gap-6",
              children: [
                z.jsxs(nt.button, {
                  onClick: () => Zt.scrollTo("projects"),
                  whileHover: { scale: 1.02 },
                  whileTap: { scale: 0.98 },
                  className:
                    "group px-8 py-4 glass rounded-full text-body font-medium text-text flex items-center gap-3 magnetic",
                  children: [
                    z.jsx("span", { children: "View Selected Work" }),
                    z.jsx(nt.span, {
                      className: "text-accent",
                      animate: { x: [0, 4, 0] },
                      transition: { duration: 1.5, repeat: 1 / 0 },
                      children: "",
                    }),
                  ],
                }),
                z.jsx(nt.button, {
                  whileHover: { scale: 1.02 },
                  whileTap: { scale: 0.98 },
                  className:
                    "px-8 py-4 rounded-full text-body font-medium text-textMuted hover:text-text transition-colors magnetic",
                  children: "Get in Touch",
                }),
              ],
            }),
            z.jsx(nt.div, {
              variants: e,
              className: "mt-16 flex flex-wrap gap-4",
              children: [
                "React",
                "TypeScript",
                "Node.js",
                "Three.js",
                "PostgreSQL",
              ].map((t, i) =>
                z.jsx(
                  "span",
                  {
                    className:
                      "px-5 py-2 glass rounded-full text-caption text-textMuted tracking-wide magnetic",
                    children: t,
                  },
                  t
                )
              ),
            }),
          ],
        }),
      }),
      z.jsx(nt.div, {
        initial: { opacity: 0 },
        animate: { opacity: 1 },
        transition: { delay: 1.5, duration: 1 },
        className:
          "absolute bottom-12 left-1/2 transform -translate-x-1/2 z-10",
        children: z.jsxs(nt.div, {
          animate: { y: [0, 8, 0] },
          transition: { duration: 2, repeat: 1 / 0, ease: "easeInOut" },
          className: "flex flex-col items-center gap-3",
          children: [
            z.jsx("span", {
              className:
                "text-caption text-textMuted uppercase tracking-widest",
              children: "Scroll",
            }),
            z.jsx("div", {
              className:
                "w-px h-12 bg-gradient-to-b from-accent/50 to-transparent",
            }),
          ],
        }),
      }),
    ],
  });
}
function Zj() {
  const n = [
      { label: "Years Experience", value: "6+" },
      { label: "Projects Delivered", value: "40+" },
      { label: "Happy Clients", value: "25+" },
      { label: "Awards", value: "3" },
    ],
    e = [
      {
        icon: Uz,
        title: "Design & Development",
        description:
          "Creating cohesive digital experiences that blend aesthetic vision with technical excellence.",
      },
      {
        icon: Nz,
        title: "Creative Technology",
        description:
          "Building interactive experiences using React, WebGL, and emerging web technologies.",
      },
      {
        icon: Bz,
        title: "System Architecture",
        description:
          "Designing scalable, maintainable systems that grow with your business needs.",
      },
      {
        icon: kz,
        title: "Data & Analytics",
        description:
          "Implementing robust data solutions that drive informed business decisions.",
      },
      {
        icon: Oz,
        title: "Cloud Infrastructure",
        description:
          "Deploying and managing modern cloud solutions on AWS and serverless platforms.",
      },
      {
        icon: Iz,
        title: "API Design",
        description:
          "Crafting intuitive, performant APIs that power seamless user experiences.",
      },
    ];
  return z.jsx("section", {
    id: "about",
    className: "py-section relative",
    children: z.jsxs("div", {
      className: "max-w-7xl mx-auto px-6 md:px-12",
      children: [
        z.jsxs(nt.div, {
          initial: { opacity: 0, y: 40 },
          whileInView: { opacity: 1, y: 0 },
          viewport: { once: !0 },
          transition: { duration: 0.8 },
          className: "mb-20",
          children: [
            z.jsx("span", {
              className:
                "text-caption font-mono tracking-widest text-accent uppercase block mb-4",
              children: "About",
            }),
            z.jsxs("div", {
              className: "grid lg:grid-cols-2 gap-12 items-end",
              children: [
                z.jsxs("h2", {
                  className: "text-heading font-display",
                  children: [
                    "Bridging Design ",
                    z.jsx("span", {
                      className: "text-gradient-gold",
                      children: "& Engineering",
                    }),
                  ],
                }),
                z.jsx("p", {
                  className: "text-body text-textMuted font-light max-w-lg",
                  children:
                    "I'm a creative developer focused on building digital products that are not just functional, but truly beautiful. With a background in both design and engineering, I bring a unique perspective to every project.",
                }),
              ],
            }),
          ],
        }),
        z.jsx(nt.div, {
          initial: { opacity: 0, y: 40 },
          whileInView: { opacity: 1, y: 0 },
          viewport: { once: !0 },
          transition: { duration: 0.8, delay: 0.2 },
          className: "grid grid-cols-2 md:grid-cols-4 gap-px bg-border mb-20",
          children: n.map((t, i) =>
            z.jsxs(
              "div",
              {
                className: "glass-surface p-8 md:p-10 text-center group",
                children: [
                  z.jsx(nt.div, {
                    className:
                      "text-4xl md:text-5xl font-display text-text mb-2",
                    initial: { opacity: 0 },
                    whileInView: { opacity: 1 },
                    transition: { delay: 0.3 + i * 0.1 },
                    children: t.value,
                  }),
                  z.jsx("div", {
                    className:
                      "text-caption text-textMuted uppercase tracking-wider font-light",
                    children: t.label,
                  }),
                ],
              },
              t.label
            )
          ),
        }),
        z.jsx("div", {
          className: "grid md:grid-cols-2 lg:grid-cols-3 gap-6",
          children: e.map((t, i) =>
            z.jsxs(
              nt.div,
              {
                initial: { opacity: 0, y: 40 },
                whileInView: { opacity: 1, y: 0 },
                viewport: { once: !0 },
                transition: { duration: 0.6, delay: i * 0.1 },
                whileHover: { y: -8 },
                className: "glass-card p-8 rounded-2xl group cursor-default",
                children: [
                  z.jsx("div", {
                    className:
                      "w-14 h-14 glass rounded-xl flex items-center justify-center mb-6 group-hover:bg-accent/10 transition-colors",
                    children: z.jsx(t.icon, {
                      className: "text-xl text-accent",
                    }),
                  }),
                  z.jsx("h3", {
                    className:
                      "text-lg font-medium mb-3 text-text group-hover:text-accent transition-colors",
                    children: t.title,
                  }),
                  z.jsx("p", {
                    className:
                      "text-body text-textMuted font-light leading-relaxed",
                    children: t.description,
                  }),
                ],
              },
              t.title
            )
          ),
        }),
        z.jsx(nt.div, {
          initial: { opacity: 0, scaleX: 0 },
          whileInView: { opacity: 1, scaleX: 1 },
          viewport: { once: !0 },
          transition: { duration: 1, delay: 0.5 },
          className:
            "mt-20 h-px bg-gradient-to-r from-transparent via-accent/30 to-transparent",
        }),
      ],
    }),
  });
}
function Kj() {
  const n = [
      {
        name: "Creative Development",
        skills: [
          { name: "React & Next.js", level: 95 },
          { name: "TypeScript", level: 90 },
          { name: "Three.js / WebGL", level: 85 },
          { name: "Framer Motion", level: 92 },
        ],
      },
      {
        name: "Backend & Infrastructure",
        skills: [
          { name: "Node.js", level: 92 },
          { name: "PostgreSQL", level: 88 },
          { name: "AWS", level: 85 },
          { name: "Docker", level: 88 },
        ],
      },
      {
        name: "Design & Tools",
        skills: [
          { name: "UI/UX Design", level: 90 },
          { name: "Figma", level: 87 },
          { name: "Git", level: 95 },
          { name: "Testing", level: 82 },
        ],
      },
    ],
    e = [
      "GraphQL",
      "Python",
      "Redis",
      "Kubernetes",
      "Tailwind CSS",
      "Storybook",
      "CI/CD",
      "MongoDB",
      "Serverless",
      "Stripe",
      "Prisma",
      "Zustand",
    ];
  return z.jsx("section", {
    id: "skills",
    className: "py-section relative",
    children: z.jsxs("div", {
      className: "max-w-7xl mx-auto px-6 md:px-12",
      children: [
        z.jsxs(nt.div, {
          initial: { opacity: 0, y: 40 },
          whileInView: { opacity: 1, y: 0 },
          viewport: { once: !0 },
          transition: { duration: 0.8 },
          className: "text-center mb-16",
          children: [
            z.jsx("span", {
              className:
                "text-caption font-mono tracking-widest text-accent uppercase block mb-4",
              children: "Expertise",
            }),
            z.jsxs("h2", {
              className: "text-heading font-display mb-6",
              children: [
                "Technical ",
                z.jsx("span", {
                  className: "text-gradient-gold",
                  children: "Proficiency",
                }),
              ],
            }),
            z.jsx("p", {
              className:
                "text-body text-textMuted font-light max-w-2xl mx-auto",
              children:
                "A curated selection of technologies and methodologies I employ to deliver exceptional digital solutions.",
            }),
          ],
        }),
        z.jsx("div", {
          className: "grid lg:grid-cols-3 gap-6 mb-20",
          children: n.map((t, i) =>
            z.jsxs(
              nt.div,
              {
                initial: { opacity: 0, y: 40 },
                whileInView: { opacity: 1, y: 0 },
                viewport: { once: !0 },
                transition: { duration: 0.6, delay: i * 0.15 },
                className: "glass-surface p-8 rounded-2xl",
                children: [
                  z.jsxs("div", {
                    className: "flex items-center gap-3 mb-8",
                    children: [
                      z.jsx("div", {
                        className:
                          "w-1 h-8 bg-gradient-to-b from-accent to-accent/50 rounded-full",
                      }),
                      z.jsx("h3", {
                        className: "text-lg font-medium text-text",
                        children: t.name,
                      }),
                    ],
                  }),
                  z.jsx("div", {
                    className: "space-y-6",
                    children: t.skills.map((r, s) =>
                      z.jsxs(
                        nt.div,
                        {
                          initial: { opacity: 0, x: -20 },
                          whileInView: { opacity: 1, x: 0 },
                          viewport: { once: !0 },
                          transition: {
                            duration: 0.4,
                            delay: i * 0.15 + s * 0.1,
                          },
                          children: [
                            z.jsxs("div", {
                              className:
                                "flex items-center justify-between mb-3",
                              children: [
                                z.jsx("span", {
                                  className:
                                    "text-body text-textLight font-light",
                                  children: r.name,
                                }),
                                z.jsxs("span", {
                                  className:
                                    "text-caption text-accent font-mono",
                                  children: [r.level, "%"],
                                }),
                              ],
                            }),
                            z.jsx("div", {
                              className:
                                "h-1 bg-border rounded-full overflow-hidden",
                              children: z.jsx(nt.div, {
                                initial: { width: 0 },
                                whileInView: { width: `${r.level}%` },
                                viewport: { once: !0 },
                                transition: {
                                  duration: 1,
                                  delay: i * 0.15 + s * 0.1 + 0.2,
                                },
                                className:
                                  "h-full bg-gradient-to-r from-accent/80 to-accent rounded-full",
                              }),
                            }),
                          ],
                        },
                        r.name
                      )
                    ),
                  }),
                ],
              },
              t.name
            )
          ),
        }),
        z.jsxs(nt.div, {
          initial: { opacity: 0 },
          whileInView: { opacity: 1 },
          viewport: { once: !0 },
          transition: { duration: 0.8, delay: 0.3 },
          className: "text-center",
          children: [
            z.jsx("p", {
              className:
                "text-caption text-textMuted uppercase tracking-widest mb-6",
              children: "Also Proficient In",
            }),
            z.jsx("div", {
              className: "flex flex-wrap justify-center gap-3",
              children: e.map((t, i) =>
                z.jsx(
                  nt.span,
                  {
                    initial: { opacity: 0, scale: 0.9 },
                    whileInView: { opacity: 1, scale: 1 },
                    viewport: { once: !0 },
                    transition: { duration: 0.3, delay: 0.4 + i * 0.05 },
                    className:
                      "px-4 py-2 glass rounded-full text-caption text-textMuted hover:text-text hover:bg-white/5 transition-all cursor-default magnetic",
                    children: t,
                  },
                  t
                )
              ),
            }),
          ],
        }),
      ],
    }),
  });
}
const Qj = [
  {
    title: "E-Commerce Platform",
    category: "Full-Stack Development",
    description:
      "A sophisticated e-commerce solution featuring real-time inventory management, seamless payment processing, and a comprehensive admin dashboard. The platform delivers exceptional performance while maintaining an elegant user experience.",
    image:
      "https://images.unsplash.com/photo-1557821552-17105176677c?w=1200&h=800&fit=crop",
    technologies: ["React", "Node.js", "PostgreSQL", "Stripe"],
    year: "2024",
  },
  {
    title: "Task Management App",
    category: "Productivity Tool",
    description:
      "A collaborative project management platform with real-time updates, team workspaces, and intuitive automated workflows. Features include drag-and-drop kanban boards and comprehensive analytics.",
    image:
      "https://images.unsplash.com/photo-1611224923853-80b023f02d71?w=1200&h=800&fit=crop",
    technologies: ["Next.js", "TypeScript", "Prisma", "WebSocket"],
    year: "2024",
  },
  {
    title: "Social Media Dashboard",
    category: "Analytics Platform",
    description:
      "An elegant analytics dashboard for social media management with multi-platform integration, intelligent scheduling, and deep engagement metrics through interactive visualizations.",
    image:
      "https://images.unsplash.com/photo-1460925895917-afdab827c52f?w=1200&h=800&fit=crop",
    technologies: ["Vue.js", "Python", "GraphQL", "D3.js"],
    year: "2023",
  },
  {
    title: "Real-time Chat Application",
    category: "Communication Platform",
    description:
      "A feature-rich messaging platform supporting channels, direct messages, file sharing, and video calls. Built with end-to-end encryption and customizable themes.",
    image:
      "https://images.unsplash.com/photo-1611746872915-64382b5c76da?w=1200&h=800&fit=crop",
    technologies: ["React", "Express", "Socket.io", "MongoDB"],
    year: "2023",
  },
];
function $j({ project: n, index: e }) {
  return z.jsxs(nt.article, {
    initial: { opacity: 0, y: 50 },
    whileInView: { opacity: 1, y: 0 },
    viewport: { once: !0 },
    transition: { duration: 0.8, delay: e * 0.15 },
    className: "group cursor-pointer",
    children: [
      z.jsxs("div", {
        className: "relative aspect-[4/3] overflow-hidden rounded-2xl mb-6",
        children: [
          z.jsx(nt.img, {
            src: n.image,
            alt: n.title,
            className:
              "w-full h-full object-cover transform group-hover:scale-105 transition-transform duration-700 ease-out",
            whileHover: { scale: 1.05 },
          }),
          z.jsx("div", {
            className:
              "absolute inset-0 bg-gradient-to-t from-background/80 via-background/20 to-transparent opacity-60",
          }),
          z.jsx("div", {
            className: "absolute top-6 right-6",
            children: z.jsx("span", {
              className:
                "px-3 py-1 glass rounded-full text-caption text-textMuted",
              children: n.year,
            }),
          }),
          z.jsxs("div", {
            className:
              "absolute inset-0 bg-background/40 opacity-0 group-hover:opacity-100 transition-opacity duration-500 flex items-center justify-center gap-4",
            children: [
              z.jsx(nt.a, {
                href: "#",
                target: "_blank",
                rel: "noopener noreferrer",
                whileHover: { scale: 1.1 },
                whileTap: { scale: 0.95 },
                className:
                  "p-4 glass rounded-full text-text hover:text-accent transition-colors",
                "aria-label": "View Project",
                children: z.jsx(J3, { size: 20 }),
              }),
              z.jsx(nt.a, {
                href: "#",
                target: "_blank",
                rel: "noopener noreferrer",
                whileHover: { scale: 1.1 },
                whileTap: { scale: 0.95 },
                className:
                  "p-4 glass rounded-full text-text hover:text-accent transition-colors",
                "aria-label": "View Code",
                children: z.jsx(Cg, { size: 20 }),
              }),
            ],
          }),
        ],
      }),
      z.jsxs("div", {
        className: "space-y-4",
        children: [
          z.jsx("span", {
            className:
              "text-caption font-mono text-accent uppercase tracking-wider",
            children: n.category,
          }),
          z.jsx("h3", {
            className:
              "text-2xl font-display text-text group-hover:text-accent transition-colors",
            children: n.title,
          }),
          z.jsx("p", {
            className:
              "text-body text-textMuted font-light leading-relaxed line-clamp-2",
            children: n.description,
          }),
          z.jsx("div", {
            className: "flex flex-wrap gap-2 pt-2",
            children: n.technologies.map((t) =>
              z.jsx(
                "span",
                {
                  className:
                    "px-3 py-1 glass rounded-full text-caption text-textMuted",
                  children: t,
                },
                t
              )
            ),
          }),
        ],
      }),
    ],
  });
}
function Jj() {
  return z.jsx("section", {
    id: "projects",
    className: "py-section relative",
    children: z.jsxs("div", {
      className: "max-w-7xl mx-auto px-6 md:px-12",
      children: [
        z.jsxs(nt.div, {
          initial: { opacity: 0, y: 40 },
          whileInView: { opacity: 1, y: 0 },
          viewport: { once: !0 },
          transition: { duration: 0.8 },
          className: "mb-20",
          children: [
            z.jsx("span", {
              className:
                "text-caption font-mono tracking-widest text-accent uppercase block mb-4",
              children: "Portfolio",
            }),
            z.jsxs("div", {
              className: "grid lg:grid-cols-2 gap-12 items-end",
              children: [
                z.jsxs("h2", {
                  className: "text-heading font-display",
                  children: [
                    "Selected ",
                    z.jsx("span", {
                      className: "text-gradient-gold",
                      children: "Work",
                    }),
                  ],
                }),
                z.jsx("p", {
                  className: "text-body text-textMuted font-light",
                  children:
                    "A collection of projects that showcase my approach to digital product development, from concept to deployment.",
                }),
              ],
            }),
          ],
        }),
        z.jsx("div", {
          className: "grid md:grid-cols-2 gap-x-8 gap-y-16",
          children: Qj.map((n, e) =>
            z.jsx($j, { project: n, index: e }, n.title)
          ),
        }),
        z.jsx(nt.div, {
          initial: { opacity: 0 },
          whileInView: { opacity: 1 },
          viewport: { once: !0 },
          transition: { duration: 0.8, delay: 0.3 },
          className: "text-center mt-20",
          children: z.jsxs(nt.a, {
            href: "https://github.com/Oumaima-El-Badraouy",
            target: "_blank",
            rel: "noopener noreferrer",
            whileHover: { scale: 1.02 },
            whileTap: { scale: 0.98 },
            className:
              "inline-flex items-center gap-3 px-8 py-4 glass rounded-full text-body text-text hover:text-accent transition-colors magnetic",
            children: [
              z.jsx("span", { children: "Explore All Projects" }),
              z.jsx(J3, { size: 16 }),
            ],
          }),
        }),
      ],
    }),
  });
}
function eX() {
  const [n, e] = se.useState({ name: "", email: "", subject: "", message: "" }),
    [t, i] = se.useState(!1),
    [r, s] = se.useState(null),
    o = async (f) => {
      f.preventDefault(),
        i(!0),
        await new Promise((h) => setTimeout(h, 1500)),
        s("success"),
        i(!1),
        e({ name: "", email: "", subject: "", message: "" }),
        setTimeout(() => s(null), 3e3);
    },
    a = [
      {
        icon: Fz,
        label: "Email",
        value: "hello@developer.com",
        href: "mailto:hello@developer.com",
      },
      {
        icon: Hz,
        label: "Phone",
        value: "+1 (555) 123-4567",
        href: "tel:+15551234567",
      },
      { icon: Vz, label: "Location", value: "San Francisco, CA", href: "#" },
    ],
    u = [
      {
        icon: Cg,
        href: "https://github.com/Oumaima-El-Badraouy",
        label: "GitHub",
      },
      {
        icon: cS,
        href: "https://www.linkedin.com/in/oumaima-el-badraouy/",
        label: "LinkedIn",
      },
      { icon: fS, href: "https://twitter.com", label: "Twitter" },
    ];
  return z.jsx("section", {
    id: "contact",
    className: "py-section relative",
    children: z.jsxs("div", {
      className: "max-w-7xl mx-auto px-6 md:px-12",
      children: [
        z.jsxs(nt.div, {
          initial: { opacity: 0, y: 40 },
          whileInView: { opacity: 1, y: 0 },
          viewport: { once: !0 },
          transition: { duration: 0.8 },
          className: "mb-20",
          children: [
            z.jsx("span", {
              className:
                "text-caption font-mono tracking-widest text-accent uppercase block mb-4",
              children: "Contact",
            }),
            z.jsxs("div", {
              className: "grid lg:grid-cols-2 gap-12 items-end",
              children: [
                z.jsxs("h2", {
                  className: "text-heading font-display",
                  children: [
                    "Let's Create ",
                    z.jsx("span", {
                      className: "text-gradient-gold",
                      children: "Together",
                    }),
                  ],
                }),
                z.jsx("p", {
                  className: "text-body text-textMuted font-light max-w-lg",
                  children:
                    "Have a project in mind? I'd love to hear about it. Whether you need a creative developer or want to collaborate on something innovative, let's start a conversation.",
                }),
              ],
            }),
          ],
        }),
        z.jsxs("div", {
          className: "grid lg:grid-cols-2 gap-12 lg:gap-20",
          children: [
            z.jsxs(nt.div, {
              initial: { opacity: 0, x: -40 },
              whileInView: { opacity: 1, x: 0 },
              viewport: { once: !0 },
              transition: { duration: 0.8 },
              children: [
                z.jsx("div", {
                  className: "space-y-8",
                  children: a.map((f) =>
                    z.jsxs(
                      nt.a,
                      {
                        href: f.href,
                        whileHover: { x: 8 },
                        className:
                          "flex items-center gap-6 p-6 glass-surface rounded-2xl group cursor-pointer magnetic",
                        children: [
                          z.jsx("div", {
                            className:
                              "w-14 h-14 glass rounded-xl flex items-center justify-center group-hover:bg-accent/10 transition-colors",
                            children: z.jsx(f.icon, {
                              className: "text-xl text-accent",
                            }),
                          }),
                          z.jsxs("div", {
                            children: [
                              z.jsx("div", {
                                className:
                                  "text-caption text-textMuted uppercase tracking-wider mb-1",
                                children: f.label,
                              }),
                              z.jsx("div", {
                                className:
                                  "text-body text-text group-hover:text-accent transition-colors",
                                children: f.value,
                              }),
                            ],
                          }),
                        ],
                      },
                      f.label
                    )
                  ),
                }),
                z.jsxs("div", {
                  className: "mt-12",
                  children: [
                    z.jsx("span", {
                      className:
                        "text-caption text-textMuted uppercase tracking-wider block mb-6",
                      children: "Connect",
                    }),
                    z.jsx("div", {
                      className: "flex gap-4",
                      children: u.map((f) =>
                        z.jsx(
                          nt.a,
                          {
                            href: f.href,
                            target: "_blank",
                            rel: "noopener noreferrer",
                            whileHover: { scale: 1.1, y: -3 },
                            whileTap: { scale: 0.95 },
                            className:
                              "w-12 h-12 glass rounded-full flex items-center justify-center text-textMuted hover:text-accent hover:bg-accent/5 transition-all magnetic",
                            "aria-label": f.label,
                            children: z.jsx(f.icon, { size: 20 }),
                          },
                          f.label
                        )
                      ),
                    }),
                  ],
                }),
              ],
            }),
            z.jsx(nt.div, {
              initial: { opacity: 0, x: 40 },
              whileInView: { opacity: 1, x: 0 },
              viewport: { once: !0 },
              transition: { duration: 0.8 },
              children: z.jsxs("form", {
                onSubmit: o,
                className: "glass-surface p-8 md:p-10 rounded-3xl",
                children: [
                  z.jsxs("div", {
                    className: "grid sm:grid-cols-2 gap-6 mb-6",
                    children: [
                      z.jsxs("div", {
                        children: [
                          z.jsx("label", {
                            htmlFor: "name",
                            className:
                              "block text-caption text-textMuted uppercase tracking-wider mb-3",
                            children: "Name",
                          }),
                          z.jsx("input", {
                            type: "text",
                            id: "name",
                            value: n.name,
                            onChange: (f) => e({ ...n, name: f.target.value }),
                            required: !0,
                            placeholder: "Your name",
                            className: "w-full",
                          }),
                        ],
                      }),
                      z.jsxs("div", {
                        children: [
                          z.jsx("label", {
                            htmlFor: "email",
                            className:
                              "block text-caption text-textMuted uppercase tracking-wider mb-3",
                            children: "Email",
                          }),
                          z.jsx("input", {
                            type: "email",
                            id: "email",
                            value: n.email,
                            onChange: (f) => e({ ...n, email: f.target.value }),
                            required: !0,
                            placeholder: "email@example.com",
                            className: "w-full",
                          }),
                        ],
                      }),
                    ],
                  }),
                  z.jsxs("div", {
                    className: "mb-6",
                    children: [
                      z.jsx("label", {
                        htmlFor: "subject",
                        className:
                          "block text-caption text-textMuted uppercase tracking-wider mb-3",
                        children: "Subject",
                      }),
                      z.jsx("input", {
                        type: "text",
                        id: "subject",
                        value: n.subject,
                        onChange: (f) => e({ ...n, subject: f.target.value }),
                        required: !0,
                        placeholder: "What's this about?",
                        className: "w-full",
                      }),
                    ],
                  }),
                  z.jsxs("div", {
                    className: "mb-8",
                    children: [
                      z.jsx("label", {
                        htmlFor: "message",
                        className:
                          "block text-caption text-textMuted uppercase tracking-wider mb-3",
                        children: "Message",
                      }),
                      z.jsx("textarea", {
                        id: "message",
                        value: n.message,
                        onChange: (f) => e({ ...n, message: f.target.value }),
                        required: !0,
                        rows: "5",
                        placeholder: "Tell me about your project...",
                        className: "w-full resize-none",
                      }),
                    ],
                  }),
                  z.jsx(nt.button, {
                    type: "submit",
                    disabled: t,
                    whileHover: { scale: t ? 1 : 1.02 },
                    whileTap: { scale: t ? 1 : 0.98 },
                    className: `w-full py-5 rounded-full text-body font-medium flex items-center justify-center gap-3 transition-all magnetic ${
                      t
                        ? "bg-surfaceLight cursor-not-allowed text-textMuted"
                        : "glass text-text hover:text-accent"
                    }`,
                    children: t
                      ? z.jsx("div", {
                          className:
                            "w-5 h-5 border-2 border-textMuted/30 border-t-textMuted rounded-full animate-spin",
                        })
                      : z.jsxs(z.Fragment, {
                          children: [
                            z.jsx("span", { children: "Send Message" }),
                            z.jsx("span", { children: "" }),
                          ],
                        }),
                  }),
                  r === "success" &&
                    z.jsx(nt.div, {
                      initial: { opacity: 0, y: 10 },
                      animate: { opacity: 1, y: 0 },
                      className: "mt-6 p-4 glass rounded-xl text-center",
                      children: z.jsx("span", {
                        className: "text-body text-accent",
                        children:
                          "Message sent successfully. I'll get back to you soon.",
                      }),
                    }),
                ],
              }),
            }),
          ],
        }),
      ],
    }),
  });
}
function tX() {
  const n = new Date().getFullYear(),
    e = {
      Navigation: [
        { name: "About", href: "#about" },
        { name: "Work", href: "#projects" },
        { name: "Contact", href: "#contact" },
      ],
      Social: [
        { name: "GitHub", href: "https://github.com/Oumaima-El-Badraouy" },
        {
          name: "LinkedIn",
          href: "https://www.linkedin.com/in/oumaima-el-badraouy/",
        },
        { name: "Twitter", href: "https://twitter.com" },
      ],
      Capabilities: [
        { name: "Web Development", href: "#skills" },
        { name: "UI/UX Design", href: "#skills" },
        { name: "Creative Direction", href: "#about" },
      ],
    },
    t = [
      {
        icon: Cg,
        href: "https://github.com/Oumaima-El-Badraouy",
        label: "GitHub",
      },
      {
        icon: cS,
        href: "https://www.linkedin.com/in/oumaima-el-badraouy/",
        label: "LinkedIn",
      },
      { icon: fS, href: "https://twitter.com", label: "Twitter" },
    ];
  return z.jsx("footer", {
    className: "bg-surface/30 border-t border-border",
    children: z.jsxs("div", {
      className: "max-w-7xl mx-auto px-6 md:px-12",
      children: [
        z.jsxs("div", {
          className:
            "py-16 md:py-20 grid grid-cols-2 md:grid-cols-4 gap-10 md:gap-8",
          children: [
            z.jsxs(nt.div, {
              initial: { opacity: 0, y: 20 },
              whileInView: { opacity: 1, y: 0 },
              viewport: { once: !0 },
              transition: { duration: 0.6 },
              className: "col-span-2 md:col-span-1",
              children: [
                z.jsxs("div", {
                  className: "flex items-center gap-3 mb-5",
                  children: [
                    z.jsx("div", {
                      className:
                        "w-10 h-10 glass-surface rounded-full flex items-center justify-center",
                      children: z.jsx("span", {
                        className: "text-lg font-display text-accent",
                        children: "A",
                      }),
                    }),
                    z.jsx("span", {
                      className: "font-display text-lg tracking-wide",
                      children: "Portfolio",
                    }),
                  ],
                }),
                z.jsx("p", {
                  className: "text-body text-textMuted font-light mb-6",
                  children:
                    "Crafting exceptional digital experiences with a focus on aesthetics and functionality.",
                }),
                z.jsx("div", {
                  className: "flex gap-3",
                  children: t.map((i) =>
                    z.jsx(
                      nt.a,
                      {
                        href: i.href,
                        target: "_blank",
                        rel: "noopener noreferrer",
                        whileHover: { scale: 1.1, y: -2 },
                        className:
                          "w-10 h-10 glass rounded-full flex items-center justify-center text-textMuted hover:text-accent hover:bg-accent/5 transition-all magnetic",
                        children: z.jsx(i.icon, { size: 18 }),
                      },
                      i.label
                    )
                  ),
                }),
              ],
            }),
            Object.entries(e).map(([i, r], s) =>
              z.jsxs(
                nt.div,
                {
                  initial: { opacity: 0, y: 20 },
                  whileInView: { opacity: 1, y: 0 },
                  viewport: { once: !0 },
                  transition: { duration: 0.6, delay: (s + 1) * 0.1 },
                  children: [
                    z.jsx("h4", {
                      className:
                        "text-sm font-medium text-text uppercase tracking-widest mb-5",
                      children: i,
                    }),
                    z.jsx("ul", {
                      className: "space-y-3",
                      children: r.map((o) =>
                        z.jsx(
                          "li",
                          {
                            children: z.jsx(nt.a, {
                              href: o.href,
                              whileHover: { x: 4 },
                              className:
                                "text-body text-textMuted hover:text-text transition-colors magnetic",
                              children: o.name,
                            }),
                          },
                          o.name
                        )
                      ),
                    }),
                  ],
                },
                i
              )
            ),
          ],
        }),
        z.jsxs(nt.div, {
          initial: { opacity: 0 },
          whileInView: { opacity: 1 },
          viewport: { once: !0 },
          transition: { duration: 0.6, delay: 0.4 },
          className:
            "py-8 border-t border-border flex flex-col md:flex-row items-center justify-between gap-4",
          children: [
            z.jsxs("p", {
              className: "text-caption text-textMuted",
              children: [" ", n, " Portfolio. All rights reserved."],
            }),
            z.jsxs("div", {
              className: "flex items-center gap-2 text-caption text-textMuted",
              children: [
                z.jsx("span", { children: "Designed & Developed with" }),
                z.jsx(nt.span, {
                  animate: { scale: [1, 1.2, 1] },
                  transition: { duration: 2, repeat: 1 / 0 },
                  className: "text-accent",
                  children: z.jsx(zz, { size: 14 }),
                }),
                z.jsx("span", { children: "in San Francisco" }),
              ],
            }),
          ],
        }),
      ],
    }),
  });
}
function nX() {
  return z.jsx("div", {
    className:
      "fixed inset-0 bg-background flex items-center justify-center z-50",
    children: z.jsxs("div", {
      className: "text-center",
      children: [
        z.jsx(nt.div, {
          initial: { opacity: 0, scale: 0.8 },
          animate: { opacity: 1, scale: 1 },
          transition: { duration: 0.6, ease: "easeOut" },
          className: "mb-8",
          children: z.jsxs("div", {
            className: "w-24 h-24 mx-auto relative",
            children: [
              z.jsx(nt.div, {
                className:
                  "absolute inset-0 border border-accent/20 rounded-full",
                animate: { rotate: 360 },
                transition: { duration: 20, repeat: 1 / 0, ease: "linear" },
              }),
              z.jsx(nt.div, {
                className:
                  "absolute inset-4 border border-t-accent border-r-transparent border-b-transparent border-l-transparent rounded-full",
                animate: { rotate: -360 },
                transition: { duration: 10, repeat: 1 / 0, ease: "linear" },
              }),
              z.jsx("div", {
                className:
                  "absolute inset-0 glass rounded-full flex items-center justify-center",
                children: z.jsx("span", {
                  className: "text-3xl font-display text-accent",
                  children: "A",
                }),
              }),
            ],
          }),
        }),
        z.jsx(nt.p, {
          initial: { opacity: 0, y: 20 },
          animate: { opacity: 1, y: 0 },
          transition: { delay: 0.4, duration: 0.6 },
          className: "text-body text-textMuted font-light tracking-wider",
          children: "Creating Experiences",
        }),
        z.jsx(nt.div, {
          initial: { width: 0, opacity: 0 },
          animate: { width: 120, opacity: 1 },
          transition: { delay: 0.6, duration: 0.6 },
          className:
            "h-px bg-gradient-to-r from-transparent via-accent to-transparent mx-auto mt-8",
        }),
        z.jsx(nt.div, {
          initial: { opacity: 0 },
          animate: { opacity: 1 },
          transition: { delay: 0.8, duration: 0.6 },
          className: "mt-4",
          children: z.jsxs("span", {
            className: "text-caption text-textMuted font-mono",
            children: [Math.floor(Math.random() * 20 + 80), "%"],
          }),
        }),
      ],
    }),
  });
}
function iX() {
  const n = se.useRef(null),
    e = se.useRef(null);
  return (
    se.useEffect(() => {
      const t = n.current,
        i = e.current,
        r = (o) => {
          t &&
            ((t.style.left = `${o.clientX}px`),
            (t.style.top = `${o.clientY}px`)),
            i &&
              ((i.style.left = `${o.clientX}px`),
              (i.style.top = `${o.clientY}px`));
        },
        s = (o) => {
          i &&
            (o.target.tagName === "A" ||
            o.target.tagName === "BUTTON" ||
            o.target.closest("button") ||
            o.target.closest("a")
              ? i.classList.add("hover")
              : i.classList.remove("hover"));
        };
      return (
        window.addEventListener("mousemove", r),
        window.addEventListener("mouseover", s),
        () => {
          window.removeEventListener("mousemove", r),
            window.removeEventListener("mouseover", s);
        }
      );
    }, []),
    z.jsxs(z.Fragment, {
      children: [
        z.jsx("div", { ref: n, className: "cursor" }),
        z.jsx("div", { ref: e, className: "cursor-follower" }),
      ],
    })
  );
}
function rX() {
  const [n, e] = se.useState(!0);
  return (
    se.useEffect(() => {
      const t = setTimeout(() => {
        e(!1);
      }, 2800);
      return () => clearTimeout(t);
    }, []),
    n
      ? z.jsx(nX, {})
      : z.jsxs(z.Fragment, {
          children: [
            z.jsx(iX, {}),
            z.jsx("div", { className: "noise-overlay" }),
            z.jsxs("div", {
              className:
                "min-h-screen bg-background text-text overflow-x-hidden",
              children: [
                z.jsx(XB, {}),
                z.jsx(qj, {}),
                z.jsx(Zj, {}),
                z.jsx(Kj, {}),
                z.jsx(Jj, {}),
                z.jsx(eX, {}),
                z.jsx(tX, {}),
              ],
            }),
          ],
        })
  );
}
Ky.createRoot(document.getElementById("root")).render(
  z.jsx(ss.StrictMode, { children: z.jsx(rX, {}) })
);
